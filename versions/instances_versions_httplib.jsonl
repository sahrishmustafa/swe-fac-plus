{"repo": "yhirose/cpp-httplib", "pull_number": 2039, "instance_id": "yhirose__cpp-httplib-2039", "issue_numbers": ["2033"], "base_commit": "9bbb4741b4f7c8fc5083c8a56d8d301a8abc25a3", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -2549,7 +2549,7 @@ inline bool is_obs_text(char c) { return 128 <= static_cast<unsigned char>(c); }\n inline bool is_field_vchar(char c) { return is_vchar(c) || is_obs_text(c); }\n \n inline bool is_field_content(const std::string &s) {\n-  if (s.empty()) { return false; }\n+  if (s.empty()) { return true; }\n \n   if (s.size() == 1) {\n     return is_field_vchar(s[0]);\n@@ -4214,22 +4214,21 @@ inline bool parse_header(const char *beg, const char *end, T fn) {\n     if (!key_len) { return false; }\n \n     auto key = std::string(beg, key_end);\n-    auto val = case_ignore::equal(key, \"Location\")\n-                   ? std::string(p, end)\n-                   : decode_url(std::string(p, end), false);\n-\n-    // NOTE: From RFC 9110:\n-    // Field values containing CR, LF, or NUL characters are\n-    // invalid and dangerous, due to the varying ways that\n-    // implementations might parse and interpret those\n-    // characters; a recipient of CR, LF, or NUL within a field\n-    // value MUST either reject the message or replace each of\n-    // those characters with SP before further processing or\n-    // forwarding of that message.\n-    static const std::string CR_LF_NUL(\"\\r\\n\\0\", 3);\n-    if (val.find_first_of(CR_LF_NUL) != std::string::npos) { return false; }\n-\n-    fn(key, val);\n+    // auto val = (case_ignore::equal(key, \"Location\") ||\n+    //             case_ignore::equal(key, \"Referer\"))\n+    //                ? std::string(p, end)\n+    //                : decode_url(std::string(p, end), false);\n+    auto val = std::string(p, end);\n+\n+    if (!detail::fields::is_field_value(val)) { return false; }\n+\n+    if (case_ignore::equal(key, \"Location\") ||\n+        case_ignore::equal(key, \"Referer\")) {\n+      fn(key, val);\n+    } else {\n+      fn(key, decode_url(val, false));\n+    }\n+\n     return true;\n   }\n \n@@ -4265,7 +4264,7 @@ inline bool read_headers(Stream &strm, Headers &headers) {\n     auto end = line_reader.ptr() + line_reader.size() - line_terminator_len;\n \n     if (!parse_header(line_reader.ptr(), end,\n-                      [&](const std::string &key, std::string &val) {\n+                      [&](const std::string &key, const std::string &val) {\n                         headers.emplace(key, val);\n                       })) {\n       return false;\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1866,7 +1866,7 @@ TEST(PathUrlEncodeTest, PathUrlEncode) {\n TEST(PathUrlEncodeTest, IncludePercentEncodingLF) {\n   Server svr;\n \n-  svr.Get(\"/\", [](const Request &req, Response &res) {\n+  svr.Get(\"/\", [](const Request &req, Response &) {\n     EXPECT_EQ(\"\\x0A\", req.get_param_value(\"something\"));\n   });\n \n@@ -4936,8 +4936,10 @@ TEST(ServerRequestParsingTest, TrimWhitespaceFromHeaderValues) {\n                           \"Connection: close\\r\\n\"\n                           \"\\r\\n\";\n \n-  ASSERT_TRUE(send_request(5, req));\n-  EXPECT_EQ(header_value, \"\\v bar \\x1B\");\n+  std::string res;\n+  ASSERT_TRUE(send_request(5, req, &res));\n+  EXPECT_EQ(header_value, \"\");\n+  EXPECT_EQ(\"HTTP/1.1 400 Bad Request\", res.substr(0, 24));\n }\n \n // Sends a raw request and verifies that there isn't a crash or exception.\n@@ -5095,6 +5097,14 @@ TEST(ServerRequestParsingTest, InvalidFieldValueContains_CR_LF_NUL) {\n   EXPECT_EQ(\"HTTP/1.1 400 Bad Request\", out.substr(0, 24));\n }\n \n+TEST(ServerRequestParsingTest, InvalidFieldValueContains_LF) {\n+  std::string out;\n+  std::string request(\n+      \"GET /header_field_value_check HTTP/1.1\\r\\nTest: [\\n\\n\\n]\\r\\n\\r\\n\", 55);\n+  test_raw_request(request, &out);\n+  EXPECT_EQ(\"HTTP/1.1 400 Bad Request\", out.substr(0, 24));\n+}\n+\n TEST(ServerRequestParsingTest, EmptyFieldValue) {\n   std::string out;\n \n@@ -7984,7 +7994,7 @@ TEST(InvalidHeaderCharsTest, is_field_value) {\n   EXPECT_FALSE(detail::fields::is_field_value(\" example_token\"));\n   EXPECT_FALSE(detail::fields::is_field_value(\"example_token \"));\n   EXPECT_TRUE(detail::fields::is_field_value(\"token@123\"));\n-  EXPECT_FALSE(detail::fields::is_field_value(\"\"));\n+  EXPECT_TRUE(detail::fields::is_field_value(\"\"));\n   EXPECT_FALSE(detail::fields::is_field_value(\"example\\rtoken\"));\n   EXPECT_FALSE(detail::fields::is_field_value(\"example\\ntoken\"));\n   EXPECT_FALSE(detail::fields::is_field_value(std::string(\"\\0\", 1)));\n", "problem_statement": "Allow URL-encoded newlines by replacing CR/LF with spaces in httplib\n**Description:**  \nCurrently, the cpp-httplib library rejects requests containing CR, LF, or NUL characters within field values, as per this commit:\n  https://github.com/yhirose/cpp-httplib/commit/975cf0dae55142109c74bf6b721cc4f0c2042eda\nDue to this issue:\n  https://github.com/yhirose/cpp-httplib/issues/1908\nReleased with cpp-httplib v0.17.1.\n\nThis behavior is problematic for use cases where URLs include encoded newlines (e.g., `%0A`), for instance in the `llama-server` project ([PR#11150](https://github.com/ggerganov/llama.cpp/pull/11150)) where a multi-line string in a URL is used to pre-fill the prompt text field (newlines are useful and needed in that context).\n\n**Steps to Reproduce:**  \n1. Send a request with a URL containing `%0A` (e.g., `http://localhost:8080/?something=%0A`).\n2. A cpp-httplib server returns a 400 error, indicating an invalid request.\n\n**Expected Behavior:**  \nAccording to RFC 9110, servers should replace CR, LF, and NUL characters with spaces in field values or rejecting the request. In the above case, using spaces would be vastly preferable, instead of not allowing the server logic to handle requests at all.\nFor instance www.google.com/search?q=cpp-httplib%0A also continues to process HTTP requests in the face of %0A in a URL.\n\n**Current Behavior:**  \nThe library rejects any request containing CR, LF, or NUL in field values, resulting in a 400 error.\n\n**Proposed Solution:**  \nModify e.g. the `parse_header()` function in `httplib.h` to replace CR, LF, and NUL characters with spaces instead of rejecting the request.\n", "hints_text": "You're getting a couple of things mixed up.\n\n1. The term \"field value\" in the HTTP RFCs refers specifically to header or trailer field values. If any of these bytes are encountered within a request's URL, it is **always** an error. Replacing with SP is not permissible in that circumstance.\n2. The URL you provided doesn't contain CR, LF, or NUL. It contains only a percent-encoded LF, which is totally allowed within URLs. (This is the whole point of percent encoding!)\n\nIn summary, this behavior *is* a bug, but not for the reason you're suggesting. It seems that the problem is that cpp-httplib checks for CR, LF, and NUL *after* evaluating percent-encoded octets, but it should apply that check *before*.\n@tim-janik @kenballus thanks for clarifying this situation. I now agree it's a bug in cpp-httplib. Thanks!\n@tim-janik, @ngxson, I added the following unit test to send \"/?something=%0A\" to reproduce this problem, but it returns 200 and I don't see any problem in the cpp-httplib server. Could give me the code snippet of your code that can reproduce it. Thanks!\n\nhttps://github.com/yhirose/cpp-httplib/commit/282f2feb77088ab905e2da5ae2e22a6d4d99a992\n> [@tim-janik](https://github.com/tim-janik), [@ngxson](https://github.com/ngxson), I added the following unit test to send \"\" to reproduce this problem, but it returns 200 and I don't see any problem in the cpp-httplib server. Could give me the code snippet of your code that can reproduce it. Thanks!\n> \n> [282f2fe](https://github.com/yhirose/cpp-httplib/commit/282f2feb77088ab905e2da5ae2e22a6d4d99a992)\n\nThe issue described happens with the interactive WebUI of llama-server, here is how to trigger it:\n\n- Checkout workaround: https://github.com/tim-janik/llama.cpp/tree/textarea-query-string-httplib-good\n- Build: `cmake -B build -DGGML_CUDA=ON && nice -n19 cmake --build build --config Release -j\n- Run: `llama.cpp/build/bin/llama-server -m Phi-3.5-mini-instruct.Q8.gguf`\n- Testing:\n```\n# Navigate to the WebUI with ?m=..., click Send, this will send a POST request and then generate\nfirefox http://localhost:8080/?m=Hello%0A\n# Or, navigate to the WebUI with ?q=..., this will automatically send a POST request and then generate\nfirefox http://localhost:8080/?q=Hello%0A\n> request: GET / 127.0.0.1 200\n> request: POST /v1/chat/completions 127.0.0.1 200\n```\n\n- Checkout the %0A issue: https://github.com/tim-janik/llama.cpp/tree/textarea-query-string-httplib-bad\n- Build & Run\n- Testing:\n```\n# Navigate to the WebUI, this will automatically send a POST request and then 400\nfirefox http://localhost:8080/?q=Hello%0A\n> request: GET / 127.0.0.1 200\n> request: POST /v1/chat/completions  400\n```\n\nThe diff between the two branches is merely:\n```diff\ndiff --git a/examples/server/httplib.h b/examples/server/httplib.h\nindex c2f12dd2..b6b76665 100644\n--- a/examples/server/httplib.h\n+++ b/examples/server/httplib.h\n@@ -4224,7 +4224,7 @@ inline bool parse_header(const char *beg, const char *end, T fn) {\n     // value MUST either reject the message or replace each of\n     // those characters with SP before further processing or\n     // forwarding of that message.\n-    static const std::string CR_LF_NUL(\"\\r\\n\\0\", 3);\n+    static const std::string CR_LF_NUL(\"\\r\\0\", 3); // CR_LF_NUL(\"\\r\\n\\0\", 3); // https://github.com/ggerganov/llama.cpp/issues/11335#issuecomment-2614759009\n     if (val.find_first_of(CR_LF_NUL) != std::string::npos) { return false; }\n \n     fn(key, val);\n```\n@tim-janik I still don't fully understand your situation, yet. This `parse_header` parses HTTP headers, and this particular check is for a HTTP header value, not a URL. I just wonder if the string `http://localhost:8080/?q=Hello%0A` is in a HTTP header value. If so, what's the HTTP header key?\n\nOpening the network tab before \"Send\" shows this POST request (using a different Port here and pasting from Firefox):\n\n```\nPOST | \u00a0\n-- | --\nscheme | http\nhost | localhost:1111\nfilename | /v1/chat/completions\n\u00a0Address | 127.0.0.1:1111\nPOST\nscheme\n\thttp\nhost\n\tlocalhost:1111\nfilename\n\t/v1/chat/completions\nAddress\n\t127.0.0.1:1111\nStatus\n200\nOK\nVersionHTTP/1.1\nTransferred39.25 kB (39.07 kB size)\nReferrer Policystrict-origin-when-cross-origin\nDNS ResolutionSystem\t\nAccess-Control-Allow-Origin\n\thttp://localhost:1111/\nContent-Type\n\ttext/event-stream\nKeep-Alive\n\ttimeout=5, max=100\nServer\n\tllama.cpp\nTransfer-Encoding\n\tchunked\nAccept\n\t*/*\nAccept-Encoding\n\tgzip, deflate, br, zstd\nAccept-Language\n\ten-US,en;q=0.5\nConnection\n\tkeep-alive\nContent-Length\n\t512\nContent-Type\n\tapplication/json\nCookie\n\tCSRF-Token-XYZ\nDNT\n\t1\nHost\n\tlocalhost:1111\nOrigin\n\thttp://localhost:1111/\nPriority\n\tu=4\nReferer\n\thttp://localhost:1111/?q=Hello%0A\nSec-Fetch-Dest\n\tempty\nSec-Fetch-Mode\n\tcors\nSec-Fetch-Site\n\tsame-origin\nSec-GPC\n\t1\nUser-Agent\n```\n\nThere is a %0A in the Referer field, is that possibly tripping up cpp-httplib?\n@tim-janik thanks for the detailed information!", "created_at": "2025-02-04T03:36:57Z", "version": "0.18"}
{"repo": "yhirose/cpp-httplib", "pull_number": 2158, "instance_id": "yhirose__cpp-httplib-2158", "issue_numbers": ["2157"], "base_commit": "08a0452fb2fe30344d068e695df415498f087bc8", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -5329,13 +5329,68 @@ serialize_multipart_formdata(const MultipartFormDataItems &items,\n   return body;\n }\n \n+inline void coalesce_ranges(Ranges &ranges, size_t content_length) {\n+  if (ranges.size() <= 1) return;\n+\n+  // Sort ranges by start position\n+  std::sort(ranges.begin(), ranges.end(),\n+            [](const Range &a, const Range &b) { return a.first < b.first; });\n+\n+  Ranges coalesced;\n+  coalesced.reserve(ranges.size());\n+\n+  for (auto &r : ranges) {\n+    auto first_pos = r.first;\n+    auto last_pos = r.second;\n+\n+    // Handle special cases like in range_error\n+    if (first_pos == -1 && last_pos == -1) {\n+      first_pos = 0;\n+      last_pos = static_cast<ssize_t>(content_length);\n+    }\n+\n+    if (first_pos == -1) {\n+      first_pos = static_cast<ssize_t>(content_length) - last_pos;\n+      last_pos = static_cast<ssize_t>(content_length) - 1;\n+    }\n+\n+    if (last_pos == -1 || last_pos >= static_cast<ssize_t>(content_length)) {\n+      last_pos = static_cast<ssize_t>(content_length) - 1;\n+    }\n+\n+    // Skip invalid ranges\n+    if (!(0 <= first_pos && first_pos <= last_pos &&\n+          last_pos < static_cast<ssize_t>(content_length))) {\n+      continue;\n+    }\n+\n+    // Coalesce with previous range if overlapping or adjacent (but not\n+    // identical)\n+    if (!coalesced.empty()) {\n+      auto &prev = coalesced.back();\n+      // Check if current range overlaps or is adjacent to previous range\n+      // but don't coalesce identical ranges (allow duplicates)\n+      if (first_pos <= prev.second + 1 &&\n+          !(first_pos == prev.first && last_pos == prev.second)) {\n+        // Extend the previous range\n+        prev.second = (std::max)(prev.second, last_pos);\n+        continue;\n+      }\n+    }\n+\n+    // Add new range\n+    coalesced.emplace_back(first_pos, last_pos);\n+  }\n+\n+  ranges = std::move(coalesced);\n+}\n+\n inline bool range_error(Request &req, Response &res) {\n   if (!req.ranges.empty() && 200 <= res.status && res.status < 300) {\n     ssize_t content_len = static_cast<ssize_t>(\n         res.content_length_ ? res.content_length_ : res.body.size());\n \n-    ssize_t prev_first_pos = -1;\n-    ssize_t prev_last_pos = -1;\n+    std::vector<std::pair<ssize_t, ssize_t>> processed_ranges;\n     size_t overwrapping_count = 0;\n \n     // NOTE: The following Range check is based on '14.2. Range' in RFC 9110\n@@ -5378,18 +5433,21 @@ inline bool range_error(Request &req, Response &res) {\n         return true;\n       }\n \n-      // Ranges must be in ascending order\n-      if (first_pos <= prev_first_pos) { return true; }\n-\n       // Request must not have more than two overlapping ranges\n-      if (first_pos <= prev_last_pos) {\n-        overwrapping_count++;\n-        if (overwrapping_count > 2) { return true; }\n+      for (const auto &processed_range : processed_ranges) {\n+        if (!(last_pos < processed_range.first ||\n+              first_pos > processed_range.second)) {\n+          overwrapping_count++;\n+          if (overwrapping_count > 2) { return true; }\n+          break; // Only count once per range\n+        }\n       }\n \n-      prev_first_pos = (std::max)(prev_first_pos, first_pos);\n-      prev_last_pos = (std::max)(prev_last_pos, last_pos);\n+      processed_ranges.emplace_back(first_pos, last_pos);\n     }\n+\n+    // After validation, coalesce overlapping ranges as per RFC 9110\n+    coalesce_ranges(req.ranges, static_cast<size_t>(content_len));\n   }\n \n   return false;\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -3992,6 +3992,16 @@ TEST_F(ServerTest, GetStreamedWithRangeMultipart) {\n   EXPECT_EQ(\"267\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(false, res->has_header(\"Content-Range\"));\n   EXPECT_EQ(267U, res->body.size());\n+\n+  // Check that both range contents are present\n+  EXPECT_TRUE(res->body.find(\"bc\\r\\n\") != std::string::npos);\n+  EXPECT_TRUE(res->body.find(\"ef\\r\\n\") != std::string::npos);\n+\n+  // Check that Content-Range headers are present for both ranges\n+  EXPECT_TRUE(res->body.find(\"Content-Range: bytes 1-2/7\") !=\n+              std::string::npos);\n+  EXPECT_TRUE(res->body.find(\"Content-Range: bytes 4-5/7\") !=\n+              std::string::npos);\n }\n \n TEST_F(ServerTest, GetStreamedWithTooManyRanges) {\n@@ -4009,14 +4019,59 @@ TEST_F(ServerTest, GetStreamedWithTooManyRanges) {\n   EXPECT_EQ(0U, res->body.size());\n }\n \n+TEST_F(ServerTest, GetStreamedWithOverwrapping) {\n+  auto res =\n+      cli_.Get(\"/streamed-with-range\", {{make_range_header({{1, 4}, {2, 5}})}});\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(StatusCode::PartialContent_206, res->status);\n+  EXPECT_EQ(5U, res->body.size());\n+\n+  // Check that overlapping ranges are coalesced into a single range\n+  EXPECT_EQ(\"bcdef\", res->body);\n+  EXPECT_EQ(\"bytes 1-5/7\", res->get_header_value(\"Content-Range\"));\n+\n+  // Should be single range, not multipart\n+  EXPECT_TRUE(res->has_header(\"Content-Range\"));\n+  EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n+}\n+\n TEST_F(ServerTest, GetStreamedWithNonAscendingRanges) {\n-  auto res = cli_.Get(\"/streamed-with-range?error\",\n-                      {{make_range_header({{0, -1}, {0, -1}})}});\n+  auto res =\n+      cli_.Get(\"/streamed-with-range\", {{make_range_header({{4, 5}, {0, 2}})}});\n   ASSERT_TRUE(res);\n-  EXPECT_EQ(StatusCode::RangeNotSatisfiable_416, res->status);\n-  EXPECT_EQ(\"0\", res->get_header_value(\"Content-Length\"));\n-  EXPECT_EQ(false, res->has_header(\"Content-Range\"));\n-  EXPECT_EQ(0U, res->body.size());\n+  EXPECT_EQ(StatusCode::PartialContent_206, res->status);\n+  EXPECT_EQ(268U, res->body.size());\n+\n+  // Check that both range contents are present\n+  EXPECT_TRUE(res->body.find(\"ef\\r\\n\") != std::string::npos);\n+  EXPECT_TRUE(res->body.find(\"abc\\r\\n\") != std::string::npos);\n+\n+  // Check that Content-Range headers are present for both ranges\n+  EXPECT_TRUE(res->body.find(\"Content-Range: bytes 4-5/7\") !=\n+              std::string::npos);\n+  EXPECT_TRUE(res->body.find(\"Content-Range: bytes 0-2/7\") !=\n+              std::string::npos);\n+}\n+\n+TEST_F(ServerTest, GetStreamedWithDuplicateRanges) {\n+  auto res =\n+      cli_.Get(\"/streamed-with-range\", {{make_range_header({{0, 2}, {0, 2}})}});\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(StatusCode::PartialContent_206, res->status);\n+  EXPECT_EQ(269U, res->body.size());\n+\n+  // Check that both duplicate range contents are present\n+  size_t first_abc = res->body.find(\"abc\\r\\n\");\n+  EXPECT_TRUE(first_abc != std::string::npos);\n+  size_t second_abc = res->body.find(\"abc\\r\\n\", first_abc + 1);\n+  EXPECT_TRUE(second_abc != std::string::npos);\n+\n+  // Check that Content-Range headers are present for both ranges\n+  size_t first_range = res->body.find(\"Content-Range: bytes 0-2/7\");\n+  EXPECT_TRUE(first_range != std::string::npos);\n+  size_t second_range =\n+      res->body.find(\"Content-Range: bytes 0-2/7\", first_range + 1);\n+  EXPECT_TRUE(second_range != std::string::npos);\n }\n \n TEST_F(ServerTest, GetStreamedWithRangesMoreThanTwoOverwrapping) {\n@@ -4122,6 +4177,19 @@ TEST_F(ServerTest, GetWithRange4) {\n   EXPECT_EQ(std::string(\"fg\"), res->body);\n }\n \n+TEST_F(ServerTest, GetWithRange5) {\n+  auto res = cli_.Get(\"/with-range\", {\n+                                         make_range_header({{0, 5}}),\n+                                         {\"Accept-Encoding\", \"\"},\n+                                     });\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(StatusCode::PartialContent_206, res->status);\n+  EXPECT_EQ(\"6\", res->get_header_value(\"Content-Length\"));\n+  EXPECT_EQ(true, res->has_header(\"Content-Range\"));\n+  EXPECT_EQ(\"bytes 0-5/7\", res->get_header_value(\"Content-Range\"));\n+  EXPECT_EQ(std::string(\"abcdef\"), res->body);\n+}\n+\n TEST_F(ServerTest, GetWithRangeOffsetGreaterThanContent) {\n   auto res = cli_.Get(\"/with-range\", {{make_range_header({{10000, 20000}})}});\n   ASSERT_TRUE(res);\n", "problem_statement": "Ranges that are not in the form 0-n do not work.\nThe library makes several bad assumptions in range_error and in a few other places that I haven't been able to track down that ranges are always from zero and that the body field of the response contains the entire file (this makes no sense. Why would you want to waste disk space and time getting the entire file rather than just a smaller chunk of it?), as ranges that are not formatted like that cause range errors. If I comment out the range_error call in the library, it still doesn't work.\nThe reason why this needs to be implemented is that video streaming needs the ability to get an arbitrary range of bytes.\n\nThis is my code for handling range requests:\n```\nstd::ostringstream sstr;\nstd::string data = \"\";\n\nif (req.ranges.size() != 0)\n{\n    Range range = req.ranges[0];\n\n    ssize_t numBytes = range.second == -1 ? 1024 : range.second - range.first;\n    ssize_t offset = range.first;\n\n    data.resize(numBytes + 1);\n\n    inputFile.seekg(offset);\n    numBytes = inputFile.readsome(data.data(), numBytes);\n\n    res.set_content(data.data(), numBytes, \"video/webm\");\n    res.content_length_ = numBytes;\n    logger->log(\"numbytes:\" + std::to_string(numBytes));\n\n    inputFile.close();\n}\nelse\n{\n    sstr << inputFile.rdbuf();\n    data = sstr.str();\n    inputFile.close();\n}\n```\n", "hints_text": "@NikkiOfTheValley thank you for the feedback and suggested implementation. Could you please send a pull request and some unit tests? Thanks a lot!\n@yhirose Oh, I should've clarified. That is my current implementation using the library itself. It's actually impossible as far as I can tell to use the library to handle range requests properly. I have no idea where exactly the bad assumption in the rest of the library code outside of range_error() is.\n\nEven if I remove the call to range_error on the server, it seems like the library tries to truncate the data (which, again, is a really wonky way of doing that), gets nonsense results, and corrupts the data. In some situations it even fails to send all the data, causing a timeout on the request. \n@NikkiOfTheValley thanks for the additional information. But I still don't fully understand what you mean and what I should do for it. Could you please show me your calling example of cpp-httplib with your HTTP request, and expected result? Then, I'll try to reproduce the problem on my machine. Thanks!\n@yhirose I'm not actually sending the requests from the client using cpp-httplib, I'm using it for a simple web server. The actual thing that's doing the requests is DASH, which is a browser-side video streaming library. It would require a lot of setup on your end to get it to work, and it's way overcomplicated to replicate exactly what I'm trying to do on your machine. Just send a request that has a range that doesn't start with zero using curl or something, and then you should be able to replicate the issue. \n@NikkiOfTheValley do you mean that you create a simple web server based on the cpp-httplib server and send HTTP requests with a '0-n range' header from your system, but you don't get responses that you expect?\n\nCould you please show me your HTTP requests and actual responses from the cpp-httplib based server?\nAlso I am not familiar to DASH. How does it work?\n\nThanks for your help and sorry for my slow understanding...", "created_at": "2025-06-23T03:27:20Z", "version": "0.21"}
{"repo": "yhirose/cpp-httplib", "pull_number": 2160, "instance_id": "yhirose__cpp-httplib-2160", "issue_numbers": ["1777"], "base_commit": "27879c4874aabfc254edd25cf58385c25ac247b7", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -76,7 +76,7 @@\n \n #ifndef CPPHTTPLIB_IDLE_INTERVAL_USECOND\n #ifdef _WIN32\n-#define CPPHTTPLIB_IDLE_INTERVAL_USECOND 10000\n+#define CPPHTTPLIB_IDLE_INTERVAL_USECOND 1000\n #else\n #define CPPHTTPLIB_IDLE_INTERVAL_USECOND 0\n #endif\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -3155,6 +3155,47 @@ TEST_F(ServerTest, GetMethod200) {\n   EXPECT_EQ(\"Hello World!\", res->body);\n }\n \n+TEST(BenchmarkTest, SimpleGetPerformance) {\n+  Server svr;\n+  \n+  svr.Get(\"/benchmark\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Benchmark Response\", \"text/plain\");\n+  });\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(\"localhost\", PORT); });\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    listen_thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(\"localhost\", PORT);\n+  \n+  const int NUM_REQUESTS = 50;\n+  const int MAX_AVERAGE_MS = 5;\n+  \n+  auto warmup = cli.Get(\"/benchmark\");\n+  ASSERT_TRUE(warmup);\n+  \n+  auto start = std::chrono::high_resolution_clock::now();\n+  for (int i = 0; i < NUM_REQUESTS; ++i) {\n+    auto res = cli.Get(\"/benchmark\");\n+    ASSERT_TRUE(res) << \"Request \" << i << \" failed\";\n+    EXPECT_EQ(StatusCode::OK_200, res->status);\n+  }\n+  auto end = std::chrono::high_resolution_clock::now();\n+  \n+  auto total_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();\n+  double avg_ms = static_cast<double>(total_ms) / NUM_REQUESTS;\n+  \n+  std::cout << \"Standalone: \" << NUM_REQUESTS << \" requests in \" << total_ms \n+            << \"ms (avg: \" << avg_ms << \"ms)\" << std::endl;\n+  \n+  EXPECT_LE(avg_ms, MAX_AVERAGE_MS) << \"Standalone test too slow: \" << avg_ms << \"ms (Issue #1777)\";\n+}\n+\n TEST_F(ServerTest, GetEmptyFile) {\n   auto res = cli_.Get(\"/empty_file\");\n   ASSERT_TRUE(res);\n", "problem_statement": "Windows req/res very slow compared to Linux\nI'm using gtest to do some performance testing. On Linux I have less than 1 ms, but the same code on Windows has ~30ms.\r\n\r\nI think it's a significant difference, but i don't undestand why\r\n\r\nClient\r\n```\r\n// Create client\r\nhttplib::Client cli(ADDR, PORT);\r\nASSERT_TRUE(cli.is_valid());\r\n\r\nhttplib::Result res;\r\n\r\n// Measure the get req/res time\r\nauto start_time = std::chrono::high_resolution_clock::now();\r\nres = cli.get(ROUTE_GET_TEST_TEXT);\r\nauto end_time = std::chrono::high_resolution_clock::now();\r\n\r\nauto elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time).count();\r\n\r\n// Verify response\r\nASSERT_TRUE(res);\r\nASSERT_TRUE(res != nullptr);\r\nEXPECT_EQ(httplib::StatusCode::OK_200, res->status);\r\nEXPECT_EQ(httplib::Error::Success, res.error());\r\nEXPECT_EQ(TXT_DEFAULT_RESPONSE, res->body);\r\n\r\n// Verify elapsed time\t\t\r\nASSERT_LE(elapsed_time, TIME_GET_US);\r\n```\r\n\r\nServer handle:\r\n```\r\n_svr.Get(ROUTE_GET_TEST_TEXT, [&](const httplib::Request& req, httplib::Response& res) {\r\n\tres.set_content(TXT_DEFAULT_RESPONSE, \"text/plain\");\r\n\t});\r\n```\r\n\r\nCommon:\r\n```\r\n#define ADDR \"127.0.0.1\"\r\n#define PORT 8181\r\n\r\n#define TXT_DEFAULT_RESPONSE  \"Default Response to txt request\"\r\n\r\n```\r\n\n", "hints_text": "I\u00b4ve made some unit tests based on your code and had similar results:\r\n\r\nOn Linux:\r\n![Linux](https://github.com/yhirose/cpp-httplib/assets/65834999/98f55312-a6f4-49bc-9994-3193e1f4b993)\r\n\r\nOn Windows:\r\n![Windows](https://github.com/yhirose/cpp-httplib/assets/65834999/4bb5de25-0ea4-4e70-b8c7-c83381a46701)\r\n\r\n\n@hconcessa @rpmocchet sorry for the late reply. I'll take a look at the behavior on my Windows machine when I have time. Thanks!\nHey Guys.\r\nI did some time investigation on the client side in Win64 PC.\r\nI found **socket_t create_socket** will took 1ms to process.\r\n\r\nSo I suspected **WSASocketW** took so much time, and got it.\r\nBut even I forced it to ues the **std.socket** to create a socket. It also cost around 1ms.\r\nIs any possiable when Win create a socket will take more time than Linux or BSD?\r\nI don't have Linux or BSD eniviroment right now.\r\nCan you test this patten for me? Thank you.\r\n\r\n```C++\r\nfor (auto rp = result; rp; rp = rp->ai_next) {\r\n    // Create a socket\r\n#ifdef _WIN32\r\n    auto sock =\r\n        WSASocketW(rp->ai_family, rp->ai_socktype, rp->ai_protocol, nullptr, 0,\r\n                   WSA_FLAG_NO_HANDLE_INHERIT | WSA_FLAG_OVERLAPPED);\r\n    /*...*/\r\n    if (sock == INVALID_SOCKET) {\r\n      sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\r\n    }\r\n#else\r\n    auto sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\r\n#endif\r\n    if (sock == INVALID_SOCKET) { continue; }\r\n```\nThere is a significant delay when connecting to localhost. It tries first to connect to 0.0.0.0 returned from `getaddrinfo` which always fails. This needs some kind of filtering on connect and skip connecting to `INADDR_ANY`.\n> There is a significant delay when connecting to localhost. It tries first to connect to 0.0.0.0 returned from `getaddrinfo` which always fails. This needs some kind of filtering on connect and skip connecting to `INADDR_ANY`.\n\nThings just go that way. `localhost` is a domain and requires resolving. Using hardcoded `0.0.0.0` and set `Host` in the header can mitigate this issue.", "created_at": "2025-06-24T04:15:22Z", "version": "0.21"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1821, "instance_id": "yhirose__cpp-httplib-1821", "issue_numbers": ["1330"], "base_commit": "ce36b8a6e5ddd049a1a00cac61d9b8a37be3e75f", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1148,10 +1148,18 @@ class ClientImpl {\n               const std::string &content_type);\n   Result Post(const std::string &path, const Headers &headers, const char *body,\n               size_t content_length, const std::string &content_type);\n+  Result Post(const std::string &path, const Headers &headers, const char *body,\n+              size_t content_length, const std::string &content_type,\n+              Progress progress);\n   Result Post(const std::string &path, const std::string &body,\n               const std::string &content_type);\n+  Result Post(const std::string &path, const std::string &body,\n+              const std::string &content_type, Progress progress);\n   Result Post(const std::string &path, const Headers &headers,\n               const std::string &body, const std::string &content_type);\n+  Result Post(const std::string &path, const Headers &headers,\n+              const std::string &body, const std::string &content_type,\n+              Progress progress);\n   Result Post(const std::string &path, size_t content_length,\n               ContentProvider content_provider,\n               const std::string &content_type);\n@@ -1167,6 +1175,8 @@ class ClientImpl {\n   Result Post(const std::string &path, const Params &params);\n   Result Post(const std::string &path, const Headers &headers,\n               const Params &params);\n+  Result Post(const std::string &path, const Headers &headers,\n+              const Params &params, Progress progress);\n   Result Post(const std::string &path, const MultipartFormDataItems &items);\n   Result Post(const std::string &path, const Headers &headers,\n               const MultipartFormDataItems &items);\n@@ -1181,10 +1191,18 @@ class ClientImpl {\n              const std::string &content_type);\n   Result Put(const std::string &path, const Headers &headers, const char *body,\n              size_t content_length, const std::string &content_type);\n+  Result Put(const std::string &path, const Headers &headers, const char *body,\n+             size_t content_length, const std::string &content_type,\n+             Progress progress);\n   Result Put(const std::string &path, const std::string &body,\n              const std::string &content_type);\n+  Result Put(const std::string &path, const std::string &body,\n+             const std::string &content_type, Progress progress);\n   Result Put(const std::string &path, const Headers &headers,\n              const std::string &body, const std::string &content_type);\n+  Result Put(const std::string &path, const Headers &headers,\n+             const std::string &body, const std::string &content_type,\n+             Progress progress);\n   Result Put(const std::string &path, size_t content_length,\n              ContentProvider content_provider, const std::string &content_type);\n   Result Put(const std::string &path,\n@@ -1199,6 +1217,8 @@ class ClientImpl {\n   Result Put(const std::string &path, const Params &params);\n   Result Put(const std::string &path, const Headers &headers,\n              const Params &params);\n+  Result Put(const std::string &path, const Headers &headers,\n+             const Params &params, Progress progress);\n   Result Put(const std::string &path, const MultipartFormDataItems &items);\n   Result Put(const std::string &path, const Headers &headers,\n              const MultipartFormDataItems &items);\n@@ -1211,13 +1231,23 @@ class ClientImpl {\n   Result Patch(const std::string &path);\n   Result Patch(const std::string &path, const char *body, size_t content_length,\n                const std::string &content_type);\n+  Result Patch(const std::string &path, const char *body, size_t content_length,\n+               const std::string &content_type, Progress progress);\n   Result Patch(const std::string &path, const Headers &headers,\n                const char *body, size_t content_length,\n                const std::string &content_type);\n+  Result Patch(const std::string &path, const Headers &headers,\n+               const char *body, size_t content_length,\n+               const std::string &content_type, Progress progress);\n   Result Patch(const std::string &path, const std::string &body,\n                const std::string &content_type);\n+  Result Patch(const std::string &path, const std::string &body,\n+               const std::string &content_type, Progress progress);\n   Result Patch(const std::string &path, const Headers &headers,\n                const std::string &body, const std::string &content_type);\n+  Result Patch(const std::string &path, const Headers &headers,\n+               const std::string &body, const std::string &content_type,\n+               Progress progress);\n   Result Patch(const std::string &path, size_t content_length,\n                ContentProvider content_provider,\n                const std::string &content_type);\n@@ -1235,13 +1265,24 @@ class ClientImpl {\n   Result Delete(const std::string &path, const Headers &headers);\n   Result Delete(const std::string &path, const char *body,\n                 size_t content_length, const std::string &content_type);\n+  Result Delete(const std::string &path, const char *body,\n+                size_t content_length, const std::string &content_type,\n+                Progress progress);\n   Result Delete(const std::string &path, const Headers &headers,\n                 const char *body, size_t content_length,\n                 const std::string &content_type);\n+  Result Delete(const std::string &path, const Headers &headers,\n+                const char *body, size_t content_length,\n+                const std::string &content_type, Progress progress);\n   Result Delete(const std::string &path, const std::string &body,\n                 const std::string &content_type);\n+  Result Delete(const std::string &path, const std::string &body,\n+                const std::string &content_type, Progress progress);\n   Result Delete(const std::string &path, const Headers &headers,\n                 const std::string &body, const std::string &content_type);\n+  Result Delete(const std::string &path, const Headers &headers,\n+                const std::string &body, const std::string &content_type,\n+                Progress progress);\n \n   Result Options(const std::string &path);\n   Result Options(const std::string &path, const Headers &headers);\n@@ -1456,7 +1497,7 @@ class ClientImpl {\n       const Headers &headers, const char *body, size_t content_length,\n       ContentProvider content_provider,\n       ContentProviderWithoutLength content_provider_without_length,\n-      const std::string &content_type);\n+      const std::string &content_type, Progress progress);\n   ContentProviderWithoutLength get_multipart_content_provider(\n       const std::string &boundary, const MultipartFormDataItems &items,\n       const MultipartFormDataProviderItems &provider_items) const;\n@@ -1531,10 +1572,18 @@ class Client {\n               const std::string &content_type);\n   Result Post(const std::string &path, const Headers &headers, const char *body,\n               size_t content_length, const std::string &content_type);\n+  Result Post(const std::string &path, const Headers &headers, const char *body,\n+              size_t content_length, const std::string &content_type,\n+              Progress progress);\n   Result Post(const std::string &path, const std::string &body,\n               const std::string &content_type);\n+  Result Post(const std::string &path, const std::string &body,\n+              const std::string &content_type, Progress progress);\n   Result Post(const std::string &path, const Headers &headers,\n               const std::string &body, const std::string &content_type);\n+  Result Post(const std::string &path, const Headers &headers,\n+              const std::string &body, const std::string &content_type,\n+              Progress progress);\n   Result Post(const std::string &path, size_t content_length,\n               ContentProvider content_provider,\n               const std::string &content_type);\n@@ -1550,6 +1599,8 @@ class Client {\n   Result Post(const std::string &path, const Params &params);\n   Result Post(const std::string &path, const Headers &headers,\n               const Params &params);\n+  Result Post(const std::string &path, const Headers &headers,\n+              const Params &params, Progress progress);\n   Result Post(const std::string &path, const MultipartFormDataItems &items);\n   Result Post(const std::string &path, const Headers &headers,\n               const MultipartFormDataItems &items);\n@@ -1564,10 +1615,18 @@ class Client {\n              const std::string &content_type);\n   Result Put(const std::string &path, const Headers &headers, const char *body,\n              size_t content_length, const std::string &content_type);\n+  Result Put(const std::string &path, const Headers &headers, const char *body,\n+             size_t content_length, const std::string &content_type,\n+             Progress progress);\n   Result Put(const std::string &path, const std::string &body,\n              const std::string &content_type);\n+  Result Put(const std::string &path, const std::string &body,\n+             const std::string &content_type, Progress progress);\n   Result Put(const std::string &path, const Headers &headers,\n              const std::string &body, const std::string &content_type);\n+  Result Put(const std::string &path, const Headers &headers,\n+             const std::string &body, const std::string &content_type,\n+             Progress progress);\n   Result Put(const std::string &path, size_t content_length,\n              ContentProvider content_provider, const std::string &content_type);\n   Result Put(const std::string &path,\n@@ -1582,6 +1641,8 @@ class Client {\n   Result Put(const std::string &path, const Params &params);\n   Result Put(const std::string &path, const Headers &headers,\n              const Params &params);\n+  Result Put(const std::string &path, const Headers &headers,\n+             const Params &params, Progress progress);\n   Result Put(const std::string &path, const MultipartFormDataItems &items);\n   Result Put(const std::string &path, const Headers &headers,\n              const MultipartFormDataItems &items);\n@@ -1594,13 +1655,23 @@ class Client {\n   Result Patch(const std::string &path);\n   Result Patch(const std::string &path, const char *body, size_t content_length,\n                const std::string &content_type);\n+  Result Patch(const std::string &path, const char *body, size_t content_length,\n+               const std::string &content_type, Progress progress);\n   Result Patch(const std::string &path, const Headers &headers,\n                const char *body, size_t content_length,\n                const std::string &content_type);\n+  Result Patch(const std::string &path, const Headers &headers,\n+               const char *body, size_t content_length,\n+               const std::string &content_type, Progress progress);\n   Result Patch(const std::string &path, const std::string &body,\n                const std::string &content_type);\n+  Result Patch(const std::string &path, const std::string &body,\n+               const std::string &content_type, Progress progress);\n   Result Patch(const std::string &path, const Headers &headers,\n                const std::string &body, const std::string &content_type);\n+  Result Patch(const std::string &path, const Headers &headers,\n+               const std::string &body, const std::string &content_type,\n+               Progress progress);\n   Result Patch(const std::string &path, size_t content_length,\n                ContentProvider content_provider,\n                const std::string &content_type);\n@@ -1618,13 +1689,24 @@ class Client {\n   Result Delete(const std::string &path, const Headers &headers);\n   Result Delete(const std::string &path, const char *body,\n                 size_t content_length, const std::string &content_type);\n+  Result Delete(const std::string &path, const char *body,\n+                size_t content_length, const std::string &content_type,\n+                Progress progress);\n   Result Delete(const std::string &path, const Headers &headers,\n                 const char *body, size_t content_length,\n                 const std::string &content_type);\n+  Result Delete(const std::string &path, const Headers &headers,\n+                const char *body, size_t content_length,\n+                const std::string &content_type, Progress progress);\n   Result Delete(const std::string &path, const std::string &body,\n                 const std::string &content_type);\n+  Result Delete(const std::string &path, const std::string &body,\n+                const std::string &content_type, Progress progress);\n   Result Delete(const std::string &path, const Headers &headers,\n                 const std::string &body, const std::string &content_type);\n+  Result Delete(const std::string &path, const Headers &headers,\n+                const std::string &body, const std::string &content_type,\n+                Progress progress);\n \n   Result Options(const std::string &path);\n   Result Options(const std::string &path, const Headers &headers);\n@@ -7435,11 +7517,12 @@ inline Result ClientImpl::send_with_content_provider(\n     const std::string &method, const std::string &path, const Headers &headers,\n     const char *body, size_t content_length, ContentProvider content_provider,\n     ContentProviderWithoutLength content_provider_without_length,\n-    const std::string &content_type) {\n+    const std::string &content_type, Progress progress) {\n   Request req;\n   req.method = method;\n   req.headers = headers;\n   req.path = path;\n+  req.progress = progress;\n \n   auto error = Error::Success;\n \n@@ -7735,14 +7818,22 @@ inline Result ClientImpl::Post(const std::string &path,\n inline Result ClientImpl::Post(const std::string &path, const char *body,\n                                size_t content_length,\n                                const std::string &content_type) {\n-  return Post(path, Headers(), body, content_length, content_type);\n+  return Post(path, Headers(), body, content_length, content_type, nullptr);\n }\n \n inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n                                const char *body, size_t content_length,\n                                const std::string &content_type) {\n   return send_with_content_provider(\"POST\", path, headers, body, content_length,\n-                                    nullptr, nullptr, content_type);\n+                                    nullptr, nullptr, content_type, nullptr);\n+}\n+\n+inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n+                               const char *body, size_t content_length,\n+                               const std::string &content_type,\n+                               Progress progress) {\n+  return send_with_content_provider(\"POST\", path, headers, body, content_length,\n+                                    nullptr, nullptr, content_type, progress);\n }\n \n inline Result ClientImpl::Post(const std::string &path, const std::string &body,\n@@ -7750,12 +7841,27 @@ inline Result ClientImpl::Post(const std::string &path, const std::string &body,\n   return Post(path, Headers(), body, content_type);\n }\n \n+inline Result ClientImpl::Post(const std::string &path, const std::string &body,\n+                               const std::string &content_type,\n+                               Progress progress) {\n+  return Post(path, Headers(), body, content_type, progress);\n+}\n+\n inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n                                const std::string &body,\n                                const std::string &content_type) {\n   return send_with_content_provider(\"POST\", path, headers, body.data(),\n-                                    body.size(), nullptr, nullptr,\n-                                    content_type);\n+                                    body.size(), nullptr, nullptr, content_type,\n+                                    nullptr);\n+}\n+\n+inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n+                               const std::string &body,\n+                               const std::string &content_type,\n+                               Progress progress) {\n+  return send_with_content_provider(\"POST\", path, headers, body.data(),\n+                                    body.size(), nullptr, nullptr, content_type,\n+                                    progress);\n }\n \n inline Result ClientImpl::Post(const std::string &path, const Params &params) {\n@@ -7781,14 +7887,15 @@ inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n                                const std::string &content_type) {\n   return send_with_content_provider(\"POST\", path, headers, nullptr,\n                                     content_length, std::move(content_provider),\n-                                    nullptr, content_type);\n+                                    nullptr, content_type, nullptr);\n }\n \n inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n                                ContentProviderWithoutLength content_provider,\n                                const std::string &content_type) {\n   return send_with_content_provider(\"POST\", path, headers, nullptr, 0, nullptr,\n-                                    std::move(content_provider), content_type);\n+                                    std::move(content_provider), content_type,\n+                                    nullptr);\n }\n \n inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n@@ -7797,6 +7904,13 @@ inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n   return Post(path, headers, query, \"application/x-www-form-urlencoded\");\n }\n \n+inline Result ClientImpl::Post(const std::string &path, const Headers &headers,\n+                               const Params &params, Progress progress) {\n+  auto query = detail::params_to_query_str(params);\n+  return Post(path, headers, query, \"application/x-www-form-urlencoded\",\n+              progress);\n+}\n+\n inline Result ClientImpl::Post(const std::string &path,\n                                const MultipartFormDataItems &items) {\n   return Post(path, Headers(), items);\n@@ -7834,7 +7948,7 @@ ClientImpl::Post(const std::string &path, const Headers &headers,\n   return send_with_content_provider(\n       \"POST\", path, headers, nullptr, 0, nullptr,\n       get_multipart_content_provider(boundary, items, provider_items),\n-      content_type);\n+      content_type, nullptr);\n }\n \n inline Result ClientImpl::Put(const std::string &path) {\n@@ -7851,7 +7965,15 @@ inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n                               const char *body, size_t content_length,\n                               const std::string &content_type) {\n   return send_with_content_provider(\"PUT\", path, headers, body, content_length,\n-                                    nullptr, nullptr, content_type);\n+                                    nullptr, nullptr, content_type, nullptr);\n+}\n+\n+inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n+                              const char *body, size_t content_length,\n+                              const std::string &content_type,\n+                              Progress progress) {\n+  return send_with_content_provider(\"PUT\", path, headers, body, content_length,\n+                                    nullptr, nullptr, content_type, progress);\n }\n \n inline Result ClientImpl::Put(const std::string &path, const std::string &body,\n@@ -7859,12 +7981,27 @@ inline Result ClientImpl::Put(const std::string &path, const std::string &body,\n   return Put(path, Headers(), body, content_type);\n }\n \n+inline Result ClientImpl::Put(const std::string &path, const std::string &body,\n+                              const std::string &content_type,\n+                              Progress progress) {\n+  return Put(path, Headers(), body, content_type, progress);\n+}\n+\n inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n                               const std::string &body,\n                               const std::string &content_type) {\n   return send_with_content_provider(\"PUT\", path, headers, body.data(),\n-                                    body.size(), nullptr, nullptr,\n-                                    content_type);\n+                                    body.size(), nullptr, nullptr, content_type,\n+                                    nullptr);\n+}\n+\n+inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n+                              const std::string &body,\n+                              const std::string &content_type,\n+                              Progress progress) {\n+  return send_with_content_provider(\"PUT\", path, headers, body.data(),\n+                                    body.size(), nullptr, nullptr, content_type,\n+                                    progress);\n }\n \n inline Result ClientImpl::Put(const std::string &path, size_t content_length,\n@@ -7886,14 +8023,15 @@ inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n                               const std::string &content_type) {\n   return send_with_content_provider(\"PUT\", path, headers, nullptr,\n                                     content_length, std::move(content_provider),\n-                                    nullptr, content_type);\n+                                    nullptr, content_type, nullptr);\n }\n \n inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n                               ContentProviderWithoutLength content_provider,\n                               const std::string &content_type) {\n   return send_with_content_provider(\"PUT\", path, headers, nullptr, 0, nullptr,\n-                                    std::move(content_provider), content_type);\n+                                    std::move(content_provider), content_type,\n+                                    nullptr);\n }\n \n inline Result ClientImpl::Put(const std::string &path, const Params &params) {\n@@ -7906,6 +8044,13 @@ inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n   return Put(path, headers, query, \"application/x-www-form-urlencoded\");\n }\n \n+inline Result ClientImpl::Put(const std::string &path, const Headers &headers,\n+                              const Params &params, Progress progress) {\n+  auto query = detail::params_to_query_str(params);\n+  return Put(path, headers, query, \"application/x-www-form-urlencoded\",\n+             progress);\n+}\n+\n inline Result ClientImpl::Put(const std::string &path,\n                               const MultipartFormDataItems &items) {\n   return Put(path, Headers(), items);\n@@ -7943,7 +8088,7 @@ ClientImpl::Put(const std::string &path, const Headers &headers,\n   return send_with_content_provider(\n       \"PUT\", path, headers, nullptr, 0, nullptr,\n       get_multipart_content_provider(boundary, items, provider_items),\n-      content_type);\n+      content_type, nullptr);\n }\n inline Result ClientImpl::Patch(const std::string &path) {\n   return Patch(path, std::string(), std::string());\n@@ -7955,12 +8100,26 @@ inline Result ClientImpl::Patch(const std::string &path, const char *body,\n   return Patch(path, Headers(), body, content_length, content_type);\n }\n \n+inline Result ClientImpl::Patch(const std::string &path, const char *body,\n+                                size_t content_length,\n+                                const std::string &content_type,\n+                                Progress progress) {\n+  return Patch(path, Headers(), body, content_length, content_type, progress);\n+}\n+\n inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,\n                                 const char *body, size_t content_length,\n                                 const std::string &content_type) {\n+  return Patch(path, headers, body, content_length, content_type, nullptr);\n+}\n+\n+inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,\n+                                const char *body, size_t content_length,\n+                                const std::string &content_type,\n+                                Progress progress) {\n   return send_with_content_provider(\"PATCH\", path, headers, body,\n                                     content_length, nullptr, nullptr,\n-                                    content_type);\n+                                    content_type, progress);\n }\n \n inline Result ClientImpl::Patch(const std::string &path,\n@@ -7969,12 +8128,25 @@ inline Result ClientImpl::Patch(const std::string &path,\n   return Patch(path, Headers(), body, content_type);\n }\n \n+inline Result ClientImpl::Patch(const std::string &path,\n+                                const std::string &body,\n+                                const std::string &content_type, Progress progress) {\n+  return Patch(path, Headers(), body, content_type, progress);\n+}\n+\n inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,\n                                 const std::string &body,\n                                 const std::string &content_type) {\n+  return Patch(path, headers, body, content_type, nullptr);\n+}\n+\n+inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,\n+                                const std::string &body,\n+                                const std::string &content_type,\n+                                Progress progress) {\n   return send_with_content_provider(\"PATCH\", path, headers, body.data(),\n-                                    body.size(), nullptr, nullptr,\n-                                    content_type);\n+                                    body.size(), nullptr, nullptr, content_type,\n+                                    progress);\n }\n \n inline Result ClientImpl::Patch(const std::string &path, size_t content_length,\n@@ -7996,14 +8168,15 @@ inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,\n                                 const std::string &content_type) {\n   return send_with_content_provider(\"PATCH\", path, headers, nullptr,\n                                     content_length, std::move(content_provider),\n-                                    nullptr, content_type);\n+                                    nullptr, content_type, nullptr);\n }\n \n inline Result ClientImpl::Patch(const std::string &path, const Headers &headers,\n                                 ContentProviderWithoutLength content_provider,\n                                 const std::string &content_type) {\n   return send_with_content_provider(\"PATCH\", path, headers, nullptr, 0, nullptr,\n-                                    std::move(content_provider), content_type);\n+                                    std::move(content_provider), content_type,\n+                                    nullptr);\n }\n \n inline Result ClientImpl::Delete(const std::string &path) {\n@@ -8021,14 +8194,30 @@ inline Result ClientImpl::Delete(const std::string &path, const char *body,\n   return Delete(path, Headers(), body, content_length, content_type);\n }\n \n+inline Result ClientImpl::Delete(const std::string &path, const char *body,\n+                                 size_t content_length,\n+                                 const std::string &content_type,\n+                                 Progress progress) {\n+  return Delete(path, Headers(), body, content_length, content_type, progress);\n+}\n+\n inline Result ClientImpl::Delete(const std::string &path,\n                                  const Headers &headers, const char *body,\n                                  size_t content_length,\n                                  const std::string &content_type) {\n+  return Delete(path, headers, body, content_length, content_type, nullptr);\n+}\n+\n+inline Result ClientImpl::Delete(const std::string &path,\n+                                 const Headers &headers, const char *body,\n+                                 size_t content_length,\n+                                 const std::string &content_type,\n+                                 Progress progress) {\n   Request req;\n   req.method = \"DELETE\";\n   req.headers = headers;\n   req.path = path;\n+  req.progress = progress;\n \n   if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }\n   req.body.assign(body, content_length);\n@@ -8042,6 +8231,14 @@ inline Result ClientImpl::Delete(const std::string &path,\n   return Delete(path, Headers(), body.data(), body.size(), content_type);\n }\n \n+inline Result ClientImpl::Delete(const std::string &path,\n+                                 const std::string &body,\n+                                 const std::string &content_type,\n+                                 Progress progress) {\n+  return Delete(path, Headers(), body.data(), body.size(), content_type,\n+                progress);\n+}\n+\n inline Result ClientImpl::Delete(const std::string &path,\n                                  const Headers &headers,\n                                  const std::string &body,\n@@ -8049,6 +8246,15 @@ inline Result ClientImpl::Delete(const std::string &path,\n   return Delete(path, headers, body.data(), body.size(), content_type);\n }\n \n+inline Result ClientImpl::Delete(const std::string &path,\n+                                 const Headers &headers,\n+                                 const std::string &body,\n+                                 const std::string &content_type,\n+                                 Progress progress) {\n+  return Delete(path, headers, body.data(), body.size(), content_type,\n+                progress);\n+}\n+\n inline Result ClientImpl::Options(const std::string &path) {\n   return Options(path, Headers());\n }\n@@ -9129,15 +9335,30 @@ inline Result Client::Post(const std::string &path, const Headers &headers,\n                            const std::string &content_type) {\n   return cli_->Post(path, headers, body, content_length, content_type);\n }\n+inline Result Client::Post(const std::string &path, const Headers &headers,\n+                           const char *body, size_t content_length,\n+                           const std::string &content_type, Progress progress) {\n+  return cli_->Post(path, headers, body, content_length, content_type,\n+                    progress);\n+}\n inline Result Client::Post(const std::string &path, const std::string &body,\n                            const std::string &content_type) {\n   return cli_->Post(path, body, content_type);\n }\n+inline Result Client::Post(const std::string &path, const std::string &body,\n+                           const std::string &content_type, Progress progress) {\n+  return cli_->Post(path, body, content_type, progress);\n+}\n inline Result Client::Post(const std::string &path, const Headers &headers,\n                            const std::string &body,\n                            const std::string &content_type) {\n   return cli_->Post(path, headers, body, content_type);\n }\n+inline Result Client::Post(const std::string &path, const Headers &headers,\n+                           const std::string &body,\n+                           const std::string &content_type, Progress progress) {\n+  return cli_->Post(path, headers, body, content_type, progress);\n+}\n inline Result Client::Post(const std::string &path, size_t content_length,\n                            ContentProvider content_provider,\n                            const std::string &content_type) {\n@@ -9168,6 +9389,10 @@ inline Result Client::Post(const std::string &path, const Headers &headers,\n                            const Params &params) {\n   return cli_->Post(path, headers, params);\n }\n+inline Result Client::Post(const std::string &path, const Headers &headers,\n+                           const Params &params, Progress progress) {\n+  return cli_->Post(path, headers, params, progress);\n+}\n inline Result Client::Post(const std::string &path,\n                            const MultipartFormDataItems &items) {\n   return cli_->Post(path, items);\n@@ -9198,15 +9423,29 @@ inline Result Client::Put(const std::string &path, const Headers &headers,\n                           const std::string &content_type) {\n   return cli_->Put(path, headers, body, content_length, content_type);\n }\n+inline Result Client::Put(const std::string &path, const Headers &headers,\n+                          const char *body, size_t content_length,\n+                          const std::string &content_type, Progress progress) {\n+  return cli_->Put(path, headers, body, content_length, content_type, progress);\n+}\n inline Result Client::Put(const std::string &path, const std::string &body,\n                           const std::string &content_type) {\n   return cli_->Put(path, body, content_type);\n }\n+inline Result Client::Put(const std::string &path, const std::string &body,\n+                          const std::string &content_type, Progress progress) {\n+  return cli_->Put(path, body, content_type, progress);\n+}\n inline Result Client::Put(const std::string &path, const Headers &headers,\n                           const std::string &body,\n                           const std::string &content_type) {\n   return cli_->Put(path, headers, body, content_type);\n }\n+inline Result Client::Put(const std::string &path, const Headers &headers,\n+                          const std::string &body,\n+                          const std::string &content_type, Progress progress) {\n+  return cli_->Put(path, headers, body, content_type, progress);\n+}\n inline Result Client::Put(const std::string &path, size_t content_length,\n                           ContentProvider content_provider,\n                           const std::string &content_type) {\n@@ -9237,6 +9476,10 @@ inline Result Client::Put(const std::string &path, const Headers &headers,\n                           const Params &params) {\n   return cli_->Put(path, headers, params);\n }\n+inline Result Client::Put(const std::string &path, const Headers &headers,\n+                          const Params &params, Progress progress) {\n+  return cli_->Put(path, headers, params, progress);\n+}\n inline Result Client::Put(const std::string &path,\n                           const MultipartFormDataItems &items) {\n   return cli_->Put(path, items);\n@@ -9264,20 +9507,39 @@ inline Result Client::Patch(const std::string &path, const char *body,\n                             const std::string &content_type) {\n   return cli_->Patch(path, body, content_length, content_type);\n }\n+inline Result Client::Patch(const std::string &path, const char *body,\n+                            size_t content_length,\n+                            const std::string &content_type, Progress progress) {\n+  return cli_->Patch(path, body, content_length, content_type, progress);\n+}\n inline Result Client::Patch(const std::string &path, const Headers &headers,\n                             const char *body, size_t content_length,\n                             const std::string &content_type) {\n   return cli_->Patch(path, headers, body, content_length, content_type);\n }\n+inline Result Client::Patch(const std::string &path, const Headers &headers,\n+                            const char *body, size_t content_length,\n+                            const std::string &content_type, Progress progress) {\n+  return cli_->Patch(path, headers, body, content_length, content_type, progress);\n+}\n inline Result Client::Patch(const std::string &path, const std::string &body,\n                             const std::string &content_type) {\n   return cli_->Patch(path, body, content_type);\n }\n+inline Result Client::Patch(const std::string &path, const std::string &body,\n+                            const std::string &content_type, Progress progress) {\n+  return cli_->Patch(path, body, content_type, progress);\n+}\n inline Result Client::Patch(const std::string &path, const Headers &headers,\n                             const std::string &body,\n                             const std::string &content_type) {\n   return cli_->Patch(path, headers, body, content_type);\n }\n+inline Result Client::Patch(const std::string &path, const Headers &headers,\n+                            const std::string &body,\n+                            const std::string &content_type, Progress progress) {\n+  return cli_->Patch(path, headers, body, content_type, progress);\n+}\n inline Result Client::Patch(const std::string &path, size_t content_length,\n                             ContentProvider content_provider,\n                             const std::string &content_type) {\n@@ -9312,20 +9574,39 @@ inline Result Client::Delete(const std::string &path, const char *body,\n                              const std::string &content_type) {\n   return cli_->Delete(path, body, content_length, content_type);\n }\n+inline Result Client::Delete(const std::string &path, const char *body,\n+                             size_t content_length,\n+                             const std::string &content_type, Progress progress) {\n+  return cli_->Delete(path, body, content_length, content_type, progress);\n+}\n inline Result Client::Delete(const std::string &path, const Headers &headers,\n                              const char *body, size_t content_length,\n                              const std::string &content_type) {\n   return cli_->Delete(path, headers, body, content_length, content_type);\n }\n+inline Result Client::Delete(const std::string &path, const Headers &headers,\n+                             const char *body, size_t content_length,\n+                             const std::string &content_type, Progress progress) {\n+  return cli_->Delete(path, headers, body, content_length, content_type, progress);\n+}\n inline Result Client::Delete(const std::string &path, const std::string &body,\n                              const std::string &content_type) {\n   return cli_->Delete(path, body, content_type);\n }\n+inline Result Client::Delete(const std::string &path, const std::string &body,\n+                             const std::string &content_type, Progress progress) {\n+  return cli_->Delete(path, body, content_type, progress);\n+}\n inline Result Client::Delete(const std::string &path, const Headers &headers,\n                              const std::string &body,\n                              const std::string &content_type) {\n   return cli_->Delete(path, headers, body, content_type);\n }\n+inline Result Client::Delete(const std::string &path, const Headers &headers,\n+                             const std::string &body,\n+                             const std::string &content_type, Progress progress) {\n+  return cli_->Delete(path, headers, body, content_type, progress);\n+}\n inline Result Client::Options(const std::string &path) {\n   return cli_->Options(path);\n }\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -779,6 +779,322 @@ TEST(CancelTest, WithCancelLargePayload_Online) {\n   EXPECT_EQ(Error::Canceled, res.error());\n }\n \n+TEST(CancelTest, NoCancelPost) {\n+  Server svr;\n+\n+  svr.Post(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Post(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+               \"application/json\", [](uint64_t, uint64_t) { return true; });\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(\"Hello World!\", res->body);\n+  EXPECT_EQ(StatusCode::OK_200, res->status);\n+}\n+\n+TEST(CancelTest, WithCancelSmallPayloadPost) {\n+  Server svr;\n+\n+  svr.Post(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Post(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+               \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n+TEST(CancelTest, WithCancelLargePayloadPost) {\n+  Server svr;\n+\n+  svr.Post(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(LARGE_DATA, \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Post(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+               \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n+TEST(CancelTest, NoCancelPut) {\n+  Server svr;\n+\n+  svr.Put(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Put(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+              \"application/json\", [](uint64_t, uint64_t) { return true; });\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(\"Hello World!\", res->body);\n+  EXPECT_EQ(StatusCode::OK_200, res->status);\n+}\n+\n+TEST(CancelTest, WithCancelSmallPayloadPut) {\n+  Server svr;\n+\n+  svr.Put(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Put(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+              \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n+TEST(CancelTest, WithCancelLargePayloadPut) {\n+  Server svr;\n+\n+  svr.Put(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(LARGE_DATA, \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Put(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+              \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n+TEST(CancelTest, NoCancelPatch) {\n+  Server svr;\n+\n+  svr.Patch(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Patch(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+                \"application/json\", [](uint64_t, uint64_t) { return true; });\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(\"Hello World!\", res->body);\n+  EXPECT_EQ(StatusCode::OK_200, res->status);\n+}\n+\n+TEST(CancelTest, WithCancelSmallPayloadPatch) {\n+  Server svr;\n+\n+  svr.Patch(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Patch(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+                \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n+TEST(CancelTest, WithCancelLargePayloadPatch) {\n+  Server svr;\n+\n+  svr.Patch(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(LARGE_DATA, \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Patch(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+                \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n+TEST(CancelTest, NoCancelDelete) {\n+  Server svr;\n+\n+  svr.Delete(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Delete(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+                 \"application/json\", [](uint64_t, uint64_t) { return true; });\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(\"Hello World!\", res->body);\n+  EXPECT_EQ(StatusCode::OK_200, res->status);\n+}\n+\n+TEST(CancelTest, WithCancelSmallPayloadDelete) {\n+  Server svr;\n+\n+  svr.Delete(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Delete(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+                 \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n+TEST(CancelTest, WithCancelLargePayloadDelete) {\n+  Server svr;\n+\n+  svr.Delete(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(LARGE_DATA, \"text/plain\");\n+  });\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.set_connection_timeout(std::chrono::seconds(5));\n+\n+  auto res =\n+      cli.Delete(\"/\", Headers(), JSON_DATA.data(), JSON_DATA.size(),\n+                 \"application/json\", [](uint64_t, uint64_t) { return false; });\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n+}\n+\n TEST(BaseAuthTest, FromHTTPWatch_Online) {\n #ifdef CPPHTTPLIB_DEFAULT_HTTPBIN\n   auto host = \"httpbin.org\";\n", "problem_statement": "httplib::Progress for Post requests?\nHello,\r\nhave you thought about adding a httplib::Progress for the \"Post\" requests ?\r\n\r\nty\n", "hints_text": "@fxfire, thanks for the feedback. I haven't had any necessity for it in my projects so far, and I am not planning to add it for now. But a pull request for this feature is always welcome!\n@fxfire hey can we talk a bit on discord? tricky#0833", "created_at": "2024-04-18T17:38:59Z", "version": "0.15"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1513, "instance_id": "yhirose__cpp-httplib-1513", "issue_numbers": ["1481"], "base_commit": "cdaa5c48dbbcb6e44420869587106ee692b85d2b", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -6289,6 +6289,13 @@ inline bool ClientImpl::send(Request &req, Response &res, Error &error) {\n     auto is_alive = false;\n     if (socket_.is_open()) {\n       is_alive = detail::is_socket_alive(socket_.sock);\n+#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+      if (is_ssl() && is_alive) {\n+        char buf[1];\n+        auto n = SSL_peek(socket_.ssl, buf, 1);\n+        if (n <= 0) { is_alive = false; }\n+      }\n+#endif\n       if (!is_alive) {\n         // Attempt to avoid sigpipe by shutting down nongracefully if it seems\n         // like the other side has already closed the connection Also, there\n@@ -6339,7 +6346,7 @@ inline bool ClientImpl::send(Request &req, Response &res, Error &error) {\n   auto ret = false;\n   auto close_connection = !keep_alive_;\n \n-  auto se = detail::scope_exit<std::function<void (void)>>([&]() {\n+  auto se = detail::scope_exit<std::function<void(void)>>([&]() {\n     // Briefly lock mutex in order to mark that a request is no longer ongoing\n     std::lock_guard<std::mutex> guard(socket_mutex_);\n     socket_requests_in_flight_ -= 1;\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -3871,6 +3871,32 @@ TEST(ServerStopTest, StopServerWithChunkedTransmission) {\n   ASSERT_FALSE(svr.is_running());\n }\n \n+TEST(ServerStopTest, ClientAccessAfterServerDown) {\n+  httplib::Server svr;\n+  svr.Post(\"/hi\", [&](const httplib::Request & /*req*/, httplib::Response &res) {\n+    res.status = 200;\n+  });\n+\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  while (!svr.is_running()) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(5));\n+  }\n+\n+  Client cli(HOST, PORT);\n+\n+  auto res = cli.Post(\"/hi\", \"data\", \"text/plain\");\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+\n+  svr.stop();\n+  thread.join();\n+  ASSERT_FALSE(svr.is_running());\n+\n+  res = cli.Post(\"/hi\", \"data\", \"text/plain\");\n+  ASSERT_FALSE(res);\n+}\n+\n TEST(StreamingTest, NoContentLengthStreaming) {\n   Server svr;\n \n@@ -4067,6 +4093,39 @@ TEST(KeepAliveTest, Issue1041) {\n   f.wait();\n }\n \n+#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+TEST(KeepAliveTest, SSLClientReconnection) {\n+  SSLServer svr(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE);\n+  ASSERT_TRUE(svr.is_valid());\n+  svr.set_keep_alive_timeout(1);\n+\n+  svr.Get(\"/hi\", [](const httplib::Request &, httplib::Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+\n+  auto f = std::async(std::launch::async, [&svr] { svr.listen(HOST, PORT); });\n+  std::this_thread::sleep_for(std::chrono::milliseconds(200));\n+\n+  SSLClient cli(HOST, PORT);\n+  cli.enable_server_certificate_verification(false);\n+  cli.set_keep_alive(true);\n+\n+  auto result = cli.Get(\"/hi\");\n+  ASSERT_TRUE(result);\n+  EXPECT_EQ(200, result->status);\n+\n+  std::this_thread::sleep_for(std::chrono::seconds(2));\n+\n+  result = cli.Get(\"/hi\");\n+\n+  svr.stop();\n+  f.wait();\n+\n+  ASSERT_TRUE(result);\n+  EXPECT_EQ(200, result->status);\n+}\n+#endif\n+\n TEST(ClientProblemDetectionTest, ContentProvider) {\n   Server svr;\n \n", "problem_statement": "detail::is_socket_alive() is not work for https connection\nis_socket_alive() is always return ture even though peer closed TLS and TCP connecton,  I dont konwn how to detect  whether TLS connection is alived.\n", "hints_text": "@chisheng thanks for the feedback. This method is not intended to be used by users, rather for internal use in cpp-httplib to detect a current socket is writable. That's why it's in the namespace `detail`.\r\n\r\nAlso there exist some unit cases where you can see it returns 'false'. One of them is `ServerTest.ClientStop`. Hope it helps.\nSorry\uff0cI didn't explain my problem clearly.Pseudocode\r\nint main()\r\n{\r\nhttplib::SSLClient cli();\r\ncli.post();//first request is success\r\nsleep(60);//The server will close the connection after 60 seconds\r\ncli.post()//second request will failed\uff0cis_socket_alive() return true for TLS socket ,it should reconnect TLS instead of use previous one. \r\n}\n@chisheng thanks for the more details. I'll try to reproduce it.\r\n\r\n> sleep(60);//The server will close the connection after 60 seconds\r\n\r\nDoes it actually mean that your server will close **within** 60 seconds?\r\n\r\n\nyes,the keep-alive timeout of http server  is 60s\n@chisheng I now confirmed it's a bug. Thanks for the report.", "created_at": "2023-03-04T04:29:47Z", "version": "0.12"}
{"repo": "yhirose/cpp-httplib", "pull_number": 2048, "instance_id": "yhirose__cpp-httplib-2048", "issue_numbers": ["2034"], "base_commit": "8aad481c69938eefc1e9f7100aefa79967697851", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -66,6 +66,10 @@\n #define CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_USECOND 0\n #endif\n \n+#ifndef CPPHTTPLIB_CLIENT_GLOBAL_TIMEOUT_MSECOND\n+#define CPPHTTPLIB_CLIENT_GLOBAL_TIMEOUT_MSECOND 0\n+#endif\n+\n #ifndef CPPHTTPLIB_IDLE_INTERVAL_SECOND\n #define CPPHTTPLIB_IDLE_INTERVAL_SECOND 0\n #endif\n@@ -664,6 +668,8 @@ struct Request {\n   ContentProvider content_provider_;\n   bool is_chunked_content_provider_ = false;\n   size_t authorization_count_ = 0;\n+  std::chrono::time_point<std::chrono::steady_clock> start_time_ =\n+      std::chrono::steady_clock::time_point::min();\n };\n \n struct Response {\n@@ -737,6 +743,8 @@ class Stream {\n   virtual void get_local_ip_and_port(std::string &ip, int &port) const = 0;\n   virtual socket_t socket() const = 0;\n \n+  virtual time_t duration() const = 0;\n+\n   ssize_t write(const char *ptr);\n   ssize_t write(const std::string &s);\n };\n@@ -1423,6 +1431,10 @@ class ClientImpl {\n   template <class Rep, class Period>\n   void set_write_timeout(const std::chrono::duration<Rep, Period> &duration);\n \n+  void set_global_timeout(time_t msec);\n+  template <class Rep, class Period>\n+  void set_global_timeout(const std::chrono::duration<Rep, Period> &duration);\n+\n   void set_basic_auth(const std::string &username, const std::string &password);\n   void set_bearer_token_auth(const std::string &token);\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n@@ -1531,6 +1543,7 @@ class ClientImpl {\n   time_t read_timeout_usec_ = CPPHTTPLIB_CLIENT_READ_TIMEOUT_USECOND;\n   time_t write_timeout_sec_ = CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_SECOND;\n   time_t write_timeout_usec_ = CPPHTTPLIB_CLIENT_WRITE_TIMEOUT_USECOND;\n+  time_t global_timeout_msec_ = CPPHTTPLIB_CLIENT_GLOBAL_TIMEOUT_MSECOND;\n \n   std::string basic_auth_username_;\n   std::string basic_auth_password_;\n@@ -1585,9 +1598,6 @@ class ClientImpl {\n   bool send_(Request &req, Response &res, Error &error);\n   Result send_(Request &&req);\n \n-#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n-  bool is_ssl_peer_could_be_closed(SSL *ssl) const;\n-#endif\n   socket_t create_client_socket(Error &error) const;\n   bool read_response_line(Stream &strm, const Request &req,\n                           Response &res) const;\n@@ -1613,8 +1623,10 @@ class ClientImpl {\n \n   std::string adjust_host_string(const std::string &host) const;\n \n-  virtual bool process_socket(const Socket &socket,\n-                              std::function<bool(Stream &strm)> callback);\n+  virtual bool\n+  process_socket(const Socket &socket,\n+                 std::chrono::time_point<std::chrono::steady_clock> start_time,\n+                 std::function<bool(Stream &strm)> callback);\n   virtual bool is_ssl() const;\n };\n \n@@ -1856,6 +1868,10 @@ class Client {\n   template <class Rep, class Period>\n   void set_write_timeout(const std::chrono::duration<Rep, Period> &duration);\n \n+  void set_global_timeout(time_t msec);\n+  template <class Rep, class Period>\n+  void set_global_timeout(const std::chrono::duration<Rep, Period> &duration);\n+\n   void set_basic_auth(const std::string &username, const std::string &password);\n   void set_bearer_token_auth(const std::string &token);\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n@@ -1973,12 +1989,16 @@ class SSLClient final : public ClientImpl {\n   void shutdown_ssl(Socket &socket, bool shutdown_gracefully) override;\n   void shutdown_ssl_impl(Socket &socket, bool shutdown_gracefully);\n \n-  bool process_socket(const Socket &socket,\n-                      std::function<bool(Stream &strm)> callback) override;\n+  bool\n+  process_socket(const Socket &socket,\n+                 std::chrono::time_point<std::chrono::steady_clock> start_time,\n+                 std::function<bool(Stream &strm)> callback) override;\n   bool is_ssl() const override;\n \n-  bool connect_with_proxy(Socket &sock, Response &res, bool &success,\n-                          Error &error);\n+  bool connect_with_proxy(\n+      Socket &sock,\n+      std::chrono::time_point<std::chrono::steady_clock> start_time,\n+      Response &res, bool &success, Error &error);\n   bool initialize_ssl(Socket &socket, Error &error);\n \n   bool load_certs();\n@@ -2240,6 +2260,14 @@ inline void ClientImpl::set_write_timeout(\n       duration, [&](time_t sec, time_t usec) { set_write_timeout(sec, usec); });\n }\n \n+template <class Rep, class Period>\n+inline void ClientImpl::set_global_timeout(\n+    const std::chrono::duration<Rep, Period> &duration) {\n+  auto msec =\n+      std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();\n+  set_global_timeout(msec);\n+}\n+\n template <class Rep, class Period>\n inline void Client::set_connection_timeout(\n     const std::chrono::duration<Rep, Period> &duration) {\n@@ -2258,6 +2286,12 @@ Client::set_write_timeout(const std::chrono::duration<Rep, Period> &duration) {\n   cli_->set_write_timeout(duration);\n }\n \n+template <class Rep, class Period>\n+inline void\n+Client::set_global_timeout(const std::chrono::duration<Rep, Period> &duration) {\n+  cli_->set_global_timeout(duration);\n+}\n+\n /*\n  * Forward declarations and types that will be part of the .h file if split into\n  * .h + .cc.\n@@ -2332,10 +2366,12 @@ void split(const char *b, const char *e, char d,\n void split(const char *b, const char *e, char d, size_t m,\n            std::function<void(const char *, const char *)> fn);\n \n-bool process_client_socket(socket_t sock, time_t read_timeout_sec,\n-                           time_t read_timeout_usec, time_t write_timeout_sec,\n-                           time_t write_timeout_usec,\n-                           std::function<bool(Stream &)> callback);\n+bool process_client_socket(\n+    socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,\n+    time_t write_timeout_sec, time_t write_timeout_usec,\n+    time_t global_timeout_msec,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time,\n+    std::function<bool(Stream &)> callback);\n \n socket_t create_client_socket(const std::string &host, const std::string &ip,\n                               int port, int address_family, bool tcp_nodelay,\n@@ -2383,6 +2419,7 @@ class BufferStream final : public Stream {\n   void get_remote_ip_and_port(std::string &ip, int &port) const override;\n   void get_local_ip_and_port(std::string &ip, int &port) const override;\n   socket_t socket() const override;\n+  time_t duration() const override;\n \n   const std::string &get_buffer() const;\n \n@@ -3300,7 +3337,10 @@ inline bool is_socket_alive(socket_t sock) {\n class SocketStream final : public Stream {\n public:\n   SocketStream(socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,\n-               time_t write_timeout_sec, time_t write_timeout_usec);\n+               time_t write_timeout_sec, time_t write_timeout_usec,\n+               time_t global_timeout_msec = 0,\n+               std::chrono::time_point<std::chrono::steady_clock> start_time =\n+                   std::chrono::steady_clock::time_point::min());\n   ~SocketStream() override;\n \n   bool is_readable() const override;\n@@ -3310,6 +3350,7 @@ class SocketStream final : public Stream {\n   void get_remote_ip_and_port(std::string &ip, int &port) const override;\n   void get_local_ip_and_port(std::string &ip, int &port) const override;\n   socket_t socket() const override;\n+  time_t duration() const override;\n \n private:\n   socket_t sock_;\n@@ -3317,6 +3358,8 @@ class SocketStream final : public Stream {\n   time_t read_timeout_usec_;\n   time_t write_timeout_sec_;\n   time_t write_timeout_usec_;\n+  time_t global_timeout_msec_;\n+  const std::chrono::time_point<std::chrono::steady_clock> start_time;\n \n   std::vector<char> read_buff_;\n   size_t read_buff_off_ = 0;\n@@ -3328,9 +3371,12 @@ class SocketStream final : public Stream {\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n class SSLSocketStream final : public Stream {\n public:\n-  SSLSocketStream(socket_t sock, SSL *ssl, time_t read_timeout_sec,\n-                  time_t read_timeout_usec, time_t write_timeout_sec,\n-                  time_t write_timeout_usec);\n+  SSLSocketStream(\n+      socket_t sock, SSL *ssl, time_t read_timeout_sec,\n+      time_t read_timeout_usec, time_t write_timeout_sec,\n+      time_t write_timeout_usec, time_t global_timeout_msec = 0,\n+      std::chrono::time_point<std::chrono::steady_clock> start_time =\n+          std::chrono::steady_clock::time_point::min());\n   ~SSLSocketStream() override;\n \n   bool is_readable() const override;\n@@ -3340,6 +3386,7 @@ class SSLSocketStream final : public Stream {\n   void get_remote_ip_and_port(std::string &ip, int &port) const override;\n   void get_local_ip_and_port(std::string &ip, int &port) const override;\n   socket_t socket() const override;\n+  time_t duration() const override;\n \n private:\n   socket_t sock_;\n@@ -3348,6 +3395,8 @@ class SSLSocketStream final : public Stream {\n   time_t read_timeout_usec_;\n   time_t write_timeout_sec_;\n   time_t write_timeout_usec_;\n+  time_t global_timeout_msec_;\n+  const std::chrono::time_point<std::chrono::steady_clock> start_time;\n };\n #endif\n \n@@ -3418,13 +3467,15 @@ process_server_socket(const std::atomic<socket_t> &svr_sock, socket_t sock,\n       });\n }\n \n-inline bool process_client_socket(socket_t sock, time_t read_timeout_sec,\n-                                  time_t read_timeout_usec,\n-                                  time_t write_timeout_sec,\n-                                  time_t write_timeout_usec,\n-                                  std::function<bool(Stream &)> callback) {\n+inline bool process_client_socket(\n+    socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,\n+    time_t write_timeout_sec, time_t write_timeout_usec,\n+    time_t global_timeout_msec,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time,\n+    std::function<bool(Stream &)> callback) {\n   SocketStream strm(sock, read_timeout_sec, read_timeout_usec,\n-                    write_timeout_sec, write_timeout_usec);\n+                    write_timeout_sec, write_timeout_usec, global_timeout_msec,\n+                    start_time);\n   return callback(strm);\n }\n \n@@ -4313,7 +4364,7 @@ inline bool read_content_without_length(Stream &strm,\n   uint64_t r = 0;\n   for (;;) {\n     auto n = strm.read(buf, CPPHTTPLIB_RECV_BUFSIZ);\n-    if (n <= 0) { return true; }\n+    if (n <= 0) { return false; }\n \n     if (!out(buf, static_cast<size_t>(n), r, 0)) { return false; }\n     r += static_cast<uint64_t>(n);\n@@ -5433,9 +5484,76 @@ inline std::string SHA_256(const std::string &s) {\n inline std::string SHA_512(const std::string &s) {\n   return message_digest(s, EVP_sha512());\n }\n-#endif\n \n-#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+inline std::pair<std::string, std::string> make_digest_authentication_header(\n+    const Request &req, const std::map<std::string, std::string> &auth,\n+    size_t cnonce_count, const std::string &cnonce, const std::string &username,\n+    const std::string &password, bool is_proxy = false) {\n+  std::string nc;\n+  {\n+    std::stringstream ss;\n+    ss << std::setfill('0') << std::setw(8) << std::hex << cnonce_count;\n+    nc = ss.str();\n+  }\n+\n+  std::string qop;\n+  if (auth.find(\"qop\") != auth.end()) {\n+    qop = auth.at(\"qop\");\n+    if (qop.find(\"auth-int\") != std::string::npos) {\n+      qop = \"auth-int\";\n+    } else if (qop.find(\"auth\") != std::string::npos) {\n+      qop = \"auth\";\n+    } else {\n+      qop.clear();\n+    }\n+  }\n+\n+  std::string algo = \"MD5\";\n+  if (auth.find(\"algorithm\") != auth.end()) { algo = auth.at(\"algorithm\"); }\n+\n+  std::string response;\n+  {\n+    auto H = algo == \"SHA-256\"   ? detail::SHA_256\n+             : algo == \"SHA-512\" ? detail::SHA_512\n+                                 : detail::MD5;\n+\n+    auto A1 = username + \":\" + auth.at(\"realm\") + \":\" + password;\n+\n+    auto A2 = req.method + \":\" + req.path;\n+    if (qop == \"auth-int\") { A2 += \":\" + H(req.body); }\n+\n+    if (qop.empty()) {\n+      response = H(H(A1) + \":\" + auth.at(\"nonce\") + \":\" + H(A2));\n+    } else {\n+      response = H(H(A1) + \":\" + auth.at(\"nonce\") + \":\" + nc + \":\" + cnonce +\n+                   \":\" + qop + \":\" + H(A2));\n+    }\n+  }\n+\n+  auto opaque = (auth.find(\"opaque\") != auth.end()) ? auth.at(\"opaque\") : \"\";\n+\n+  auto field = \"Digest username=\\\"\" + username + \"\\\", realm=\\\"\" +\n+               auth.at(\"realm\") + \"\\\", nonce=\\\"\" + auth.at(\"nonce\") +\n+               \"\\\", uri=\\\"\" + req.path + \"\\\", algorithm=\" + algo +\n+               (qop.empty() ? \", response=\\\"\"\n+                            : \", qop=\" + qop + \", nc=\" + nc + \", cnonce=\\\"\" +\n+                                  cnonce + \"\\\", response=\\\"\") +\n+               response + \"\\\"\" +\n+               (opaque.empty() ? \"\" : \", opaque=\\\"\" + opaque + \"\\\"\");\n+\n+  auto key = is_proxy ? \"Proxy-Authorization\" : \"Authorization\";\n+  return std::make_pair(key, field);\n+}\n+\n+inline bool is_ssl_peer_could_be_closed(SSL *ssl, socket_t sock) {\n+  detail::set_nonblocking(sock, true);\n+  auto se = detail::scope_exit([&]() { detail::set_nonblocking(sock, false); });\n+\n+  char buf[1];\n+  return !SSL_peek(ssl, buf, 1) &&\n+         SSL_get_error(ssl, 0) == SSL_ERROR_ZERO_RETURN;\n+}\n+\n #ifdef _WIN32\n // NOTE: This code came up with the following stackoverflow post:\n // https://stackoverflow.com/questions/9507184/can-openssl-on-windows-use-the-system-certificate-store\n@@ -5574,68 +5692,6 @@ class WSInit {\n static WSInit wsinit_;\n #endif\n \n-#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n-inline std::pair<std::string, std::string> make_digest_authentication_header(\n-    const Request &req, const std::map<std::string, std::string> &auth,\n-    size_t cnonce_count, const std::string &cnonce, const std::string &username,\n-    const std::string &password, bool is_proxy = false) {\n-  std::string nc;\n-  {\n-    std::stringstream ss;\n-    ss << std::setfill('0') << std::setw(8) << std::hex << cnonce_count;\n-    nc = ss.str();\n-  }\n-\n-  std::string qop;\n-  if (auth.find(\"qop\") != auth.end()) {\n-    qop = auth.at(\"qop\");\n-    if (qop.find(\"auth-int\") != std::string::npos) {\n-      qop = \"auth-int\";\n-    } else if (qop.find(\"auth\") != std::string::npos) {\n-      qop = \"auth\";\n-    } else {\n-      qop.clear();\n-    }\n-  }\n-\n-  std::string algo = \"MD5\";\n-  if (auth.find(\"algorithm\") != auth.end()) { algo = auth.at(\"algorithm\"); }\n-\n-  std::string response;\n-  {\n-    auto H = algo == \"SHA-256\"   ? detail::SHA_256\n-             : algo == \"SHA-512\" ? detail::SHA_512\n-                                 : detail::MD5;\n-\n-    auto A1 = username + \":\" + auth.at(\"realm\") + \":\" + password;\n-\n-    auto A2 = req.method + \":\" + req.path;\n-    if (qop == \"auth-int\") { A2 += \":\" + H(req.body); }\n-\n-    if (qop.empty()) {\n-      response = H(H(A1) + \":\" + auth.at(\"nonce\") + \":\" + H(A2));\n-    } else {\n-      response = H(H(A1) + \":\" + auth.at(\"nonce\") + \":\" + nc + \":\" + cnonce +\n-                   \":\" + qop + \":\" + H(A2));\n-    }\n-  }\n-\n-  auto opaque = (auth.find(\"opaque\") != auth.end()) ? auth.at(\"opaque\") : \"\";\n-\n-  auto field = \"Digest username=\\\"\" + username + \"\\\", realm=\\\"\" +\n-               auth.at(\"realm\") + \"\\\", nonce=\\\"\" + auth.at(\"nonce\") +\n-               \"\\\", uri=\\\"\" + req.path + \"\\\", algorithm=\" + algo +\n-               (qop.empty() ? \", response=\\\"\"\n-                            : \", qop=\" + qop + \", nc=\" + nc + \", cnonce=\\\"\" +\n-                                  cnonce + \"\\\", response=\\\"\") +\n-               response + \"\\\"\" +\n-               (opaque.empty() ? \"\" : \", opaque=\\\"\" + opaque + \"\\\"\");\n-\n-  auto key = is_proxy ? \"Proxy-Authorization\" : \"Authorization\";\n-  return std::make_pair(key, field);\n-}\n-#endif\n-\n inline bool parse_www_authenticate(const Response &res,\n                                    std::map<std::string, std::string> &auth,\n                                    bool is_proxy) {\n@@ -5954,20 +6010,45 @@ inline ssize_t Stream::write(const std::string &s) {\n \n namespace detail {\n \n+inline void calc_actual_timeout(time_t global_timeout_msec,\n+                                time_t duration_msec, time_t timeout_sec,\n+                                time_t timeout_usec, time_t &actual_timeout_sec,\n+                                time_t &actual_timeout_usec) {\n+  auto timeout_msec = (timeout_sec * 1000) + (timeout_usec / 1000);\n+\n+  auto actual_timeout_msec =\n+      std::min(global_timeout_msec - duration_msec, timeout_msec);\n+\n+  actual_timeout_sec = actual_timeout_msec / 1000;\n+  actual_timeout_usec = (actual_timeout_msec % 1000) * 1000;\n+}\n+\n // Socket stream implementation\n-inline SocketStream::SocketStream(socket_t sock, time_t read_timeout_sec,\n-                                  time_t read_timeout_usec,\n-                                  time_t write_timeout_sec,\n-                                  time_t write_timeout_usec)\n+inline SocketStream::SocketStream(\n+    socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,\n+    time_t write_timeout_sec, time_t write_timeout_usec,\n+    time_t global_timeout_msec,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time)\n     : sock_(sock), read_timeout_sec_(read_timeout_sec),\n       read_timeout_usec_(read_timeout_usec),\n       write_timeout_sec_(write_timeout_sec),\n-      write_timeout_usec_(write_timeout_usec), read_buff_(read_buff_size_, 0) {}\n+      write_timeout_usec_(write_timeout_usec),\n+      global_timeout_msec_(global_timeout_msec), start_time(start_time),\n+      read_buff_(read_buff_size_, 0) {}\n \n inline SocketStream::~SocketStream() = default;\n \n inline bool SocketStream::is_readable() const {\n-  return select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;\n+  if (global_timeout_msec_ <= 0) {\n+    return select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;\n+  }\n+\n+  time_t read_timeout_sec;\n+  time_t read_timeout_usec;\n+  calc_actual_timeout(global_timeout_msec_, duration(), read_timeout_sec_,\n+                      read_timeout_usec_, read_timeout_sec, read_timeout_usec);\n+\n+  return select_read(sock_, read_timeout_sec, read_timeout_usec) > 0;\n }\n \n inline bool SocketStream::is_writable() const {\n@@ -6044,6 +6125,12 @@ inline void SocketStream::get_local_ip_and_port(std::string &ip,\n \n inline socket_t SocketStream::socket() const { return sock_; }\n \n+inline time_t SocketStream::duration() const {\n+  return std::chrono::duration_cast<std::chrono::milliseconds>(\n+             std::chrono::steady_clock::now() - start_time)\n+      .count();\n+}\n+\n // Buffer stream implementation\n inline bool BufferStream::is_readable() const { return true; }\n \n@@ -6072,6 +6159,8 @@ inline void BufferStream::get_local_ip_and_port(std::string & /*ip*/,\n \n inline socket_t BufferStream::socket() const { return 0; }\n \n+inline time_t BufferStream::duration() const { return 0; }\n+\n inline const std::string &BufferStream::get_buffer() const { return buffer; }\n \n inline PathParamsMatcher::PathParamsMatcher(const std::string &pattern) {\n@@ -7368,6 +7457,7 @@ inline void ClientImpl::copy_settings(const ClientImpl &rhs) {\n   read_timeout_usec_ = rhs.read_timeout_usec_;\n   write_timeout_sec_ = rhs.write_timeout_sec_;\n   write_timeout_usec_ = rhs.write_timeout_usec_;\n+  global_timeout_msec_ = rhs.global_timeout_msec_;\n   basic_auth_username_ = rhs.basic_auth_username_;\n   basic_auth_password_ = rhs.basic_auth_password_;\n   bearer_token_auth_token_ = rhs.bearer_token_auth_token_;\n@@ -7514,18 +7604,6 @@ inline bool ClientImpl::send(Request &req, Response &res, Error &error) {\n   return ret;\n }\n \n-#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n-inline bool ClientImpl::is_ssl_peer_could_be_closed(SSL *ssl) const {\n-  detail::set_nonblocking(socket_.sock, true);\n-  auto se = detail::scope_exit(\n-      [&]() { detail::set_nonblocking(socket_.sock, false); });\n-\n-  char buf[1];\n-  return !SSL_peek(ssl, buf, 1) &&\n-         SSL_get_error(ssl, 0) == SSL_ERROR_ZERO_RETURN;\n-}\n-#endif\n-\n inline bool ClientImpl::send_(Request &req, Response &res, Error &error) {\n   {\n     std::lock_guard<std::mutex> guard(socket_mutex_);\n@@ -7540,7 +7618,9 @@ inline bool ClientImpl::send_(Request &req, Response &res, Error &error) {\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n       if (is_alive && is_ssl()) {\n-        if (is_ssl_peer_could_be_closed(socket_.ssl)) { is_alive = false; }\n+        if (detail::is_ssl_peer_could_be_closed(socket_.ssl, socket_.sock)) {\n+          is_alive = false;\n+        }\n       }\n #endif\n \n@@ -7565,7 +7645,8 @@ inline bool ClientImpl::send_(Request &req, Response &res, Error &error) {\n         auto &scli = static_cast<SSLClient &>(*this);\n         if (!proxy_host_.empty() && proxy_port_ != -1) {\n           auto success = false;\n-          if (!scli.connect_with_proxy(socket_, res, success, error)) {\n+          if (!scli.connect_with_proxy(socket_, req.start_time_, res, success,\n+                                       error)) {\n             return success;\n           }\n         }\n@@ -7611,7 +7692,7 @@ inline bool ClientImpl::send_(Request &req, Response &res, Error &error) {\n     }\n   });\n \n-  ret = process_socket(socket_, [&](Stream &strm) {\n+  ret = process_socket(socket_, req.start_time_, [&](Stream &strm) {\n     return handle_request(strm, req, res, close_connection, error);\n   });\n \n@@ -8020,6 +8101,9 @@ inline Result ClientImpl::send_with_content_provider(\n   req.headers = headers;\n   req.path = path;\n   req.progress = progress;\n+  if (global_timeout_msec_ > 0) {\n+    req.start_time_ = std::chrono::steady_clock::now();\n+  }\n \n   auto error = Error::Success;\n \n@@ -8046,7 +8130,7 @@ inline bool ClientImpl::process_request(Stream &strm, Request &req,\n   if (is_ssl()) {\n     auto is_proxy_enabled = !proxy_host_.empty() && proxy_port_ != -1;\n     if (!is_proxy_enabled) {\n-      if (is_ssl_peer_could_be_closed(socket_.ssl)) {\n+      if (detail::is_ssl_peer_could_be_closed(socket_.ssl, socket_.sock)) {\n         error = Error::SSLPeerCouldBeClosed_;\n         return false;\n       }\n@@ -8171,12 +8255,14 @@ inline ContentProviderWithoutLength ClientImpl::get_multipart_content_provider(\n   };\n }\n \n-inline bool\n-ClientImpl::process_socket(const Socket &socket,\n-                           std::function<bool(Stream &strm)> callback) {\n+inline bool ClientImpl::process_socket(\n+    const Socket &socket,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time,\n+    std::function<bool(Stream &strm)> callback) {\n   return detail::process_client_socket(\n       socket.sock, read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,\n-      write_timeout_usec_, std::move(callback));\n+      write_timeout_usec_, global_timeout_msec_, start_time,\n+      std::move(callback));\n }\n \n inline bool ClientImpl::is_ssl() const { return false; }\n@@ -8200,6 +8286,9 @@ inline Result ClientImpl::Get(const std::string &path, const Headers &headers,\n   req.path = path;\n   req.headers = headers;\n   req.progress = std::move(progress);\n+  if (global_timeout_msec_ > 0) {\n+    req.start_time_ = std::chrono::steady_clock::now();\n+  }\n \n   return send_(std::move(req));\n }\n@@ -8265,6 +8354,9 @@ inline Result ClientImpl::Get(const std::string &path, const Headers &headers,\n         return content_receiver(data, data_length);\n       };\n   req.progress = std::move(progress);\n+  if (global_timeout_msec_ > 0) {\n+    req.start_time_ = std::chrono::steady_clock::now();\n+  }\n \n   return send_(std::move(req));\n }\n@@ -8310,6 +8402,9 @@ inline Result ClientImpl::Head(const std::string &path,\n   req.method = \"HEAD\";\n   req.headers = headers;\n   req.path = path;\n+  if (global_timeout_msec_ > 0) {\n+    req.start_time_ = std::chrono::steady_clock::now();\n+  }\n \n   return send_(std::move(req));\n }\n@@ -8727,6 +8822,9 @@ inline Result ClientImpl::Delete(const std::string &path,\n   req.headers = headers;\n   req.path = path;\n   req.progress = progress;\n+  if (global_timeout_msec_ > 0) {\n+    req.start_time_ = std::chrono::steady_clock::now();\n+  }\n \n   if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }\n   req.body.assign(body, content_length);\n@@ -8774,6 +8872,9 @@ inline Result ClientImpl::Options(const std::string &path,\n   req.method = \"OPTIONS\";\n   req.headers = headers;\n   req.path = path;\n+  if (global_timeout_msec_ > 0) {\n+    req.start_time_ = std::chrono::steady_clock::now();\n+  }\n \n   return send_(std::move(req));\n }\n@@ -8827,6 +8928,10 @@ inline void ClientImpl::set_write_timeout(time_t sec, time_t usec) {\n   write_timeout_usec_ = usec;\n }\n \n+inline void ClientImpl::set_global_timeout(time_t msec) {\n+  global_timeout_msec_ = msec;\n+}\n+\n inline void ClientImpl::set_basic_auth(const std::string &username,\n                                        const std::string &password) {\n   basic_auth_username_ = username;\n@@ -9065,12 +9170,14 @@ inline bool process_server_socket_ssl(\n }\n \n template <typename T>\n-inline bool\n-process_client_socket_ssl(SSL *ssl, socket_t sock, time_t read_timeout_sec,\n-                          time_t read_timeout_usec, time_t write_timeout_sec,\n-                          time_t write_timeout_usec, T callback) {\n+inline bool process_client_socket_ssl(\n+    SSL *ssl, socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,\n+    time_t write_timeout_sec, time_t write_timeout_usec,\n+    time_t global_timeout_msec,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time, T callback) {\n   SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,\n-                       write_timeout_sec, write_timeout_usec);\n+                       write_timeout_sec, write_timeout_usec,\n+                       global_timeout_msec, start_time);\n   return callback(strm);\n }\n \n@@ -9083,27 +9190,37 @@ class SSLInit {\n };\n \n // SSL socket stream implementation\n-inline SSLSocketStream::SSLSocketStream(socket_t sock, SSL *ssl,\n-                                        time_t read_timeout_sec,\n-                                        time_t read_timeout_usec,\n-                                        time_t write_timeout_sec,\n-                                        time_t write_timeout_usec)\n+inline SSLSocketStream::SSLSocketStream(\n+    socket_t sock, SSL *ssl, time_t read_timeout_sec, time_t read_timeout_usec,\n+    time_t write_timeout_sec, time_t write_timeout_usec,\n+    time_t global_timeout_msec,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time)\n     : sock_(sock), ssl_(ssl), read_timeout_sec_(read_timeout_sec),\n       read_timeout_usec_(read_timeout_usec),\n       write_timeout_sec_(write_timeout_sec),\n-      write_timeout_usec_(write_timeout_usec) {\n+      write_timeout_usec_(write_timeout_usec),\n+      global_timeout_msec_(global_timeout_msec), start_time(start_time) {\n   SSL_clear_mode(ssl, SSL_MODE_AUTO_RETRY);\n }\n \n inline SSLSocketStream::~SSLSocketStream() = default;\n \n inline bool SSLSocketStream::is_readable() const {\n-  return detail::select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;\n+  if (global_timeout_msec_ <= 0) {\n+    return select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0;\n+  }\n+\n+  time_t read_timeout_sec;\n+  time_t read_timeout_usec;\n+  calc_actual_timeout(global_timeout_msec_, duration(), read_timeout_sec_,\n+                      read_timeout_usec_, read_timeout_sec, read_timeout_usec);\n+\n+  return select_read(sock_, read_timeout_sec, read_timeout_usec) > 0;\n }\n \n inline bool SSLSocketStream::is_writable() const {\n   return select_write(sock_, write_timeout_sec_, write_timeout_usec_) > 0 &&\n-         is_socket_alive(sock_);\n+         is_socket_alive(sock_) && !is_ssl_peer_could_be_closed(ssl_, sock_);\n }\n \n inline ssize_t SSLSocketStream::read(char *ptr, size_t size) {\n@@ -9134,8 +9251,9 @@ inline ssize_t SSLSocketStream::read(char *ptr, size_t size) {\n       }\n     }\n     return ret;\n+  } else {\n+    return -1;\n   }\n-  return -1;\n }\n \n inline ssize_t SSLSocketStream::write(const char *ptr, size_t size) {\n@@ -9181,6 +9299,12 @@ inline void SSLSocketStream::get_local_ip_and_port(std::string &ip,\n \n inline socket_t SSLSocketStream::socket() const { return sock_; }\n \n+inline time_t SSLSocketStream::duration() const {\n+  return std::chrono::duration_cast<std::chrono::milliseconds>(\n+             std::chrono::steady_clock::now() - start_time)\n+      .count();\n+}\n+\n static SSLInit sslinit_;\n \n } // namespace detail\n@@ -9421,16 +9545,22 @@ inline bool SSLClient::create_and_connect_socket(Socket &socket, Error &error) {\n }\n \n // Assumes that socket_mutex_ is locked and that there are no requests in flight\n-inline bool SSLClient::connect_with_proxy(Socket &socket, Response &res,\n-                                          bool &success, Error &error) {\n+inline bool SSLClient::connect_with_proxy(\n+    Socket &socket,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time,\n+    Response &res, bool &success, Error &error) {\n   success = true;\n   Response proxy_res;\n   if (!detail::process_client_socket(\n           socket.sock, read_timeout_sec_, read_timeout_usec_,\n-          write_timeout_sec_, write_timeout_usec_, [&](Stream &strm) {\n+          write_timeout_sec_, write_timeout_usec_, global_timeout_msec_,\n+          start_time, [&](Stream &strm) {\n             Request req2;\n             req2.method = \"CONNECT\";\n             req2.path = host_and_port_;\n+            if (global_timeout_msec_ > 0) {\n+              req2.start_time_ = std::chrono::steady_clock::now();\n+            }\n             return process_request(strm, req2, proxy_res, false, error);\n           })) {\n     // Thread-safe to close everything because we are assuming there are no\n@@ -9450,7 +9580,8 @@ inline bool SSLClient::connect_with_proxy(Socket &socket, Response &res,\n         proxy_res = Response();\n         if (!detail::process_client_socket(\n                 socket.sock, read_timeout_sec_, read_timeout_usec_,\n-                write_timeout_sec_, write_timeout_usec_, [&](Stream &strm) {\n+                write_timeout_sec_, write_timeout_usec_, global_timeout_msec_,\n+                start_time, [&](Stream &strm) {\n                   Request req3;\n                   req3.method = \"CONNECT\";\n                   req3.path = host_and_port_;\n@@ -9458,6 +9589,9 @@ inline bool SSLClient::connect_with_proxy(Socket &socket, Response &res,\n                       req3, auth, 1, detail::random_string(10),\n                       proxy_digest_auth_username_, proxy_digest_auth_password_,\n                       true));\n+                  if (global_timeout_msec_ > 0) {\n+                    req3.start_time_ = std::chrono::steady_clock::now();\n+                  }\n                   return process_request(strm, req3, proxy_res, false, error);\n                 })) {\n           // Thread-safe to close everything because we are assuming there are\n@@ -9613,13 +9747,15 @@ inline void SSLClient::shutdown_ssl_impl(Socket &socket,\n   assert(socket.ssl == nullptr);\n }\n \n-inline bool\n-SSLClient::process_socket(const Socket &socket,\n-                          std::function<bool(Stream &strm)> callback) {\n+inline bool SSLClient::process_socket(\n+    const Socket &socket,\n+    std::chrono::time_point<std::chrono::steady_clock> start_time,\n+    std::function<bool(Stream &strm)> callback) {\n   assert(socket.ssl);\n   return detail::process_client_socket_ssl(\n       socket.ssl, socket.sock, read_timeout_sec_, read_timeout_usec_,\n-      write_timeout_sec_, write_timeout_usec_, std::move(callback));\n+      write_timeout_sec_, write_timeout_usec_, global_timeout_msec_, start_time,\n+      std::move(callback));\n }\n \n inline bool SSLClient::is_ssl() const { return true; }\n", "test_patch": "diff --git a/test/fuzzing/server_fuzzer.cc b/test/fuzzing/server_fuzzer.cc\n--- a/test/fuzzing/server_fuzzer.cc\n+++ b/test/fuzzing/server_fuzzer.cc\n@@ -39,6 +39,8 @@ class FuzzedStream : public httplib::Stream {\n \n   socket_t socket() const override { return 0; }\n \n+  time_t duration() const override { return 0; };\n+\n private:\n   const uint8_t *data_;\n   size_t size_;\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -162,7 +162,8 @@ TEST(SocketStream, is_writable_UNIX) {\n \n   const auto asSocketStream = [&](socket_t fd,\n                                   std::function<bool(Stream &)> func) {\n-    return detail::process_client_socket(fd, 0, 0, 0, 0, func);\n+    return detail::process_client_socket(\n+        fd, 0, 0, 0, 0, 0, std::chrono::steady_clock::time_point::min(), func);\n   };\n   asSocketStream(fds[0], [&](Stream &s0) {\n     EXPECT_EQ(s0.socket(), fds[0]);\n@@ -206,7 +207,8 @@ TEST(SocketStream, is_writable_INET) {\n \n   const auto asSocketStream = [&](socket_t fd,\n                                   std::function<bool(Stream &)> func) {\n-    return detail::process_client_socket(fd, 0, 0, 0, 0, func);\n+    return detail::process_client_socket(\n+        fd, 0, 0, 0, 0, 0, std::chrono::steady_clock::time_point::min(), func);\n   };\n   asSocketStream(disconnected_svr_sock, [&](Stream &ss) {\n     EXPECT_EQ(ss.socket(), disconnected_svr_sock);\n@@ -4904,7 +4906,8 @@ static bool send_request(time_t read_timeout_sec, const std::string &req,\n   if (client_sock == INVALID_SOCKET) { return false; }\n \n   auto ret = detail::process_client_socket(\n-      client_sock, read_timeout_sec, 0, 0, 0, [&](Stream &strm) {\n+      client_sock, read_timeout_sec, 0, 0, 0, 0,\n+      std::chrono::steady_clock::time_point::min(), [&](Stream &strm) {\n         if (req.size() !=\n             static_cast<size_t>(strm.write(req.data(), req.size()))) {\n           return false;\n@@ -8190,3 +8193,255 @@ TEST(Expect100ContinueTest, ServerClosesConnection) {\n   }\n }\n #endif\n+\n+TEST(GlobalTimeoutTest, ContentStream) {\n+  Server svr;\n+\n+  svr.Get(\"/stream\", [&](const Request &, Response &res) {\n+    auto data = new std::string(\"01234567890123456789\");\n+\n+    res.set_content_provider(\n+        data->size(), \"text/plain\",\n+        [&, data](size_t offset, size_t length, DataSink &sink) {\n+          const size_t DATA_CHUNK_SIZE = 4;\n+          const auto &d = *data;\n+          std::this_thread::sleep_for(std::chrono::seconds(1));\n+          sink.write(&d[offset], std::min(length, DATA_CHUNK_SIZE));\n+          return true;\n+        },\n+        [data](bool success) {\n+          EXPECT_FALSE(success);\n+          delete data;\n+        });\n+  });\n+\n+  svr.Get(\"/stream_without_length\", [&](const Request &, Response &res) {\n+    auto i = new size_t(0);\n+\n+    res.set_content_provider(\n+        \"text/plain\",\n+        [i](size_t, DataSink &sink) {\n+          if (*i < 5) {\n+            std::this_thread::sleep_for(std::chrono::seconds(1));\n+            sink.write(\"abcd\", 4);\n+            (*i)++;\n+          } else {\n+            sink.done();\n+          }\n+          return true;\n+        },\n+        [i](bool success) {\n+          EXPECT_FALSE(success);\n+          delete i;\n+        });\n+  });\n+\n+  svr.Get(\"/chunked\", [&](const Request &, Response &res) {\n+    auto i = new size_t(0);\n+\n+    res.set_chunked_content_provider(\n+        \"text/plain\",\n+        [i](size_t, DataSink &sink) {\n+          if (*i < 5) {\n+            std::this_thread::sleep_for(std::chrono::seconds(1));\n+            sink.os << \"abcd\";\n+            (*i)++;\n+          } else {\n+            sink.done();\n+          }\n+          return true;\n+        },\n+        [i](bool success) {\n+          EXPECT_FALSE(success);\n+          delete i;\n+        });\n+  });\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(\"localhost\", PORT); });\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    listen_thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  const time_t timeout = 2000;\n+  const time_t threshold = 200;\n+\n+  Client cli(\"localhost\", PORT);\n+  cli.set_global_timeout(std::chrono::milliseconds(timeout));\n+\n+\n+  {\n+    auto start = std::chrono::steady_clock::now();\n+\n+    auto res = cli.Get(\"/stream\");\n+\n+    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(\n+                       std::chrono::steady_clock::now() - start)\n+                       .count();\n+\n+    ASSERT_FALSE(res);\n+    EXPECT_EQ(Error::Read, res.error());\n+    EXPECT_TRUE(timeout <= elapsed && elapsed < timeout + threshold);\n+  }\n+\n+  {\n+    auto start = std::chrono::steady_clock::now();\n+\n+    auto res = cli.Get(\"/stream_without_length\");\n+\n+    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(\n+                       std::chrono::steady_clock::now() - start)\n+                       .count();\n+\n+    ASSERT_FALSE(res);\n+    EXPECT_EQ(Error::Read, res.error());\n+    EXPECT_TRUE(timeout <= elapsed && elapsed < timeout + threshold);\n+  }\n+\n+  {\n+    auto start = std::chrono::steady_clock::now();\n+\n+    auto res = cli.Get(\"/chunked\", [&](const char *data, size_t data_length) {\n+      EXPECT_EQ(\"abcd\", string(data, data_length));\n+      return true;\n+    });\n+\n+    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(\n+                       std::chrono::steady_clock::now() - start)\n+                       .count();\n+\n+    ASSERT_FALSE(res);\n+    EXPECT_EQ(Error::Read, res.error());\n+    EXPECT_TRUE(timeout <= elapsed && elapsed < timeout + threshold);\n+  }\n+}\n+\n+#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+TEST(GlobalTimeoutTest, ContentStreamSSL) {\n+  SSLServer svr(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE);\n+\n+  svr.Get(\"/stream\", [&](const Request &, Response &res) {\n+    auto data = new std::string(\"01234567890123456789\");\n+\n+    res.set_content_provider(\n+        data->size(), \"text/plain\",\n+        [&, data](size_t offset, size_t length, DataSink &sink) {\n+          const size_t DATA_CHUNK_SIZE = 4;\n+          const auto &d = *data;\n+            std::this_thread::sleep_for(std::chrono::seconds(1));\n+          sink.write(&d[offset], std::min(length, DATA_CHUNK_SIZE));\n+          return true;\n+        },\n+        [data](bool success) {\n+          EXPECT_FALSE(success);\n+          delete data;\n+        });\n+  });\n+\n+  svr.Get(\"/stream_without_length\", [&](const Request &, Response &res) {\n+    auto i = new size_t(0);\n+\n+    res.set_content_provider(\n+        \"text/plain\",\n+        [i](size_t, DataSink &sink) {\n+          if (*i < 5) {\n+            std::this_thread::sleep_for(std::chrono::seconds(1));\n+            sink.write(\"abcd\", 4);\n+            (*i)++;\n+          } else {\n+            sink.done();\n+          }\n+          return true;\n+        },\n+        [i](bool success) {\n+          EXPECT_FALSE(success);\n+          delete i;\n+        });\n+  });\n+\n+  svr.Get(\"/chunked\", [&](const Request &, Response &res) {\n+    auto i = new size_t(0);\n+\n+    res.set_chunked_content_provider(\n+        \"text/plain\",\n+        [i](size_t, DataSink &sink) {\n+          if (*i < 5) {\n+            std::this_thread::sleep_for(std::chrono::seconds(1));\n+            sink.os << \"abcd\";\n+            (*i)++;\n+          } else {\n+            sink.done();\n+          }\n+          return true;\n+        },\n+        [i](bool success) {\n+          EXPECT_FALSE(success);\n+          delete i;\n+        });\n+  });\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(\"localhost\", PORT); });\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    listen_thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  const time_t timeout = 2000;\n+  const time_t threshold = 1000; // SSL_shutdown is slow...\n+\n+  SSLClient cli(\"localhost\", PORT);\n+  cli.enable_server_certificate_verification(false);\n+  cli.set_global_timeout(std::chrono::milliseconds(timeout));\n+\n+  {\n+    auto start = std::chrono::steady_clock::now();\n+\n+    auto res = cli.Get(\"/stream\");\n+\n+    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(\n+                       std::chrono::steady_clock::now() - start)\n+                       .count();\n+\n+    ASSERT_FALSE(res);\n+    EXPECT_EQ(Error::Read, res.error());\n+    EXPECT_TRUE(timeout <= elapsed && elapsed < timeout + threshold);\n+  }\n+\n+  {\n+    auto start = std::chrono::steady_clock::now();\n+\n+    auto res = cli.Get(\"/stream_without_length\");\n+\n+    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(\n+                       std::chrono::steady_clock::now() - start)\n+                       .count();\n+\n+    ASSERT_FALSE(res);\n+    EXPECT_EQ(Error::Read, res.error());\n+    EXPECT_TRUE(timeout <= elapsed && elapsed < timeout + threshold);\n+  }\n+\n+  {\n+    auto start = std::chrono::steady_clock::now();\n+\n+    auto res = cli.Get(\"/chunked\", [&](const char *data, size_t data_length) {\n+      EXPECT_EQ(\"abcd\", string(data, data_length));\n+      return true;\n+    });\n+\n+    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(\n+                       std::chrono::steady_clock::now() - start)\n+                       .count();\n+\n+    ASSERT_FALSE(res);\n+    EXPECT_EQ(Error::Read, res.error());\n+    EXPECT_TRUE(timeout <= elapsed && elapsed < timeout + threshold);\n+  }\n+}\n+#endif\n", "problem_statement": "Global timeout feature (same as \"--max-time\" curl option)\nHi,\n\nI've finally had some time to investigate the issue reported [here](https://github.com/yhirose/cpp-httplib/issues/1733), and created a small example:\n\nA client that wants to have a reply in at most 2100 ms:\n\n```c++\n#include <httplib.h>\n\nint main()\n{\n\n  httplib::Client http_client(\"http://127.0.0.1:8082\");\n  auto timeout = std::chrono::milliseconds{2100};\n  http_client.set_connection_timeout(timeout);\n  http_client.set_read_timeout(timeout);\n  http_client.set_write_timeout(timeout);\n  auto start = std::chrono::steady_clock::now();\n  http_client.Get(\"/\");\n  auto end = std::chrono::steady_clock::now();\n  auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n  std::cout << \"Elapsed time: \" << elapsed.count() << \"ms\\n\";\n}\n```\n\nA simple server to test (in python):\n\n```python\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport time\n\nclass SimpleHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        if self.path == \"/\":\n            self.send_response(200)\n            self.send_header(\"Content-type\", \"text/html\")\n            self.end_headers()\n            for i in range(5):\n                time.sleep(1)\n                self.wfile.write(f\"Response part {i+1}\\n\".encode('utf-8'))            \n        else:\n            self.send_response(404)\n            self.end_headers()\n\ndef run(server_class=HTTPServer, handler_class=SimpleHTTPRequestHandler):\n    server_address = ('', 8082)\n    httpd = server_class(server_address, handler_class)\n    print(\"Starting httpd server on port 8082...\")\n    httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    run()\n```\n\nIt will print something like\n\nElapsed time: 5001ms\n\nwhile I was expecting something close to\n\nElapsed time: 2100ms\n\nPerhaps there is another way to set a timeout for the request?\n\nThanks\n\n", "hints_text": "Hi, the piece of code that set the socket option is this:\n\nhttps://github.com/yhirose/cpp-httplib/blob/282f2feb77088ab905e2da5ae2e22a6d4d99a992/httplib.h#L3744-L3748\n\nThe socket use `SO_RCVTIMEO` and `SO_SNDTIMEO` for setting the timeout using `timeval` struct. But, the documentation of [`setsockopt`](https://man.freebsd.org/cgi/man.cgi?query=setsockopt&sektion=2) using `SO_RCVTIMEO` says:\n\n> _In the current implementation, this timer is restarted each time additional data are received by the protocol, and thus the limit is in effect an inactivity timer._\n\nYour python server is writing a response to the socket each second five times, if you modify the server to sleep $5<$ seconds, you will have your timeout as you expect.\n\nMaybe could be a good feature make a timeout different to the `setsockopt` implementation to expect that kind of results.\nIt could be good that @yhirose mention this on the README file \ud83d\udcaf \nHi Sebastian, thanks for looking into this. Yes, I figured that, this is\r\nwhy the test server is sending data by chunks. Libcurl has a \"global\"\r\ntimeout, which in my opinion is a useful thing.\r\n\r\nOn Mon, Feb 3, 2025, 02:59 Sebastian Galindo ***@***.***>\r\nwrote:\r\n\r\n> It could be good that @yhirose <https://github.com/yhirose> mention this\r\n> on the README file \ud83d\udcaf\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/yhirose/cpp-httplib/issues/2034#issuecomment-2629786367>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAEYNNE77TTVS34AJI6B2HD2N3LQRAVCNFSM6AAAAABWAWARK2VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDMMRZG44DMMZWG4>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n\n@marcovc could you clarify the status of this issue? If it's not an issue on cpp-httplib, I would like to close it.\nHi, \n\nThis is my second and last attempt to point out that there is no way to set a global timeout in httplib (client). If you feel that is not an important feature to have in your library, feel free to close it. \n\nThanks.\n@marcovc thanks! By the way, could you explain more about 'global' timeout that is implemented in libcurl?\nBy \"global timeout\" I mean a way to request that the call to httplib client takes at most X seconds.\n\nExample:\n\n```c++\nhttplib::Client http_client(\"https://etc\");\nhttp_client.set_global_timeout(2s);\nauto tic = std::chrono::steady_clock::now();\nhttp_client.Get(\"/\"); \nauto tac = std::chrono::steady_clock::now();\nassert(tac - tic <= 2s);\n```\n\nThere is no way to do the second line. All the existing timeouts (set_connection_timeout, set_read_timeout, set_write_timeout) are useful for their own purposes, but they can't be used to set a global timeout.\n\nIn my opinion, it is very useful to do so. The user might not care about how long does it take to establish the connection, or time elapsed between reads or writes, but instead just needs the whole thing to take less than X seconds.\n\nlibcurl has that: https://curl.se/libcurl/c/CURLOPT_TIMEOUT.html\n@marcovc could you confirm that CURLOPT_TIMEOUT really works as you explains? Also is there the corresponding curl option that I can easily test with? Thanks!\nLooks like it should correspond to the \"--max-time\" curl option.\n> could you confirm that CURLOPT_TIMEOUT really works as you explains? \n\nI'm literally pointing you to the manual page for that option. Not sure what you'd like me to confirm?\n> I'm literally pointing you to the manual page for that option. Not sure what you'd like me to confirm?\n\n@marcovc Don't worry. I'll try with `--max-time`. Thanks for the info!\nFYI, I've finished implementing the machinery for global timeouts for an unrelated PR. I'm now considering what changes to make to `ClientImpl`. It's quite a bit of code though (500 lines *before* adding global timeouts), and I'm not sure how @yhirose will feel about it. He hasn't responded yet to my wall-of-text on the other PR.\nA proof-of-concept would omit asynchronous DNS, but a simple, ugly thread-based resolver is easy enough to add.", "created_at": "2025-02-10T04:16:16Z", "version": "0.18"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1765, "instance_id": "yhirose__cpp-httplib-1765", "issue_numbers": ["1763"], "base_commit": "44b3fe6277398f424f1844295b7ae46ba5a1a35f", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -2412,6 +2412,7 @@ inline bool is_valid_path(const std::string &path) {\n     // Read component\n     auto beg = i;\n     while (i < path.size() && path[i] != '/') {\n+      if (path[i] == '\\0') { return false; }\n       i++;\n     }\n \n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -71,6 +71,15 @@ TEST(DecodeURLTest, PercentCharacter) {\n       R\"(descrip=Gastos \u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00d1 6)\");\n }\n \n+TEST(DecodeURLTest, PercentCharacterNUL) {\n+  string expected;\n+  expected.push_back('x');\n+  expected.push_back('\\0');\n+  expected.push_back('x');\n+\n+  EXPECT_EQ(detail::decode_url(\"x%00x\", false), expected);\n+}\n+\n TEST(EncodeQueryParamTest, ParseUnescapedChararactersTest) {\n   string unescapedCharacters = \"-_.!~*'()\";\n \n@@ -2482,6 +2491,12 @@ TEST_F(ServerTest, GetMethodInvalidMountPath) {\n   EXPECT_EQ(StatusCode::NotFound_404, res->status);\n }\n \n+TEST_F(ServerTest, GetMethodEmbeddedNUL) {\n+  auto res = cli_.Get(\"/mount/dir/test.html%00.js\");\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(StatusCode::NotFound_404, res->status);\n+}\n+\n TEST_F(ServerTest, GetMethodOutOfBaseDirMount) {\n   auto res = cli_.Get(\"/mount/../www2/dir/test.html\");\n   ASSERT_TRUE(res);\n", "problem_statement": "detail::is_valid_path returns true for paths with embedded NULs\nThe `detail::is_valid_path` function judges `std::string`s that contain embedded NUL bytes (`'\\0'`) as valid paths. At least on Linux, this is not the case: paths are NUL-terminated and cannot contain NULs. The interpretation difference means that the file request handler can be tricked into serving static files with an unexpected Content-Type:\r\n\r\n```\r\n% ~ \u203a curl -I http://localhost:3456/style.css      \r\nHTTP/1.1 200 OK\r\nAccept-Ranges: bytes\r\nContent-Length: 4862\r\nContent-Type: text/css\r\nKeep-Alive: timeout=5, max=5\r\n\r\n% ~ \u203a curl -I http://localhost:3456/style.css%00.js\r\nHTTP/1.1 200 OK\r\nAccept-Ranges: bytes\r\nContent-Length: 4862\r\nContent-Type: text/javascript\r\nKeep-Alive: timeout=5, max=5\r\n```\r\n\r\nTested on Linux with httplib 0.13.1.\n", "hints_text": "@wandernauta thanks for the report. Do you have time to fix this problem and make a pull request?", "created_at": "2024-01-27T12:54:56Z", "version": "0.14"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1483, "instance_id": "yhirose__cpp-httplib-1483", "issue_numbers": ["1478", "1478"], "base_commit": "439caf5b798bd07497e70265383c8bc4e2c448c5", "patch": "diff --git a/example/ssesvr.cc b/example/ssesvr.cc\n--- a/example/ssesvr.cc\n+++ b/example/ssesvr.cc\n@@ -19,7 +19,7 @@ class EventDispatcher {\n     unique_lock<mutex> lk(m_);\n     int id = id_;\n     cv_.wait(lk, [&] { return cid_ == id; });\n-    if (sink->is_writable()) { sink->write(message_.data(), message_.size()); }\n+    sink->write(message_.data(), message_.size());\n   }\n \n   void send_event(const string &message) {\ndiff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -340,7 +340,6 @@ class DataSink {\n \n   std::function<bool(const char *data, size_t data_len)> write;\n   std::function<void()> done;\n-  std::function<bool()> is_writable;\n   std::ostream os;\n \n private:\n@@ -3632,7 +3631,7 @@ inline bool write_content(Stream &strm, const ContentProvider &content_provider,\n \n   data_sink.write = [&](const char *d, size_t l) -> bool {\n     if (ok) {\n-      if (write_data(strm, d, l)) {\n+      if (strm.is_writable() && write_data(strm, d, l)) {\n         offset += l;\n       } else {\n         ok = false;\n@@ -3641,14 +3640,14 @@ inline bool write_content(Stream &strm, const ContentProvider &content_provider,\n     return ok;\n   };\n \n-  data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };\n-\n   while (offset < end_offset && !is_shutting_down()) {\n-    if (!content_provider(offset, end_offset - offset, data_sink)) {\n+    if (!strm.is_writable()) {\n+      error = Error::Write;\n+      return false;\n+    } else if (!content_provider(offset, end_offset - offset, data_sink)) {\n       error = Error::Canceled;\n       return false;\n-    }\n-    if (!ok) {\n+    } else if (!ok) {\n       error = Error::Write;\n       return false;\n     }\n@@ -3680,18 +3679,21 @@ write_content_without_length(Stream &strm,\n   data_sink.write = [&](const char *d, size_t l) -> bool {\n     if (ok) {\n       offset += l;\n-      if (!write_data(strm, d, l)) { ok = false; }\n+      if (!strm.is_writable() || !write_data(strm, d, l)) { ok = false; }\n     }\n     return ok;\n   };\n \n   data_sink.done = [&](void) { data_available = false; };\n \n-  data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };\n-\n   while (data_available && !is_shutting_down()) {\n-    if (!content_provider(offset, 0, data_sink)) { return false; }\n-    if (!ok) { return false; }\n+    if (!strm.is_writable()) {\n+      return false;\n+    } else if (!content_provider(offset, 0, data_sink)) {\n+      return false;\n+    } else if (!ok) {\n+      return false;\n+    }\n   }\n   return true;\n }\n@@ -3720,7 +3722,10 @@ write_content_chunked(Stream &strm, const ContentProvider &content_provider,\n           // Emit chunked response header and footer for each chunk\n           auto chunk =\n               from_i_to_hex(payload.size()) + \"\\r\\n\" + payload + \"\\r\\n\";\n-          if (!write_data(strm, chunk.data(), chunk.size())) { ok = false; }\n+          if (!strm.is_writable() ||\n+              !write_data(strm, chunk.data(), chunk.size())) {\n+            ok = false;\n+          }\n         }\n       } else {\n         ok = false;\n@@ -3759,14 +3764,14 @@ write_content_chunked(Stream &strm, const ContentProvider &content_provider,\n     }\n   };\n \n-  data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };\n-\n   while (data_available && !is_shutting_down()) {\n-    if (!content_provider(offset, 0, data_sink)) {\n+    if (!strm.is_writable()) {\n+      error = Error::Write;\n+      return false;\n+    } else if (!content_provider(offset, 0, data_sink)) {\n       error = Error::Canceled;\n       return false;\n-    }\n-    if (!ok) {\n+    } else if (!ok) {\n       error = Error::Write;\n       return false;\n     }\n@@ -6544,8 +6549,6 @@ inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n         return ok;\n       };\n \n-      data_sink.is_writable = [&](void) { return ok && true; };\n-\n       while (ok && offset < content_length) {\n         if (!content_provider(offset, content_length - offset, data_sink)) {\n           error = Error::Canceled;\n@@ -6717,7 +6720,6 @@ inline ContentProviderWithoutLength ClientImpl::get_multipart_content_provider(\n       bool has_data = true;\n       cur_sink.write = sink.write;\n       cur_sink.done = [&]() { has_data = false; };\n-      cur_sink.is_writable = sink.is_writable;\n \n       if (!provider_items[cur_item].provider(offset - cur_start, cur_sink))\n         return false;\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1650,7 +1650,6 @@ class ServerTest : public ::testing::Test {\n              [&](const Request & /*req*/, Response &res) {\n                res.set_chunked_content_provider(\n                    \"text/plain\", [](size_t /*offset*/, DataSink &sink) {\n-                     EXPECT_TRUE(sink.is_writable());\n                      sink.os << \"123\";\n                      sink.os << \"456\";\n                      sink.os << \"789\";\n@@ -1664,7 +1663,6 @@ class ServerTest : public ::testing::Test {\n                res.set_chunked_content_provider(\n                    \"text/plain\",\n                    [i](size_t /*offset*/, DataSink &sink) {\n-                     EXPECT_TRUE(sink.is_writable());\n                      switch (*i) {\n                      case 0: sink.os << \"123\"; break;\n                      case 1: sink.os << \"456\"; break;\n@@ -1694,7 +1692,6 @@ class ServerTest : public ::testing::Test {\n                res.set_content_provider(\n                    data->size(), \"text/plain\",\n                    [data](size_t offset, size_t length, DataSink &sink) {\n-                     EXPECT_TRUE(sink.is_writable());\n                      size_t DATA_CHUNK_SIZE = 4;\n                      const auto &d = *data;\n                      auto out_len =\n@@ -1714,8 +1711,6 @@ class ServerTest : public ::testing::Test {\n                res.set_content_provider(\n                    size_t(-1), \"text/plain\",\n                    [](size_t /*offset*/, size_t /*length*/, DataSink &sink) {\n-                     if (!sink.is_writable()) return false;\n-\n                      sink.os << \"data_chunk\";\n                      return true;\n                    });\n@@ -2952,7 +2947,6 @@ TEST_F(ServerTest, PutWithContentProvider) {\n   auto res = cli_.Put(\n       \"/put\", 3,\n       [](size_t /*offset*/, size_t /*length*/, DataSink &sink) {\n-        EXPECT_TRUE(sink.is_writable());\n         sink.os << \"PUT\";\n         return true;\n       },\n@@ -2979,7 +2973,6 @@ TEST_F(ServerTest, PutWithContentProviderWithoutLength) {\n   auto res = cli_.Put(\n       \"/put\",\n       [](size_t /*offset*/, DataSink &sink) {\n-        EXPECT_TRUE(sink.is_writable());\n         sink.os << \"PUT\";\n         sink.done();\n         return true;\n@@ -3006,7 +2999,6 @@ TEST_F(ServerTest, PutWithContentProviderWithGzip) {\n   auto res = cli_.Put(\n       \"/put\", 3,\n       [](size_t /*offset*/, size_t /*length*/, DataSink &sink) {\n-        EXPECT_TRUE(sink.is_writable());\n         sink.os << \"PUT\";\n         return true;\n       },\n@@ -3035,7 +3027,6 @@ TEST_F(ServerTest, PutWithContentProviderWithoutLengthWithGzip) {\n   auto res = cli_.Put(\n       \"/put\",\n       [](size_t /*offset*/, DataSink &sink) {\n-        EXPECT_TRUE(sink.is_writable());\n         sink.os << \"PUT\";\n         sink.done();\n         return true;\n", "problem_statement": "Check if stream is writable to avoid infinite loop in write_content_chunked while using SSE\nHi @yhirose ! Here is PR which fixes issue described in #1475 \r\n\r\nAs you asked here is the copy of issue description:\r\n\r\nI am using server-sent events and faced infinite loop. In my case infinite loop occurs when I reopen web-page/web-browser several times.\r\nHow to reproduce: run SSE example ssesvr.cc, open browser and reload page several times (5 or 6 in my case on 8-core processor). Voila, page not loading!\r\nInfinite loop is here: https://github.com/yhirose/cpp-httplib/blob/master/httplib.h#L3764\r\nMy hotfix looks like this: while (data_available && !is_shutting_down() && strm.is_writable()) { (add && strm.is_writable()). Not sure it's absolutely correct, so no PR from me :) Also I see there are similar pieces of code, maybe they are affected too.\r\nPlease investigate the problem!\r\nThanks!\nCheck if stream is writable to avoid infinite loop in write_content_chunked while using SSE\nHi @yhirose ! Here is PR which fixes issue described in #1475 \r\n\r\nAs you asked here is the copy of issue description:\r\n\r\nI am using server-sent events and faced infinite loop. In my case infinite loop occurs when I reopen web-page/web-browser several times.\r\nHow to reproduce: run SSE example ssesvr.cc, open browser and reload page several times (5 or 6 in my case on 8-core processor). Voila, page not loading!\r\nInfinite loop is here: https://github.com/yhirose/cpp-httplib/blob/master/httplib.h#L3764\r\nMy hotfix looks like this: while (data_available && !is_shutting_down() && strm.is_writable()) { (add && strm.is_writable()). Not sure it's absolutely correct, so no PR from me :) Also I see there are similar pieces of code, maybe they are affected too.\r\nPlease investigate the problem!\r\nThanks!\n", "hints_text": "@aldoshkind thanks for the pull request. The change looks good to me. Could you do the same at L3692 as well?\nI added same check on lines L3692 and L3646 and tested all three modes manually.\r\nI got new questions while reading the code:\r\n- shouldn't we return `false` if stream isn't writable anymore?\r\n- shouldn't we set `error` in `write_content_without_length` like in `write_content_chunked` and `write_content`?\r\n- if so, which error should we return? What does `Error::Connection` mean? It would be awesome to have comments on all the errors :)\n@aldoshkind thanks for the pull request. The change looks good to me. Could you do the same at L3692 as well?\nI added same check on lines L3692 and L3646 and tested all three modes manually.\r\nI got new questions while reading the code:\r\n- shouldn't we return `false` if stream isn't writable anymore?\r\n- shouldn't we set `error` in `write_content_without_length` like in `write_content_chunked` and `write_content`?\r\n- if so, which error should we return? What does `Error::Connection` mean? It would be awesome to have comments on all the errors :)", "created_at": "2023-02-04T03:29:42Z", "version": "0.11"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1523, "instance_id": "yhirose__cpp-httplib-1523", "issue_numbers": ["1459"], "base_commit": "f2f47284890e9ed1ab1750a21c06441bdd5fcb6c", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1823,7 +1823,8 @@ std::string params_to_query_str(const Params &params);\n \n void parse_query_text(const std::string &s, Params &params);\n \n-bool parse_multipart_boundary(const std::string &content_type, std::string &boundary);\n+bool parse_multipart_boundary(const std::string &content_type,\n+                              std::string &boundary);\n \n bool parse_range_header(const std::string &s, Ranges &ranges);\n \n@@ -3391,6 +3392,14 @@ inline const char *get_header_value(const Headers &headers,\n   return def;\n }\n \n+inline bool compare_case_ignore(const std::string &a, const std::string &b) {\n+  if (a.size() != b.size()) { return false; }\n+  for (size_t i = 0; i < b.size(); i++) {\n+    if (::tolower(a[i]) != ::tolower(b[i])) { return false; }\n+  }\n+  return true;\n+}\n+\n template <typename T>\n inline bool parse_header(const char *beg, const char *end, T fn) {\n   // Skip trailing spaces and tabs.\n@@ -3414,7 +3423,11 @@ inline bool parse_header(const char *beg, const char *end, T fn) {\n   }\n \n   if (p < end) {\n-    fn(std::string(beg, key_end), decode_url(std::string(p, end), false));\n+    auto key = std::string(beg, key_end);\n+    auto val = compare_case_ignore(key, \"Location\")\n+                   ? std::string(p, end)\n+                   : decode_url(std::string(p, end), false);\n+    fn(std::move(key), std::move(val));\n     return true;\n   }\n \n@@ -6463,11 +6476,11 @@ inline bool ClientImpl::redirect(Request &req, Response &res, Error &error) {\n     return false;\n   }\n \n-  auto location = detail::decode_url(res.get_header_value(\"location\"), true);\n+  auto location = res.get_header_value(\"location\");\n   if (location.empty()) { return false; }\n \n   const static std::regex re(\n-      R\"((?:(https?):)?(?://(?:\\[([\\d:]+)\\]|([^:/?#]+))(?::(\\d+))?)?([^?#]*(?:\\?[^#]*)?)(?:#.*)?)\");\n+      R\"((?:(https?):)?(?://(?:\\[([\\d:]+)\\]|([^:/?#]+))(?::(\\d+))?)?([^?#]*)(\\?[^#]*)?(?:#.*)?)\");\n \n   std::smatch m;\n   if (!std::regex_match(location, m, re)) { return false; }\n@@ -6479,6 +6492,7 @@ inline bool ClientImpl::redirect(Request &req, Response &res, Error &error) {\n   if (next_host.empty()) { next_host = m[3].str(); }\n   auto port_str = m[4].str();\n   auto next_path = m[5].str();\n+  auto next_query = m[6].str();\n \n   auto next_port = port_;\n   if (!port_str.empty()) {\n@@ -6491,22 +6505,24 @@ inline bool ClientImpl::redirect(Request &req, Response &res, Error &error) {\n   if (next_host.empty()) { next_host = host_; }\n   if (next_path.empty()) { next_path = \"/\"; }\n \n+  auto path = detail::decode_url(next_path, true) + next_query;\n+\n   if (next_scheme == scheme && next_host == host_ && next_port == port_) {\n-    return detail::redirect(*this, req, res, next_path, location, error);\n+    return detail::redirect(*this, req, res, path, location, error);\n   } else {\n     if (next_scheme == \"https\") {\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n       SSLClient cli(next_host.c_str(), next_port);\n       cli.copy_settings(*this);\n       if (ca_cert_store_) { cli.set_ca_cert_store(ca_cert_store_); }\n-      return detail::redirect(cli, req, res, next_path, location, error);\n+      return detail::redirect(cli, req, res, path, location, error);\n #else\n       return false;\n #endif\n     } else {\n       ClientImpl cli(next_host.c_str(), next_port);\n       cli.copy_settings(*this);\n-      return detail::redirect(cli, req, res, next_path, location, error);\n+      return detail::redirect(cli, req, res, path, location, error);\n     }\n   }\n }\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -5978,3 +5978,34 @@ TEST(TaskQueueTest, IncreaseAtomicInteger) {\n   EXPECT_NO_THROW(task_queue->shutdown());\n   EXPECT_EQ(number_of_task, count.load());\n }\n+\n+TEST(RedirectTest, RedirectToUrlWithQueryParameters) {\n+  Server svr;\n+\n+  svr.Get(\"/\", [](const Request & /*req*/, Response &res) {\n+    res.set_redirect(R\"(/hello?key=val%26key2%3Dval2)\");\n+  });\n+\n+  svr.Get(\"/hello\", [](const Request &req, Response &res) {\n+    res.set_content(req.get_param_value(\"key\"), \"text/plain\");\n+  });\n+\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  std::this_thread::sleep_for(std::chrono::seconds(1));\n+\n+  {\n+    Client cli(HOST, PORT);\n+    cli.set_follow_location(true);\n+\n+    auto res = cli.Get(\"/\");\n+    ASSERT_TRUE(res);\n+    EXPECT_EQ(200, res->status);\n+    EXPECT_EQ(\"val&key2=val2\", res->body);\n+  }\n+\n+  svr.stop();\n+  thread.join();\n+  ASSERT_FALSE(svr.is_running());\n+}\n+\n", "problem_statement": "Fix \"Location\" header url corrupted by percent-unescaping in redirect\u2026\nRedirected GET request like `https://sphinx.acast.com/p/acast/s/a-bientot-de-te-revoir/e/63a4721c69c77e001126ad39/media.mp3`\r\nare failing and while it looks like an agent setup problem it is actually the processing of the `Location` response header.\r\n\r\nhttplib is percent-un-escaping every response header with `decode_url` in `parse_header`, giving this address\r\n`https://stitcher2.acast.com/livestitches/4d4cc4fe72c9452bd0b0992a5c89e434.mp3?aid=63a4721c69c77e001126ad39&chid=a8879bdf-de58-4537-8dab-a3bb13948786&ci=oFpQlSRp3GFDZwrcZw5e3SEuFWtGfBXjcj6-mtxC8TJYKWNWTP3KWg==&pf=rss&sv=sphinx@1.134.1&uid=6ec01abdba610f88f88e42ff560ecdef&Expires=1672100680731&Key-Pair-Id=K38CTQXUSD0VVB&Signature=XoIMT7YfpbpOerJXwA4JVT-zat8V2flxU5AKtwr8LEGegGAu6hNSgeyLgq7gQmpv6pv6im2hKSyfUUqQmBEW8MCFLUYiUXuSVEcuVZ3BAT8u0gzcSdTFC1wOGhZTAExH15vei9-UAOVMj7Mq-jP-8hd-H~Atrj2YKI9krbWoslScK4yepWvpzwvBWP8-58NPIy6FaSfMHWwODigNCrJudiR0DPrr6x-HVSiwB~q5aTNVvlABQqGxNkpWtnAie8TuYKEvmioTlEL1aFj8RxMWke7yRc4uOchJtak5COoej4x780f0mepp-eh0OGtsB1izB7hGsyob0c8DwCYoVGTsRg__` in the `Location` result header and the redirected request fails.\r\n\r\nHowever Firefox (for instance) successfully redirects to\r\n`https://stitcher2.acast.com/livestitches/4d4cc4fe72c9452bd0b0992a5c89e434.mp3?aid=63a4721c69c77e001126ad39&chid=a8879bdf-de58-4537-8dab-a3bb13948786&ci=oFpQlSRp3GFDZwrcZw5e3SEuFWtGfBXjcj6-mtxC8TJYKWNWTP3KWg%3D%3D&pf=rss&sv=sphinx%401.134.1&uid=6ec01abdba610f88f88e42ff560ecdef&Expires=1672109987714&Key-Pair-Id=K38CTQXUSD0VVB&Signature=TQXsBs7XluU~YRtPTcYe1EtVuvnkf542tbp1p7KUnvn24rm-tQjO8dYgLSbXlJCBwsiPtbnJc-YjLbGlaVLKDzzfABj2lCldE-KoeUSdnEQPWXdPK6FK5BR7kuN-CuY1MfQ-0sDa4MTGAErHZZB1p3~jiiZbbP7fYd9ttBfXwlZgjv5BtHOL4KQs7QY7q-~ZP5tXoGhtufPMruWRYOptrves991ax5lgKPwTvzhXSL6CEKpHWoAMi88shXnBBC~f2iOropB-yzcj5K-uaK6LPcObfHh9Akgl~uIAqbLka2Nrq-HQ-7QrMIUmFcA2nTEaAF66dGRj7AGtEkS2m2hB4A__`, with escaped parts here `%3D%3D&pf=rss&sv=sphinx%40`\r\n\r\nThis fix skips decoding for `Location` (case sensitive) only, it may be too restrictive.\n", "hints_text": "@maudoin, thanks for the pull request. As I always ask any contributors, could you add a unit text to verify your change is good? Thanks.\n@yhirose I will try to do this this week, I don't have a working supported environment yet (I dropped the header in a cmake/mingw project that doesn't have gtest)\n@yhirose, here is an update with a test for this specific Location\n@yhirose could you format your code by using  clangformat with `.clang-format` in this repo?\n@maudoin can I ask you a question?\r\n\r\n> This fix skips decoding for Location (case sensitive) only, it may be too restrictive.\r\n\r\nWhat does it mean? HTTP header key is case-insensitive. \r\nhttps://stackoverflow.com/questions/5258977/are-http-headers-case-sensitive\r\n\r\nThanks!\nIndeed for the website I tested with I received a header with a capital L and it was enough to fix for me.  I was not sure if I should have converted both the constant and the variable to lowercase to be case insensitive, looking at your link I should have...\n@maudoin sorry for the delay in responding. I have one more question. You mentioned FireFox handles it properly. How about curl and other brothers like Chrome or Edge?\nthe original link expired but you can also try\r\n```\r\nhttps://sphinx.acast.com/p/acast/s/a-bientot-de-te-revoir/e/63ebb88102ceee0011d61116/media.mp3\r\n```\r\nit works in **opera**, **edge** and **chrome** as well where it is redirected with an initial code 302 through the `location` header  to\r\n```\r\nhttps://stitcher2.acast.com/livestitches/a5d2ed841fb4ab95b5b506346c279a57.mp3?aid=63ebb88102ceee0011d61116&chid=a8879bdf-de58-4537-8dab-a3bb13948786&ci=cZrHefNW8vl-9TIIlHQLGiYVcJYf8tq-JS5sFxQA4aEYq6TNi86LyA==&pf=rss&sv=sphinx@1.153.1&uid=0376c7c2f1a02cb4108bf0f77c19d200&Expires=1678505407834&Key-Pair-Id=K38CTQXUSD0VVB&Signature=c5re1JRDWZKR3guSRB31Ui1yDq5VMDMI6YUn~TxJCREgx0VgVXREyhK8Ioc-kSVeoJzo2dKPspRZB5WFbuqSKiOtxu~1AlU6UzWArWW8Ufh6i5dmyeCbOGEFiW586Xa6KYCpYYlUAsnIXrh7jALfVeEDaE13pFf3uNB78xEpLabcVP4IdPyndqB50FAACcTCOgqMkyqY2x~e6UAJzURLgEOshoQ6wAAJ3QQ6suo~HRY5rNoBCFSEIHpC7-c7AlphLJo3eo9EyVk1yKvJ1-DX3L1j3loVPs3G8Cy-rb4oYuYKdDDaogclR34Hc~qtYBj7bvOeeHcufz36gFv6~aj03Q__\r\n```\r\non the other hand\r\n`curl https://sphinx.acast.com/p/acast/s/a-bientot-de-te-revoir/e/63ebb88102ceee0011d61116/media.mp3`\r\ngives me\r\n`curl: (35) schannel: next InitializeSecurityContext failed: Unknown error (0x80092012) - The revocation function was unable to check revocation for the certificate.`\r\nso I am not sure", "created_at": "2023-03-11T03:03:10Z", "version": "0.12"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1579, "instance_id": "yhirose__cpp-httplib-1579", "issue_numbers": ["1471"], "base_commit": "698a1e51ecc6450b19757169736b173730c1d440", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1118,6 +1118,7 @@ class ClientImpl {\n   void set_ca_cert_path(const std::string &ca_cert_file_path,\n                         const std::string &ca_cert_dir_path = std::string());\n   void set_ca_cert_store(X509_STORE *ca_cert_store);\n+  X509_STORE *create_ca_cert_store(const char *ca_cert, std::size_t size);\n #endif\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n@@ -1498,6 +1499,7 @@ class Client {\n                         const std::string &ca_cert_dir_path = std::string());\n \n   void set_ca_cert_store(X509_STORE *ca_cert_store);\n+  void load_ca_cert_store(const char *ca_cert, std::size_t size);\n \n   long get_openssl_verify_result() const;\n \n@@ -1557,6 +1559,7 @@ class SSLClient : public ClientImpl {\n   bool is_valid() const override;\n \n   void set_ca_cert_store(X509_STORE *ca_cert_store);\n+  void load_ca_cert_store(const char *ca_cert, std::size_t size);\n \n   long get_openssl_verify_result() const;\n \n@@ -7584,6 +7587,35 @@ inline void ClientImpl::set_ca_cert_store(X509_STORE *ca_cert_store) {\n     ca_cert_store_ = ca_cert_store;\n   }\n }\n+\n+inline X509_STORE *ClientImpl::create_ca_cert_store(const char *ca_cert,\n+                                                    std::size_t size) {\n+  auto mem = BIO_new_mem_buf(ca_cert, size);\n+  if (!mem) return nullptr;\n+\n+  auto inf = PEM_X509_INFO_read_bio(mem, nullptr, nullptr, nullptr);\n+  if (!inf) {\n+    BIO_free_all(mem);\n+    return nullptr;\n+  }\n+\n+  auto cts = X509_STORE_new();\n+  if (cts) {\n+    for (int first = 0, last = sk_X509_INFO_num(inf); first < last; ++first) {\n+      auto itmp = sk_X509_INFO_value(inf, first);\n+      if (!itmp) continue;\n+\n+      if (itmp->x509) X509_STORE_add_cert(cts, itmp->x509);\n+\n+      if (itmp->crl) X509_STORE_add_crl(cts, itmp->crl);\n+    }\n+  }\n+\n+  sk_X509_INFO_pop_free(inf, X509_INFO_free);\n+  BIO_free_all(mem);\n+\n+  return cts;\n+}\n #endif\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n@@ -7984,6 +8016,11 @@ inline void SSLClient::set_ca_cert_store(X509_STORE *ca_cert_store) {\n   }\n }\n \n+inline void SSLClient::load_ca_cert_store(const char *ca_cert,\n+                                          std::size_t size) {\n+  set_ca_cert_store(ClientImpl::create_ca_cert_store(ca_cert, size));\n+}\n+\n inline long SSLClient::get_openssl_verify_result() const {\n   return verify_result_;\n }\n@@ -8767,6 +8804,10 @@ inline void Client::set_ca_cert_store(X509_STORE *ca_cert_store) {\n   }\n }\n \n+inline void Client::load_ca_cert_store(const char *ca_cert, std::size_t size) {\n+  set_ca_cert_store(cli_->create_ca_cert_store(ca_cert, size));\n+}\n+\n inline long Client::get_openssl_verify_result() const {\n   if (is_ssl_) {\n     return static_cast<SSLClient &>(*cli_).get_openssl_verify_result();\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -4710,6 +4710,49 @@ TEST(SSLClientTest, ServerCertificateVerification4) {\n   ASSERT_EQ(200, res->status);\n }\n \n+TEST(SSLClientTest, ServerCertificateVerification5_Online) {\n+  std::string cert;\n+  detail::read_file(CA_CERT_FILE, cert);\n+\n+  SSLClient cli(\"google.com\");\n+  cli.load_ca_cert_store(cert.data(), cert.size());\n+  const auto res = cli.Get(\"/\");\n+  ASSERT_TRUE(res);\n+  ASSERT_EQ(301, res->status);\n+}\n+\n+TEST(SSLClientTest, ServerCertificateVerification6_Online) {\n+  // clang-format off\n+  static constexpr char cert[] =\n+    \"GlobalSign Root CA\\n\"\n+    \"==================\\n\"\n+    \"-----BEGIN CERTIFICATE-----\\n\"\n+    \"MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkGA1UEBhMCQkUx\\n\"\n+    \"GTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jvb3QgQ0ExGzAZBgNVBAMTEkds\\n\"\n+    \"b2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAwMDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNV\\n\"\n+    \"BAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYD\\n\"\n+    \"VQQDExJHbG9iYWxTaWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDa\\n\"\n+    \"DuaZjc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavpxy0Sy6sc\\n\"\n+    \"THAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp1Wrjsok6Vjk4bwY8iGlb\\n\"\n+    \"Kk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdGsnUOhugZitVtbNV4FpWi6cgKOOvyJBNP\\n\"\n+    \"c1STE4U6G7weNLWLBYy5d4ux2x8gkasJU26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrX\\n\"\n+    \"gzT/LCrBbBlDSgeF59N89iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV\\n\"\n+    \"HRMBAf8EBTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0BAQUF\\n\"\n+    \"AAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOzyj1hTdNGCbM+w6Dj\\n\"\n+    \"Y1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE38NflNUVyRRBnMRddWQVDf9VMOyG\\n\"\n+    \"j/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymPAbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhH\\n\"\n+    \"hm4qxFYxldBniYUr+WymXUadDKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveC\\n\"\n+    \"X4XSQRjbgbMEHMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\\n\"\n+    \"-----END CERTIFICATE-----\\n\";\n+  // clang-format on\n+\n+  SSLClient cli(\"google.com\");\n+  cli.load_ca_cert_store(cert, sizeof(cert));\n+  const auto res = cli.Get(\"/\");\n+  ASSERT_TRUE(res);\n+  ASSERT_EQ(301, res->status);\n+}\n+\n TEST(SSLClientTest, WildcardHostNameMatch_Online) {\n   SSLClient cli(\"www.youtube.com\");\n \n", "problem_statement": "Handy API for in-memory certificate loading\nCurrently, I'm embedding some certificates into my code to avoid packaging with cert files.\r\nI saw that [`curl`](https://curl.se/libcurl/c/cacertinmem.html) has a good example of this, so I ended up writing something like this.\r\n\r\n```cpp\r\n// In some header\r\ninline constexpr char my_cert[] = {\r\n    \"-----BEGIN CERTIFICATE-----\\n\"\r\n    // ...\r\n    \"-----END CERTIFICATE-----\\n\"\r\n};\r\n\r\nX509_STORE* create_ca_cert_store(const char* data, std::size_t size)\r\n{\r\n    BIO* mem = nullptr;\r\n    STACK_OF(X509_INFO)* inf = nullptr;\r\n    X509_STORE* cts = nullptr;\r\n\r\n    [&] {\r\n        mem = BIO_new_mem_buf(data, size);\r\n        if (!mem)\r\n            return;\r\n\r\n        inf = PEM_X509_INFO_read_bio(mem, nullptr, nullptr, nullptr);\r\n        if (!inf)\r\n            return;\r\n\r\n        cts = X509_STORE_new();\r\n        if (!cts)\r\n            return;\r\n\r\n        for (int first = 0, last = sk_X509_INFO_num(inf); first < last; ++first) {\r\n            X509_INFO* itmp = sk_X509_INFO_value(inf, first);\r\n            if (!itmp)\r\n                continue;\r\n\r\n            if (itmp->x509)\r\n                X509_STORE_add_cert(cts, itmp->x509);\r\n\r\n            if (itmp->crl)\r\n                X509_STORE_add_crl(cts, itmp->crl);\r\n        }\r\n    }();\r\n\r\n    if (inf)\r\n        sk_X509_INFO_pop_free(inf, X509_INFO_free);\r\n\r\n    if (mem)\r\n        BIO_free_all(mem);\r\n\r\n    return cts;\r\n}\r\n\r\nint main() {\r\n    SSLClient client { \"httpbin.org\" };\r\n    // It returns nullptr if creating cert store fails\r\n    // but set_ca_cert_store() will check it\r\n    auto* store = create_ca_cert_store(my_cert, sizeof(my_cert));\r\n    client.set_ca_cert_store(store);\r\n    // ...\r\n}\r\n```\r\n\r\nI tested without default system certs and it works fine.\r\nBut it would be nice if we had an `SSLClient::create_ca_cert_store` API for in-memory cert loading.\n", "hints_text": "@jimmy-park thanks for the suggestion.\r\n\r\n> I saw that [curl](https://curl.se/libcurl/c/cacertinmem.html) has a good example of this\r\n\r\nWhere did you find it?\n@yhirose I linked it to the curl. Here it is https://curl.se/libcurl/c/cacertinmem.html\nI second @jimmy-park's request. This feature is useful e.g. to build standalone binaries.\n@jimmy-park sorry for the late reply. Your suggestion looks reasonable to be added into cpp-httplib. Could you make a pull request with a unit test, and close this issue? Thanks!\n@yhirose Okay I'll try it. Actually I already did similar things in my [repo](https://github.com/jimmy-park/cert-cmake) \ud83d\ude04", "created_at": "2023-06-03T11:04:21Z", "version": "0.12"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1830, "instance_id": "yhirose__cpp-httplib-1830", "issue_numbers": ["1800"], "base_commit": "3b6597bba913d51161383657829b7e644e59c006", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -9213,7 +9213,7 @@ inline Client::Client(const std::string &scheme_host_port,\n                       const std::string &client_cert_path,\n                       const std::string &client_key_path) {\n   const static std::regex re(\n-      R\"((?:([a-z]+):\\/\\/)?(?:\\[([\\d:]+)\\]|([^:/?#]+))(?::(\\d+))?)\");\n+      R\"((?:([a-z]+):\\/\\/)?(?:\\[([a-fA-F\\d:]+)\\]|([^:/?#]+))(?::(\\d+))?)\");\n \n   std::smatch m;\n   if (std::regex_match(scheme_host_port, m, re)) {\n@@ -9250,6 +9250,8 @@ inline Client::Client(const std::string &scheme_host_port,\n                                              client_key_path);\n     }\n   } else {\n+    // NOTE: Update TEST(UniversalClientImplTest, Ipv6LiteralAddress)\n+    // if port param below changes.\n     cli_ = detail::make_unique<ClientImpl>(scheme_host_port, 80,\n                                            client_cert_path, client_key_path);\n   }\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -7373,3 +7373,18 @@ TEST(PathParamsTest, SequenceOfParams) {\n \n   EXPECT_EQ(request.path_params, expected_params);\n }\n+\n+TEST(UniversalClientImplTest, Ipv6LiteralAddress) {\n+  // If ipv6 regex working, regex match codepath is taken.\n+  // else port will default to 80 in Client impl\n+  int clientImplMagicPort = 80;\n+  int port = 4321;\n+  // above ports must be different to avoid false negative\n+  EXPECT_NE(clientImplMagicPort, port);\n+\n+  std::string ipV6TestURL = \"http://[ff06::c3]\";\n+\n+  Client cli(ipV6TestURL + \":\" + std::to_string(port), CLIENT_CERT_FILE,\n+               CLIENT_PRIVATE_KEY_FILE);\n+  EXPECT_EQ(cli.port(), port);\n+}\n", "problem_statement": "The URL regular expression cannot match an IPv6 address\ninline Client::Client(const std::string &scheme_host_port,\r\n                      const std::string &client_cert_path,\r\n                      const std::string &client_key_path) {\r\n  const static std::regex re(\r\n      R\"((?:([a-z]+):\\/\\/)?(?:\\[([\\d:]+)\\]|([^:/?#]+))(?::(\\d+))?)\");\r\n\r\nThe 're' is unable to match 'http://[ff06::c3]:3000' because '[([\\d:]+)]' can only match sequences of digits.\n", "hints_text": "", "created_at": "2024-05-02T06:31:38Z", "version": "0.15"}
{"repo": "yhirose/cpp-httplib", "pull_number": 2080, "instance_id": "yhirose__cpp-httplib-2080", "issue_numbers": ["2068"], "base_commit": "22d90c29b47cb318febeefad96cddc6a99b00366", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -7333,6 +7333,16 @@ inline ClientImpl::ClientImpl(const std::string &host, int port,\n       client_cert_path_(client_cert_path), client_key_path_(client_key_path) {}\n \n inline ClientImpl::~ClientImpl() {\n+  // Wait until all the requests in flight are handled.\n+  size_t retry_count = 10;\n+  while (retry_count-- > 0) {\n+    {\n+      std::lock_guard<std::mutex> guard(socket_mutex_);\n+      if (socket_requests_in_flight_ == 0) { break; }\n+    }\n+    std::this_thread::sleep_for(std::chrono::milliseconds{1});\n+  }\n+\n   std::lock_guard<std::mutex> guard(socket_mutex_);\n   shutdown_socket(socket_);\n   close_socket(socket_);\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -8351,3 +8351,86 @@ TEST(MaxTimeoutTest, ContentStreamSSL) {\n   max_timeout_test(svr, cli, timeout, threshold);\n }\n #endif\n+\n+class EventDispatcher {\n+public:\n+  EventDispatcher() {}\n+\n+  void wait_event(DataSink *sink) {\n+    unique_lock<mutex> lk(m_);\n+    int id = id_;\n+    cv_.wait(lk, [&] { return cid_ == id; });\n+    sink->write(message_.data(), message_.size());\n+  }\n+\n+  void send_event(const string &message) {\n+    lock_guard<mutex> lk(m_);\n+    cid_ = id_++;\n+    message_ = message;\n+    cv_.notify_all();\n+  }\n+\n+private:\n+  mutex m_;\n+  condition_variable cv_;\n+  atomic_int id_{0};\n+  atomic_int cid_{-1};\n+  string message_;\n+};\n+\n+TEST(ClientInThreadTest, Issue2068) {\n+  EventDispatcher ed;\n+\n+  Server svr;\n+  svr.Get(\"/event1\", [&](const Request & /*req*/, Response &res) {\n+    res.set_chunked_content_provider(\"text/event-stream\",\n+                                     [&](size_t /*offset*/, DataSink &sink) {\n+                                       ed.wait_event(&sink);\n+                                       return true;\n+                                     });\n+  });\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(HOST, PORT); });\n+\n+  svr.wait_until_ready();\n+\n+  thread event_thread([&] {\n+    int id = 0;\n+    while (svr.is_running()) {\n+      this_thread::sleep_for(chrono::milliseconds(500));\n+\n+      std::stringstream ss;\n+      ss << \"data: \" << id << \"\\n\\n\";\n+      ed.send_event(ss.str());\n+      id++;\n+    }\n+  });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+\n+    listen_thread.join();\n+    event_thread.join();\n+\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  {\n+    auto client = detail::make_unique<Client>(HOST, PORT);\n+    client->set_read_timeout(std::chrono::minutes(10));\n+\n+    std::atomic<bool> stop{false};\n+\n+    std::thread t([&] {\n+      client->Get(\"/event1\",\n+                  [&](const char *, size_t) -> bool { return !stop; });\n+    });\n+\n+    std::this_thread::sleep_for(std::chrono::seconds(2));\n+    stop = true;\n+    client->stop();\n+    client.reset();\n+\n+    t.join();\n+  }\n+}\n", "problem_statement": "Assertion failed when destroying httplib::Client\nWhen destroying an `httplib::Client` object in one thread while a `Get` request is still active in another thread, the program aborts with an assertion error, even after calling `httplib::Client::stop()`.\n\nMy use case involves a thread consuming SSE using `Get`. I want to stop the `Get` request gracefully so the thread can exit. However, calling `stop()` before destroying the client does not resolve the issue.\n\n\n\nAssertion error:\n\n```\nclient: httplib.h:7514: void httplib::ClientImpl::close_socket(Socket&): Assertion `socket_requests_in_flight_ == 0 || socket_requests_are_from_thread_ == std::this_thread::get_id()' failed.\nAborted (core dumped)\n```\n\nTested on `2b5d1eea8d7e9f881ac4be04ce31df782b26b6a9`\n\nMinimal Reproduction:\n\n`client.cpp`\n```\n#include \"httplib.h\"\n\n#include <atomic>\n#include <chrono>\n#include <iostream>\n#include <memory>\n#include <thread>\n\nusing namespace httplib;\nusing namespace std;\n\nint main(void) {\n  std::unique_ptr<Client> client(std::make_unique<Client>(\"localhost:1234\"));\n  client->set_read_timeout(std::chrono::minutes(10));\n\n  std::atomic<bool> stop{false};\n\n  std::thread t([&] {\n    client->Get(\"/event1\", [&](const char *data, size_t data_length) -> bool {\n      std::cout << std::string(data, data_length) << \"\\n\";\n      return !stop;\n    });\n  });\n\n  std::this_thread::sleep_for(std::chrono::seconds(5));\n  std::cout << \"stop\\n\";\n  stop = true;\n  client->stop();\n  std::cout << \"stop done\\n\";\n\n  std::cout << \"destroy\\n\";\n  client.reset();\n  std::cout << \"destroy done\\n\";\n\n  t.join();\n}\n\n```\n\n\n`server.cpp`\n```\n#include \"httplib.h\"\n\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <iostream>\n#include <mutex>\n#include <sstream>\n#include <thread>\n\nusing namespace httplib;\nusing namespace std;\n\nclass EventDispatcher {\npublic:\n  EventDispatcher() {}\n\n  void wait_event(DataSink *sink) {\n    unique_lock<mutex> lk(m_);\n    int id = id_;\n    cv_.wait(lk, [&] { return cid_ == id; });\n    sink->write(message_.data(), message_.size());\n  }\n\n  void send_event(const string &message) {\n    lock_guard<mutex> lk(m_);\n    cid_ = id_++;\n    message_ = message;\n    cv_.notify_all();\n  }\n\nprivate:\n  mutex m_;\n  condition_variable cv_;\n  atomic_int id_{0};\n  atomic_int cid_{-1};\n  string message_;\n};\n\nint main(void) {\n  EventDispatcher ed;\n\n  Server svr;\n  svr.Get(\"/event1\", [&](const Request & /*req*/, Response &res) {\n    cout << \"connected to event1...\" << endl;\n    res.set_chunked_content_provider(\"text/event-stream\",\n                                     [&](size_t /*offset*/, DataSink &sink) {\n                                       ed.wait_event(&sink);\n                                       return true;\n                                     });\n  });\n\n  thread t([&] {\n    int id = 0;\n    while (true) {\n      this_thread::sleep_for(chrono::seconds(1));\n      // cout << \"send event: \" << id << std::endl;\n      std::stringstream ss;\n      ss << \"data: \" << id << \"\\n\\n\";\n      ed.send_event(ss.str());\n      id++;\n    }\n  });\n\n  svr.listen(\"localhost\", 1234);\n}\n```\n\nQuestion:\n\nIs this the correct way to stop and destroy the client gracefully? Any suggestions or workarounds would be greatly appreciated.\n\n", "hints_text": "Try this order:\n```c++\n  stop = true;\n  client->stop();\n  t.join();\n  std::cout << \"stop done\\n\";\n\n  std::cout << \"destroy\\n\";\n  client.reset();\n  std::cout << \"destroy done\\n\";\n```\n\nLooks to me like `socket_requests_in_flight_ != 0`, meaning the `GET` request is ongoing when you destroy the client. `client->stop()` doesn't wait, you have to wait by joining the thread.\nThank you, that works. But I wonder if the client destructor could stop or wait for completion without asserting or crashing.\n> Thank you, that works. But I wonder if the client destructor could stop or wait for completion without asserting or crashing.\n\nWell, it's the thread that creates the problem and that's your responsibility\u2026 \ud83e\udd37\u200d\u2642\n\nFigure these issues out in development (with assertions) and build for production with `NDEBUG`, is my recommendation. Waiting isn't a great idea, as that could take indefinitely.", "created_at": "2025-02-21T00:44:30Z", "version": "0.19"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1911, "instance_id": "yhirose__cpp-httplib-1911", "issue_numbers": ["1808"], "base_commit": "c88b09bc6be4300d07140c777719ba24fc6288a2", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -6956,7 +6956,9 @@ Server::process_request(Stream &strm, bool close_connection,\n       strm.write_format(\"HTTP/1.1 %d %s\\r\\n\\r\\n\", status,\n                         status_message(status));\n       break;\n-    default: return write_response(strm, close_connection, req, res);\n+    default:\n+      connection_closed = true;\n+      return write_response(strm, true, req, res);\n     }\n   }\n \n", "test_patch": "diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt\n--- a/test/CMakeLists.txt\n+++ b/test/CMakeLists.txt\n@@ -24,9 +24,11 @@ else()\n     FetchContent_MakeAvailable(gtest)\n endif()\n \n+find_package(curl REQUIRED)\n+\n add_executable(httplib-test test.cc)\n target_compile_options(httplib-test PRIVATE \"$<$<CXX_COMPILER_ID:MSVC>:/utf-8;/bigobj>\")\n-target_link_libraries(httplib-test PRIVATE httplib GTest::gtest_main)\n+target_link_libraries(httplib-test PRIVATE httplib GTest::gtest_main CURL::libcurl)\n gtest_discover_tests(httplib-test)\n \n file(\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1,6 +1,7 @@\n #include <httplib.h>\n #include <signal.h>\n \n+#include <curl/curl.h>\n #include <gtest/gtest.h>\n \n #include <atomic>\n@@ -12,6 +13,7 @@\n #include <stdexcept>\n #include <thread>\n #include <type_traits>\n+#include <vector>\n \n #define SERVER_CERT_FILE \"./cert.pem\"\n #define SERVER_CERT2_FILE \"./cert2.pem\"\n@@ -7606,3 +7608,101 @@ TEST(DirtyDataRequestTest, HeadFieldValueContains_CR_LF_NUL) {\n   Client cli(HOST, PORT);\n   cli.Get(\"/test\", {{\"Test\", \"_\\n\\r_\\n\\r_\"}});\n }\n+\n+TEST(Expect100ContinueTest, ServerClosesConnection) {\n+  static constexpr char reject[] = \"Unauthorized\";\n+  static constexpr char accept[] = \"Upload accepted\";\n+  constexpr size_t total_size = 10 * 1024 * 1024 * 1024ULL;\n+\n+  Server svr;\n+\n+  svr.set_expect_100_continue_handler([](const Request &req, Response &res) {\n+    res.status = StatusCode::Unauthorized_401;\n+    res.set_content(reject, \"text/plain\");\n+    return res.status;\n+  });\n+  svr.Post(\"/\", [&](const Request & /*req*/, Response &res) {\n+    res.set_content(accept, \"text/plain\");\n+  });\n+\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  {\n+    const auto curl = std::unique_ptr<CURL, decltype(&curl_easy_cleanup)>{\n+        curl_easy_init(), &curl_easy_cleanup};\n+    ASSERT_NE(curl, nullptr);\n+\n+    curl_easy_setopt(curl.get(), CURLOPT_URL, HOST);\n+    curl_easy_setopt(curl.get(), CURLOPT_PORT, PORT);\n+    curl_easy_setopt(curl.get(), CURLOPT_POST, 1L);\n+    auto list = std::unique_ptr<curl_slist, decltype(&curl_slist_free_all)>{\n+        curl_slist_append(nullptr, \"Content-Type: application/octet-stream\"),\n+        &curl_slist_free_all};\n+    ASSERT_NE(list, nullptr);\n+    curl_easy_setopt(curl.get(), CURLOPT_HTTPHEADER, list.get());\n+\n+    struct read_data {\n+      size_t read_size;\n+      size_t total_size;\n+    } data = {0, total_size};\n+    using read_callback_t =\n+        size_t (*)(char *ptr, size_t size, size_t nmemb, void *userdata);\n+    read_callback_t read_callback = [](char *ptr, size_t size, size_t nmemb,\n+                                       void *userdata) -> size_t {\n+      read_data *data = (read_data *)userdata;\n+\n+      if (!userdata || data->read_size >= data->total_size) { return 0; }\n+\n+      std::fill_n(ptr, size * nmemb, 'A');\n+      data->read_size += size * nmemb;\n+      return size * nmemb;\n+    };\n+    curl_easy_setopt(curl.get(), CURLOPT_READDATA, data);\n+    curl_easy_setopt(curl.get(), CURLOPT_READFUNCTION, read_callback);\n+\n+    std::vector<char> buffer;\n+    curl_easy_setopt(curl.get(), CURLOPT_WRITEDATA, &buffer);\n+    using write_callback_t =\n+        size_t (*)(char *ptr, size_t size, size_t nmemb, void *userdata);\n+    write_callback_t write_callback = [](char *ptr, size_t size, size_t nmemb,\n+                                         void *userdata) -> size_t {\n+      std::vector<char> *buffer = (std::vector<char> *)userdata;\n+      buffer->reserve(buffer->size() + size * nmemb + 1);\n+      buffer->insert(buffer->end(), (char *)ptr, (char *)ptr + size * nmemb);\n+      return size * nmemb;\n+    };\n+    curl_easy_setopt(curl.get(), CURLOPT_WRITEFUNCTION, write_callback);\n+\n+    {\n+      const auto res = curl_easy_perform(curl.get());\n+      ASSERT_EQ(res, CURLE_OK);\n+    }\n+\n+    {\n+      auto response_code = long{};\n+      const auto res =\n+          curl_easy_getinfo(curl.get(), CURLINFO_RESPONSE_CODE, &response_code);\n+      ASSERT_EQ(res, CURLE_OK);\n+      ASSERT_EQ(response_code, StatusCode::Unauthorized_401);\n+    }\n+\n+    {\n+      auto dl = curl_off_t{};\n+      const auto res = curl_easy_getinfo(curl.get(), CURLINFO_SIZE_DOWNLOAD_T, &dl);\n+      ASSERT_EQ(res, CURLE_OK);\n+      ASSERT_EQ(dl, sizeof reject - 1);\n+    }\n+\n+    {\n+      buffer.push_back('\\0');\n+      ASSERT_STRCASEEQ(buffer.data(), reject);\n+    }\n+  }\n+}\n", "problem_statement": "Incorrect handling of `Expect: 100-continue` during large file uploads\n### Description\r\n\r\nWhen using `curl` to upload large files (>1M) to a server written with cpp-httplib, `curl` adds the `Expect: 100-continue` header. After the server rejects the request by returning a non-100 status code and some data, `curl` blocks for 1 second after receiving the data and then fails with a broken pipe error.\r\n\r\n### Steps to Reproduce\r\n\r\n1. Set up a server using cpp-httplib.\r\n2. Use `curl` to upload a file larger than 1M to the server.\r\n3. Observe the `--trace` output from `curl`, which shows that it still sends data after handling the `100-continue` response.\r\n\r\n    ```\r\n    == Info: Done waiting for 100-continue\r\n    => Send data, 65536 bytes (0x10000)\r\n    ```\r\n\r\n### Expected Behavior\r\n\r\nAccording to [RFC 7231 section 5.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-5.1.1):\r\n\r\n```\r\nA server that responds with a final status code before reading the\r\nentire message body SHOULD indicate in that response whether it\r\nintends to close the connection or continue reading and discarding\r\nthe request message (see Section 6.6 of [RFC7230]).\r\n```\r\n\r\nThe expected behavior is for the server to either:\r\n\r\n1. Read and discard the remaining request data, or\r\n2. Close the connection immediately with a `Connection: close` header.\r\n\r\n### Current Behavior\r\n\r\nCurrently, cpp-httplib does not handle this scenario correctly. It neither reads and discards the remaining request data nor closes the connection immediately. Instead, it leaves the connection as-is and continues to respond with the `Keep-Alive` header for `CPPHTTPLIB_KEEPALIVE_MAX_COUNT` times if the client does not close the connection in the request header.\r\n\r\n### Attempted Solution\r\n\r\nThe following modification to the code at https://github.com/yhirose/cpp-httplib/blob/548dfff0aef25e36e971af96b49ce7fbb72d840e/httplib.h#L6706 resolves the issue for `curl`:\r\n\r\n```c++\r\ndefault:\r\n  connection_closed = true;\r\n  return write_response(strm, true, req, res);\r\n```\r\n\r\nWith this change, curl exits without the broken pipe error.\r\n\r\nAdditional Context\r\n* Link to the relevant curl documentation: https://everything.curl.dev/http/post/expect100.html\r\n\n", "hints_text": "Update: The latest [RFC 9110 section 10.1.1](https://datatracker.ietf.org/doc/html/rfc9110#section-10.1.1) says `A server that responds with a final status code before reading the entire request content SHOULD indicate whether it intends to close the connection (e.g., see Section 9.6 of [HTTP/1.1]) or continue reading the request content.`\r\n\r\n\n@solarispika thanks for the report. Could you send a pull request that you suggests and a unit test in `test/test.cc`? Thanks!\nSure! I'll take some time to see how I can add some proper tests.\r\n\n@yhirose I have difficulty where `httplib::Client` doesn't implement the `Expect: 100-continue` behavior, so I can't use it to test the server behavior effectively. It simply sends all the data and encounters a write error.\r\n\r\nTo comprehensively test the server implementation, the client should also support the required behavior as per the specification. However, I don't have enough time to implement the necessary changes in `httplib::Client` to handle the `Expect: 100-continue` header and the associated server responses.\r\n\r\nInstead, I propose using an external tool or library that already supports the `Expect: 100-continue` behavior to test the server implementation. This approach will allow me to focus on the server-side changes while leveraging existing solutions that correctly handle the required client-side behavior.\r\n\r\nPlease let me know if you have any concerns or suggestions regarding this proposed approach.\n@solarispika sorry for the late reply.\r\n\r\n> Instead, I propose using an external tool or library that already supports the Expect: 100-continue behavior to test the server implementation. This approach will allow me to focus on the server-side changes while leveraging existing solutions that correctly handle the required client-side behavior.\r\n\r\nNo problem. You can just focus on the server-side changes.\nHow do I test this to see the broken behaviour?\r\nI compiled the upload example, and then ran\r\n`curl -F 'text_file=@toupload' -F 'image_file=@toupload' http://localhost:8080/upload-test-post --trace tracefile.log`\r\n\r\nBut it appears to work fine, where \"toupload\" is an 8MB+ file.\n@solarispika could you replay to the @paulharris's comment?\n@paulharris You need to setup 100-continue handler to reject uploads.\r\nFor example,\r\n```c++\r\n  svr.set_expect_100_continue_handler([](Request const& req, Response& res) {\r\n    res.status = 400;\r\n    res.set_content(\"{\\\"error\\\": \\\"You Shall Not Upload!!!!\\\"}\", \"application/json; charset=utf-8\");\r\n    return 400;\r\n  });\r\n```\r\n\n@solarispika \r\n\r\n> Instead, I propose using an external tool or library that already supports the `Expect: 100-continue` behavior to test the server implementation. This approach will allow me to focus on the server-side changes while leveraging existing solutions that correctly handle the required client-side behavior.\r\n> \r\n> Please let me know if you have any concerns or suggestions regarding this proposed approach.\r\n\r\nAre you planning to implement it (only server-side is ok) anytime soon?", "created_at": "2024-09-04T09:42:06Z", "version": "0.17"}
{"repo": "yhirose/cpp-httplib", "pull_number": 2163, "instance_id": "yhirose__cpp-httplib-2163", "issue_numbers": ["2162"], "base_commit": "aabd0634aeac096a422e5c21a0b62b5e5f7590ef", "patch": "diff --git a/example/Makefile b/example/Makefile\n--- a/example/Makefile\n+++ b/example/Makefile\n@@ -18,7 +18,7 @@ ZLIB_SUPPORT = -DCPPHTTPLIB_ZLIB_SUPPORT -lz\n BROTLI_DIR = $(PREFIX)/opt/brotli\n BROTLI_SUPPORT = -DCPPHTTPLIB_BROTLI_SUPPORT -I$(BROTLI_DIR)/include -L$(BROTLI_DIR)/lib -lbrotlicommon -lbrotlienc -lbrotlidec\n \n-all: server client hello simplecli simplesvr upload redirect ssesvr ssecli benchmark one_time_request server_and_client\n+all: server client hello simplecli simplesvr upload redirect ssesvr ssecli benchmark one_time_request server_and_client accept_header\n \n server : server.cc ../httplib.h Makefile\n \t$(CXX) -o server $(CXXFLAGS) server.cc $(OPENSSL_SUPPORT) $(ZLIB_SUPPORT) $(BROTLI_SUPPORT)\n@@ -56,9 +56,12 @@ one_time_request : one_time_request.cc ../httplib.h Makefile\n server_and_client : server_and_client.cc ../httplib.h Makefile\n \t$(CXX) -o server_and_client $(CXXFLAGS) server_and_client.cc $(OPENSSL_SUPPORT) $(ZLIB_SUPPORT) $(BROTLI_SUPPORT)\n \n+accept_header : accept_header.cc ../httplib.h Makefile\n+\t$(CXX) -o accept_header $(CXXFLAGS) accept_header.cc $(OPENSSL_SUPPORT) $(ZLIB_SUPPORT) $(BROTLI_SUPPORT)\n+\n pem:\n \topenssl genrsa 2048 > key.pem\n \topenssl req -new -key key.pem | openssl x509 -days 3650 -req -signkey key.pem > cert.pem\n \n clean:\n-\trm server client hello simplecli simplesvr upload redirect ssesvr ssecli benchmark one_time_request server_and_client *.pem\n+\trm server client hello simplecli simplesvr upload redirect ssesvr ssecli benchmark one_time_request server_and_client accept_header *.pem\ndiff --git a/example/accept_header.cc b/example/accept_header.cc\nnew file mode 100644\n--- /dev/null\n+++ b/example/accept_header.cc\n@@ -0,0 +1,134 @@\n+#include \"httplib.h\"\n+#include <iostream>\n+\n+int main() {\n+    using namespace httplib;\n+    \n+    // Example usage of parse_accept_header function\n+    std::cout << \"=== Accept Header Parser Example ===\" << std::endl;\n+    \n+    // Example 1: Simple Accept header\n+    std::string accept1 = \"text/html,application/json,text/plain\";\n+    std::vector<std::string> result1;\n+    if (detail::parse_accept_header(accept1, result1)) {\n+        std::cout << \"\\nExample 1: \" << accept1 << std::endl;\n+        std::cout << \"Parsed order:\" << std::endl;\n+        for (size_t i = 0; i < result1.size(); ++i) {\n+            std::cout << \"  \" << (i + 1) << \". \" << result1[i] << std::endl;\n+        }\n+    } else {\n+        std::cout << \"\\nExample 1: Failed to parse Accept header\" << std::endl;\n+    }\n+    \n+    // Example 2: Accept header with quality values\n+    std::string accept2 = \"text/html;q=0.9,application/json;q=1.0,text/plain;q=0.8\";\n+    std::vector<std::string> result2;\n+    if (detail::parse_accept_header(accept2, result2)) {\n+        std::cout << \"\\nExample 2: \" << accept2 << std::endl;\n+        std::cout << \"Parsed order (sorted by priority):\" << std::endl;\n+        for (size_t i = 0; i < result2.size(); ++i) {\n+            std::cout << \"  \" << (i + 1) << \". \" << result2[i] << std::endl;\n+        }\n+    } else {\n+        std::cout << \"\\nExample 2: Failed to parse Accept header\" << std::endl;\n+    }\n+    \n+    // Example 3: Browser-like Accept header\n+    std::string accept3 = \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\";\n+    std::vector<std::string> result3;\n+    if (detail::parse_accept_header(accept3, result3)) {\n+        std::cout << \"\\nExample 3: \" << accept3 << std::endl;\n+        std::cout << \"Parsed order:\" << std::endl;\n+        for (size_t i = 0; i < result3.size(); ++i) {\n+            std::cout << \"  \" << (i + 1) << \". \" << result3[i] << std::endl;\n+        }\n+    } else {\n+        std::cout << \"\\nExample 3: Failed to parse Accept header\" << std::endl;\n+    }\n+    \n+    // Example 4: Invalid Accept header examples\n+    std::cout << \"\\n=== Invalid Accept Header Examples ===\" << std::endl;\n+    \n+    std::vector<std::string> invalid_examples = {\n+        \"text/html;q=1.5,application/json\",  // q > 1.0\n+        \"text/html;q=-0.1,application/json\", // q < 0.0\n+        \"text/html;q=invalid,application/json\", // invalid q value\n+        \"invalidtype,application/json\",      // invalid media type\n+        \",application/json\"                  // empty entry\n+    };\n+    \n+    for (const auto& invalid_accept : invalid_examples) {\n+        std::vector<std::string> temp_result;\n+        std::cout << \"\\nTesting invalid: \" << invalid_accept << std::endl;\n+        if (detail::parse_accept_header(invalid_accept, temp_result)) {\n+            std::cout << \"  Unexpectedly succeeded!\" << std::endl;\n+        } else {\n+            std::cout << \"  Correctly rejected as invalid\" << std::endl;\n+        }\n+    }\n+    \n+    // Example 4: Server usage example\n+    std::cout << \"\\n=== Server Usage Example ===\" << std::endl;\n+    Server svr;\n+    \n+    svr.Get(\"/api/data\", [](const Request& req, Response& res) {\n+        // Get Accept header\n+        auto accept_header = req.get_header_value(\"Accept\");\n+        if (accept_header.empty()) {\n+            accept_header = \"*/*\";  // Default if no Accept header\n+        }\n+        \n+        // Parse accept header to get preferred content types\n+        std::vector<std::string> preferred_types;\n+        if (!detail::parse_accept_header(accept_header, preferred_types)) {\n+            // Invalid Accept header\n+            res.status = 400;  // Bad Request\n+            res.set_content(\"Invalid Accept header\", \"text/plain\");\n+            return;\n+        }\n+        \n+        std::cout << \"Client Accept header: \" << accept_header << std::endl;\n+        std::cout << \"Preferred types in order:\" << std::endl;\n+        for (size_t i = 0; i < preferred_types.size(); ++i) {\n+            std::cout << \"  \" << (i + 1) << \". \" << preferred_types[i] << std::endl;\n+        }\n+        \n+        // Choose response format based on client preference\n+        std::string response_content;\n+        std::string content_type;\n+        \n+        for (const auto& type : preferred_types) {\n+            if (type == \"application/json\" || type == \"application/*\" || type == \"*/*\") {\n+                response_content = \"{\\\"message\\\": \\\"Hello, World!\\\", \\\"data\\\": [1, 2, 3]}\";\n+                content_type = \"application/json\";\n+                break;\n+            } else if (type == \"text/html\" || type == \"text/*\") {\n+                response_content = \"<html><body><h1>Hello, World!</h1><p>Data: 1, 2, 3</p></body></html>\";\n+                content_type = \"text/html\";\n+                break;\n+            } else if (type == \"text/plain\") {\n+                response_content = \"Hello, World!\\nData: 1, 2, 3\";\n+                content_type = \"text/plain\";\n+                break;\n+            }\n+        }\n+        \n+        if (response_content.empty()) {\n+            // No supported content type found\n+            res.status = 406;  // Not Acceptable\n+            res.set_content(\"No acceptable content type found\", \"text/plain\");\n+            return;\n+        }\n+        \n+        res.set_content(response_content, content_type);\n+        std::cout << \"Responding with: \" << content_type << std::endl;\n+    });\n+    \n+    std::cout << \"Server configured. You can test it with:\" << std::endl;\n+    std::cout << \"  curl -H \\\"Accept: application/json\\\" http://localhost:8080/api/data\" << std::endl;\n+    std::cout << \"  curl -H \\\"Accept: text/html\\\" http://localhost:8080/api/data\" << std::endl;\n+    std::cout << \"  curl -H \\\"Accept: text/plain\\\" http://localhost:8080/api/data\" << std::endl;\n+    std::cout << \"  curl -H \\\"Accept: text/html;q=0.9,application/json;q=1.0\\\" http://localhost:8080/api/data\" << std::endl;\n+    \n+    return 0;\n+}\ndiff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -670,6 +670,7 @@ struct Request {\n   std::function<bool()> is_connection_closed = []() { return true; };\n \n   // for client\n+  std::vector<std::string> accept_content_types;\n   ResponseHandler response_handler;\n   ContentReceiverWithProgress content_receiver;\n   Progress progress;\n@@ -2491,6 +2492,9 @@ bool parse_multipart_boundary(const std::string &content_type,\n \n bool parse_range_header(const std::string &s, Ranges &ranges);\n \n+bool parse_accept_header(const std::string &s,\n+                         std::vector<std::string> &content_types);\n+\n int close_socket(socket_t sock);\n \n ssize_t send_socket(socket_t sock, const void *ptr, size_t size, int flags);\n@@ -5026,6 +5030,123 @@ inline bool parse_range_header(const std::string &s, Ranges &ranges) try {\n } catch (...) { return false; }\n #endif\n \n+inline bool parse_accept_header(const std::string &s,\n+                                std::vector<std::string> &content_types) {\n+  content_types.clear();\n+\n+  // Empty string is considered valid (no preference)\n+  if (s.empty()) { return true; }\n+\n+  // Check for invalid patterns: leading/trailing commas or consecutive commas\n+  if (s.front() == ',' || s.back() == ',' ||\n+      s.find(\",,\") != std::string::npos) {\n+    return false;\n+  }\n+\n+  struct AcceptEntry {\n+    std::string media_type;\n+    double quality;\n+    int order; // Original order in header\n+  };\n+\n+  std::vector<AcceptEntry> entries;\n+  int order = 0;\n+  bool has_invalid_entry = false;\n+\n+  // Split by comma and parse each entry\n+  split(s.data(), s.data() + s.size(), ',', [&](const char *b, const char *e) {\n+    std::string entry(b, e);\n+    entry = trim_copy(entry);\n+\n+    if (entry.empty()) {\n+      has_invalid_entry = true;\n+      return;\n+    }\n+\n+    AcceptEntry accept_entry;\n+    accept_entry.quality = 1.0; // Default quality\n+    accept_entry.order = order++;\n+\n+    // Find q= parameter\n+    auto q_pos = entry.find(\";q=\");\n+    if (q_pos == std::string::npos) { q_pos = entry.find(\"; q=\"); }\n+\n+    if (q_pos != std::string::npos) {\n+      // Extract media type (before q parameter)\n+      accept_entry.media_type = trim_copy(entry.substr(0, q_pos));\n+\n+      // Extract quality value\n+      auto q_start = entry.find('=', q_pos) + 1;\n+      auto q_end = entry.find(';', q_start);\n+      if (q_end == std::string::npos) { q_end = entry.length(); }\n+\n+      std::string quality_str =\n+          trim_copy(entry.substr(q_start, q_end - q_start));\n+      if (quality_str.empty()) {\n+        has_invalid_entry = true;\n+        return;\n+      }\n+\n+      try {\n+        accept_entry.quality = std::stod(quality_str);\n+        // Check if quality is in valid range [0.0, 1.0]\n+        if (accept_entry.quality < 0.0 || accept_entry.quality > 1.0) {\n+          has_invalid_entry = true;\n+          return;\n+        }\n+      } catch (...) {\n+        has_invalid_entry = true;\n+        return;\n+      }\n+    } else {\n+      // No quality parameter, use entire entry as media type\n+      accept_entry.media_type = entry;\n+    }\n+\n+    // Remove additional parameters from media type\n+    auto param_pos = accept_entry.media_type.find(';');\n+    if (param_pos != std::string::npos) {\n+      accept_entry.media_type =\n+          trim_copy(accept_entry.media_type.substr(0, param_pos));\n+    }\n+\n+    // Basic validation of media type format\n+    if (accept_entry.media_type.empty()) {\n+      has_invalid_entry = true;\n+      return;\n+    }\n+\n+    // Check for basic media type format (should contain '/' or be '*')\n+    if (accept_entry.media_type != \"*\" &&\n+        accept_entry.media_type.find('/') == std::string::npos) {\n+      has_invalid_entry = true;\n+      return;\n+    }\n+\n+    entries.push_back(accept_entry);\n+  });\n+\n+  // Return false if any invalid entry was found\n+  if (has_invalid_entry) { return false; }\n+\n+  // Sort by quality (descending), then by original order (ascending)\n+  std::sort(entries.begin(), entries.end(),\n+            [](const AcceptEntry &a, const AcceptEntry &b) {\n+              if (a.quality != b.quality) {\n+                return a.quality > b.quality; // Higher quality first\n+              }\n+              return a.order < b.order; // Earlier order first for same quality\n+            });\n+\n+  // Extract sorted media types\n+  content_types.reserve(entries.size());\n+  for (const auto &entry : entries) {\n+    content_types.push_back(entry.media_type);\n+  }\n+\n+  return true;\n+}\n+\n class MultipartFormDataParser {\n public:\n   MultipartFormDataParser() = default;\n@@ -7446,6 +7567,14 @@ Server::process_request(Stream &strm, const std::string &remote_addr,\n   req.set_header(\"LOCAL_ADDR\", req.local_addr);\n   req.set_header(\"LOCAL_PORT\", std::to_string(req.local_port));\n \n+  if (req.has_header(\"Accept\")) {\n+    const auto &accept_header = req.get_header_value(\"Accept\");\n+    if (!detail::parse_accept_header(accept_header, req.accept_content_types)) {\n+      res.status = StatusCode::BadRequest_400;\n+      return write_response(strm, close_connection, req, res);\n+    }\n+  }\n+\n   if (req.has_header(\"Range\")) {\n     const auto &range_header_value = req.get_header_value(\"Range\");\n     if (!detail::parse_range_header(range_header_value, req.ranges)) {\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -308,6 +308,201 @@ TEST(TrimTests, TrimStringTests) {\n   EXPECT_TRUE(detail::trim_copy(\"\").empty());\n }\n \n+TEST(ParseAcceptHeaderTest, BasicAcceptParsing) {\n+  // Simple case without quality values\n+  std::vector<std::string> result1;\n+  EXPECT_TRUE(detail::parse_accept_header(\n+      \"text/html,application/json,text/plain\", result1));\n+  EXPECT_EQ(result1.size(), 3);\n+  EXPECT_EQ(result1[0], \"text/html\");\n+  EXPECT_EQ(result1[1], \"application/json\");\n+  EXPECT_EQ(result1[2], \"text/plain\");\n+\n+  // With quality values\n+  std::vector<std::string> result2;\n+  EXPECT_TRUE(detail::parse_accept_header(\n+      \"text/html;q=0.9,application/json;q=1.0,text/plain;q=0.8\", result2));\n+  EXPECT_EQ(result2.size(), 3);\n+  EXPECT_EQ(result2[0], \"application/json\"); // highest q value\n+  EXPECT_EQ(result2[1], \"text/html\");\n+  EXPECT_EQ(result2[2], \"text/plain\"); // lowest q value\n+}\n+\n+TEST(ParseAcceptHeaderTest, MixedQualityValues) {\n+  // Mixed with and without quality values\n+  std::vector<std::string> result;\n+  EXPECT_TRUE(detail::parse_accept_header(\n+      \"text/html,application/json;q=0.5,text/plain;q=0.8\", result));\n+  EXPECT_EQ(result.size(), 3);\n+  EXPECT_EQ(result[0], \"text/html\");        // no q value means 1.0\n+  EXPECT_EQ(result[1], \"text/plain\");       // q=0.8\n+  EXPECT_EQ(result[2], \"application/json\"); // q=0.5\n+}\n+\n+TEST(ParseAcceptHeaderTest, EdgeCases) {\n+  // Empty header\n+  std::vector<std::string> empty_result;\n+  EXPECT_TRUE(detail::parse_accept_header(\"\", empty_result));\n+  EXPECT_TRUE(empty_result.empty());\n+\n+  // Single type\n+  std::vector<std::string> single_result;\n+  EXPECT_TRUE(detail::parse_accept_header(\"application/json\", single_result));\n+  EXPECT_EQ(single_result.size(), 1);\n+  EXPECT_EQ(single_result[0], \"application/json\");\n+\n+  // Wildcard types\n+  std::vector<std::string> wildcard_result;\n+  EXPECT_TRUE(detail::parse_accept_header(\n+      \"text/*;q=0.5,*/*;q=0.1,application/json\", wildcard_result));\n+  EXPECT_EQ(wildcard_result.size(), 3);\n+  EXPECT_EQ(wildcard_result[0], \"application/json\");\n+  EXPECT_EQ(wildcard_result[1], \"text/*\");\n+  EXPECT_EQ(wildcard_result[2], \"*/*\");\n+}\n+\n+TEST(ParseAcceptHeaderTest, RealWorldExamples) {\n+  // Common browser Accept header\n+  std::vector<std::string> browser_result;\n+  EXPECT_TRUE(\n+      detail::parse_accept_header(\"text/html,application/xhtml+xml,application/\"\n+                                  \"xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n+                                  browser_result));\n+  EXPECT_EQ(browser_result.size(), 6);\n+  EXPECT_EQ(browser_result[0], \"text/html\");             // q=1.0 (default)\n+  EXPECT_EQ(browser_result[1], \"application/xhtml+xml\"); // q=1.0 (default)\n+  EXPECT_EQ(browser_result[2], \"image/webp\");            // q=1.0 (default)\n+  EXPECT_EQ(browser_result[3], \"image/apng\");            // q=1.0 (default)\n+  EXPECT_EQ(browser_result[4], \"application/xml\");       // q=0.9\n+  EXPECT_EQ(browser_result[5], \"*/*\");                   // q=0.8\n+\n+  // API client header\n+  std::vector<std::string> api_result;\n+  EXPECT_TRUE(detail::parse_accept_header(\n+      \"application/json;q=0.9,application/xml;q=0.8,text/plain;q=0.1\",\n+      api_result));\n+  EXPECT_EQ(api_result.size(), 3);\n+  EXPECT_EQ(api_result[0], \"application/json\");\n+  EXPECT_EQ(api_result[1], \"application/xml\");\n+  EXPECT_EQ(api_result[2], \"text/plain\");\n+}\n+\n+TEST(ParseAcceptHeaderTest, SpecialCases) {\n+  // Quality value with 3 decimal places\n+  std::vector<std::string> decimal_result;\n+  EXPECT_TRUE(detail::parse_accept_header(\n+      \"text/html;q=0.123,application/json;q=0.456\", decimal_result));\n+  EXPECT_EQ(decimal_result.size(), 2);\n+  EXPECT_EQ(decimal_result[0], \"application/json\"); // Higher q value\n+  EXPECT_EQ(decimal_result[1], \"text/html\");\n+\n+  // Zero quality (should still be included but with lowest priority)\n+  std::vector<std::string> zero_q_result;\n+  EXPECT_TRUE(detail::parse_accept_header(\"text/html;q=0,application/json;q=1\",\n+                                          zero_q_result));\n+  EXPECT_EQ(zero_q_result.size(), 2);\n+  EXPECT_EQ(zero_q_result[0], \"application/json\"); // q=1\n+  EXPECT_EQ(zero_q_result[1], \"text/html\");        // q=0\n+\n+  // No spaces around commas\n+  std::vector<std::string> no_space_result;\n+  EXPECT_TRUE(detail::parse_accept_header(\n+      \"text/html;q=0.9,application/json;q=0.8,text/plain;q=0.7\",\n+      no_space_result));\n+  EXPECT_EQ(no_space_result.size(), 3);\n+  EXPECT_EQ(no_space_result[0], \"text/html\");\n+  EXPECT_EQ(no_space_result[1], \"application/json\");\n+  EXPECT_EQ(no_space_result[2], \"text/plain\");\n+}\n+\n+TEST(ParseAcceptHeaderTest, InvalidCases) {\n+  std::vector<std::string> result;\n+\n+  // Invalid quality value (> 1.0)\n+  EXPECT_FALSE(\n+      detail::parse_accept_header(\"text/html;q=1.5,application/json\", result));\n+\n+  // Invalid quality value (< 0.0)\n+  EXPECT_FALSE(\n+      detail::parse_accept_header(\"text/html;q=-0.1,application/json\", result));\n+\n+  // Invalid quality value (not a number)\n+  EXPECT_FALSE(detail::parse_accept_header(\n+      \"text/html;q=invalid,application/json\", result));\n+\n+  // Empty quality value\n+  EXPECT_FALSE(\n+      detail::parse_accept_header(\"text/html;q=,application/json\", result));\n+\n+  // Invalid media type format (no slash and not wildcard)\n+  EXPECT_FALSE(\n+      detail::parse_accept_header(\"invalidtype,application/json\", result));\n+\n+  // Empty media type\n+  result.clear();\n+  EXPECT_FALSE(detail::parse_accept_header(\",application/json\", result));\n+\n+  // Only commas\n+  result.clear();\n+  EXPECT_FALSE(detail::parse_accept_header(\",,,\", result));\n+\n+  // Valid cases should still work\n+  EXPECT_TRUE(detail::parse_accept_header(\"*/*\", result));\n+  EXPECT_EQ(result.size(), 1);\n+  EXPECT_EQ(result[0], \"*/*\");\n+\n+  EXPECT_TRUE(detail::parse_accept_header(\"*\", result));\n+  EXPECT_EQ(result.size(), 1);\n+  EXPECT_EQ(result[0], \"*\");\n+\n+  EXPECT_TRUE(detail::parse_accept_header(\"text/*\", result));\n+  EXPECT_EQ(result.size(), 1);\n+  EXPECT_EQ(result[0], \"text/*\");\n+}\n+\n+TEST(ParseAcceptHeaderTest, ContentTypesPopulatedAndInvalidHeaderHandling) {\n+  Server svr;\n+\n+  svr.Get(\"/accept_ok\", [&](const Request &req, Response &res) {\n+    EXPECT_EQ(req.accept_content_types.size(), 3);\n+    EXPECT_EQ(req.accept_content_types[0], \"application/json\");\n+    EXPECT_EQ(req.accept_content_types[1], \"text/html\");\n+    EXPECT_EQ(req.accept_content_types[2], \"*/*\");\n+    res.set_content(\"ok\", \"text/plain\");\n+  });\n+\n+  svr.Get(\"/accept_bad_request\", [&](const Request & /*req*/, Response &res) {\n+    EXPECT_TRUE(false);\n+    res.set_content(\"bad request\", \"text/plain\");\n+  });\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(\"localhost\", PORT); });\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    listen_thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(\"localhost\", PORT);\n+\n+  {\n+    auto res =\n+        cli.Get(\"/accept_ok\",\n+                {{\"Accept\", \"application/json, text/html;q=0.8, */*;q=0.1\"}});\n+    ASSERT_TRUE(res);\n+    EXPECT_EQ(StatusCode::OK_200, res->status);\n+  }\n+\n+  {\n+    auto res = cli.Get(\"/accept_bad_request\",\n+                       {{\"Accept\", \"text/html;q=abc,application/json\"}});\n+    ASSERT_TRUE(res);\n+    EXPECT_EQ(StatusCode::BadRequest_400, res->status);\n+  }\n+}\n+\n TEST(DivideTest, DivideStringTests) {\n   auto divide = [](const std::string &str, char d) {\n     std::string lhs;\n", "problem_statement": "Returning different content types based on the Accept header request\nIs there a way currently to deliver different content based on the Accept Header.\n\nI would like to send:\n\na text/plain response for Accept: text/plain\nan application/json for Accept: application/json\nand possibly a application/json, if the Accept header contains */*\n\nDo I have to parse the Accept header myself, or is there some facility that I have missed to do this, either via a route, or via an if test something like this:\n\nif (request.content_includes(\"text/plain\"))\n  ...\n\n", "hints_text": "@jspashett we have to manually check the mime type with `get_header_value()` in a request handler.\nThanks. It might be a good candidate for an enhancement becuase parsing the Accept header correctly isn't easy. Especially since it can have priroties, can be empty or it  can say text/* or `*/*` which both match for example, text/plain", "created_at": "2025-06-24T21:21:51Z", "version": "0.22"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1745, "instance_id": "yhirose__cpp-httplib-1745", "issue_numbers": ["1628"], "base_commit": "ad9f6423e2ff0a7795f64bbf91828b7e32be87cb", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -81,7 +81,7 @@ option(HTTPLIB_NO_EXCEPTIONS \"Disable the use of C++ exceptions\" OFF)\n \n # Change as needed to set an OpenSSL minimum version.\n # This is used in the installed Cmake config file.\n-set(_HTTPLIB_OPENSSL_MIN_VER \"1.1.1\")\n+set(_HTTPLIB_OPENSSL_MIN_VER \"3.0.0\")\n \n # Allow for a build to require OpenSSL to pass, instead of just being optional\n option(HTTPLIB_REQUIRE_OPENSSL \"Requires OpenSSL to be found & linked, or fails build.\" OFF)\ndiff --git a/example/Makefile b/example/Makefile\n--- a/example/Makefile\n+++ b/example/Makefile\n@@ -4,8 +4,7 @@ CXXFLAGS = -O2 -std=c++11 -I.. -Wall -Wextra -pthread\n PREFIX = /usr/local\n #PREFIX = $(shell brew --prefix)\n \n-OPENSSL_DIR = $(PREFIX)/opt/openssl@1.1\n-#OPENSSL_DIR = $(PREFIX)/opt/openssl@3\n+OPENSSL_DIR = $(PREFIX)/opt/openssl@3\n OPENSSL_SUPPORT = -DCPPHTTPLIB_OPENSSL_SUPPORT -I$(OPENSSL_DIR)/include -L$(OPENSSL_DIR)/lib -lssl -lcrypto\n \n ifneq ($(OS), Windows_NT)\ndiff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -264,10 +264,8 @@ using socket_t = int;\n #include <iostream>\n #include <sstream>\n \n-#if OPENSSL_VERSION_NUMBER < 0x1010100fL\n-#error Sorry, OpenSSL versions prior to 1.1.1 are not supported\n-#elif OPENSSL_VERSION_NUMBER < 0x30000000L\n-#define SSL_get1_peer_certificate SSL_get_peer_certificate\n+#if OPENSSL_VERSION_NUMBER < 0x30000000L\n+#error Sorry, OpenSSL versions prior to 3.0.0 are not supported\n #endif\n \n #endif\n", "test_patch": "diff --git a/test/Makefile b/test/Makefile\n--- a/test/Makefile\n+++ b/test/Makefile\n@@ -4,8 +4,7 @@ CXXFLAGS = -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion -Wshadow #\n PREFIX = /usr/local\n #PREFIX = $(shell brew --prefix)\n \n-OPENSSL_DIR = $(PREFIX)/opt/openssl@1.1\n-#OPENSSL_DIR = $(PREFIX)/opt/openssl@3\n+OPENSSL_DIR = $(PREFIX)/opt/openssl@3\n OPENSSL_SUPPORT = -DCPPHTTPLIB_OPENSSL_SUPPORT -I$(OPENSSL_DIR)/include -L$(OPENSSL_DIR)/lib -lssl -lcrypto\n \n ifneq ($(OS), Windows_NT)\n", "problem_statement": "OpenSSL 1.1.1 End of Life on September 11, 2023\n\n", "hints_text": "https://www.openssl.org/policies/releasestrat.html\nNote that the README says only OpenSSL 1.1.1 and 3.0 are supported, but 3.1 seems to work fine at least with cpp-httplib 0.12.6 on Linux.  I have not tried Windows.  OpenSSL has gotten better about semantic versioning and I don't think 3.1 removes anything.  It shows up as the same \"libssl.so.3\".  \r\n\r\nArch Linux is now shipping OpenSSL 3.1 so it might be a good time to make support for it official.  ", "created_at": "2023-12-23T17:04:35Z", "version": "0.14"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1910, "instance_id": "yhirose__cpp-httplib-1910", "issue_numbers": ["1908"], "base_commit": "c5ee20877597e4b9a7082d111036aac636598ee0", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -2790,6 +2790,10 @@ inline bool stream_line_reader::getline() {\n   fixed_buffer_used_size_ = 0;\n   glowable_buffer_.clear();\n \n+#ifndef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR\n+  char prev_byte = 0;\n+#endif\n+\n   for (size_t i = 0;; i++) {\n     char byte;\n     auto n = strm_.read(&byte, 1);\n@@ -2806,7 +2810,12 @@ inline bool stream_line_reader::getline() {\n \n     append(byte);\n \n+#ifdef CPPHTTPLIB_ALLOW_LF_AS_LINE_TERMINATOR\n     if (byte == '\\n') { break; }\n+#else\n+    if (prev_byte == '\\r' && byte == '\\n') { break; }\n+    prev_byte = byte;\n+#endif\n   }\n \n   return true;\n@@ -2862,7 +2871,8 @@ inline bool mmap::open(const char *path) {\n   // If the following line doesn't compile due to QuadPart, update Windows SDK.\n   // See:\n   // https://github.com/yhirose/cpp-httplib/issues/1903#issuecomment-2316520721\n-  if (static_cast<ULONGLONG>(size.QuadPart) > std::numeric_limits<decltype(size_)>::max()) {\n+  if (static_cast<ULONGLONG>(size.QuadPart) >\n+      std::numeric_limits<decltype(size_)>::max()) {\n     // `size_t` might be 32-bits, on 32-bits Windows.\n     return false;\n   }\n@@ -4049,7 +4059,22 @@ inline bool read_headers(Stream &strm, Headers &headers) {\n     auto end = line_reader.ptr() + line_reader.size() - line_terminator_len;\n \n     parse_header(line_reader.ptr(), end,\n-                 [&](const std::string &key, const std::string &val) {\n+                 [&](const std::string &key, std::string &val) {\n+                   // NOTE: From RFC 9110:\n+                   // Field values containing CR, LF, or NUL characters are\n+                   // invalid and dangerous, due to the varying ways that\n+                   // implementations might parse and interpret those\n+                   // characters; a recipient of CR, LF, or NUL within a field\n+                   // value MUST either reject the message or replace each of\n+                   // those characters with SP before further processing or\n+                   // forwarding of that message.\n+                   for (auto &c : val) {\n+                     switch (c) {\n+                     case '\\0':\n+                     case '\\n':\n+                     case '\\r': c = ' '; break;\n+                     }\n+                   }\n                    headers.emplace(key, val);\n                  });\n   }\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -4718,6 +4718,11 @@ static void test_raw_request(const std::string &req,\n   svr.Put(\"/put_hi\", [&](const Request & /*req*/, Response &res) {\n     res.set_content(\"ok\", \"text/plain\");\n   });\n+  svr.Get(\"/header_field_value_check\", [&](const Request &req, Response &res) {\n+    auto val = req.get_header_value(\"Test\");\n+    EXPECT_EQ(\"[   ]\", val);\n+    res.set_content(\"ok\", \"text/plain\");\n+  });\n \n   // Server read timeout must be longer than the client read timeout for the\n   // bug to reproduce, probably to force the server to process a request\n@@ -4851,6 +4856,12 @@ TEST(ServerRequestParsingTest, InvalidSpaceInURL) {\n   EXPECT_EQ(\"HTTP/1.1 400 Bad Request\", out.substr(0, 24));\n }\n \n+TEST(ServerRequestParsingTest, InvalidFieldValueContains_CR_LF_NUL) {\n+  std::string request(\n+      \"GET /header_field_value_check HTTP/1.1\\r\\nTest: [\\r\\x00\\n]\\r\\n\\r\\n\", 55);\n+  test_raw_request(request);\n+}\n+\n TEST(ServerStopTest, StopServerWithChunkedTransmission) {\n   Server svr;\n \n@@ -7572,3 +7583,26 @@ TEST(FileSystemTest, FileAndDirExistenceCheck) {\n   EXPECT_FALSE(detail::is_file(dir_path));\n   EXPECT_TRUE(detail::is_dir(dir_path));\n }\n+\n+TEST(DirtyDataRequestTest, HeadFieldValueContains_CR_LF_NUL) {\n+  Server svr;\n+\n+  svr.Get(\"/test\", [&](const Request &req, Response &) {\n+    auto val = req.get_header_value(\"Test\");\n+    EXPECT_EQ(val.size(), 7u);\n+    EXPECT_EQ(val, \"_  _  _\");\n+  });\n+\n+  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+  cli.Get(\"/test\", {{\"Test\", \"_\\n\\r_\\n\\r_\"}});\n+}\n", "problem_statement": "Header parser incorrectly accepts NUL and CR within header values\nFrom RFC 9110:\r\n> Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.\r\n\r\ncpp-httplib does not enforce this rule for CR and NUL. You can see this by running a simple example that echoes back header values (such as [this](https://github.com/narfindustries/http-garden/blob/main/images/cpp_httplib/server.cpp)), and sending it a request containing NUL and CR within a header value:\r\n```sh\r\nprintf 'GET / HTTP/1.1\\r\\nHost: whatever\\r\\nTest: \\r\\x00\\r\\n\\r\\n' \\\r\n  | timeout 1 ncat --no-shutdown localhost 80 \\\r\n  | grep '\"headers\"' \\\r\n  | jq '.[\"headers\"][1][1]' \\\r\n  | xargs echo \\\r\n  | base64 -d \\\r\n  | xxd\r\n```\r\n```\r\n00000000: 0d00                                     ..\r\n```\n", "hints_text": "", "created_at": "2024-09-03T04:31:01Z", "version": "0.17"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1527, "instance_id": "yhirose__cpp-httplib-1527", "issue_numbers": ["1481"], "base_commit": "ed0719f2bcb5fd7a3f7a52f304316a1c20851fbb", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -8541,13 +8541,29 @@ inline SSL *ssl_new(socket_t sock, SSL_CTX *ctx, std::mutex &ctx_mutex,\n   return ssl;\n }\n \n-inline void ssl_delete(std::mutex &ctx_mutex, SSL *ssl,\n+inline void ssl_delete(std::mutex &ctx_mutex, SSL *ssl, socket_t sock,\n                        bool shutdown_gracefully) {\n   // sometimes we may want to skip this to try to avoid SIGPIPE if we know\n   // the remote has closed the network connection\n   // Note that it is not always possible to avoid SIGPIPE, this is merely a\n   // best-efforts.\n-  if (shutdown_gracefully) { SSL_shutdown(ssl); }\n+  if (shutdown_gracefully) {\n+#ifdef _WIN32\n+    SSL_shutdown(ssl);\n+#else\n+    timeval tv;\n+    tv.tv_sec = 1;\n+    tv.tv_usec = 0;\n+    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,\n+               reinterpret_cast<const void *>(&tv), sizeof(tv));\n+\n+    auto ret = SSL_shutdown(ssl);\n+    while (ret == 0) {\n+      std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+      ret = SSL_shutdown(ssl);\n+    }\n+#endif\n+  }\n \n   std::lock_guard<std::mutex> guard(ctx_mutex);\n   SSL_free(ssl);\n@@ -8826,7 +8842,7 @@ inline bool SSLServer::process_and_close_socket(socket_t sock) {\n     // Shutdown gracefully if the result seemed successful, non-gracefully if\n     // the connection appeared to be closed.\n     const bool shutdown_gracefully = ret;\n-    detail::ssl_delete(ctx_mutex_, ssl, shutdown_gracefully);\n+    detail::ssl_delete(ctx_mutex_, ssl, sock, shutdown_gracefully);\n   }\n \n   detail::shutdown_socket(sock);\n@@ -9109,7 +9125,8 @@ inline void SSLClient::shutdown_ssl_impl(Socket &socket,\n     return;\n   }\n   if (socket.ssl) {\n-    detail::ssl_delete(ctx_mutex_, socket.ssl, shutdown_gracefully);\n+    detail::ssl_delete(ctx_mutex_, socket.ssl, socket.sock,\n+                       shutdown_gracefully);\n     socket.ssl = nullptr;\n   }\n   assert(socket.ssl == nullptr);\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -54,6 +54,166 @@ MultipartFormData &get_file_value(MultipartFormDataItems &files,\n #endif\n }\n \n+#ifndef _WIN32\n+class UnixSocketTest : public ::testing::Test {\n+protected:\n+  void TearDown() override { std::remove(pathname_.c_str()); }\n+\n+  void client_GET(const std::string &addr) {\n+    httplib::Client cli{addr};\n+    cli.set_address_family(AF_UNIX);\n+    ASSERT_TRUE(cli.is_valid());\n+\n+    const auto &result = cli.Get(pattern_);\n+    ASSERT_TRUE(result) << \"error: \" << result.error();\n+\n+    const auto &resp = result.value();\n+    EXPECT_EQ(resp.status, StatusCode::OK_200);\n+    EXPECT_EQ(resp.body, content_);\n+  }\n+\n+  const std::string pathname_{\"./httplib-server.sock\"};\n+  const std::string pattern_{\"/hi\"};\n+  const std::string content_{\"Hello World!\"};\n+};\n+\n+TEST_F(UnixSocketTest, pathname) {\n+  httplib::Server svr;\n+  svr.Get(pattern_, [&](const httplib::Request &, httplib::Response &res) {\n+    res.set_content(content_, \"text/plain\");\n+  });\n+\n+  std::thread t{[&] {\n+    ASSERT_TRUE(svr.set_address_family(AF_UNIX).listen(pathname_, 80));\n+  }};\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    t.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+  ASSERT_TRUE(svr.is_running());\n+\n+  client_GET(pathname_);\n+}\n+\n+#if defined(__linux__) ||                                                      \\\n+    /* __APPLE__ */ (defined(SOL_LOCAL) && defined(SO_PEERPID))\n+TEST_F(UnixSocketTest, PeerPid) {\n+  httplib::Server svr;\n+  std::string remote_port_val;\n+  svr.Get(pattern_, [&](const httplib::Request &req, httplib::Response &res) {\n+    res.set_content(content_, \"text/plain\");\n+    remote_port_val = req.get_header_value(\"REMOTE_PORT\");\n+  });\n+\n+  std::thread t{[&] {\n+    ASSERT_TRUE(svr.set_address_family(AF_UNIX).listen(pathname_, 80));\n+  }};\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    t.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+  ASSERT_TRUE(svr.is_running());\n+\n+  client_GET(pathname_);\n+  EXPECT_EQ(std::to_string(getpid()), remote_port_val);\n+}\n+#endif\n+\n+#ifdef __linux__\n+TEST_F(UnixSocketTest, abstract) {\n+  constexpr char svr_path[]{\"\\x00httplib-server.sock\"};\n+  const std::string abstract_addr{svr_path, sizeof(svr_path) - 1};\n+\n+  httplib::Server svr;\n+  svr.Get(pattern_, [&](const httplib::Request &, httplib::Response &res) {\n+    res.set_content(content_, \"text/plain\");\n+  });\n+\n+  std::thread t{[&] {\n+    ASSERT_TRUE(svr.set_address_family(AF_UNIX).listen(abstract_addr, 80));\n+  }};\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    t.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+  ASSERT_TRUE(svr.is_running());\n+\n+  client_GET(abstract_addr);\n+}\n+#endif\n+\n+TEST(SocketStream, is_writable_UNIX) {\n+  int fds[2];\n+  ASSERT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+\n+  const auto asSocketStream = [&](socket_t fd,\n+                                  std::function<bool(Stream &)> func) {\n+    return detail::process_client_socket(fd, 0, 0, 0, 0, func);\n+  };\n+  asSocketStream(fds[0], [&](Stream &s0) {\n+    EXPECT_EQ(s0.socket(), fds[0]);\n+    EXPECT_TRUE(s0.is_writable());\n+\n+    EXPECT_EQ(0, close(fds[1]));\n+    EXPECT_FALSE(s0.is_writable());\n+\n+    return true;\n+  });\n+  EXPECT_EQ(0, close(fds[0]));\n+}\n+\n+TEST(SocketStream, is_writable_INET) {\n+  sockaddr_in addr;\n+  memset(&addr, 0, sizeof(addr));\n+  addr.sin_family = AF_INET;\n+  addr.sin_port = htons(PORT + 1);\n+  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n+\n+  int disconnected_svr_sock = -1;\n+  std::thread svr{[&] {\n+    const int s = socket(AF_INET, SOCK_STREAM, 0);\n+    ASSERT_LE(0, s);\n+    ASSERT_EQ(0, ::bind(s, reinterpret_cast<sockaddr *>(&addr), sizeof(addr)));\n+    ASSERT_EQ(0, listen(s, 1));\n+    ASSERT_LE(0, disconnected_svr_sock = accept(s, nullptr, nullptr));\n+    ASSERT_EQ(0, close(s));\n+  }};\n+  std::this_thread::sleep_for(std::chrono::milliseconds(100));\n+\n+  std::thread cli{[&] {\n+    const int s = socket(AF_INET, SOCK_STREAM, 0);\n+    ASSERT_LE(0, s);\n+    ASSERT_EQ(0, connect(s, reinterpret_cast<sockaddr *>(&addr), sizeof(addr)));\n+    ASSERT_EQ(0, close(s));\n+  }};\n+  cli.join();\n+  svr.join();\n+  ASSERT_NE(disconnected_svr_sock, -1);\n+\n+  const auto asSocketStream = [&](socket_t fd,\n+                                  std::function<bool(Stream &)> func) {\n+    return detail::process_client_socket(fd, 0, 0, 0, 0, func);\n+  };\n+  asSocketStream(disconnected_svr_sock, [&](Stream &ss) {\n+    EXPECT_EQ(ss.socket(), disconnected_svr_sock);\n+    EXPECT_FALSE(ss.is_writable());\n+\n+    return true;\n+  });\n+\n+  ASSERT_EQ(0, close(disconnected_svr_sock));\n+}\n+#endif // #ifndef _WIN32\n+\n TEST(ClientTest, MoveConstructible) {\n   EXPECT_FALSE(std::is_copy_constructible<Client>::value);\n   EXPECT_TRUE(std::is_nothrow_move_constructible<Client>::value);\n@@ -4996,6 +5156,60 @@ TEST(KeepAliveTest, SSLClientReconnection) {\n   ASSERT_TRUE(result);\n   EXPECT_EQ(StatusCode::OK_200, result->status);\n }\n+\n+TEST(KeepAliveTest, SSLClientReconnectionPost) {\n+  SSLServer svr(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE);\n+  ASSERT_TRUE(svr.is_valid());\n+  svr.set_keep_alive_timeout(1);\n+  std::string content = \"reconnect\";\n+\n+  svr.Post(\"/hi\", [](const httplib::Request &, httplib::Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+\n+  auto f = std::async(std::launch::async, [&svr] { svr.listen(HOST, PORT); });\n+  std::this_thread::sleep_for(std::chrono::milliseconds(200));\n+\n+  SSLClient cli(HOST, PORT);\n+  cli.enable_server_certificate_verification(false);\n+  cli.set_keep_alive(true);\n+\n+  auto result = cli.Post(\n+      \"/hi\", content.size(),\n+      [&content](size_t offset, size_t length, DataSink &sink) {\n+        sink.write(content.c_str(), content.size());\n+        return true;\n+      },\n+      \"text/plain\");\n+  ASSERT_TRUE(result);\n+  EXPECT_EQ(200, result->status);\n+\n+  std::this_thread::sleep_for(std::chrono::seconds(2));\n+\n+  // Recoonect\n+  result = cli.Post(\n+      \"/hi\", content.size(),\n+      [&content](size_t offset, size_t length, DataSink &sink) {\n+        sink.write(content.c_str(), content.size());\n+        return true;\n+      },\n+      \"text/plain\");\n+  ASSERT_TRUE(result);\n+  EXPECT_EQ(200, result->status);\n+\n+  result = cli.Post(\n+      \"/hi\", content.size(),\n+      [&content](size_t offset, size_t length, DataSink &sink) {\n+        sink.write(content.c_str(), content.size());\n+        return true;\n+      },\n+      \"text/plain\");\n+  ASSERT_TRUE(result);\n+  EXPECT_EQ(200, result->status);\n+\n+  svr.stop();\n+  f.wait();\n+}\n #endif\n \n TEST(ClientProblemDetectionTest, ContentProvider) {\n@@ -6970,166 +7184,6 @@ TEST(MultipartFormDataTest, ContentLength) {\n \n #endif\n \n-#ifndef _WIN32\n-class UnixSocketTest : public ::testing::Test {\n-protected:\n-  void TearDown() override { std::remove(pathname_.c_str()); }\n-\n-  void client_GET(const std::string &addr) {\n-    httplib::Client cli{addr};\n-    cli.set_address_family(AF_UNIX);\n-    ASSERT_TRUE(cli.is_valid());\n-\n-    const auto &result = cli.Get(pattern_);\n-    ASSERT_TRUE(result) << \"error: \" << result.error();\n-\n-    const auto &resp = result.value();\n-    EXPECT_EQ(resp.status, StatusCode::OK_200);\n-    EXPECT_EQ(resp.body, content_);\n-  }\n-\n-  const std::string pathname_{\"./httplib-server.sock\"};\n-  const std::string pattern_{\"/hi\"};\n-  const std::string content_{\"Hello World!\"};\n-};\n-\n-TEST_F(UnixSocketTest, pathname) {\n-  httplib::Server svr;\n-  svr.Get(pattern_, [&](const httplib::Request &, httplib::Response &res) {\n-    res.set_content(content_, \"text/plain\");\n-  });\n-\n-  std::thread t{[&] {\n-    ASSERT_TRUE(svr.set_address_family(AF_UNIX).listen(pathname_, 80));\n-  }};\n-  auto se = detail::scope_exit([&] {\n-    svr.stop();\n-    t.join();\n-    ASSERT_FALSE(svr.is_running());\n-  });\n-\n-  svr.wait_until_ready();\n-  ASSERT_TRUE(svr.is_running());\n-\n-  client_GET(pathname_);\n-}\n-\n-#if defined(__linux__) ||                                                      \\\n-    /* __APPLE__ */ (defined(SOL_LOCAL) && defined(SO_PEERPID))\n-TEST_F(UnixSocketTest, PeerPid) {\n-  httplib::Server svr;\n-  std::string remote_port_val;\n-  svr.Get(pattern_, [&](const httplib::Request &req, httplib::Response &res) {\n-    res.set_content(content_, \"text/plain\");\n-    remote_port_val = req.get_header_value(\"REMOTE_PORT\");\n-  });\n-\n-  std::thread t{[&] {\n-    ASSERT_TRUE(svr.set_address_family(AF_UNIX).listen(pathname_, 80));\n-  }};\n-  auto se = detail::scope_exit([&] {\n-    svr.stop();\n-    t.join();\n-    ASSERT_FALSE(svr.is_running());\n-  });\n-\n-  svr.wait_until_ready();\n-  ASSERT_TRUE(svr.is_running());\n-\n-  client_GET(pathname_);\n-  EXPECT_EQ(std::to_string(getpid()), remote_port_val);\n-}\n-#endif\n-\n-#ifdef __linux__\n-TEST_F(UnixSocketTest, abstract) {\n-  constexpr char svr_path[]{\"\\x00httplib-server.sock\"};\n-  const std::string abstract_addr{svr_path, sizeof(svr_path) - 1};\n-\n-  httplib::Server svr;\n-  svr.Get(pattern_, [&](const httplib::Request &, httplib::Response &res) {\n-    res.set_content(content_, \"text/plain\");\n-  });\n-\n-  std::thread t{[&] {\n-    ASSERT_TRUE(svr.set_address_family(AF_UNIX).listen(abstract_addr, 80));\n-  }};\n-  auto se = detail::scope_exit([&] {\n-    svr.stop();\n-    t.join();\n-    ASSERT_FALSE(svr.is_running());\n-  });\n-\n-  svr.wait_until_ready();\n-  ASSERT_TRUE(svr.is_running());\n-\n-  client_GET(abstract_addr);\n-}\n-#endif\n-\n-TEST(SocketStream, is_writable_UNIX) {\n-  int fds[2];\n-  ASSERT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n-\n-  const auto asSocketStream = [&](socket_t fd,\n-                                  std::function<bool(Stream &)> func) {\n-    return detail::process_client_socket(fd, 0, 0, 0, 0, func);\n-  };\n-  asSocketStream(fds[0], [&](Stream &s0) {\n-    EXPECT_EQ(s0.socket(), fds[0]);\n-    EXPECT_TRUE(s0.is_writable());\n-\n-    EXPECT_EQ(0, close(fds[1]));\n-    EXPECT_FALSE(s0.is_writable());\n-\n-    return true;\n-  });\n-  EXPECT_EQ(0, close(fds[0]));\n-}\n-\n-TEST(SocketStream, is_writable_INET) {\n-  sockaddr_in addr;\n-  memset(&addr, 0, sizeof(addr));\n-  addr.sin_family = AF_INET;\n-  addr.sin_port = htons(PORT + 1);\n-  addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n-\n-  int disconnected_svr_sock = -1;\n-  std::thread svr{[&] {\n-    const int s = socket(AF_INET, SOCK_STREAM, 0);\n-    ASSERT_LE(0, s);\n-    ASSERT_EQ(0, ::bind(s, reinterpret_cast<sockaddr *>(&addr), sizeof(addr)));\n-    ASSERT_EQ(0, listen(s, 1));\n-    ASSERT_LE(0, disconnected_svr_sock = accept(s, nullptr, nullptr));\n-    ASSERT_EQ(0, close(s));\n-  }};\n-  std::this_thread::sleep_for(std::chrono::milliseconds(100));\n-\n-  std::thread cli{[&] {\n-    const int s = socket(AF_INET, SOCK_STREAM, 0);\n-    ASSERT_LE(0, s);\n-    ASSERT_EQ(0, connect(s, reinterpret_cast<sockaddr *>(&addr), sizeof(addr)));\n-    ASSERT_EQ(0, close(s));\n-  }};\n-  cli.join();\n-  svr.join();\n-  ASSERT_NE(disconnected_svr_sock, -1);\n-\n-  const auto asSocketStream = [&](socket_t fd,\n-                                  std::function<bool(Stream &)> func) {\n-    return detail::process_client_socket(fd, 0, 0, 0, 0, func);\n-  };\n-  asSocketStream(disconnected_svr_sock, [&](Stream &ss) {\n-    EXPECT_EQ(ss.socket(), disconnected_svr_sock);\n-    EXPECT_FALSE(ss.is_writable());\n-\n-    return true;\n-  });\n-\n-  ASSERT_EQ(0, close(disconnected_svr_sock));\n-}\n-#endif // #ifndef _WIN32\n-\n TEST(TaskQueueTest, IncreaseAtomicInteger) {\n   static constexpr unsigned int number_of_tasks{1000000};\n   std::atomic_uint count{0};\n", "problem_statement": "detail::is_socket_alive() is not work for https connection\nis_socket_alive() is always return ture even though peer closed TLS and TCP connecton,  I dont konwn how to detect  whether TLS connection is alived.\n", "hints_text": "@chisheng thanks for the feedback. This method is not intended to be used by users, rather for internal use in cpp-httplib to detect a current socket is writable. That's why it's in the namespace `detail`.\r\n\r\nAlso there exist some unit cases where you can see it returns 'false'. One of them is `ServerTest.ClientStop`. Hope it helps.\nSorry\uff0cI didn't explain my problem clearly.Pseudocode\r\nint main()\r\n{\r\nhttplib::SSLClient cli();\r\ncli.post();//first request is success\r\nsleep(60);//The server will close the connection after 60 seconds\r\ncli.post()//second request will failed\uff0cis_socket_alive() return true for TLS socket ,it should reconnect TLS instead of use previous one. \r\n}\n@chisheng thanks for the more details. I'll try to reproduce it.\r\n\r\n> sleep(60);//The server will close the connection after 60 seconds\r\n\r\nDoes it actually mean that your server will close **within** 60 seconds?\r\n\r\n\nyes,the keep-alive timeout of http server  is 60s\n@chisheng I now confirmed it's a bug. Thanks for the report.\n@chisheng I fixed it. Could you try it with the latest httplib.h in your project?\n@chisheng it seems like my fix disable KeepAlive connection completely... Sorry about that. I'll work on it again.\n@chisheng I now fixed it. Could you try the latest httplib.h in the master branch? If it works on your machine, I'll bump up the version number. Thanks!\n@yhirose I can confirm that c7e959 fixes the issues I mentioned in https://github.com/yhirose/cpp-httplib/issues/1379. (Also, as you are aware of, ba5884 did not work very well.)\r\n\r\nThanks for the fix!\n> @chisheng I now fixed it. Could you try the latest httplib.h in the master branch? If it works on your machine, I'll bump up the version number. Thanks!\r\n\r\n    sorry,I think it is still have a problem,I usring 0.9.7 because It wasn't implemented at the time that using post method with provicer \uff0cI add extended post port with provider According to my situation in small Small memory device\u3002\r\n\r\nFunction with provider may be not work \uff0cbeacause i  find write_request return false\uff0cSSL_peek is not executed.and SSL_peek\uff08\uff09return 0 mean TLS broken? did not use SSL_get_error() to  get error ,I guess SSL_get_error  return  SSL_ERROR_WANT_READ when The server response delay \uff0cSSL_peek return 0 in this situation.\r\n\n@chisheng, thanks for the feedback.\r\n\r\n> I usring 0.9.7 because...\r\n\r\nWhat does it mean by that? If it's not you, could tell the developer to try with the latest httplib.h in the master branch? 0.9.7 is too old, and I don't support it any more.\r\n\r\n>  Function with provider may be not work \uff0cbeacause i find write_request return false\r\n\r\nI can't reproduce the problem on my machine. Could you provide the smallest possible code example or a unit test, so that I can see what's going on? My test case in `test/test.cc` is `KeepAliveTest.SSLClientReconnection`.\r\n\r\n> SSL_peek\uff08\uff09return 0 mean TLS broken?\r\n\r\nNot necessarily though, it's the only way to detect the SSL peer is closed, because when the client succeeds sending a HTTP request, it is supposed to receive a HTTP response according to the HTTP specification. But just in case, I added a code to check the error code from `SSL_get_error`, and let the client reconnect only when the error code is `SSL_ERROR_ZERO_RETURN`. https://github.com/yhirose/cpp-httplib/commit/1ebb8412c594a091750f1b614d6aae3964c0db44\r\n\r\n<img width=\"796\" alt=\"image\" src=\"https://user-images.githubusercontent.com/357397/223433107-ecbc398a-5fc0-4be1-a4c9-281e78292152.png\">\r\n\n\r\nInstead of GET request, Mey be use POST  requests with both MultipartFormDataItems and ContentProviders can indicate the problem.I will do the test on  x86  device using latest version\uff0cbut it takes some time.Currently I am using this library in the  embed arm linux system\nI think the most reasonable way to determine whether the ssl connection is broken by peer is to use the function SSL_ Peek() and SSL_ get_ Shutdown (), just as catboost used.\r\n\r\nhttps://github.com/catboost/catboost/blob/master/library/cpp/neh/https.cpp\r\n\r\nint PollReadT(const TDuration& timeout) {\r\n\tif (!Connection_) {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\twhile (true) {\r\n\t\tconst int rpoll = Connection_->PollT(CONT_POLL_READ, timeout);\r\n\t\tif (!Ssl_ || rpoll) {\r\n\t\t\treturn rpoll;\r\n\t\t}\r\n\r\n\t\tchar c = 0;\r\n\t\tconst int rpeek = SSL_peek(Ssl_.Get(), &c, sizeof(c));\r\n\t\tif (rpeek < 0) {\r\n\t\t\treturn -1;\r\n\t\t} else if (rpeek > 0) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\tif ((SSL_get_shutdown(Ssl_.Get()) & SSL_RECEIVED_SHUTDOWN) != 0) {\r\n\t\t\t\tShutdown(); // wait until shutdown is finished\r\n\t\t\t\treturn EIO;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nIn addition, I don't think all compilers can guarantee SSL_ Peek() precedes SSL_ get_ Error () is called,in the following statement.\r\n    if (SSL_peek(socket_.ssl, buf, 1) == 0 && SSL_get_error(socket_.ssl, 0) == SSL_ERROR_ZERO_RETURN) \n> In addition, I don't think all compilers can guarantee SSL_ Peek() precedes SSL_ get_ Error () is called,in the following statement.\r\n\r\nYour saying isn't correct. Short-circuiting and evaluation order are required for operators `||` and `&&` in both C and C++ standards.\r\nhttps://stackoverflow.com/questions/628526/is-short-circuiting-logical-operators-mandated-and-evaluation-order\nUse the following unit test code to reproduce the bug\r\n\r\nTEST(KeepAliveTest, SSLClientReconnection) {\r\n  SSLServer svr(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE);\r\n  ASSERT_TRUE(svr.is_valid());\r\n  svr.set_keep_alive_timeout(1);\r\n  std::string content=\"reconnect\";\r\n\r\n  svr.Post(\"/hi\", [](const httplib::Request &, httplib::Response &res) {\r\n    res.set_content(\"Hello World!\", \"text/plain\");\r\n  });\r\n\r\n  auto f = std::async(std::launch::async, [&svr] { svr.listen(HOST, PORT); });\r\n  std::this_thread::sleep_for(std::chrono::milliseconds(200));\r\n\r\n  SSLClient cli(HOST, PORT);\r\n  cli.enable_server_certificate_verification(false);\r\n  cli.set_keep_alive(true);\r\n\r\n  auto result = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n    sink.write(content.c_str(),content.size());\r\n    return true;\r\n\r\n  },\"text/plain\");\r\n  ASSERT_TRUE(result);\r\n  EXPECT_EQ(200, result->status);\r\n\r\n\r\n  std::this_thread::sleep_for(std::chrono::seconds(2));\r\n\r\n  // Recoonect\r\n    result = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n    sink.write(content.c_str(),content.size());\r\n  return true;\r\n  },\"text/plain\");\r\n  ASSERT_TRUE(result);\r\n  EXPECT_EQ(200, result->status);\r\n\r\n    result = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n    sink.write(content.c_str(),content.size());\r\n  return true;\r\n  },\"text/plain\");\r\n  ASSERT_TRUE(result);\r\n  EXPECT_EQ(200, result->status);\r\n\r\n  svr.stop();\r\n  f.wait();\r\n}\nI just tested with your unit test using `Post` method, but I don't see any problem with the latest httplib.h.\r\n\r\n```\r\n~/cpp-httplib/test$ make test && ./test --gtest_filter=\"*SSLClientReconnection*\"\r\nmake: `test' is up to date.\r\nRunning main() from gtest/gtest_main.cc\r\nNote: Google Test filter = *SSLClientReconnection*\r\n[==========] Running 1 test from 1 test suite.\r\n[----------] Global test environment set-up.\r\n[----------] 1 test from KeepAliveTest\r\n[ RUN      ] KeepAliveTest.SSLClientReconnection\r\n[       OK ] KeepAliveTest.SSLClientReconnection (3249 ms)\r\n[----------] 1 test from KeepAliveTest (3249 ms total)\r\n\r\n[----------] Global test environment tear-down\r\n[==========] 1 test from 1 test suite ran. (3249 ms total)\r\n[  PASSED  ] 1 test.\r\n```\nDo you completely replace my unit test code or you just replace the original unit test get method with the post method? You must use the method with a provider to reproduce it\nYes, I took your version of `KeepAliveTest.SSLClientReconnection`, and replaced my original version with yours completely.\nStrangely, I replaced a computer and still can reproduce this bug.In theory, if you use the request function with the provider parameter, write_ Request() returns false, resulting in SSL_ Peek() cannot be executed.\r\n\r\n  if (!write_request(strm, req, close_connection, error)) { return false; }//returned ,when call Post() with provider parameter,write_ Request() returns false\r\n\r\n#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\r\n  if (is_ssl()) {\r\n    char buf[1];\r\n    if (SSL_peek(socket_.ssl, buf, 1) == 0 &&\r\n.............\r\n\r\n\r\nchisheng@chisheng-EQ59:~/code/cpp-httplib/test$ make test && ./test --gtest_filter=\"*SSLClientReconnection*\"\r\nopenssl genrsa 2048 > key.pem\r\nopenssl req -new -batch -config test.conf -key key.pem | openssl x509 -days 3650 -req -signkey key.pem > cert.pem\r\nCertificate request self-signature ok\r\nsubject=C = US, ST = Test State or Province, L = Test Locality, O = Organization Name, OU = Organizational Unit Name, CN = Common Name, emailAddress = test@email.address\r\nopenssl req -x509 -config test.conf -key key.pem -sha256 -days 3650 -nodes -out cert2.pem -extensions SAN\r\nopenssl genrsa 2048 > rootCA.key.pem\r\nopenssl req -x509 -new -batch -config test.rootCA.conf -key rootCA.key.pem -days 1024 > rootCA.cert.pem\r\nopenssl genrsa 2048 > client.key.pem\r\nopenssl req -new -batch -config test.conf -key client.key.pem | openssl x509 -days 370 -req -CA rootCA.cert.pem -CAkey rootCA.key.pem -CAcreateserial > client.cert.pem\r\nCertificate request self-signature ok\r\nsubject=C = US, ST = Test State or Province, L = Test Locality, O = Organization Name, OU = Organizational Unit Name, CN = Common Name, emailAddress = test@email.address\r\nopenssl genrsa -passout pass:test123! 2048 > key_encrypted.pem\r\nopenssl req -new -batch -config test.conf -key key_encrypted.pem | openssl x509 -days 3650 -req -signkey key_encrypted.pem > cert_encrypted.pem\r\nCertificate request self-signature ok\r\nsubject=C = US, ST = Test State or Province, L = Test Locality, O = Organization Name, OU = Organizational Unit Name, CN = Common Name, emailAddress = test@email.address\r\n#c_rehash .\r\nclang++ -o test -I.. -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion -Wshadow  test.cc include_httplib.cc gtest/gtest-all.cc gtest/gtest_main.cc -DCPPHTTPLIB_OPENSSL_SUPPORT -I/usr/local/opt/openssl@1.1/include -L/usr/local/opt/openssl@1.1/lib -lssl -lcrypto -DCPPHTTPLIB_ZLIB_SUPPORT -lz -DCPPHTTPLIB_BROTLI_SUPPORT -I/usr/local/opt/brotli/include -L/usr/local/opt/brotli/lib -lbrotlicommon -lbrotlienc -lbrotlidec -pthread\r\ntest.cc:4181:63: warning: unused parameter 'offset' [-Wunused-parameter]\r\nauto result = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n                                                              ^\r\ntest.cc:4181:78: warning: unused parameter 'length' [-Wunused-parameter]\r\nauto result = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n                                                                             ^\r\ntest.cc:4192:58: warning: unused parameter 'offset' [-Wunused-parameter]\r\nresult = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n                                                         ^\r\ntest.cc:4192:73: warning: unused parameter 'length' [-Wunused-parameter]\r\nresult = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n                                                                        ^\r\ntest.cc:4199:58: warning: unused parameter 'offset' [-Wunused-parameter]\r\nresult = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n                                                         ^\r\ntest.cc:4199:73: warning: unused parameter 'length' [-Wunused-parameter]\r\nresult = cli.Post(\"/hi\",content.size(),[&content](size_t offset, size_t length, DataSink &sink){\r\n                                                                        ^\r\nIn file included from test.cc:4:\r\n./gtest/gtest.h:11427:11: warning: comparison of integers of different signs: 'const unsigned long' and 'const int' [-Wsign-compare]\r\n  if (lhs == rhs) {\r\n      ~~~ ^  ~~~\r\n./gtest/gtest.h:11446:12: note: in instantiation of function template specialization 'testing::internal::CmpHelperEQ<unsigned long, int>' requested here\r\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\r\n           ^\r\ntest.cc:1836:19: note: in instantiation of function template specialization 'testing::internal::EqHelper::Compare<unsigned long, int, nullptr>' requested here\r\n                  EXPECT_EQ(text_value.size(), 1);\r\n                  ^\r\n./gtest/gtest.h:11926:54: note: expanded from macro 'EXPECT_EQ'\r\n  EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)\r\n                                                     ^\r\n7 warnings generated.\r\nRunning main() from gtest/gtest_main.cc\r\nNote: Google Test filter = *SSLClientReconnection*\r\n[==========] Running 1 test from 1 test suite.\r\n[----------] Global test environment set-up.\r\n[----------] 1 test from KeepAliveTest\r\n[ RUN      ] KeepAliveTest.SSLClientReconnection\r\ntest.cc:4196: Failure\r\nValue of: result\r\n  Actual: false\r\nExpected: true\r\n", "created_at": "2023-03-14T02:13:35Z", "version": "0.16"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1132, "instance_id": "yhirose__cpp-httplib-1132", "issue_numbers": ["1041"], "base_commit": "cec6288a99de90ce609c0ae279dc58530a3c14fc", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -2337,6 +2337,17 @@ inline bool wait_until_socket_is_ready(socket_t sock, time_t sec, time_t usec) {\n #endif\n }\n \n+inline bool is_socket_alive(socket_t sock) {\n+  const auto val = detail::select_read(sock, 0, 0);\n+  if (val == 0) {\n+    return true;\n+  } else if (val < 0 && errno == EBADF) {\n+    return false;\n+  }\n+  char buf[1];\n+  return detail::read_socket(sock, &buf[0], sizeof(buf), MSG_PEEK) > 0;\n+}\n+\n class SocketStream : public Stream {\n public:\n   SocketStream(socket_t sock, time_t read_timeout_sec, time_t read_timeout_usec,\n@@ -5723,13 +5734,14 @@ inline bool ClientImpl::send(Request &req, Response &res, Error &error) {\n \n   {\n     std::lock_guard<std::mutex> guard(socket_mutex_);\n+\n     // Set this to false immediately - if it ever gets set to true by the end of\n     // the request, we know another thread instructed us to close the socket.\n     socket_should_be_closed_when_request_is_done_ = false;\n \n     auto is_alive = false;\n     if (socket_.is_open()) {\n-      is_alive = detail::select_write(socket_.sock, 0, 0) > 0;\n+      is_alive = detail::is_socket_alive(socket_.sock);\n       if (!is_alive) {\n         // Attempt to avoid sigpipe by shutting down nongracefully if it seems\n         // like the other side has already closed the connection Also, there\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -3756,6 +3756,36 @@ TEST(KeepAliveTest, ReadTimeout) {\n   ASSERT_FALSE(svr.is_running());\n }\n \n+TEST(KeepAliveTest, Issue1041) {\n+  const auto resourcePath = \"/hi\";\n+\n+  Server svr;\n+  svr.set_keep_alive_timeout(3);\n+\n+  svr.Get(resourcePath, [](const httplib::Request &, httplib::Response &res) {\n+    res.set_content(\"Hello World!\", \"text/plain\");\n+  });\n+\n+  auto a2 = std::async(std::launch::async, [&svr]{ svr.listen(HOST, PORT); });\n+  std::this_thread::sleep_for(std::chrono::milliseconds(200));\n+\n+  Client cli(HOST, PORT);\n+  cli.set_keep_alive(true);\n+\n+  auto result = cli.Get(resourcePath);\n+  ASSERT_TRUE(result);\n+  EXPECT_EQ(200, result->status);\n+\n+  std::this_thread::sleep_for(std::chrono::seconds(5));\n+\n+  result = cli.Get(resourcePath);\n+  ASSERT_TRUE(result);\n+  EXPECT_EQ(200, result->status);\n+\n+  svr.stop();\n+  a2.wait();\n+}\n+\n TEST(ClientProblemDetectionTest, ContentProvider) {\n   Server svr;\n \n", "problem_statement": "Client keep-alive support is broken\nHello,\r\n\r\nI recently added this http library to server HTTP requests within the ccache compiler cache. Because a compilation requires up four HTTP requests I enabled keep-alive support in the Client.\r\n\r\nBut we observed a race condition on Linux:\r\n\r\n1. Connection is opened and a GET request is issued. Turns out to be a cache miss\r\n2. Compilation starts and takes 90s, meanwhile the server closes the connection\r\n3. A PUT is issued on the now closed connection\r\n4. The ccache process receives SIGPIPE.\r\n\r\nSomehow the `is_alive` detection does not work as expected. A rough test case looks like this:\r\n\r\n```c++\r\nTEST(KeepAlive, SimpleInterface_Online) {\r\n\r\n  const auto host = \"127.0.0.1\";\r\n  const auto port = 8080;\r\n  const auto resourcePath = \"/hi\";\r\n\r\n  Server svr;\r\n\r\n  svr.set_keep_alive_timeout(3);\r\n\r\n  svr.Get(resourcePath, [](const httplib::Request &, httplib::Response &res) {\r\n    res.set_content(\"Hello World!\", \"text/plain\");\r\n  });\r\n\r\n  auto a2 = std::async(std::launch::async, [&svr, host, port]{ svr.listen(host, port); });\r\n\r\n  std::this_thread::sleep_for(std::chrono::milliseconds(200));\r\n\r\n  Client cli(host, port);\r\n  cli.set_keep_alive(true);\r\n\r\n  auto result = cli.Get(resourcePath);\r\n  ASSERT_TRUE(result);\r\n  EXPECT_EQ(200, result->status);\r\n\r\n  std::this_thread::sleep_for(std::chrono::seconds(5));\r\n\r\n  result = cli.Get(resourcePath);\r\n  ASSERT_TRUE(result);\r\n  EXPECT_EQ(200, result->status);\r\n\r\n  svr.stop();\r\n  a2.wait();\r\n}\r\n```\r\n\r\nBesides the non-working `is_alive` detection the library should set the `MSG_NOSIGNAL` on Linux and `SO_NOSIGPIPE` on Apple platforms to not badly interfere with the library host process.\r\n\r\nThanks,\r\nGregor\n", "hints_text": "Call stack leading to `SIGPIPE`:\r\n```\r\n#0  0x00007f709fc5b730 in __libc_send (fd=5, buf=0x7f709e7a8aa2, len=9514928, flags=0) at ../sysdeps/unix/sysv/linux/send.c:28\r\n#1  0x000055c1b4b021f2 in httplib::detail::SocketStream::<lambda()>::operator()(void) const (__closure=0x7ffd17839a90) at ../src/third_party/httplib.cpp:2595\r\n#2  0x000055c1b4b157b6 in httplib::detail::handle_EINTR<httplib::detail::SocketStream::write(char const*, size_t)::<lambda()> >(httplib::detail::SocketStream::<lambda()>) (fn=...)\r\n    at ../src/third_party/httplib.cpp:380\r\n#3  0x000055c1b4b0225d in httplib::detail::SocketStream::write (this=0x7ffd1783a2f0, \r\n    ptr=0x7f709e7a8aa2 \"\\302R&\\205]\\253\\224\\354\\373R\\331\\227\\220q8\\317!{*\\352\\224\\031\\204\\231(\\203\\020\\021\\364p\\342\\325\\254!\\250;\\377\\205\\225\\263\\225~a\\001\\355\\372.\\354:\\335\\273\\341;Pk\\364\\265\\366\\300\\327\\n\\003*j?k\\351\\274-]\\307sr\\347\\262\\342\\022\\356H%\\\\B\\251A:\\002\\323\\235+\\246\\270\\a\\361\\265\\250\\aqL1\\257\\342\\212\\351\\347\\325\\204\\311$\\337\\017\\273J\\272\\266Mw\\335bi\\345\\375G-(\\221\\277\\247\\333\\355v\\223\\375w\\212\\255\\032j?b\\210\\351\\372\\231Xs}\\235z\", size=9514928) at ../src/third_party/httplib.cpp:2594\r\n#4  0x000055c1b4afe56e in httplib::detail::write_data (strm=..., d=0x7f709e761010 \"cCrS\\001\\001\\001\", l=9808450) at ../src/third_party/httplib.cpp:1502\r\n#5  0x000055c1b4b0bbee in httplib::ClientImpl::write_request (this=0x55c1b500c390, strm=..., req=..., close_connection=false, error=@0x7ffd1783a5c4: httplib::Error::Success)\r\n    at ../src/third_party/httplib.cpp:4140\r\n#6  0x000055c1b4b0c4bf in httplib::ClientImpl::process_request (this=0x55c1b500c390, strm=..., req=..., res=..., close_connection=false, error=@0x7ffd1783a5c4: httplib::Error::Success)\r\n    at ../src/third_party/httplib.cpp:4262\r\n#7  0x000055c1b4b0aa3b in httplib::ClientImpl::handle_request (this=0x55c1b500c390, strm=..., req=..., res=..., close_connection=false, error=@0x7ffd1783a5c4: httplib::Error::Success)\r\n    at ../src/third_party/httplib.cpp:3912\r\n#8  0x000055c1b4b0a003 in httplib::ClientImpl::<lambda(httplib::Stream&)>::operator()(httplib::Stream &) const (__closure=0x55c1b5016d60, strm=...) at ../src/third_party/httplib.cpp:3854\r\n#9  0x000055c1b4b1a134 in std::_Function_handler<bool(httplib::Stream&), httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::<lambda(httplib::Stream&)> >::_M_invoke(const std::_Any_data &, httplib::Stream &) (__functor=..., __args#0=...) at /usr/include/c++/9/bits/std_function.h:285\r\n#10 0x000055c1b4b26319 in std::function<bool (httplib::Stream&)>::operator()(httplib::Stream&) const (this=0x7ffd1783a370, __args#0=...) at /usr/include/c++/9/bits/std_function.h:688\r\n#11 0x000055c1b4afc557 in httplib::detail::process_client_socket(int, long, long, long, long, std::function<bool (httplib::Stream&)>) (sock=5, read_timeout_sec=20, read_timeout_usec=0, write_timeout_sec=20, \r\n    write_timeout_usec=0, callback=...) at ../src/third_party/httplib.cpp:596\r\n#12 0x000055c1b4b0cab7 in httplib::ClientImpl::process_socket(httplib::ClientImpl::Socket const&, std::function<bool (httplib::Stream&)>) (this=0x55c1b500c390, socket=..., callback=...)\r\n    at ../src/third_party/httplib.cpp:4344\r\n#13 0x000055c1b4b0a3d4 in httplib::ClientImpl::send (this=0x55c1b500c390, req=..., res=..., error=@0x7ffd1783a5c4: httplib::Error::Success) at ../src/third_party/httplib.cpp:3853\r\n#14 0x000055c1b4b0bec7 in httplib::ClientImpl::send_with_content_provider(httplib::Request&, char const*, unsigned long, std::function<bool (unsigned long, unsigned long, httplib::DataSink&)>, std::function<bool (unsigned long, httplib::DataSink&)>, char const*, httplib::Error&) (this=0x55c1b500c390, req=..., body=0x7f709f0bc010 \"cCrS\\001\\001\\001\", content_length=9808450, content_provider=..., \r\n    content_provider_without_length=..., content_type=0x55c1b4bcb604 \"application/octet-stream\", error=@0x7ffd1783a5c4: httplib::Error::Success) at ../src/third_party/httplib.cpp:4228\r\n#15 0x000055c1b4b0c0d6 in httplib::ClientImpl::send_with_content_provider(char const*, char const*, std::multimap<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, httplib::detail::ci, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > const&, char const*, unsigned long, std::function<bool (unsigned long, unsigned long, httplib::DataSink&)>, std::function<bool (unsigned long, httplib::DataSink&)>, char const*) (this=0x55c1b500c390, method=0x55c1b4bce36d \"PUT\", path=0x55c1b50e0820 \"/cache/135di89r02vv5fgopbtsopfjllo01b8lg\", Python Exception <class 'AttributeError'> 'NoneType' object has no attribute 'pointer': \r\nheaders=std::multimap with 0 elements, \r\n    body=0x7f709f0bc010 \"cCrS\\001\\001\\001\", content_length=9808450, content_provider=..., content_provider_without_length=..., content_type=0x55c1b4bcb604 \"application/octet-stream\")\r\n    at ../src/third_party/httplib.cpp:4247\r\n#16 0x000055c1b4b0f7d1 in httplib::ClientImpl::Put (this=0x55c1b500c390, path=0x55c1b50e0820 \"/cache/135di89r02vv5fgopbtsopfjllo01b8lg\", Python Exception <class 'AttributeError'> 'NoneType' object has no attribute 'pointer': \r\nheaders=std::multimap with 0 elements, \r\n    body=0x7f709f0bc010 \"cCrS\\001\\001\\001\", content_length=9808450, content_type=0x55c1b4bcb604 \"application/octet-stream\") at ../src/third_party/httplib.cpp:4604\r\n#17 0x000055c1b4b0f6d2 in httplib::ClientImpl::Put (this=0x55c1b500c390, path=0x55c1b50e0820 \"/cache/135di89r02vv5fgopbtsopfjllo01b8lg\", body=0x7f709f0bc010 \"cCrS\\001\\001\\001\", content_length=9808450, \r\n    content_type=0x55c1b4bcb604 \"application/octet-stream\") at ../src/third_party/httplib.cpp:4597\r\n#18 0x000055c1b4b134d4 in httplib::Client::Put (this=0x55c1b50106c8, path=0x55c1b50e0820 \"/cache/135di89r02vv5fgopbtsopfjllo01b8lg\", body=0x7f709f0bc010 \"cCrS\\001\\001\\001\", content_length=9808450, \r\n    content_type=0x55c1b4bcb604 \"application/octet-stream\") at ../src/third_party/httplib.cpp:5804\r\n```\n@gjasny, for clarification, does `MSG_NOSIGNAL` fix the problem on Linux on your machine?\nAny response please?\nHello,\r\n\r\nI'm going to test ccache 4.4.1 which ignores the signal: https://github.com/ccache/ccache/commit/b2a88e7b885cd43882b525fdaf2b57dd931a0427\r\n\r\nThe test should be done tomorrow.\r\n\r\nThanks for your patience,\r\nGregor\nEven with ignoring SIGPIPE it's still broken: https://github.com/ccache/ccache/pull/934\n@gjasny, thanks for the additional comment.\nI'm having an issue where Post() returns an httplib::Result with a \"Read\" error code when using keep alive.  It happens when doing a request with a long delay before it.  My guess is that the server is terminating the connection and the HTTP lib is not picking up on it.  Not sure if it's the same issue as here.\n@lightray22, I am not sure whether it's the same as @gjasny reported. Could you try to make the smallest possible code to reproduce it? It will tell the truth. Thanks!\nI think it is likely the same problem.  I wrote a minimal program that produces a backtrace with valgrind.  Ends with a SIGPIPE.\r\n\r\n```\r\n#include \"httplib.h\"\r\n#include <iostream>\r\n#include <thread>\r\n#include <chrono>\r\n\r\nhttplib::Client httpClient(\"http://localhost\");\r\n\r\nvoid doRequest()\r\n{\r\n    httplib::Params urlParams {{\"app\",\"server\"},{\"action\",\"getconfig\"}};\r\n\r\n    std::string url(\"/Andromeda2/api/index.php?\" +\r\n        httplib::detail::params_to_query_str(urlParams));\r\n\r\n    httplib::MultipartFormDataItems postParams;\r\n\r\n    std::cout << \"doing request...\" << std::endl;\r\n\r\n    httplib::Result response(httpClient.Post(url.c_str(), postParams));\r\n\r\n    std::cout << \"request done!\" << std::endl;\r\n\r\n    if (!response) \r\n    { \r\n        std::cout << \"failed\"; std::cout << \": \" << response.error() << std::endl;\r\n    }\r\n    else\r\n    {\r\n        std::cout << \"success\"; std::cout << \": \" << response->status << \" \" << response->body << std::endl;\r\n\r\n        httplib::Headers::iterator it = response->headers.begin();\r\n        for (; it != response->headers.end(); it++)\r\n        {\r\n            std::cout << \"\\t\" << it->first << \" \" << it->second << std::endl;\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    httpClient.set_keep_alive(true);\r\n\r\n    for (int wait : {1, 5, 90, 120, 150})\r\n    {\r\n        std::cout << \"waiting \" << wait << \" seconds...\" << std::endl;\r\n\r\n        std::this_thread::sleep_for(std::chrono::seconds(wait));\r\n\r\n        doRequest();\r\n    }\r\n\r\n    std::cout << \"return\" << std::endl; return 1;\r\n}\r\n```\r\n\r\nCompile and run...  `g++ test.cpp -g -o test && valgrind -v ./test`\r\n\r\nProgram output...\r\n\r\n```\r\nwaiting 1 seconds...\r\ndoing request...\r\nrequest done!\r\nsuccess: 200 {\"ok\":true,\"code\":200,\"appdata\":{\"api\":2,\"apps\":{\"server\":\"2.0\",\"accounts\":\"2.0\",\"files\":\"2.0\",\"test\":\"2.0\"},\"features\":{\"enabled\":true,\"read_only\":\"off\"}}}\r\n        Cache-Control no-cache\r\n        Connection keep-alive\r\n        Content-Type application/json\r\n        Date Fri, 15 Oct 2021 19:34:36 GMT\r\n        Server nginx/1.20.1\r\n        Transfer-Encoding chunked\r\nwaiting 5 seconds...\r\ndoing request...\r\nrequest done!\r\nsuccess: 200 {\"ok\":true,\"code\":200,\"appdata\":{\"api\":2,\"apps\":{\"server\":\"2.0\",\"accounts\":\"2.0\",\"files\":\"2.0\",\"test\":\"2.0\"},\"features\":{\"enabled\":true,\"read_only\":\"off\"}}}\r\n        Cache-Control no-cache\r\n        Connection keep-alive\r\n        Content-Type application/json\r\n        Date Fri, 15 Oct 2021 19:34:41 GMT\r\n        Server nginx/1.20.1\r\n        Transfer-Encoding chunked\r\nwaiting 90 seconds...\r\ndoing request...\r\n==179226==\r\n==179226== Process terminating with default action of signal 13 (SIGPIPE)\r\n==179226==    at 0x4BAF3E0: send (send.c:28)\r\n==179226==    by 0x11BDD7: httplib::detail::SocketStream::write(char const*, unsigned long)::{lambda()#1}::operator()() const (httplib.h:4399)\r\n==179226==    by 0x12A714: long httplib::detail::handle_EINTR<httplib::detail::SocketStream::write(char const*, unsigned long)::{lambda()#1}>(httplib::detail::SocketStream::write(char const*, unsigned long)::{lambda()#1}) (httplib.h:2185)\r\n==179226==    by 0x11BE42: httplib::detail::SocketStream::write(char const*, unsigned long) (httplib.h:4398)\r\n==179226==    by 0x1187ED: httplib::detail::write_data(httplib::Stream&, char const*, unsigned long) (httplib.h:3306)\r\n==179226==    by 0x124465: httplib::ClientImpl::write_request(httplib::Stream&, httplib::Request&, bool, httplib::Error&) (httplib.h:5944)\r\n==179226==    by 0x124D3C: httplib::ClientImpl::process_request(httplib::Stream&, httplib::Request&, httplib::Response&, bool, httplib::Error&) (httplib.h:6066)\r\n==179226==    by 0x1232B4: httplib::ClientImpl::handle_request(httplib::Stream&, httplib::Request&, httplib::Response&, bool, httplib::Error&) (httplib.h:5716)\r\n==179226==    by 0x1222CA: httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::{lambda(httplib::Stream&)#1}::operator()(httplib::Stream&) const (httplib.h:5658)\r\n==179226==    by 0x1481BE: bool std::__invoke_impl<bool, httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::{lambda(httplib::Stream&)#1}&, httplib::Stream&>(std::__invoke_other, httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::{lambda(httplib::Stream&)#1}&, httplib::Stream&) (invoke.h:60)\r\n==179226==    by 0x140A9E: std::enable_if<std::__and_<std::__not_<std::is_void<bool> >, std::is_convertible<std::__invoke_result<httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::{lambda(httplib::Stream&)#1}&, httplib::Stream&>::type, std::is_void> >::value, std::is_void>::type std::__invoke_r<bool, httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::{lambda(httplib::Stream&)#1}&, httplib::Stream&>(std::__invoke_result&&, (httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::{lambda(httplib::Stream&)#1}&)...) (invoke.h:141)\r\n==179226==    by 0x13737A: std::_Function_handler<bool (httplib::Stream&), httplib::ClientImpl::send(httplib::Request&, httplib::Response&, httplib::Error&)::{lambda(httplib::Stream&)#1}>::_M_invoke(std::_Any_data const&, httplib::Stream&) (std_function.h:291)\r\n--179226-- Discarding syms at 0x51d8560-0x51df08c in /usr/lib/x86_64-linux-gnu/libnss_files-2.33.so (have_dinfo 1)\r\n==179226==\r\n==179226== HEAP SUMMARY:\r\n==179226==     in use at exit: 10,149 bytes in 40 blocks\r\n==179226==   total heap usage: 3,328 allocs, 3,288 frees, 144,349 bytes allocated\r\n==179226==\r\n==179226== Searching for pointers to 40 not-freed blocks\r\n==179226== Checked 141,888 bytes\r\n==179226==\r\n==179226== LEAK SUMMARY:\r\n==179226==    definitely lost: 0 bytes in 0 blocks\r\n==179226==    indirectly lost: 0 bytes in 0 blocks\r\n==179226==      possibly lost: 0 bytes in 0 blocks\r\n==179226==    still reachable: 10,149 bytes in 40 blocks\r\n==179226==         suppressed: 0 bytes in 0 blocks\r\n==179226== Rerun with --leak-check=full to see details of leaked memory\r\n==179226==\r\n==179226== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n```\r\n\r\nI'm guessing that the server terminated the connection and httplib does not handle it.\n@lightray22, thanks for the detailed information! I now got two evidences. I am too busy to work on it though, hope I'll get back to this problem sometime this year.\nAlso my compiler is `g++ (Ubuntu 10.3.0-1ubuntu1) 10.3.0`\nHello @yhirose\r\nI tried what you suggested here:\r\n> @gjasny, for clarification, does `MSG_NOSIGNAL` fix the problem on Linux on your machine?\r\n\r\nand I can confirm it really works for another issue I described in #1121 after you had fixed the original one.\r\nI did it as simple as that:\r\n```cpp\r\n#ifndef CPPHTTPLIB_RECV_FLAGS\r\n#define CPPHTTPLIB_RECV_FLAGS MSG_NOSIGNAL\r\n#endif\r\n\r\n#ifndef CPPHTTPLIB_SEND_FLAGS\r\n#define CPPHTTPLIB_SEND_FLAGS MSG_NOSIGNAL\r\n#endif\r\n```\r\n\r\nand hope it's the correct way.\r\nThanks again!\r\n\n@lightray22, could you take a look at the @tsilia's comment above. At least, the SIGPIPE issue can be handled accordingly.\nBased on @gjasny 's [comment](https://github.com/yhirose/cpp-httplib/issues/1041#issuecomment-919051105) it seems that might fix the crashing issue but the keep-alive still won't work correctly.\n@gjasny, I finally started investigating this problem. As you mentioned, `is_alive` doesn't say `false` after the server closes the socket due to expiration of keep-alive timeout. Here is the line that causes the problem.\r\n\r\nhttps://github.com/yhirose/cpp-httplib/blob/9639578c2a05ae8b93f589ef2cf4ba42e222af90/httplib.h#L5728\r\nhttps://github.com/yhirose/cpp-httplib/blob/9639578c2a05ae8b93f589ef2cf4ba42e222af90/httplib.h#L2282\r\n\r\nI thought `select` system call with timeout second 0 will tell us whether the socket is still alive or closed. But apparently it doesn't... According to my research, there is basically no way to detect a TCP socket closed unless `read/recv` is used... The following stackoverflow post is one of them explaining this fact.\r\nhttps://stackoverflow.com/questions/6404008/how-to-detect-a-tcp-socket-disconnection-with-c-berkeley-socket\r\n\r\nPlease let me know if you know a cross-platform way to detect a socket closed on the other side. I'll also do more research on it. Thanks for your help!\n@yhirose \r\n> I thought `select` system call with timeout second 0 will tell us whether the socket is still alive or closed. But apparently it doesn't...\r\n\r\nThis is probably because you only use write FDs in the mentioned `select` call. I read somewhere that if remote party closes the connection gracefully (i.e. using `close`/`closesocket`) then `select` with a *read FD* on your end will indicate an available read operation, and if a subsequent call to `read` (or `recv`) returns `0` it means the connection has been closed.\r\n\r\nMaybe you should consider trying this approach.\n@tsilia, thanks for the comment. But unless the client send (`write`) a HTTP request, there won't be any data to read. So I don't think this won't work. Am I missing something to understand your idea fully?\nYes, I know the server woulnd't write to the socket on its end until we asked it to.\r\nThe idea is that socket is made readable by the client network stack, not by the server's writing to it (it should work for stream sockets, but not for datagram ones, as 0-sized datagrams are allowed). And you can't *actually* read anything from the socket in this particular case, you can only *attempt* to read and the `::read` (or `::recv`) function will return 0 which indicates that socket has  been closed by the remote party.\nOk, this is kinda quick and dirty, but it actually works (I borrowed the socket-related code from you and someone else). You can try it yourself:\r\n```cpp\r\nvoid ClientThreadFunc(bool& bStop)\r\n{\r\n\tstruct addrinfo hints, *res;\r\n\tint sockfd;\r\n\r\n\tmemset(&hints, 0, sizeof hints);\r\n\thints.ai_family = AF_UNSPEC;\r\n\thints.ai_socktype = SOCK_STREAM;\r\n\r\n\tgetaddrinfo(ServerAddress.c_str(), std::to_string(ServerPort).c_str(), &hints, &res);\r\n\tsockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\r\n\tconnect(sockfd, res->ai_addr, res->ai_addrlen);\r\n\r\n\twhile (!bStop)\r\n\t{\r\n\t\tfd_set fdsr;\r\n\t\tFD_ZERO(&fdsr);\r\n\t\tFD_SET(sockfd, &fdsr);\r\n\r\n\t\tfd_set fdsw;\r\n\t\tFD_ZERO(&fdsw);\r\n\t\tFD_SET(sockfd, &fdsw);\r\n\r\n\t\ttimeval tv;\r\n\t\ttv.tv_sec = static_cast<long>(0);\r\n\t\ttv.tv_usec = static_cast<decltype(tv.tv_usec)>(0);\r\n\r\n\t\tauto sel = select(static_cast<int>(sockfd + 1), &fdsr, nullptr, nullptr, &tv);\r\n\t\tif (sel == 1)\r\n\t\t{\r\n\t\t\tif (FD_ISSET(sockfd, &fdsr))\r\n\t\t\t{\r\n\t\t\t\tchar buf[1]{};\r\n\t\t\t\tif (read(sockfd, &buf[0], sizeof(buf)) == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tstd::cout << \"Remote peer disconnected!\" << std::endl;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tstd::this_thread::sleep_for(1ms);\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tbool bStop = false;\r\n\tstd::thread t(&ClientThreadFunc, std::ref(bStop));\r\n\r\n\tstd::cout << \"Press enter key to stop client...\" << std::endl;\r\n\tstd::cin.get();\r\n\tstd::cerr << \"* Stopping client...\" << std::endl;\r\n\tbStop = true;\r\n\tif (t.joinable())\r\n\t\tt.join();\r\n\r\n\tstd::cerr << \"* Client stopped. Exiting...\" << std::endl;\r\n\treturn 0;\r\n}\r\n```\r\nThis code doesn't even need to write to socket anything, you can connect to a cpphttplib-powered server which has keep alive turned on and timeout set to, say, 5 seconds, and wait for the server to close socket. Once the server does so, the client will output 'Remote peer disconnected!'.\r\n\r\nSorry if my comment was misleading or confusing. I probably should have mentioned that it's actually the TCP protocol that allows this possible, because when a peer closes the connection gracefully, there's some stuff going on between the peers at the TCP level.\r\n\r\nDetecting a lost connection (e.g., hung) is completely different story though. You will probably have to use TCP keep alive feature which can be turned on using SO_KEEPALIVE at SOL_SOCKET level.\n@yhirose \r\nSorry, I must say that I screwed up the code, but the idea is working anyway, just not in the old snippet above ^\r\n\r\nI've fixed the previous post.", "created_at": "2021-12-14T19:32:29Z", "version": "0.9"}
{"repo": "yhirose/cpp-httplib", "pull_number": 2167, "instance_id": "yhirose__cpp-httplib-2167", "issue_numbers": ["1601"], "base_commit": "e6ff3d7ac28cb7c1659a8ae3148ea745ccd170c5", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -278,6 +278,14 @@ using socket_t = int;\n #include <unordered_set>\n #include <utility>\n \n+#if defined(__APPLE__)\n+#include <TargetConditionals.h>\n+#if TARGET_OS_OSX || TARGET_OS_IPHONE\n+#include <CFNetwork/CFHost.h>\n+#include <CoreFoundation/CoreFoundation.h>\n+#endif\n+#endif\n+\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n #ifdef _WIN32\n #include <wincrypt.h>\n@@ -292,13 +300,16 @@ using socket_t = int;\n #ifdef _MSC_VER\n #pragma comment(lib, \"crypt32.lib\")\n #endif\n-#elif defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN) && defined(__APPLE__)\n+#endif // _WIN32\n+\n+#if defined(__APPLE__)\n+#if defined(CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN)\n #include <TargetConditionals.h>\n #if TARGET_OS_OSX\n-#include <CoreFoundation/CoreFoundation.h>\n #include <Security/Security.h>\n #endif // TARGET_OS_OSX\n-#endif // _WIN32\n+#endif // CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN\n+#endif // ___APPLE__\n \n #include <openssl/err.h>\n #include <openssl/evp.h>\n@@ -321,7 +332,7 @@ using socket_t = int;\n #error Sorry, OpenSSL versions prior to 3.0.0 are not supported\n #endif\n \n-#endif\n+#endif // CPPHTTPLIB_OPENSSL_SUPPORT\n \n #ifdef CPPHTTPLIB_ZLIB_SUPPORT\n #include <zlib.h>\n@@ -3369,11 +3380,323 @@ unescape_abstract_namespace_unix_domain(const std::string &s) {\n   return s;\n }\n \n+inline int getaddrinfo_with_timeout(const char *node, const char *service,\n+                                    const struct addrinfo *hints,\n+                                    struct addrinfo **res, time_t timeout_sec) {\n+  if (timeout_sec <= 0) {\n+    // No timeout specified, use standard getaddrinfo\n+    return getaddrinfo(node, service, hints, res);\n+  }\n+\n+#ifdef _WIN32\n+  // Windows-specific implementation using GetAddrInfoEx with overlapped I/O\n+  OVERLAPPED overlapped = {0};\n+  HANDLE event = CreateEventW(nullptr, TRUE, FALSE, nullptr);\n+  if (!event) { return EAI_FAIL; }\n+\n+  overlapped.hEvent = event;\n+\n+  PADDRINFOEXW result_addrinfo = nullptr;\n+  HANDLE cancel_handle = nullptr;\n+\n+  ADDRINFOEXW hints_ex = {0};\n+  if (hints) {\n+    hints_ex.ai_flags = hints->ai_flags;\n+    hints_ex.ai_family = hints->ai_family;\n+    hints_ex.ai_socktype = hints->ai_socktype;\n+    hints_ex.ai_protocol = hints->ai_protocol;\n+  }\n+\n+  auto wnode = u8string_to_wstring(node);\n+  auto wservice = u8string_to_wstring(service);\n+\n+  auto ret = ::GetAddrInfoExW(wnode.data(), wservice.data(), NS_DNS, nullptr,\n+                              hints ? &hints_ex : nullptr, &result_addrinfo,\n+                              nullptr, &overlapped, nullptr, &cancel_handle);\n+\n+  if (ret == WSA_IO_PENDING) {\n+    auto wait_result =\n+        ::WaitForSingleObject(event, static_cast<DWORD>(timeout_sec * 1000));\n+    if (wait_result == WAIT_TIMEOUT) {\n+      if (cancel_handle) { ::GetAddrInfoExCancel(&cancel_handle); }\n+      ::CloseHandle(event);\n+      return EAI_AGAIN;\n+    }\n+\n+    DWORD bytes_returned;\n+    if (!::GetOverlappedResult((HANDLE)INVALID_SOCKET, &overlapped,\n+                               &bytes_returned, FALSE)) {\n+      ::CloseHandle(event);\n+      return ::WSAGetLastError();\n+    }\n+  }\n+\n+  ::CloseHandle(event);\n+\n+  if (ret == NO_ERROR || ret == WSA_IO_PENDING) {\n+    *res = reinterpret_cast<struct addrinfo *>(result_addrinfo);\n+    return 0;\n+  }\n+\n+  return ret;\n+#elif defined(__APPLE__)\n+  // macOS implementation using CFHost API for asynchronous DNS resolution\n+  CFStringRef hostname_ref = CFStringCreateWithCString(\n+      kCFAllocatorDefault, node, kCFStringEncodingUTF8);\n+  if (!hostname_ref) { return EAI_MEMORY; }\n+\n+  CFHostRef host_ref = CFHostCreateWithName(kCFAllocatorDefault, hostname_ref);\n+  CFRelease(hostname_ref);\n+  if (!host_ref) { return EAI_MEMORY; }\n+\n+  // Set up context for callback\n+  struct CFHostContext {\n+    bool completed = false;\n+    bool success = false;\n+    CFArrayRef addresses = nullptr;\n+    std::mutex mutex;\n+    std::condition_variable cv;\n+  } context;\n+\n+  CFHostClientContext client_context;\n+  memset(&client_context, 0, sizeof(client_context));\n+  client_context.info = &context;\n+\n+  // Set callback\n+  auto callback = [](CFHostRef theHost, CFHostInfoType /*typeInfo*/,\n+                     const CFStreamError *error, void *info) {\n+    auto ctx = static_cast<CFHostContext *>(info);\n+    std::lock_guard<std::mutex> lock(ctx->mutex);\n+\n+    if (error && error->error != 0) {\n+      ctx->success = false;\n+    } else {\n+      Boolean hasBeenResolved;\n+      ctx->addresses = CFHostGetAddressing(theHost, &hasBeenResolved);\n+      if (ctx->addresses && hasBeenResolved) {\n+        CFRetain(ctx->addresses);\n+        ctx->success = true;\n+      } else {\n+        ctx->success = false;\n+      }\n+    }\n+    ctx->completed = true;\n+    ctx->cv.notify_one();\n+  };\n+\n+  if (!CFHostSetClient(host_ref, callback, &client_context)) {\n+    CFRelease(host_ref);\n+    return EAI_SYSTEM;\n+  }\n+\n+  // Schedule on run loop\n+  CFRunLoopRef run_loop = CFRunLoopGetCurrent();\n+  CFHostScheduleWithRunLoop(host_ref, run_loop, kCFRunLoopDefaultMode);\n+\n+  // Start resolution\n+  CFStreamError stream_error;\n+  if (!CFHostStartInfoResolution(host_ref, kCFHostAddresses, &stream_error)) {\n+    CFHostUnscheduleFromRunLoop(host_ref, run_loop, kCFRunLoopDefaultMode);\n+    CFRelease(host_ref);\n+    return EAI_FAIL;\n+  }\n+\n+  // Wait for completion with timeout\n+  auto timeout_time =\n+      std::chrono::steady_clock::now() + std::chrono::seconds(timeout_sec);\n+  bool timed_out = false;\n+\n+  {\n+    std::unique_lock<std::mutex> lock(context.mutex);\n+\n+    while (!context.completed) {\n+      auto now = std::chrono::steady_clock::now();\n+      if (now >= timeout_time) {\n+        timed_out = true;\n+        break;\n+      }\n+\n+      // Run the runloop for a short time\n+      lock.unlock();\n+      CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.1, true);\n+      lock.lock();\n+    }\n+  }\n+\n+  // Clean up\n+  CFHostUnscheduleFromRunLoop(host_ref, run_loop, kCFRunLoopDefaultMode);\n+  CFHostSetClient(host_ref, nullptr, nullptr);\n+\n+  if (timed_out || !context.completed) {\n+    CFHostCancelInfoResolution(host_ref, kCFHostAddresses);\n+    CFRelease(host_ref);\n+    return EAI_AGAIN;\n+  }\n+\n+  if (!context.success || !context.addresses) {\n+    CFRelease(host_ref);\n+    return EAI_NODATA;\n+  }\n+\n+  // Convert CFArray to addrinfo\n+  CFIndex count = CFArrayGetCount(context.addresses);\n+  if (count == 0) {\n+    CFRelease(context.addresses);\n+    CFRelease(host_ref);\n+    return EAI_NODATA;\n+  }\n+\n+  struct addrinfo *result_addrinfo = nullptr;\n+  struct addrinfo **current = &result_addrinfo;\n+\n+  for (CFIndex i = 0; i < count; i++) {\n+    CFDataRef addr_data =\n+        static_cast<CFDataRef>(CFArrayGetValueAtIndex(context.addresses, i));\n+    if (!addr_data) continue;\n+\n+    const struct sockaddr *sockaddr_ptr =\n+        reinterpret_cast<const struct sockaddr *>(CFDataGetBytePtr(addr_data));\n+    socklen_t sockaddr_len = static_cast<socklen_t>(CFDataGetLength(addr_data));\n+\n+    // Allocate addrinfo structure\n+    *current = static_cast<struct addrinfo *>(malloc(sizeof(struct addrinfo)));\n+    if (!*current) {\n+      freeaddrinfo(result_addrinfo);\n+      CFRelease(context.addresses);\n+      CFRelease(host_ref);\n+      return EAI_MEMORY;\n+    }\n+\n+    memset(*current, 0, sizeof(struct addrinfo));\n+\n+    // Set up addrinfo fields\n+    (*current)->ai_family = sockaddr_ptr->sa_family;\n+    (*current)->ai_socktype = hints ? hints->ai_socktype : SOCK_STREAM;\n+    (*current)->ai_protocol = hints ? hints->ai_protocol : IPPROTO_TCP;\n+    (*current)->ai_addrlen = sockaddr_len;\n+\n+    // Copy sockaddr\n+    (*current)->ai_addr = static_cast<struct sockaddr *>(malloc(sockaddr_len));\n+    if (!(*current)->ai_addr) {\n+      freeaddrinfo(result_addrinfo);\n+      CFRelease(context.addresses);\n+      CFRelease(host_ref);\n+      return EAI_MEMORY;\n+    }\n+    memcpy((*current)->ai_addr, sockaddr_ptr, sockaddr_len);\n+\n+    // Set port if service is specified\n+    if (service && strlen(service) > 0) {\n+      int port = atoi(service);\n+      if (port > 0) {\n+        if (sockaddr_ptr->sa_family == AF_INET) {\n+          reinterpret_cast<struct sockaddr_in *>((*current)->ai_addr)\n+              ->sin_port = htons(static_cast<uint16_t>(port));\n+        } else if (sockaddr_ptr->sa_family == AF_INET6) {\n+          reinterpret_cast<struct sockaddr_in6 *>((*current)->ai_addr)\n+              ->sin6_port = htons(static_cast<uint16_t>(port));\n+        }\n+      }\n+    }\n+\n+    current = &((*current)->ai_next);\n+  }\n+\n+  CFRelease(context.addresses);\n+  CFRelease(host_ref);\n+\n+  *res = result_addrinfo;\n+  return 0;\n+#elif defined(_GNU_SOURCE) && defined(__GLIBC__) &&                            \\\n+    (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2))\n+  // Linux implementation using getaddrinfo_a for asynchronous DNS resolution\n+  struct gaicb request;\n+  struct gaicb *requests[1] = {&request};\n+  struct sigevent sevp;\n+  struct timespec timeout;\n+\n+  // Initialize the request structure\n+  memset(&request, 0, sizeof(request));\n+  request.ar_name = node;\n+  request.ar_service = service;\n+  request.ar_request = hints;\n+\n+  // Set up timeout\n+  timeout.tv_sec = timeout_sec;\n+  timeout.tv_nsec = 0;\n+\n+  // Initialize sigevent structure (not used, but required)\n+  memset(&sevp, 0, sizeof(sevp));\n+  sevp.sigev_notify = SIGEV_NONE;\n+\n+  // Start asynchronous resolution\n+  int start_result = getaddrinfo_a(GAI_NOWAIT, requests, 1, &sevp);\n+  if (start_result != 0) { return start_result; }\n+\n+  // Wait for completion with timeout\n+  int wait_result =\n+      gai_suspend((const struct gaicb *const *)requests, 1, &timeout);\n+\n+  if (wait_result == 0) {\n+    // Completed successfully, get the result\n+    int gai_result = gai_error(&request);\n+    if (gai_result == 0) {\n+      *res = request.ar_result;\n+      return 0;\n+    } else {\n+      // Clean up on error\n+      if (request.ar_result) { freeaddrinfo(request.ar_result); }\n+      return gai_result;\n+    }\n+  } else if (wait_result == EAI_AGAIN) {\n+    // Timeout occurred, cancel the request\n+    gai_cancel(&request);\n+    return EAI_AGAIN;\n+  } else {\n+    // Other error occurred\n+    gai_cancel(&request);\n+    return wait_result;\n+  }\n+#else\n+  // Fallback implementation using thread-based timeout for other Unix systems\n+  std::mutex result_mutex;\n+  std::condition_variable result_cv;\n+  auto completed = false;\n+  auto result = EAI_SYSTEM;\n+  struct addrinfo *result_addrinfo = nullptr;\n+\n+  std::thread resolve_thread([&]() {\n+    auto thread_result = getaddrinfo(node, service, hints, &result_addrinfo);\n+\n+    std::lock_guard<std::mutex> lock(result_mutex);\n+    result = thread_result;\n+    completed = true;\n+    result_cv.notify_one();\n+  });\n+\n+  // Wait for completion or timeout\n+  std::unique_lock<std::mutex> lock(result_mutex);\n+  auto finished = result_cv.wait_for(lock, std::chrono::seconds(timeout_sec),\n+                                     [&] { return completed; });\n+\n+  if (finished) {\n+    // Operation completed within timeout\n+    resolve_thread.join();\n+    *res = result_addrinfo;\n+    return result;\n+  } else {\n+    // Timeout occurred\n+    resolve_thread.detach(); // Let the thread finish in background\n+    return EAI_AGAIN;        // Return timeout error\n+  }\n+#endif\n+}\n+\n template <typename BindOrConnect>\n socket_t create_socket(const std::string &host, const std::string &ip, int port,\n                        int address_family, int socket_flags, bool tcp_nodelay,\n                        bool ipv6_v6only, SocketOptions socket_options,\n-                       BindOrConnect bind_or_connect) {\n+                       BindOrConnect bind_or_connect, time_t timeout_sec = 0) {\n   // Get address info\n   const char *node = nullptr;\n   struct addrinfo hints;\n@@ -3443,7 +3766,8 @@ socket_t create_socket(const std::string &host, const std::string &ip, int port,\n \n   auto service = std::to_string(port);\n \n-  if (getaddrinfo(node, service.c_str(), &hints, &result)) {\n+  if (getaddrinfo_with_timeout(node, service.c_str(), &hints, &result,\n+                               timeout_sec)) {\n #if defined __linux__ && !defined __ANDROID__\n     res_init();\n #endif\n@@ -3541,7 +3865,9 @@ inline bool bind_ip_address(socket_t sock, const std::string &host) {\n   hints.ai_socktype = SOCK_STREAM;\n   hints.ai_protocol = 0;\n \n-  if (getaddrinfo(host.c_str(), \"0\", &hints, &result)) { return false; }\n+  if (getaddrinfo_with_timeout(host.c_str(), \"0\", &hints, &result, 0)) {\n+    return false;\n+  }\n   auto se = detail::scope_exit([&] { freeaddrinfo(result); });\n \n   auto ret = false;\n@@ -3646,7 +3972,8 @@ inline socket_t create_client_socket(\n \n         error = Error::Success;\n         return true;\n-      });\n+      },\n+      connection_timeout_sec); // Pass DNS timeout\n \n   if (sock != INVALID_SOCKET) {\n     error = Error::Success;\n@@ -5867,7 +6194,8 @@ inline void hosted_at(const std::string &hostname,\n   hints.ai_socktype = SOCK_STREAM;\n   hints.ai_protocol = 0;\n \n-  if (getaddrinfo(hostname.c_str(), nullptr, &hints, &result)) {\n+  if (detail::getaddrinfo_with_timeout(hostname.c_str(), nullptr, &hints,\n+                                       &result, 0)) {\n #if defined __linux__ && !defined __ANDROID__\n     res_init();\n #endif\n", "test_patch": "diff --git a/test/Makefile b/test/Makefile\n--- a/test/Makefile\n+++ b/test/Makefile\n@@ -9,7 +9,7 @@ OPENSSL_SUPPORT = -DCPPHTTPLIB_OPENSSL_SUPPORT -I$(OPENSSL_DIR)/include -L$(OPEN\n ifneq ($(OS), Windows_NT)\n \tUNAME_S := $(shell uname -s)\n \tifeq ($(UNAME_S), Darwin)\n-\t\tOPENSSL_SUPPORT += -DCPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN -framework CoreFoundation -framework Security\n+\t\tOPENSSL_SUPPORT += -DCPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN -framework CoreFoundation -framework Security -framework CFNetwork\n \tendif\n endif\n \n@@ -21,7 +21,15 @@ BROTLI_SUPPORT = -DCPPHTTPLIB_BROTLI_SUPPORT -I$(BROTLI_DIR)/include -L$(BROTLI_\n ZSTD_DIR = $(PREFIX)/opt/zstd\n ZSTD_SUPPORT = -DCPPHTTPLIB_ZSTD_SUPPORT -I$(ZSTD_DIR)/include -L$(ZSTD_DIR)/lib -lzstd\n \n-TEST_ARGS = gtest/src/gtest-all.cc gtest/src/gtest_main.cc -Igtest -Igtest/include $(OPENSSL_SUPPORT) $(ZLIB_SUPPORT) $(BROTLI_SUPPORT) $(ZSTD_SUPPORT) -pthread -lcurl\n+LIBS = -lpthread -lcurl\n+ifneq ($(OS), Windows_NT)\n+\tUNAME_S := $(shell uname -s)\n+\tifneq ($(UNAME_S), Darwin)\n+\t\tLIBS += -lanl\n+\tendif\n+endif\n+\n+TEST_ARGS = gtest/src/gtest-all.cc gtest/src/gtest_main.cc -Igtest -Igtest/include $(OPENSSL_SUPPORT) $(ZLIB_SUPPORT) $(BROTLI_SUPPORT) $(ZSTD_SUPPORT) $(LIBS)\n \n # By default, use standalone_fuzz_target_runner.\n # This runner does no fuzzing, but simply executes the inputs\n@@ -86,7 +94,7 @@ fuzz_test: server_fuzzer\n \n # Fuzz target, so that you can choose which $(LIB_FUZZING_ENGINE) to use.\n server_fuzzer : fuzzing/server_fuzzer.cc ../httplib.h standalone_fuzz_target_runner.o\n-\t$(CXX) -o $@ -I.. $(CXXFLAGS) $< $(OPENSSL_SUPPORT) $(ZLIB_SUPPORT) $(BROTLI_SUPPORT) $(LIB_FUZZING_ENGINE) -pthread\n+\t$(CXX) -o $@ -I.. $(CXXFLAGS) $< $(OPENSSL_SUPPORT) $(ZLIB_SUPPORT) $(BROTLI_SUPPORT) $(LIB_FUZZING_ENGINE) $(ZSTD_SUPPORT) $(LIBS)\n \t@file $@\n \n # Standalone fuzz runner, which just reads inputs from fuzzing/corpus/ dir and\ndiff --git a/test/fuzzing/Makefile b/test/fuzzing/Makefile\n--- a/test/fuzzing/Makefile\n+++ b/test/fuzzing/Makefile\n@@ -20,7 +20,7 @@ all : server_fuzzer\n # Fuzz target, so that you can choose which $(LIB_FUZZING_ENGINE) to use.\n server_fuzzer : server_fuzzer.cc ../../httplib.h\n # \t$(CXX) $(CXXFLAGS) -o $@  $<  -Wl,-Bstatic $(OPENSSL_SUPPORT)  -Wl,-Bdynamic -ldl  $(ZLIB_SUPPORT)  $(LIB_FUZZING_ENGINE) -pthread\n-\t$(CXX) $(CXXFLAGS) -o $@  $<  $(ZLIB_SUPPORT)  $(LIB_FUZZING_ENGINE) -pthread\n+\t$(CXX) $(CXXFLAGS) -o $@  $<  $(ZLIB_SUPPORT)  $(LIB_FUZZING_ENGINE) -pthread -lanl\n \tzip -q -r server_fuzzer_seed_corpus.zip corpus\n \n clean:\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -3388,31 +3388,20 @@ void performance_test(const char *host) {\n \n   Client cli(host, port);\n \n-  const int NUM_REQUESTS = 50;\n-  const int MAX_AVERAGE_MS = 5;\n+  auto start = std::chrono::high_resolution_clock::now();\n \n-  auto warmup = cli.Get(\"/benchmark\");\n-  ASSERT_TRUE(warmup);\n+  auto res = cli.Get(\"/benchmark\");\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(StatusCode::OK_200, res->status);\n \n-  auto start = std::chrono::high_resolution_clock::now();\n-  for (int i = 0; i < NUM_REQUESTS; ++i) {\n-    auto res = cli.Get(\"/benchmark\");\n-    ASSERT_TRUE(res) << \"Request \" << i << \" failed\";\n-    EXPECT_EQ(StatusCode::OK_200, res->status);\n-  }\n   auto end = std::chrono::high_resolution_clock::now();\n \n-  auto total_ms =\n+  auto elapsed =\n       std::chrono::duration_cast<std::chrono::milliseconds>(end - start)\n           .count();\n-  double avg_ms = static_cast<double>(total_ms) / NUM_REQUESTS;\n-\n-  std::cout << \"Peformance test at \\\"\" << host << \"\\\": \" << NUM_REQUESTS\n-            << \" requests in \" << total_ms << \"ms (avg: \" << avg_ms << \"ms)\"\n-            << std::endl;\n \n-  EXPECT_LE(avg_ms, MAX_AVERAGE_MS)\n-      << \"Performance is too slow: \" << avg_ms << \"ms (Issue #1777)\";\n+  EXPECT_LE(elapsed, 5) << \"Performance is too slow: \" << elapsed\n+                        << \"ms (Issue #1777)\";\n }\n \n TEST(BenchmarkTest, localhost) { performance_test(\"localhost\"); }\n", "problem_statement": "Client Get operation stalls in getaddrinfo when network is down\nHello!\r\n\r\nWe are seeing the following issue when the network is completely unavailable: the Get operations stalls in the [getaddrinfo](https://github.com/yhirose/cpp-httplib/blob/bd9612b81e6f39ab24a4be52fcda93658c0ca2dc/httplib.h#L2705) for about 30 seconds. We set the connection timeout and read timeout, but they don't have any effect.\r\n\r\nIs it possible that this logic also respects the connection timeout?\n", "hints_text": "@TheMostDiligent thanks for the feedback. As far as I know, `getaddrinfo` is a blocking function and doesn't provide timeout option. So there is no way for me to deal with it... Do you know how other HTTP libraries handle this situation?\nI am not very profound in HTTP handling. However, I tried to research the subject a bit and apparently there is an alternative function: [getaddrinfo_a](https://man7.org/linux/man-pages/man3/getaddrinfo_a.3.html) that supports asynchronous wait mode (`GAI_NOWAIT`). \r\nIn this mode, the function exits immediately and an [event](https://man7.org/linux/man-pages/man7/sigevent.7.html) is triggered when the operation completes. I think this will allow to wait for the event in the loop and abort the loop if timeout elapses. Or even better, if the user-provided callback returns false similar to the callback of the Get function.\nIt looks like only Linux supports it... How could it be possible to do the same in Windows and MacOS?\n> It looks like only Linux supports it\r\n\r\nIt does seem so. On Mac, there is [DNSServiceGetAddrInfo](https://developer.apple.com/documentation/dnssd/1804700-dnsservicegetaddrinfo) that allows async wait. [This article](https://eggerapps.at/blog/2014/hostname-lookups.html) describes it in detail. Looks like it is quite a hassle to implement this...\r\n\r\nOn Windows, I actually did not see that problem.\r\n\nIt seems like we may use `GetAddrInfoEx` which supports timeout parameter.\r\nhttps://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexw\r\n\r\nIn any case, supporting this feature on all three platforms and ensuring they work correctly will not likely be an easy task for me. So please don't expect me to implement it in the near future. A pull request is always welcome! :)\nThis stackoverflow post is helpful to write thread timeout code.\r\nhttps://stackoverflow.com/questions/40550730/how-to-implement-timeout-for-function-in-c", "created_at": "2025-06-28T12:31:06Z", "version": "0.22"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1976, "instance_id": "yhirose__cpp-httplib-1976", "issue_numbers": ["1973", "1973"], "base_commit": "924f214303b860b78350e1e2dfb0521a8724464f", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -2258,13 +2258,33 @@ make_basic_authentication_header(const std::string &username,\n \n namespace detail {\n \n+#if defined(_WIN32)\n+std::wstring u8string_to_wstring(const char *s) {\n+  std::wstring ws;\n+  auto len = static_cast<int>(strlen(s));\n+  auto wlen = ::MultiByteToWideChar(CP_UTF8, 0, s, len, nullptr, 0);\n+  if (wlen > 0) {\n+    ws.resize(wlen);\n+    wlen = ::MultiByteToWideChar(CP_UTF8, 0, s, len, const_cast<LPWSTR>(reinterpret_cast<LPCWSTR>(ws.data())), wlen);\n+    if (wlen != ws.size()) {\n+      ws.clear(); \n+    }\n+  }\n+  return ws;\n+}\n+#endif\n+\n struct FileStat {\n   FileStat(const std::string &path);\n   bool is_file() const;\n   bool is_dir() const;\n \n private:\n+#if defined(_WIN32)\n+  struct _stat st_;\n+#else\n   struct stat st_;\n+#endif\n   int ret_ = -1;\n };\n \n@@ -2639,7 +2659,12 @@ inline bool is_valid_path(const std::string &path) {\n }\n \n inline FileStat::FileStat(const std::string &path) {\n+#if defined(_WIN32)\n+  auto wpath = u8string_to_wstring(path.c_str());\n+  ret_ = _wstat(wpath.c_str(), &st_);\n+#else\n   ret_ = stat(path.c_str(), &st_);\n+#endif\n }\n inline bool FileStat::is_file() const {\n   return ret_ >= 0 && S_ISREG(st_.st_mode);\n@@ -2909,10 +2934,8 @@ inline bool mmap::open(const char *path) {\n   close();\n \n #if defined(_WIN32)\n-  std::wstring wpath;\n-  for (size_t i = 0; i < strlen(path); i++) {\n-    wpath += path[i];\n-  }\n+  auto wpath = u8string_to_wstring(path);\n+  if (wpath.empty()) { return false; }\n \n #if _WIN32_WINNT >= _WIN32_WINNT_WIN8\n   hFile_ = ::CreateFile2(wpath.c_str(), GENERIC_READ, FILE_SHARE_READ,\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1,3 +1,4 @@\n+\ufeff// NOTE: This file should be saved as UTF-8 w/ BOM\n #include <httplib.h>\n #include <signal.h>\n \n@@ -241,7 +242,7 @@ TEST(DecodeURLTest, PercentCharacter) {\n       detail::decode_url(\n           R\"(descrip=Gastos%20%C3%A1%C3%A9%C3%AD%C3%B3%C3%BA%C3%B1%C3%91%206)\",\n           false),\n-      R\"(descrip=Gastos \u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00d1 6)\");\n+      u8\"descrip=Gastos \u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00d1 6\");\n }\n \n TEST(DecodeURLTest, PercentCharacterNUL) {\n@@ -267,9 +268,9 @@ TEST(EncodeQueryParamTest, ParseReservedCharactersTest) {\n }\n \n TEST(EncodeQueryParamTest, TestUTF8Characters) {\n-  string chineseCharacters = \"\u4e2d\u56fd\u8a9e\";\n-  string russianCharacters = \"\u0434\u043e\u043c\";\n-  string brazilianCharacters = \"\u00f3culos\";\n+  string chineseCharacters = u8\"\u4e2d\u56fd\u8a9e\";\n+  string russianCharacters = u8\"\u0434\u043e\u043c\";\n+  string brazilianCharacters = u8\"\u00f3culos\";\n \n   EXPECT_EQ(detail::encode_query_param(chineseCharacters),\n             \"%E4%B8%AD%E5%9B%BD%E8%AA%9E\");\n@@ -5271,6 +5272,27 @@ TEST(MountTest, Redicect) {\n   EXPECT_EQ(StatusCode::OK_200, res->status);\n }\n \n+TEST(MountTest, MultibytesPathName) {\n+  Server svr;\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(\"localhost\", PORT); });\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    listen_thread.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.set_mount_point(\"/\", \"./www\");\n+  svr.wait_until_ready();\n+\n+  Client cli(\"localhost\", PORT);\n+\n+  auto res = cli.Get(u8\"/\u65e5\u672c\u8a9eDir/\u65e5\u672c\u8a9eFile.txt\");\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(StatusCode::OK_200, res->status);\n+  EXPECT_EQ(u8\"\u65e5\u672c\u8a9e\u30b3\u30f3\u30c6\u30f3\u30c4\", res->body);\n+}\n+\n TEST(KeepAliveTest, ReadTimeout) {\n   Server svr;\n \ndiff --git \"a/test/www/\\346\\227\\245\\346\\234\\254\\350\\252\\236Dir/\\346\\227\\245\\346\\234\\254\\350\\252\\236File.txt\" \"b/test/www/\\346\\227\\245\\346\\234\\254\\350\\252\\236Dir/\\346\\227\\245\\346\\234\\254\\350\\252\\236File.txt\"\nnew file mode 100644\n--- /dev/null\n+++ \"b/test/www/\\346\\227\\245\\346\\234\\254\\350\\252\\236Dir/\\346\\227\\245\\346\\234\\254\\350\\252\\236File.txt\"\n@@ -0,0 +1 @@\n+\u65e5\u672c\u8a9e\u30b3\u30f3\u30c6\u30f3\u30c4\n\\ No newline at end of file\n", "problem_statement": "fix(httplib):Fix the problem that CreateFile2 in mmap::open fails to \u2026\nWhen the open path exists in Chinese when CreateFile2 in un icode encoding the original way is invalid, must open the failure although this situation is rarely used but unfortunately that person appeared is me, so fix this problem!\nfix(httplib):Fix the problem that CreateFile2 in mmap::open fails to \u2026\nWhen the open path exists in Chinese when CreateFile2 in un icode encoding the original way is invalid, must open the failure although this situation is rarely used but unfortunately that person appeared is me, so fix this problem!\n", "hints_text": "\n", "created_at": "2024-11-14T03:42:28Z", "version": "0.18"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1989, "instance_id": "yhirose__cpp-httplib-1989", "issue_numbers": ["1985"], "base_commit": "1a7a7ed1c301f4ef08ced9c398d320a80f1468f1", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -612,6 +612,7 @@ using Ranges = std::vector<Range>;\n struct Request {\n   std::string method;\n   std::string path;\n+  Params params;\n   Headers headers;\n   std::string body;\n \n@@ -623,7 +624,6 @@ struct Request {\n   // for server\n   std::string version;\n   std::string target;\n-  Params params;\n   MultipartFormDataMap files;\n   Ranges ranges;\n   Match matches;\n@@ -7420,7 +7420,7 @@ inline bool ClientImpl::send(Request &req, Response &res, Error &error) {\n inline bool ClientImpl::is_ssl_peer_could_be_closed(SSL *ssl) const {\n   char buf[1];\n   return !SSL_peek(ssl, buf, 1) &&\n-    SSL_get_error(ssl, 0) == SSL_ERROR_ZERO_RETURN;\n+         SSL_get_error(ssl, 0) == SSL_ERROR_ZERO_RETURN;\n }\n #endif\n \n@@ -7438,9 +7438,7 @@ inline bool ClientImpl::send_(Request &req, Response &res, Error &error) {\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n       if (is_alive && is_ssl()) {\n-        if (is_ssl_peer_could_be_closed(socket_.ssl)) {\n-          is_alive = false;\n-        }\n+        if (is_ssl_peer_could_be_closed(socket_.ssl)) { is_alive = false; }\n       }\n #endif\n \n@@ -7799,7 +7797,13 @@ inline bool ClientImpl::write_request(Stream &strm, Request &req,\n   {\n     detail::BufferStream bstrm;\n \n-    const auto &path = url_encode_ ? detail::encode_url(req.path) : req.path;\n+    const auto &path_with_query =\n+        req.params.empty() ? req.path\n+                           : append_query_params(req.path, req.params);\n+\n+    const auto &path =\n+        url_encode_ ? detail::encode_url(path_with_query) : path_with_query;\n+\n     detail::write_request_line(bstrm, req.method, path);\n \n     header_writer_(bstrm, req.headers);\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -6542,6 +6542,40 @@ TEST(SendAPI, SimpleInterface_Online) {\n   EXPECT_EQ(StatusCode::MovedPermanently_301, res->status);\n }\n \n+TEST(SendAPI, WithParamsInRequest) {\n+  Server svr;\n+\n+  svr.Get(\"/\", [&](const Request &req, Response & /*res*/) {\n+    EXPECT_TRUE(req.has_param(\"test\"));\n+    EXPECT_EQ(\"test_value\", req.get_param_value(\"test\"));\n+  });\n+\n+  auto t = std::thread([&]() { svr.listen(HOST, PORT); });\n+\n+  auto se = detail::scope_exit([&] {\n+    svr.stop();\n+    t.join();\n+    ASSERT_FALSE(svr.is_running());\n+  });\n+\n+  svr.wait_until_ready();\n+\n+  Client cli(HOST, PORT);\n+\n+  {\n+    Request req;\n+    req.method = \"GET\";\n+    req.path = \"/\";\n+    req.params.emplace(\"test\", \"test_value\");\n+    auto res = cli.send(req);\n+    ASSERT_TRUE(res);\n+  }\n+  {\n+    auto res = cli.Get(\"/\", {{\"test\", \"test_value\"}}, Headers{});\n+    ASSERT_TRUE(res);\n+  }\n+}\n+\n TEST(ClientImplMethods, GetSocketTest) {\n   httplib::Server svr;\n   svr.Get(\"/\", [&](const httplib::Request & /*req*/, httplib::Response &res) {\n", "problem_statement": "missing query pararm in httplib::Client::send\nWhen i try send a request using `httplib::Client::send(const httplib::Request& request)`, the params set via `request.params.insert(...)` dissapear. But if I hardcode them in the request path, it will work. So, it looks like problem is in the request building\r\n\r\n```\r\n#include <iostream>\r\n\r\n#include \"cpp-httplib/httplib.h\"\r\n\r\nusing namespace std;\r\nint main() {\r\n    httplib::Server server;\r\n    server.Get(\"/\", [](const httplib::Request& req, httplib::Response& response) {\r\n        if (req.has_param(\"test\")) {\r\n            cout << \"test=\" << req.get_param_value(\"test\") << endl;\r\n        } else {\r\n            cout << \"No such param 'test'\" << endl;\r\n        }\r\n    });\r\n\r\n    thread t([&]() { server.listen(\"localhost\", 4444); });\r\n    sleep(1);\r\n\r\n    httplib::Client client(\"localhost\", 4444);\r\n    httplib::Request request;\r\n    request.method = \"GET\";\r\n    request.path = \"/\";\r\n    request.params.insert(pair<string, string>(\"test\", \"testvalue\"));\r\n\r\n    auto res = client.send(request);\r\n    cout << res->status << endl;\r\n\r\n    cout<<\"-----------------------\"<<endl;\r\n\r\n    request.path = \"/?test=testvalue\";\r\n    res = client.send(request);\r\n    cout << res->status << endl;\r\n\r\n    server.stop();\r\n    t.join();\r\n    return 0;\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\nNo such param 'test'\r\n200\r\n-----------------------\r\ntest=testvalue\r\n200\r\n```\n", "hints_text": "", "created_at": "2024-11-27T16:37:46Z", "version": "0.18"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1243, "instance_id": "yhirose__cpp-httplib-1243", "issue_numbers": ["1235"], "base_commit": "0857eba17b9d3ef90d45950f9853b7579d6a7f29", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -170,6 +170,7 @@ using socket_t = SOCKET;\n #include <arpa/inet.h>\n #include <cstring>\n #include <ifaddrs.h>\n+#include <net/if.h>\n #include <netdb.h>\n #include <netinet/in.h>\n #ifdef __linux__\n@@ -2649,11 +2650,14 @@ inline bool bind_ip_address(socket_t sock, const char *host) {\n #endif\n \n #ifdef USE_IF2IP\n-inline std::string if2ip(const std::string &ifn) {\n+inline std::string if2ip(int address_family, const std::string &ifn) {\n   struct ifaddrs *ifap;\n   getifaddrs(&ifap);\n+  std::string addr_candidate;\n   for (auto ifa = ifap; ifa; ifa = ifa->ifa_next) {\n-    if (ifa->ifa_addr && ifn == ifa->ifa_name) {\n+    if (ifa->ifa_addr && ifn == ifa->ifa_name &&\n+        (AF_UNSPEC == address_family ||\n+         ifa->ifa_addr->sa_family == address_family)) {\n       if (ifa->ifa_addr->sa_family == AF_INET) {\n         auto sa = reinterpret_cast<struct sockaddr_in *>(ifa->ifa_addr);\n         char buf[INET_ADDRSTRLEN];\n@@ -2661,11 +2665,26 @@ inline std::string if2ip(const std::string &ifn) {\n           freeifaddrs(ifap);\n           return std::string(buf, INET_ADDRSTRLEN);\n         }\n+      } else if (ifa->ifa_addr->sa_family == AF_INET6) {\n+        auto sa = reinterpret_cast<struct sockaddr_in6 *>(ifa->ifa_addr);\n+        if (!IN6_IS_ADDR_LINKLOCAL(&sa->sin6_addr)) {\n+          char buf[INET6_ADDRSTRLEN] = {};\n+          if (inet_ntop(AF_INET6, &sa->sin6_addr, buf, INET6_ADDRSTRLEN)) {\n+            // equivalent to mac's IN6_IS_ADDR_UNIQUE_LOCAL\n+            auto s6_addr_head = sa->sin6_addr.s6_addr[0];\n+            if (s6_addr_head == 0xfc || s6_addr_head == 0xfd) {\n+              addr_candidate = std::string(buf, INET6_ADDRSTRLEN);\n+            } else {\n+              freeifaddrs(ifap);\n+              return std::string(buf, INET6_ADDRSTRLEN);\n+            }\n+          }\n+        }\n       }\n     }\n   }\n   freeifaddrs(ifap);\n-  return std::string();\n+  return addr_candidate;\n }\n #endif\n \n@@ -2680,7 +2699,7 @@ inline socket_t create_client_socket(\n       [&](socket_t sock2, struct addrinfo &ai) -> bool {\n         if (!intf.empty()) {\n #ifdef USE_IF2IP\n-          auto ip = if2ip(intf);\n+          auto ip = if2ip(address_family, intf);\n           if (ip.empty()) { ip = intf; }\n           if (!bind_ip_address(sock2, ip.c_str())) {\n             error = Error::BindIPAddress;\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1419,10 +1419,9 @@ TEST(InvalidFormatTest, StatusCode) {\n TEST(URLFragmentTest, WithFragment) {\n   Server svr;\n \n-  svr.Get(\"/hi\",\n-          [](const Request &req, Response &/*res*/) {\n-            EXPECT_TRUE(req.target == \"/hi\");\n-          });\n+  svr.Get(\"/hi\", [](const Request &req, Response & /*res*/) {\n+    EXPECT_TRUE(req.target == \"/hi\");\n+  });\n \n   auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n \n@@ -4369,6 +4368,20 @@ TEST(SSLClientTest, WildcardHostNameMatch_Online) {\n   ASSERT_EQ(200, res->status);\n }\n \n+#if 0\n+TEST(SSLClientTest, SetInterfaceWithINET6) {\n+  auto cli = std::make_shared<httplib::Client>(\"https://httpbin.org\");\n+  ASSERT_TRUE(cli != nullptr);\n+\n+  cli->set_address_family(AF_INET6);\n+  cli->set_interface(\"en0\");\n+\n+  auto res = cli->Get(\"/get\");\n+  ASSERT_TRUE(res);\n+  ASSERT_EQ(200, res->status);\n+}\n+#endif\n+\n TEST(SSLClientServerTest, ClientCertPresent) {\n   SSLServer svr(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE, CLIENT_CA_CERT_FILE,\n                 CLIENT_CA_CERT_DIR);\n@@ -4838,15 +4851,15 @@ TEST(MultipartFormDataTest, LargeData) {\n             return true;\n           });\n \n-        EXPECT_TRUE(std::string(files[0].name) == \"document\");\n-        EXPECT_EQ(size_t(1024 * 1024 * 2), files[0].content.size());\n-        EXPECT_TRUE(files[0].filename == \"2MB_data\");\n-        EXPECT_TRUE(files[0].content_type == \"application/octet-stream\");\n+      EXPECT_TRUE(std::string(files[0].name) == \"document\");\n+      EXPECT_EQ(size_t(1024 * 1024 * 2), files[0].content.size());\n+      EXPECT_TRUE(files[0].filename == \"2MB_data\");\n+      EXPECT_TRUE(files[0].content_type == \"application/octet-stream\");\n \n-        EXPECT_TRUE(files[1].name == \"hello\");\n-        EXPECT_TRUE(files[1].content == \"world\");\n-        EXPECT_TRUE(files[1].filename == \"\");\n-        EXPECT_TRUE(files[1].content_type == \"\");\n+      EXPECT_TRUE(files[1].name == \"hello\");\n+      EXPECT_TRUE(files[1].content == \"world\");\n+      EXPECT_TRUE(files[1].filename == \"\");\n+      EXPECT_TRUE(files[1].content_type == \"\");\n     } else {\n       std::string body;\n       content_reader([&](const char *data, size_t data_length) {\n", "problem_statement": "BindIPAddress when force address family to IPV6 and set outbound interface\n```\r\n//\r\n// Created by Kotarou on 2022/4/6.\r\n//\r\n#include <httplib.h>\r\n\r\nstd::unique_ptr<httplib::Client>\r\nget_http_client(std::string_view url, int family = AF_UNSPEC, const char *nif_name = nullptr) {\r\n    auto client = std::make_unique<httplib::Client>(url.data());\r\n\r\n    // set outbound interface\r\n    if (nif_name != nullptr) {\r\n        client->set_interface(nif_name);\r\n    }\r\n\r\n    // set address family\r\n    client->set_address_family(family);\r\n    client->set_connection_timeout(5);\r\n    client->set_read_timeout(5, 1000);\r\n    client->set_follow_location(true);\r\n    client->set_default_headers({{\"User-Agent\", \"Mozilla\"}});\r\n\r\n    return client;\r\n}\r\n\r\nvoid print_response(const httplib::Result &result) {\r\n    if (result) {\r\n        std::cout << result->body << std::endl;\r\n    } else {\r\n        std::cerr << \"Error: \" << httplib::to_string(result.error()) << std::endl;\r\n    }\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    std::cout << \"AF_UNSPEC, no nif\" << std::endl;\r\n    auto client = get_http_client(\"https://api.ip.sb:443\");\r\n    auto response = client->Get(\"/ip\");\r\n    print_response(response);\r\n\r\n    std::cout << \"AF_UNSPEC, en0\" << std::endl;\r\n    client = get_http_client(\"https://api.ip.sb:443\", AF_UNSPEC, \"en0\");\r\n    response = client->Get(\"/ip\");\r\n    print_response(response);\r\n\r\n    std::cout << \"AF_INET, no nif\" << std::endl;\r\n    client = get_http_client(\"https://api.ip.sb:443\", AF_INET);\r\n    response = client->Get(\"/ip\");\r\n    print_response(response);\r\n\r\n    std::cout << \"AF_INET, en0\" << std::endl;\r\n    client = get_http_client(\"https://api.ip.sb:443\", AF_INET, \"en0\");\r\n    response = client->Get(\"/ip\");\r\n    print_response(response);\r\n\r\n    std::cout << \"AF_INET6, no nif\" << std::endl;\r\n    client = get_http_client(\"https://api.ip.sb:443\", AF_INET6);\r\n    response = client->Get(\"/ip\");\r\n    print_response(response);\r\n\r\n    std::cout << \"AF_INET6, en0\" << std::endl;\r\n    client = get_http_client(\"https://api.ip.sb:443\", AF_INET6, \"en0\");\r\n    response = client->Get(\"/ip\");\r\n    print_response(response);\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\nAF_UNSPEC, no nif\r\n2405:aacf:acdc:6dc:33:cda2:153e:745\r\n\r\nAF_UNSPEC, en0\r\n38.13.192.76\r\n\r\nAF_INET, no nif\r\n38.13.192.76\r\n\r\nAF_INET, en0\r\n38.13.192.76\r\n\r\nAF_INET6, no nif\r\n2405:aacf:acdc:6dc:33:cda2:153e:745\r\n\r\nAF_INET6, en0\r\nError: BindIPAddress\r\n```\r\n\r\nnot sure what cause this, but when set address family to AF_INET6 and also force to use en0 as outbound interface, library returned a bind ip error.\n", "hints_text": "@CyberKoo, I feel that it's a general HTTP problem, not a cpp-httplib specific problem. Could you try with other HTTP libraries (or just use the system socket library) on your machine, so that we can check if it's a really cpp-httplib problem?\r\nThanks for your help!\n```\r\n//\r\n// Created by Kotarou on 2022/4/6.\r\n//\r\n#include <arpa/inet.h>\r\n#include <netinet/in.h>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <sys/socket.h>\r\n#include <unistd.h>\r\n#include <net/if.h>\r\n\r\n#include <iostream>\r\n\r\nint main(int argc, char *argv[]) {\r\n    int fd;\r\n    fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\r\n\r\n    // nif (macos)\r\n    uint32_t nif_index = if_nametoindex(\"en0\");\r\n\r\n    struct sockaddr_in6 server_addr{};\r\n    inet_pton(AF_INET6, \"2606:4700:20::ac43:4bac\", &server_addr.sin6_addr);    // ipv6.ip.sb\r\n    server_addr.sin6_family = AF_INET6;\r\n    server_addr.sin6_port = htons(80);\r\n    server_addr.sin6_scope_id = nif_index;\r\n\r\n    connect(fd, (struct sockaddr *) &server_addr, sizeof(server_addr));\r\n\r\n    const char request[] = \"GET / HTTP/1.0\\n\"\r\n                           \"Host: ipv6.ip.sb\\n\"\r\n                           \"User-Agent: {}\\n\"\r\n                           \"Accept: */*\\r\\n\\r\\n\";\r\n\r\n    write(fd, &request, sizeof(request));\r\n\r\n    char buffer[1024] = {};\r\n    read(fd, &buffer, 1023);\r\n\r\n    std::cout << buffer << std::endl;\r\n\r\n    close(fd);\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\noutput\r\n```\r\nHTTP/1.1 301 Moved Permanently\r\nDate: Wed, 06 Apr 2022 12:47:48 GMT\r\nContent-Type: text/html\r\nConnection: close\r\nLocation: https://ipv6.ip.sb/\r\nCF-Cache-Status: DYNAMIC\r\nReport-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=jJxo4kyHV0UC8zH5jjnlVqwTsF35whVW3f8JkYdaAZ8%2BO%2BidWU%2FszhuLQpMW6n%2F7%2FZcYdaDJqOOI%2F4%2F63wDhr52KDXQZJQtw8 6fcd47e6a q7fU2fjyrtMzwGI%3D\"}],\"group\":\"cf-nel\",\"max_age\":604800}\r\nNEL: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}\r\nServer: cloudflare\r\nCF-RAY: 6f7aa25hU4p3H7q-LAX\r\nalt-svc: h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400\r\n\r\n<html>\r\n<head><title>301 Moved Permanently</title></head>\r\n<body>\r\n<center><h1>301 Moved Permanently</h1></center>\r\n<hr><center>nginx</center>\r\n</body>\r\n</html>\r\n```\nI think this problem was cause by the if2ip function, which only return IPV4 address.\r\nhttps://github.com/yhirose/cpp-httplib/blob/020b0db090dc8e197cbedbdc4db7e3120eda5333/httplib.h#L2652\nThanks for the report. Could you try again with #1236?\nThanks for the fix, but here are some issues I've found.\r\n\r\n1. this fix will return an ipv6 address even the address family is set to AF_INET,  need to pass the address_family from create_client_socket to if2ip.\r\n<img width=\"624\" alt=\"Snipaste_2022-04-07_10-57-39\" src=\"https://user-images.githubusercontent.com/2918558/162111398-0565d044-5559-45ad-8f30-df4be17b06c1.png\">\r\n\r\n2. incorrect ipv6 address returned from if2ip, cast ifa->ifa_addr to sockaddr_in then use inet_ntop to extract IP address will result the address in backward.\r\n<img width=\"609\" alt=\"Snipaste_2022-04-07_10-41-48\" src=\"https://user-images.githubusercontent.com/2918558/162109814-015a041d-7eef-42f8-b3f7-227df854470c.png\">\r\n\r\nfor ipv6 address use struct sockaddr_in6 and &sa->sin6_addr\r\n```\r\nauto sa = reinterpret_cast<struct sockaddr_in6 *>(ifa->ifa_addr);\r\nif (inet_ntop(af, &sa->sin6_addr, &buf[0], bufsiz)) {\r\n  freeifaddrs(ifap);\r\n  return buf;\r\n}\r\n```\r\n\r\n3. function will return link-local address (fe80) instead of global unicast address.4. \r\nmay be use if_nametoindex from <net/if.h> for POSIX systems? this will rule out need to dealing with ip address\r\n\r\n<img width=\"832\" alt=\"Snipaste_2022-04-07_10-49-47\" src=\"https://user-images.githubusercontent.com/2918558/162110597-425d10ed-257d-472b-a912-3d7ea185618c.png\">\r\n\r\n", "created_at": "2022-04-12T10:27:15Z", "version": "0.10"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1326, "instance_id": "yhirose__cpp-httplib-1326", "issue_numbers": ["1325"], "base_commit": "5e6f973b99a001a68e52bfca254e42135ad3f4e0", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -123,15 +123,17 @@\n #endif //_CRT_NONSTDC_NO_DEPRECATE\n \n #if defined(_MSC_VER)\n+#if _MSC_VER < 1900\n+#error Sorry, Visual Studio versions prior to 2015 are not supported\n+#endif\n+\n+#pragma comment(lib, \"ws2_32.lib\")\n+\n #ifdef _WIN64\n using ssize_t = __int64;\n #else\n using ssize_t = int;\n #endif\n-\n-#if _MSC_VER < 1900\n-#define snprintf _snprintf_s\n-#endif\n #endif // _MSC_VER\n \n #ifndef S_ISREG\n@@ -154,10 +156,6 @@ using ssize_t = int;\n #define WSA_FLAG_NO_HANDLE_INHERIT 0x80\n #endif\n \n-#ifdef _MSC_VER\n-#pragma comment(lib, \"ws2_32.lib\")\n-#endif\n-\n #ifndef strcasecmp\n #define strcasecmp _stricmp\n #endif // strcasecmp\n@@ -1520,11 +1518,7 @@ inline ssize_t Stream::write_format(const char *fmt, const Args &...args) {\n   const auto bufsiz = 2048;\n   std::array<char, bufsiz> buf{};\n \n-#if defined(_MSC_VER) && _MSC_VER < 1900\n-  auto sn = _snprintf_s(buf.data(), bufsiz, _TRUNCATE, fmt, args...);\n-#else\n   auto sn = snprintf(buf.data(), buf.size() - 1, fmt, args...);\n-#endif\n   if (sn <= 0) { return sn; }\n \n   auto n = static_cast<size_t>(sn);\n@@ -1534,14 +1528,8 @@ inline ssize_t Stream::write_format(const char *fmt, const Args &...args) {\n \n     while (n >= glowable_buf.size() - 1) {\n       glowable_buf.resize(glowable_buf.size() * 2);\n-#if defined(_MSC_VER) && _MSC_VER < 1900\n-      n = static_cast<size_t>(_snprintf_s(&glowable_buf[0], glowable_buf.size(),\n-                                          glowable_buf.size() - 1, fmt,\n-                                          args...));\n-#else\n       n = static_cast<size_t>(\n           snprintf(&glowable_buf[0], glowable_buf.size() - 1, fmt, args...));\n-#endif\n     }\n     return write(&glowable_buf[0], n);\n   } else {\n@@ -4711,7 +4699,7 @@ inline bool BufferStream::is_readable() const { return true; }\n inline bool BufferStream::is_writable() const { return true; }\n \n inline ssize_t BufferStream::read(char *ptr, size_t size) {\n-#if defined(_MSC_VER) && _MSC_VER <= 1900\n+#if defined(_MSC_VER) && _MSC_VER < 1910\n   auto len_read = buffer._Copy_s(ptr, size, size, position);\n #else\n   auto len_read = buffer.copy(ptr, size, position);\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -4982,7 +4982,7 @@ TEST(MultipartFormDataTest, LargeData) {\n \n TEST(MultipartFormDataTest, WithPreamble) {\n   Server svr;\n-  svr.Post(\"/post\", [&](const Request &req, Response &res) {\n+  svr.Post(\"/post\", [&](const Request & /*req*/, Response &res) {\n     res.set_content(\"ok\", \"text/plain\");\n   });\n \n", "problem_statement": "No longer support VS 2013 and older\n\n", "hints_text": "", "created_at": "2022-07-15T00:21:06Z", "version": "0.10"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1296, "instance_id": "yhirose__cpp-httplib-1296", "issue_numbers": ["1292"], "base_commit": "4001637beb48fb77f1bb94aa4aa160256a938991", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -2708,9 +2708,9 @@ inline socket_t create_client_socket(\n       [&](socket_t sock2, struct addrinfo &ai) -> bool {\n         if (!intf.empty()) {\n #ifdef USE_IF2IP\n-          auto ip = if2ip(address_family, intf);\n-          if (ip.empty()) { ip = intf; }\n-          if (!bind_ip_address(sock2, ip.c_str())) {\n+          auto ip_from_if = if2ip(address_family, intf);\n+          if (ip_from_if.empty()) { ip_from_if = intf; }\n+          if (!bind_ip_address(sock2, ip_from_if.c_str())) {\n             error = Error::BindIPAddress;\n             return false;\n           }\n@@ -6320,8 +6320,8 @@ inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n           auto last = offset + data_len == content_length;\n \n           auto ret = compressor.compress(\n-              data, data_len, last, [&](const char *data, size_t data_len) {\n-                req.body.append(data, data_len);\n+              data, data_len, last, [&](const char *compressed_data, size_t compressed_data_len) {\n+                req.body.append(compressed_data, compressed_data_len);\n                 return true;\n               });\n \n@@ -7378,11 +7378,11 @@ inline SSL_CTX *SSLServer::ssl_context() const { return ctx_; }\n inline bool SSLServer::process_and_close_socket(socket_t sock) {\n   auto ssl = detail::ssl_new(\n       sock, ctx_, ctx_mutex_,\n-      [&](SSL *ssl) {\n+      [&](SSL *ssl2) {\n         return detail::ssl_connect_or_accept_nonblocking(\n-            sock, ssl, SSL_accept, read_timeout_sec_, read_timeout_usec_);\n+            sock, ssl2, SSL_accept, read_timeout_sec_, read_timeout_usec_);\n       },\n-      [](SSL * /*ssl*/) { return true; });\n+      [](SSL * /*ssl2*/) { return true; });\n \n   bool ret = false;\n   if (ssl) {\n@@ -7576,31 +7576,31 @@ inline bool SSLClient::load_certs() {\n inline bool SSLClient::initialize_ssl(Socket &socket, Error &error) {\n   auto ssl = detail::ssl_new(\n       socket.sock, ctx_, ctx_mutex_,\n-      [&](SSL *ssl) {\n+      [&](SSL *ssl2) {\n         if (server_certificate_verification_) {\n           if (!load_certs()) {\n             error = Error::SSLLoadingCerts;\n             return false;\n           }\n-          SSL_set_verify(ssl, SSL_VERIFY_NONE, nullptr);\n+          SSL_set_verify(ssl2, SSL_VERIFY_NONE, nullptr);\n         }\n \n         if (!detail::ssl_connect_or_accept_nonblocking(\n-                socket.sock, ssl, SSL_connect, connection_timeout_sec_,\n+                socket.sock, ssl2, SSL_connect, connection_timeout_sec_,\n                 connection_timeout_usec_)) {\n           error = Error::SSLConnection;\n           return false;\n         }\n \n         if (server_certificate_verification_) {\n-          verify_result_ = SSL_get_verify_result(ssl);\n+          verify_result_ = SSL_get_verify_result(ssl2);\n \n           if (verify_result_ != X509_V_OK) {\n             error = Error::SSLServerVerification;\n             return false;\n           }\n \n-          auto server_cert = SSL_get_peer_certificate(ssl);\n+          auto server_cert = SSL_get_peer_certificate(ssl2);\n \n           if (server_cert == nullptr) {\n             error = Error::SSLServerVerification;\n@@ -7617,8 +7617,8 @@ inline bool SSLClient::initialize_ssl(Socket &socket, Error &error) {\n \n         return true;\n       },\n-      [&](SSL *ssl) {\n-        SSL_set_tlsext_host_name(ssl, host_.c_str());\n+      [&](SSL *ssl2) {\n+        SSL_set_tlsext_host_name(ssl2, host_.c_str());\n         return true;\n       });\n \n", "test_patch": "diff --git a/test/Makefile b/test/Makefile\n--- a/test/Makefile\n+++ b/test/Makefile\n@@ -1,5 +1,5 @@\n CXX = clang++\n-CXXFLAGS = -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion # -fno-exceptions -DCPPHTTPLIB_NO_EXCEPTIONS -fsanitize=address\n+CXXFLAGS = -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion -Wshadow # -fno-exceptions -DCPPHTTPLIB_NO_EXCEPTIONS -fsanitize=address\n \n PREFIX = /usr/local\n #PREFIX = $(shell brew --prefix)\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -109,11 +109,11 @@ TEST(SplitTest, ParseQueryString) {\n   detail::split(s.c_str(), s.c_str() + s.size(), '&',\n                 [&](const char *b, const char *e) {\n                   string key, val;\n-                  detail::split(b, e, '=', [&](const char *b, const char *e) {\n+                  detail::split(b, e, '=', [&](const char *b2, const char *e2) {\n                     if (key.empty()) {\n-                      key.assign(b, e);\n+                      key.assign(b2, e2);\n                     } else {\n-                      val.assign(b, e);\n+                      val.assign(b2, e2);\n                     }\n                   });\n                   dic.emplace(key, val);\n@@ -3015,8 +3015,8 @@ TEST(GzipDecompressor, ChunkedDecompression) {\n     httplib::detail::gzip_compressor compressor;\n     bool result = compressor.compress(\n         data.data(), data.size(),\n-        /*last=*/true, [&](const char *data, size_t size) {\n-          compressed_data.insert(compressed_data.size(), data, size);\n+        /*last=*/true, [&](const char *compressed_data_chunk, size_t compressed_data_size) {\n+          compressed_data.insert(compressed_data.size(), compressed_data_chunk, compressed_data_size);\n           return true;\n         });\n     ASSERT_TRUE(result);\n@@ -3035,8 +3035,8 @@ TEST(GzipDecompressor, ChunkedDecompression) {\n           std::min(compressed_data.size() - chunk_begin, chunk_size);\n       bool result = decompressor.decompress(\n           compressed_data.data() + chunk_begin, current_chunk_size,\n-          [&](const char *data, size_t size) {\n-            decompressed_data.insert(decompressed_data.size(), data, size);\n+          [&](const char *decompressed_data_chunk, size_t decompressed_data_chunk_size) {\n+            decompressed_data.insert(decompressed_data.size(), decompressed_data_chunk, decompressed_data_chunk_size);\n             return true;\n           });\n       ASSERT_TRUE(result);\n", "problem_statement": "Variable shadowing in httplib.h\nThe following were found by GCC/Clang\r\n```\r\n/cpp-httplib/httplib.h:2711:16: error: declaration of 'auto ip' shadows a parameter [-Werror=shadow]\r\n 2711 |           auto ip = if2ip(address_family, intf);\r\n      |                ^~\r\n/cpp-httplib/httplib.h:2701:35: note: shadowed declaration is here\r\n 2701 |     const char *host, const char *ip, int port, int address_family,\r\n      |                       ~~~~~~~~~~~~^~\r\n/cpp-httplib/httplib.h: In lambda function:\r\n/cpp-httplib/httplib.h:7381:16: error: declaration of 'ssl' shadows a previous local [-Werror=shadow]\r\n 7381 |       [&](SSL *ssl) {\r\n      |           ~~~~~^~~\r\n/cpp-httplib/httplib.h:7379:8: note: shadowed declaration is here\r\n 7379 |   auto ssl = detail::ssl_new(\r\n      |        ^~~\r\n/cpp-httplib/httplib.h: In lambda function:\r\n/cpp-httplib/httplib.h:7579:16: error: declaration of 'ssl' shadows a previous local [-Werror=shadow]\r\n 7579 |       [&](SSL *ssl) {\r\n      |           ~~~~~^~~\r\n/cpp-httplib/httplib.h:7577:8: note: shadowed declaration is here\r\n 7577 |   auto ssl = detail::ssl_new(\r\n      |        ^~~\r\n/cpp-httplib/httplib.h: In lambda function:\r\n/cpp-httplib/httplib.h:7620:16: error: declaration of 'ssl' shadows a previous local [-Werror=shadow]\r\n 7620 |       [&](SSL *ssl) {\r\n      |           ~~~~~^~~\r\n/cpp-httplib/httplib.h:7577:8: note: shadowed declaration is here\r\n 7577 |   auto ssl = detail::ssl_new(\r\n      |        ^~~\r\n```\n", "hints_text": "", "created_at": "2022-05-27T15:41:38Z", "version": "0.10"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1122, "instance_id": "yhirose__cpp-httplib-1122", "issue_numbers": ["1121"], "base_commit": "084c643973b43fe796f56bf9c124c5a7ce4c0efc", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -2406,12 +2406,14 @@ inline bool keep_alive(socket_t sock, time_t keep_alive_timeout_sec) {\n \n template <typename T>\n inline bool\n-process_server_socket_core(socket_t sock, size_t keep_alive_max_count,\n+process_server_socket_core(const std::atomic<socket_t> &svr_sock, socket_t sock,\n+                           size_t keep_alive_max_count,\n                            time_t keep_alive_timeout_sec, T callback) {\n   assert(keep_alive_max_count > 0);\n   auto ret = false;\n   auto count = keep_alive_max_count;\n-  while (count > 0 && keep_alive(sock, keep_alive_timeout_sec)) {\n+  while (svr_sock != INVALID_SOCKET && count > 0 &&\n+         keep_alive(sock, keep_alive_timeout_sec)) {\n     auto close_connection = count == 1;\n     auto connection_closed = false;\n     ret = callback(close_connection, connection_closed);\n@@ -2423,12 +2425,13 @@ process_server_socket_core(socket_t sock, size_t keep_alive_max_count,\n \n template <typename T>\n inline bool\n-process_server_socket(socket_t sock, size_t keep_alive_max_count,\n+process_server_socket(const std::atomic<socket_t> &svr_sock, socket_t sock,\n+                      size_t keep_alive_max_count,\n                       time_t keep_alive_timeout_sec, time_t read_timeout_sec,\n                       time_t read_timeout_usec, time_t write_timeout_sec,\n                       time_t write_timeout_usec, T callback) {\n   return process_server_socket_core(\n-      sock, keep_alive_max_count, keep_alive_timeout_sec,\n+      svr_sock, sock, keep_alive_max_count, keep_alive_timeout_sec,\n       [&](bool close_connection, bool &connection_closed) {\n         SocketStream strm(sock, read_timeout_sec, read_timeout_usec,\n                           write_timeout_sec, write_timeout_usec);\n@@ -5540,8 +5543,9 @@ inline bool Server::is_valid() const { return true; }\n \n inline bool Server::process_and_close_socket(socket_t sock) {\n   auto ret = detail::process_server_socket(\n-      sock, keep_alive_max_count_, keep_alive_timeout_sec_, read_timeout_sec_,\n-      read_timeout_usec_, write_timeout_sec_, write_timeout_usec_,\n+      svr_sock_, sock, keep_alive_max_count_, keep_alive_timeout_sec_,\n+      read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,\n+      write_timeout_usec_,\n       [this](Stream &strm, bool close_connection, bool &connection_closed) {\n         return process_request(strm, close_connection, connection_closed,\n                                nullptr);\n@@ -6904,14 +6908,13 @@ bool ssl_connect_or_accept_nonblocking(socket_t sock, SSL *ssl,\n }\n \n template <typename T>\n-inline bool\n-process_server_socket_ssl(SSL *ssl, socket_t sock, size_t keep_alive_max_count,\n-                          time_t keep_alive_timeout_sec,\n-                          time_t read_timeout_sec, time_t read_timeout_usec,\n-                          time_t write_timeout_sec, time_t write_timeout_usec,\n-                          T callback) {\n+inline bool process_server_socket_ssl(\n+    const std::atomic<socket_t> &svr_sock, SSL *ssl, socket_t sock,\n+    size_t keep_alive_max_count, time_t keep_alive_timeout_sec,\n+    time_t read_timeout_sec, time_t read_timeout_usec, time_t write_timeout_sec,\n+    time_t write_timeout_usec, T callback) {\n   return process_server_socket_core(\n-      sock, keep_alive_max_count, keep_alive_timeout_sec,\n+      svr_sock, sock, keep_alive_max_count, keep_alive_timeout_sec,\n       [&](bool close_connection, bool &connection_closed) {\n         SSLSocketStream strm(sock, ssl, read_timeout_sec, read_timeout_usec,\n                              write_timeout_sec, write_timeout_usec);\n@@ -7170,7 +7173,7 @@ inline bool SSLServer::process_and_close_socket(socket_t sock) {\n   bool ret = false;\n   if (ssl) {\n     ret = detail::process_server_socket_ssl(\n-        ssl, sock, keep_alive_max_count_, keep_alive_timeout_sec_,\n+        svr_sock_, ssl, sock, keep_alive_max_count_, keep_alive_timeout_sec_,\n         read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,\n         write_timeout_usec_,\n         [this, ssl](Stream &strm, bool close_connection,\n", "test_patch": "diff --git a/test/Makefile b/test/Makefile\n--- a/test/Makefile\n+++ b/test/Makefile\n@@ -68,4 +68,4 @@ cert.pem:\n \t#c_rehash .\n \n clean:\n-\trm -f test test_split test_proxy server_fuzzer pem *.0 *.o *.1 *.srl httplib.h httplib.cc\n+\trm -f test test_split test_proxy server_fuzzer *.pem *.0 *.o *.1 *.srl httplib.h httplib.cc\n", "problem_statement": "Can't properly stop server when using huge max keep alives\nHello.\r\nI'm having an issue with server not stopping when calling `httplib::Server::set_keep_alive_max_count()` with high values.\r\nI have a client that constantly posts data to the server. In order to fight delays caused by reconnects, I've set server's keep alive max count to something really big, like `size_t-1`.\r\nThis had a side effect, though. Now the server won't stop even if I call `httplib::Server::stop()` or `delete` the object, unless I stop the client first.\r\nThis is reproduced with the latest version of the library on Windows 10 (Visual Studio 2015) and on Ubuntu 20.04 (GCC 9.3.0).\r\nI've made a simple POC, which can be cloned [here](https://github.com/tsilia/poc-httplib-inf-keepalive)\r\n\r\n```cpp\r\nhttplib::Client client(ServerAddress, ServerPort); \r\nclient.set_keep_alive(true); \r\nclient.set_tcp_nodelay(true); \r\nconst auto timeout_ms = 250ms; \r\nclient.set_connection_timeout(timeout_ms); \r\nclient.set_read_timeout(timeout_ms); \r\nclient.set_write_timeout(timeout_ms); \r\nwhile (!bStop) \r\n{ \r\n    const auto rnd_num = dist(rnd_eng); \r\n    const auto res = client.Post(\"/post\", std::to_string(rnd_num), \"text/plain\"); \r\n    if (res) \r\n        std::cout << \"Successfully posted \" << rnd_num << std::endl; \r\n    else\r\n        std::cerr << \"Failed to post data: \" << res.error() << std::endl; \r\n    std::this_thread::sleep_for(100ms); \r\n} \r\n```\r\n```cpp\r\nhttplib::Server server;\r\nserver.Post(\"/post\", [](const httplib::Request& req, httplib::Response& res){ std::cout << req.body << std::endl; });\r\nserver.set_read_timeout(250ms);\r\nserver.set_write_timeout(250ms);\r\nserver.set_keep_alive_max_count(std::numeric_limits<size_t>::max());\t// we need to keep the connection as long as it's possible\r\nstd::thread t(&ServerThreadFunc, std::ref(server));\r\n// ...\r\n```\r\nClient posts random numbers to the server and the server writes them to the console. Both client and server start and wait for Enter key press and then stop.\r\nHere's the output from the POC:\r\n```\r\n<few tens of lines skipped here for brevity...>\r\nSuccessfully posted 43947042\t\t\t\t43947042\r\nSuccessfully posted 1378809981\t\t\t\t1378809981\r\nSuccessfully posted 1207164250\t\t\t\t1207164250\r\nSuccessfully posted 364545187\t\t\t\t<I pressed Enter here>\r\nSuccessfully posted 1929071970\t\t\t\t* Stopping server...\r\nSuccessfully posted 1865738035\t\t\t\t364545187\r\nSuccessfully posted 220569898\t\t\t\t1929071970\r\nSuccessfully posted 749776600\t\t\t\t1865738035\r\nSuccessfully posted 605919889\t\t\t\t220569898\r\nSuccessfully posted 1237080960\t\t\t\t749776600\r\nSuccessfully posted 861215939\t\t\t\t605919889\r\nSuccessfully posted 503199557\t\t\t\t1237080960\r\nSuccessfully posted 966993176\t\t\t\t861215939\r\nSuccessfully posted 1651974673\t\t\t\t503199557\r\nSuccessfully posted 890630703\t\t\t\t966993176\r\nSuccessfully posted 955166610\t\t\t\t1651974673\r\nSuccessfully posted 16639733\t\t\t\t890630703\r\nSuccessfully posted 240271742\t\t\t\t955166610\r\nSuccessfully posted 666065921\t\t\t\t16639733\r\nSuccessfully posted 1103401709\t\t\t\t240271742\r\nSuccessfully posted 365783871\t\t\t\t666065921\r\nSuccessfully posted 1189772211\t\t\t\t1103401709\r\nSuccessfully posted 525604376\t\t\t\t365783871\r\nSuccessfully posted 509062528\t\t\t\t1189772211\r\nSuccessfully posted 2128336317\t\t\t\t525604376\r\nSuccessfully posted 589131183\t\t\t\t509062528\r\nSuccessfully posted 1181657040\t\t\t\t2128336317\r\nSuccessfully posted 1875305780\t\t\t\t589131183\r\nSuccessfully posted 2088318575\t\t\t\t1181657040\r\nSuccessfully posted 1204340850\t\t\t\t1875305780\r\nSuccessfully posted 738036583\t\t\t\t2088318575\r\nSuccessfully posted 1087698345\t\t\t\t1204340850\r\nSuccessfully posted 363737784\t\t\t\t738036583\r\nSuccessfully posted 33426829\t\t\t\t1087698345\r\nSuccessfully posted 2142136596\t\t\t\t363737784\r\nSuccessfully posted 416116248\t\t\t\t33426829\r\nSuccessfully posted 1377263354\t\t\t\t2142136596\r\n<I pressed Enter here>\t\t\t\t\t416116248\r\n* Stopping client...\t\t\t\t\t1377263354\r\n* Client stopped. Exiting...\t\t\t\t* Server stopped. Exiting...\r\n```\r\nI marked the moments when I pressed Enter key with the `<I pressed Enter here>` text.\r\nYou can see that I pressed Enter key in the server console and the server said: '* Stopping server...', but continued to work and did so until I pressed Enter in the client console. This made client stop and so did the server.\r\nLooks like the server might ignore stop request in case when there's still incoming data in the socket. Or, am I doing something wrong maybe?\r\nThanks in advance.\n", "hints_text": "@tsilia, thanks for the report. This is a bug in cpp-httplib. I'll take a look at it this weekend. Thanks!", "created_at": "2021-12-11T03:50:19Z", "version": "0.9"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1051, "instance_id": "yhirose__cpp-httplib-1051", "issue_numbers": ["1050"], "base_commit": "3c522386e961d61768ea527d04713b5402356dd4", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1161,6 +1161,8 @@ class Client {\n                   const std::string &client_cert_path,\n                   const std::string &client_key_path);\n \n+  Client(Client &&) = default;\n+\n   ~Client();\n \n   bool is_valid() const;\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -8,6 +8,7 @@\n #include <sstream>\n #include <stdexcept>\n #include <thread>\n+#include <type_traits>\n \n #define SERVER_CERT_FILE \"./cert.pem\"\n #define SERVER_CERT2_FILE \"./cert2.pem\"\n@@ -40,6 +41,11 @@ MultipartFormData &get_file_value(MultipartFormDataItems &files,\n   throw std::runtime_error(\"invalid mulitpart form data name error\");\n }\n \n+TEST(ConstructorTest, MoveConstructible) {\n+  EXPECT_FALSE(std::is_copy_constructible<Client>::value);\n+  EXPECT_TRUE(std::is_nothrow_move_constructible<Client>::value);\n+}\n+\n #ifdef _WIN32\n TEST(StartupTest, WSAStartup) {\n   WSADATA wsaData;\n", "problem_statement": "Add move constructor for Client\nSince `Client` already uses the PIMPL pattern, it seems reasonably to provide a default move constructor for it. This enables classes that have a `Client` member variable to be movable.\r\n\r\nIf using C++11 or later, we only need to add\r\n```c++\r\nClient(Client &&) = default;\r\n```\r\nunless we want to support older standards.\n", "hints_text": "@ZizhengTai, that's a reasonable request even if I don't need it. Could you send me a pull request and a unit test for it? I'll take a look at and merge it right away. Thanks!\n@yhirose In the test, I can either use `static_assert` to fail the test build at compile time if `Client` is not move-constructible, or use `EXPECT_TRUE` to fail the test only at test runtime. Which approach do you prefer? The former fails sooner while the latter outputs the failure together with the rest of the test, which might be desired.", "created_at": "2021-09-16T06:17:13Z", "version": "0.9"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1320, "instance_id": "yhirose__cpp-httplib-1320", "issue_numbers": ["1317"], "base_commit": "caa31aafda38af208ba7a4790d9ab88f741a9687", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -3794,6 +3794,7 @@ class MultipartFormDataParser {\n       switch (state_) {\n       case 0: { // Initial boundary\n         auto pattern = dash_ + boundary_ + crlf_;\n+        buf_erase(buf_find(pattern));\n         if (pattern.size() > buf_size()) { return true; }\n         if (!buf_start_with(pattern)) { return false; }\n         buf_erase(pattern.size());\n@@ -3887,17 +3888,13 @@ class MultipartFormDataParser {\n           if (buf_start_with(pattern)) {\n             buf_erase(pattern.size());\n             is_valid_ = true;\n-            state_ = 5;\n+            buf_erase(buf_size()); // Remove epilogue\n           } else {\n             return true;\n           }\n         }\n         break;\n       }\n-      case 5: { // Done\n-        is_valid_ = false;\n-        return false;\n-      }\n       }\n     }\n \n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -3015,8 +3015,10 @@ TEST(GzipDecompressor, ChunkedDecompression) {\n     httplib::detail::gzip_compressor compressor;\n     bool result = compressor.compress(\n         data.data(), data.size(),\n-        /*last=*/true, [&](const char *compressed_data_chunk, size_t compressed_data_size) {\n-          compressed_data.insert(compressed_data.size(), compressed_data_chunk, compressed_data_size);\n+        /*last=*/true,\n+        [&](const char *compressed_data_chunk, size_t compressed_data_size) {\n+          compressed_data.insert(compressed_data.size(), compressed_data_chunk,\n+                                 compressed_data_size);\n           return true;\n         });\n     ASSERT_TRUE(result);\n@@ -3035,8 +3037,11 @@ TEST(GzipDecompressor, ChunkedDecompression) {\n           std::min(compressed_data.size() - chunk_begin, chunk_size);\n       bool result = decompressor.decompress(\n           compressed_data.data() + chunk_begin, current_chunk_size,\n-          [&](const char *decompressed_data_chunk, size_t decompressed_data_chunk_size) {\n-            decompressed_data.insert(decompressed_data.size(), decompressed_data_chunk, decompressed_data_chunk_size);\n+          [&](const char *decompressed_data_chunk,\n+              size_t decompressed_data_chunk_size) {\n+            decompressed_data.insert(decompressed_data.size(),\n+                                     decompressed_data_chunk,\n+                                     decompressed_data_chunk_size);\n             return true;\n           });\n       ASSERT_TRUE(result);\n@@ -4974,5 +4979,48 @@ TEST(MultipartFormDataTest, LargeData) {\n   svr.stop();\n   t.join();\n }\n+\n+TEST(MultipartFormDataTest, WithPreamble) {\n+  Server svr;\n+  svr.Post(\"/post\", [&](const Request &req, Response &res) {\n+    res.set_content(\"ok\", \"text/plain\");\n+  });\n+\n+  thread t = thread([&] { svr.listen(HOST, PORT); });\n+  while (!svr.is_running()) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+\n+  const std::string body =\n+      \"This is the preamble.  It is to be ignored, though it\\r\\n\"\n+      \"is a handy place for composition agents to include an\\r\\n\"\n+      \"explanatory note to non-MIME conformant readers.\\r\\n\"\n+      \"\\r\\n\"\n+      \"\\r\\n\"\n+      \"--simple boundary\\r\\n\"\n+      \"Content-Disposition: form-data; name=\\\"field1\\\"\\r\\n\"\n+      \"\\r\\n\"\n+      \"value1\\r\\n\"\n+      \"--simple boundary\\r\\n\"\n+      \"Content-Disposition: form-data; name=\\\"field2\\\"; \"\n+      \"filename=\\\"example.txt\\\"\\r\\n\"\n+      \"\\r\\n\"\n+      \"value2\\r\\n\"\n+      \"--simple boundary--\\r\\n\"\n+      \"This is the epilogue.  It is also to be ignored.\\r\\n\";\n+\n+  std::string content_type =\n+      R\"(multipart/form-data; boundary=\"simple boundary\")\";\n+\n+  Client cli(HOST, PORT);\n+  auto res = cli.Post(\"/post\", body, content_type.c_str());\n+\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+\n+  svr.stop();\n+  t.join();\n+}\n+\n #endif\n \n", "problem_statement": "class MultipartFormDataParser cannot handle content starts with 2 CRLF\n**Description:**\r\n\r\nwhen handling multipart/form-data content, function `httplib::detail::MultipartFormDataParser::parse()` will fail contents that does not start with the boundary delimiter (line #3798).\r\n\r\nhttps://github.com/yhirose/cpp-httplib/blob/caa31aafda38af208ba7a4790d9ab88f741a9687/httplib.h#L3796-L3798\r\n\r\nexample multipart/form-data content:\r\n```\r\n\\r\\n\\r\\n------53014704754052338\\r\\nContent-Disposition: form-data; name=\\\"file\\\"; filename=\\\"346ba067e51efc5f.jpg\\\"\\r\\nContent-Type: image/jpeg\\r\\n\\r\\n\\377\\330\\377............\r\n```\r\n\r\nAbove form-data work perfectly with other websites.\r\n\r\nHowever, I think [RFC 2046](https://www.rfc-editor.org/rfc/rfc2046.txt) acquiesce CRLF preceding the boundary delimiter line\r\n> The CRLF preceding the boundary delimiter line is conceptually\r\n   attached to the boundary\r\n\r\nIs this a bug? Or I misunderstand how boundary delimiter works?\r\n\r\n**Possible fix:**\r\n\r\nmaybe left trim all the CRLFs before parsing form-data?\r\n\n", "hints_text": "@Gavin1937, thank you for the report. Could you show me entire your multipart/form-data including `Content-Type: multipart/form-data; boundary=----53014704754052338`?\nThank you for your reply. Here is a netcat dump of my request:\r\n[out.txt](https://github.com/yhirose/cpp-httplib/files/9068386/out.txt)\r\n\r\n\n@Gavin1937, I took a look at RFC 2046 carefully. It turned out that I forgot to skip 'preamble` text.\r\n\r\n>    There appears to be room for additional information prior to the\r\n>    first boundary delimiter line and following the final boundary\r\n>    delimiter line.  These areas should generally be left blank, and\r\n>    implementations must ignore anything that appears before the first\r\n>    boundary delimiter line or after the last one.\r\n> \r\n>    NOTE:  These \"preamble\" and \"epilogue\" areas are generally not used\r\n>    because of the lack of proper typing of these parts and the lack of\r\n>    clear semantics for handling these areas at gateways, particularly\r\n>    X.400 gateways.  However, rather than leaving the preamble area\r\n>    blank, many MIME implementations have found this to be a convenient\r\n> \r\n\r\nHere is the example showing 'preamble' and 'epilogue' in RFC 2046:\r\n\r\n```\r\nFrom: Nathaniel Borenstein <nsb@bellcore.com>\r\nTo: Ned Freed <ned@innosoft.com>\r\nDate: Sun, 21 Mar 1993 23:56:48 -0800 (PST)\r\nSubject: Sample message\r\nMIME-Version: 1.0\r\nContent-type: multipart/mixed; boundary=\"simple boundary\"\r\n\r\nThis is the preamble.  It is to be ignored, though it\r\nis a handy place for composition agents to include an\r\nexplanatory note to non-MIME conformant readers.\r\n\r\n--simple boundary\r\n\r\nThis is implicitly typed plain US-ASCII text.\r\nIt does NOT end with a linebreak.\r\n--simple boundary\r\nContent-type: text/plain; charset=us-ascii\r\n\r\nThis is explicitly typed plain US-ASCII text.\r\nIt DOES end with a linebreak.\r\n\r\n--simple boundary--\r\n\r\nThis is the epilogue.  It is also to be ignored.\r\n```\r\n\r\nI'll try to handle the format correctly according to the spec when I have time.\r\nThanks again for your fine report.\nThank you for your work!", "created_at": "2022-07-08T21:11:36Z", "version": "0.10"}
{"repo": "yhirose/cpp-httplib", "pull_number": 342, "instance_id": "yhirose__cpp-httplib-342", "issue_numbers": ["341"], "base_commit": "89740a808d934cd77c184423a8e6398d1b1ea6f2", "patch": "diff --git a/example/simplesvr.cc b/example/simplesvr.cc\n--- a/example/simplesvr.cc\n+++ b/example/simplesvr.cc\n@@ -122,7 +122,7 @@ int main(int argc, const char **argv) {\n   auto base_dir = \"./\";\n   if (argc > 2) { base_dir = argv[2]; }\n \n-  if (!svr.set_base_dir(base_dir)) {\n+  if (!svr.set_mount_point(base_dir, \"/\")) {\n     cout << \"The specified base directory doesn't exist...\";\n     return 1;\n   }\ndiff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -465,7 +465,9 @@ class Server {\n   Server &Delete(const char *pattern, Handler handler);\n   Server &Options(const char *pattern, Handler handler);\n \n-  bool set_base_dir(const char *dir, const char *mount_point = nullptr);\n+  [[deprecated]] bool set_base_dir(const char *dir, const char *mount_point = nullptr);\n+  bool set_mount_point(const char *dir, const char *mount_point);\n+  bool remove_mount_point(const char *mount_point);\n   void set_file_extension_and_mimetype_mapping(const char *ext,\n                                                const char *mime);\n   void set_file_request_handler(Handler handler);\n@@ -2889,6 +2891,10 @@ inline Server &Server::Options(const char *pattern, Handler handler) {\n }\n \n inline bool Server::set_base_dir(const char *dir, const char *mount_point) {\n+  return  set_mount_point(dir, mount_point);\n+}\n+\n+inline bool Server::set_mount_point(const char *dir, const char *mount_point) {\n   if (detail::is_dir(dir)) {\n     std::string mnt = mount_point ? mount_point : \"/\";\n     if (!mnt.empty() && mnt[0] == '/') {\n@@ -2899,6 +2905,16 @@ inline bool Server::set_base_dir(const char *dir, const char *mount_point) {\n   return false;\n }\n \n+inline bool Server::remove_mount_point(const char *mount_point) {\n+  for (auto it = base_dirs_.begin(); it != base_dirs_.end(); ++it) {\n+      if (it->first == mount_point) {\n+          base_dirs_.erase(it);\n+          return true;\n+      }\n+  }\n+  return false;\n+}\n+\n inline void Server::set_file_extension_and_mimetype_mapping(const char *ext,\n                                                             const char *mime) {\n   file_extension_and_mimetype_map_[ext] = mime;\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -662,8 +662,8 @@ class ServerTest : public ::testing::Test {\n   }\n \n   virtual void SetUp() {\n-    svr_.set_base_dir(\"./www\");\n-    svr_.set_base_dir(\"./www2\", \"/mount\");\n+    svr_.set_mount_point(\"./www\", \"/\");\n+    svr_.set_mount_point(\"./www2\", \"/mount\");\n     svr_.set_file_extension_and_mimetype_mapping(\"abcde\", \"text/abcde\");\n \n     svr_.Get(\"/hi\",\n@@ -1245,7 +1245,7 @@ TEST_F(ServerTest, UserDefinedMIMETypeMapping) {\n }\n \n TEST_F(ServerTest, InvalidBaseDirMount) {\n-  EXPECT_EQ(false, svr_.set_base_dir(\"./www3\", \"invalid_mount_point\"));\n+  EXPECT_EQ(false, svr_.set_mount_point(\"./www3\", \"invalid_mount_point\"));\n }\n \n TEST_F(ServerTest, EmptyRequest) {\n@@ -2069,6 +2069,50 @@ TEST(ServerStopTest, StopServerWithChunkedTransmission) {\n   ASSERT_FALSE(svr.is_running());\n }\n \n+TEST(MountTest, Unmount) {\n+  Server svr;\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(\"localhost\", PORT); });\n+  while (!svr.is_running()) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+\n+  // Give GET time to get a few messages.\n+  std::this_thread::sleep_for(std::chrono::seconds(1));\n+\n+  Client cli(\"localhost\", PORT);\n+\n+  svr.set_mount_point(\"./www2\", \"/mount2\");\n+\n+  auto res = cli.Get(\"/\");\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(404, res->status);\n+\n+  res = cli.Get(\"/mount2/dir/test.html\");\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(200, res->status);\n+\n+  svr.set_mount_point(\"./www\", \"/\");\n+\n+  res = cli.Get(\"/dir/\");\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(200, res->status);\n+\n+  svr.remove_mount_point(\"/\");\n+  res = cli.Get(\"/dir/\");\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(404, res->status);\n+\n+  svr.remove_mount_point(\"/mount2\");\n+  res = cli.Get(\"/mount2/dir/test.html\");\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(404, res->status);\n+\n+  svr.stop();\n+  listen_thread.join();\n+  ASSERT_FALSE(svr.is_running());\n+}\n+\n class ServerTestWithAI_PASSIVE : public ::testing::Test {\n protected:\n   ServerTestWithAI_PASSIVE()\n", "problem_statement": "Allow to remove base directories in runtime\n`set_base_dir()` allows adding new directories, but there is no way to remove them.\r\n\r\nSome kind of `remove_base_dir(prefix)` or `remove_mount_point(mount_point)` could address this. I think the function should take prefix, and not path, because the same directory can be added under different prefixes.\n", "hints_text": "@trollixx, thanks for the feedback. I just wonder when you need to call the `remove_???` methods? Do you want to call them **before** or **after** a server starts?\r\n\r\nIf it's **before**, there is no problem adding and using those methods.\r\n\r\nBut if it' **after**, we have to do it in a different thread. That means that the server now needs to project `base_dirs_` member variable in `handle_file_request` with a `std::mutex` which could cause really bad performance and the server can no longer accepts simultaneous requests effectively.\nUnfortunately, `std::shared_mutex` was only added in C++17 and is not available in C++11. May be possible to reproduce its features with semaphores or flags though.  \r\nAlternatively there is `std::shared_future` which has a blocking `get()` but it may reduce performance of the server because of extra copy operations.\nI am trying to use `cpp-httplib` to serve content locally in [my project](https://github.com/zealdocs/zeal). It's a documentation manager, and docsets (basically bundles of HTML pages) can be installed and removed at any time. I have added `remove_mount_point` function, and ignored thread safety for the initial implementation (see zealdocs/zeal#1182, specifically commit `unmount HTTP server prefix on docset removal`), and it seems to work as desired.\r\n\r\nI think that due to the way Zeal works it's not even possible to trigger issues from the lack of synchronization between threads, but before merging the PR I am planning to address that. Performance drawbacks are not a concern in this use case, in the end it's a single user application.\nThe race condition should only occur if a client attempts to send the server a request at the exact moment that any mount point is changed. But when that occurs there will likely be a segfault.  \r\nAlso note that threads and clients will not always have a one-to-one ratio. Some web browsers, in order to speed up webpage loading times, will load page assets (e.g. images and other media, stylesheets etc) in parallel using multiple connections. When doing so they will use multiple threads on the server.  \r\n", "created_at": "2020-02-01T01:36:11Z", "version": "0.5"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1046, "instance_id": "yhirose__cpp-httplib-1046", "issue_numbers": ["1023"], "base_commit": "e3e28c623165f9965efd2abbb7a31891c0fad684", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1671,6 +1671,10 @@ bool parse_range_header(const std::string &s, Ranges &ranges);\n \n int close_socket(socket_t sock);\n \n+ssize_t send_socket(socket_t sock, const void *ptr, size_t size, int flags);\n+\n+ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags);\n+\n enum class EncodingType { None = 0, Gzip, Brotli };\n \n EncodingType encoding_type(const Request &req, const Response &res);\n@@ -2189,6 +2193,34 @@ template <typename T> inline ssize_t handle_EINTR(T fn) {\n   return res;\n }\n \n+inline ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags) {\n+  return handle_EINTR([&]() {\n+    return recv(sock,\n+#ifdef _WIN32\n+                static_cast<char *>(ptr),\n+                static_cast<int>(size),\n+#else\n+                ptr,\n+                size,\n+#endif\n+                flags);\n+  });\n+}\n+\n+inline ssize_t send_socket(socket_t sock, const void *ptr, size_t size, int flags) {\n+  return handle_EINTR([&]() {\n+    return send(sock,\n+#ifdef _WIN32\n+                static_cast<const char *>(ptr),\n+                static_cast<int>(size),\n+#else\n+                ptr,\n+                size,\n+#endif\n+                flags);\n+  });\n+}\n+\n inline ssize_t select_read(socket_t sock, time_t sec, time_t usec) {\n #ifdef CPPHTTPLIB_USE_POLL\n   struct pollfd pfd_read;\n@@ -2313,6 +2345,12 @@ class SocketStream : public Stream {\n   time_t read_timeout_usec_;\n   time_t write_timeout_sec_;\n   time_t write_timeout_usec_;\n+\n+  std::vector<char> read_buff_;\n+  size_t read_buff_off_ = 0;\n+  size_t read_buff_content_size_ = 0;\n+\n+  static const size_t read_buff_size_ = 1024 * 4;\n };\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n@@ -4368,7 +4406,8 @@ inline SocketStream::SocketStream(socket_t sock, time_t read_timeout_sec,\n     : sock_(sock), read_timeout_sec_(read_timeout_sec),\n       read_timeout_usec_(read_timeout_usec),\n       write_timeout_sec_(write_timeout_sec),\n-      write_timeout_usec_(write_timeout_usec) {}\n+      write_timeout_usec_(write_timeout_usec),\n+      read_buff_(read_buff_size_, 0) {}\n \n inline SocketStream::~SocketStream() {}\n \n@@ -4381,31 +4420,56 @@ inline bool SocketStream::is_writable() const {\n }\n \n inline ssize_t SocketStream::read(char *ptr, size_t size) {\n-  if (!is_readable()) { return -1; }\n-\n #ifdef _WIN32\n-  if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {\n-    return -1;\n-  }\n-  return recv(sock_, ptr, static_cast<int>(size), CPPHTTPLIB_RECV_FLAGS);\n+  size = std::min(size, static_cast<size_t>((std::numeric_limits<int>::max)()));\n #else\n-  return handle_EINTR(\n-      [&]() { return recv(sock_, ptr, size, CPPHTTPLIB_RECV_FLAGS); });\n+  size = std::min(size, static_cast<size_t>((std::numeric_limits<ssize_t>::max)()));\n #endif\n+\n+  if (read_buff_off_ < read_buff_content_size_) {\n+    auto remaining_size = read_buff_content_size_ - read_buff_off_;\n+    if (size <= remaining_size) {\n+      memcpy(ptr, read_buff_.data() + read_buff_off_, size);\n+      read_buff_off_ += size;\n+      return static_cast<ssize_t>(size);\n+    } else {\n+      memcpy(ptr, read_buff_.data() + read_buff_off_, remaining_size);\n+      read_buff_off_ += remaining_size;\n+      return static_cast<ssize_t>(remaining_size);\n+    }\n+  }\n+\n+  if (!is_readable()) { return -1; }\n+\n+  read_buff_off_ = 0;\n+  read_buff_content_size_ = 0;\n+\n+  if (size < read_buff_size_) {\n+    auto n = read_socket(sock_, read_buff_.data(), read_buff_size_, CPPHTTPLIB_RECV_FLAGS);\n+    if (n <= 0) {\n+      return n;\n+    } else if (n <= static_cast<ssize_t>(size)) {\n+      memcpy(ptr, read_buff_.data(), static_cast<size_t>(n));\n+      return n;\n+    } else {\n+      memcpy(ptr, read_buff_.data(), size);\n+      read_buff_off_ = size;\n+      read_buff_content_size_ = static_cast<size_t>(n);\n+      return static_cast<ssize_t>(size);\n+    }\n+  } else {\n+    return read_socket(sock_, ptr, size, CPPHTTPLIB_RECV_FLAGS);\n+  }\n }\n \n inline ssize_t SocketStream::write(const char *ptr, size_t size) {\n   if (!is_writable()) { return -1; }\n \n #ifdef _WIN32\n-  if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {\n-    return -1;\n-  }\n-  return send(sock_, ptr, static_cast<int>(size), CPPHTTPLIB_SEND_FLAGS);\n-#else\n-  return handle_EINTR(\n-      [&]() { return send(sock_, ptr, size, CPPHTTPLIB_SEND_FLAGS); });\n+  size = std::min(size, static_cast<size_t>((std::numeric_limits<int>::max)()));\n #endif\n+\n+  return send_socket(sock_, ptr, size, CPPHTTPLIB_SEND_FLAGS);\n }\n \n inline void SocketStream::get_remote_ip_and_port(std::string &ip,\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1349,11 +1349,13 @@ class ServerTest : public ::testing::Test {\n                std::this_thread::sleep_for(std::chrono::seconds(2));\n                res.set_content(\"slow\", \"text/plain\");\n              })\n+#if 0\n         .Post(\"/slowpost\",\n               [&](const Request & /*req*/, Response &res) {\n                 std::this_thread::sleep_for(std::chrono::seconds(2));\n                 res.set_content(\"slow\", \"text/plain\");\n               })\n+#endif\n         .Get(\"/remote_addr\",\n              [&](const Request &req, Response &res) {\n                auto remote_addr = req.headers.find(\"REMOTE_ADDR\")->second;\n@@ -2623,6 +2625,7 @@ TEST_F(ServerTest, SlowRequest) {\n       std::thread([=]() { auto res = cli_.Get(\"/slow\"); }));\n }\n \n+#if 0\n TEST_F(ServerTest, SlowPost) {\n   char buffer[64 * 1024];\n   memset(buffer, 0x42, sizeof(buffer));\n@@ -2640,7 +2643,6 @@ TEST_F(ServerTest, SlowPost) {\n   EXPECT_EQ(200, res->status);\n }\n \n-#if 0\n TEST_F(ServerTest, SlowPostFail) {\n   char buffer[64 * 1024];\n   memset(buffer, 0x42, sizeof(buffer));\n@@ -3564,10 +3566,12 @@ TEST(StreamingTest, NoContentLengthStreaming) {\n   Client client(HOST, PORT);\n \n   auto get_thread = std::thread([&client]() {\n-    auto res = client.Get(\"/stream\", [](const char *data, size_t len) -> bool {\n-      EXPECT_EQ(\"aaabbb\", std::string(data, len));\n+    std::string s;\n+    auto res = client.Get(\"/stream\", [&s](const char *data, size_t len) -> bool {\n+      s += std::string(data, len);\n       return true;\n     });\n+    EXPECT_EQ(\"aaabbb\", s);\n   });\n \n   // Give GET time to get a few messages.\n", "problem_statement": "Getline/header parsing is very inefficient\nIt reads one byte from the stream: https://github.com/yhirose/cpp-httplib/blob/a58f0426148daef861e4eaf43548784d340a8ad6/httplib.h#L2133\r\nThis triggers one select + recv() system call on linux for each byte.\n", "hints_text": "I also don't understand why there is a `select` for a single socket. Why not just block on the socket and use `read`?\n@Mic92, sorry that this library doesn't meet your performance requirement. Let me explain the background of this library a bit. This library started to provide a solution to embed HTTP functionalities in desktop applications at my workplace. The performance wasn't a priority, rather I focused on how easily the HTTP client/server capabilities can be added to applications. That's why I keep this library as a simple single header-only library.\r\n\r\n> This triggers one select + recv() system call on linux for each byte.\r\n\r\nYou are absolutely right. If there is an easy way to do buffering in `SocketStream` class, I think we can reduce the `recv` and `select` calls with a small change just within the class. (I believe `SSLSocketStream::read` is ok, because it uses OpenSSL BIO underneath.) I don't have time to work on the improvement right now, but I would very much appreciate if you could work on it and send a pull request. :)\r\n\r\n> I also don't understand why there is a select for a single socket. Why not just block on the socket and use read?\r\n\r\nI was trying to provide a reliable socket 'time out' detection. I tried some different ways, but `select` was the most reliable way working on various operating systems. If you have a better idea which is guaranteed to work on Windows, Mac and Linux OSs, please let me know. (You can also see how we got to this solution in the past issues and unit test cases.)\r\n\r\nIf you need a performance intensive cross-platform HTTP functionality, why not use [drogon](https://github.com/drogonframework/drogon) instead?\r\n\r\nThank you for bring the attention to this matter!\r\n\r\n\r\n\r\n\r\n\r\n\nfair enough. Drogon it is. Using socket option one can usually set timeouts on connections.\n> Using socket option one can usually set timeouts on connections. \r\n\r\nhttps://github.com/yhirose/cpp-httplib/blob/a58f0426148daef861e4eaf43548784d340a8ad6/httplib.h#L2595\r\n\r\nBut some socket options like `SO_RCVTIMEO` above don't work or aren't stable as they advertise on some OSs. That's the real world unfortunately...\r\nhttps://github.com/yhirose/cpp-httplib/issues/34#issuecomment-354512631\r\n\r\nEven `select` isn't perfect for all the situations. So sometimes, users need to chose `poll` with `CPPHTTPLIB_USE_POLL` for timeout.\r\n\n@Mic92, approximately how much slower do you think this library is than other HTTP libraries? Is it very much noticeable in any cases, or only on some situations where the performance is really critical? Thanks for you comment since I don't have any experience of using other HTTP libraries. :)\nI don't have very complex applications written for cpp-httplib,\r\nbut let's just do this simple comparison with go http server from the standard library:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"log\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc handler(w http.ResponseWriter, r *http.Request) {\r\n    fmt.Fprintf(w, \"Hello world!\")\r\n}\r\n\r\nfunc main() {\r\n    http.HandleFunc(\"/some/random/url/lets/see/how/it/goes\", handler)\r\n    log.Fatal(http.ListenAndServe(\":1234\", nil))\r\n}\r\n```\r\n\r\n```cpp\r\n#include \"httplib.h\"\r\n\r\nint main() {\r\n    using namespace httplib;\r\n    Server svr;\r\n    svr.Get(\"/some/random/url/lets/see/how/it/goes\", [](const Request &req, Response &res) {\r\n      res.set_content(\"Hello World!\", \"text/plain\");\r\n    });\r\n    svr.listen(\"localhost\", 1234);\r\n}\r\n```\r\n\r\nAnd benchmark with `wrk`:\r\n\r\n```console\r\n$ wrk http://localhost:1234/some/random/url/lets/see/how/it/goes\r\n```\r\n\r\nResult for cpp-httplib:\r\n\r\n```\r\nRunning 10s test @ http://localhost:1234/some/random/url/lets/see/how/it/goes\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency   342.05us    5.20ms 202.06ms   99.81%\r\n    Req/Sec    26.13k     4.31k   37.27k    66.00%\r\n  519796 requests in 10.00s, 51.95MB read\r\nRequests/sec:  51973.49\r\nTransfer/sec:      5.19MB\r\n```\r\n\r\nResult for golang:\r\n\r\n```\r\nRunning 10s test @ http://localhost:1234/some/random/url/lets/see/how/it/goes\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency    60.79us  127.00us   9.54ms   96.16%\r\n    Req/Sec   102.96k     9.79k  122.31k    62.38%\r\n  2067862 requests in 10.10s, 254.40MB read\r\nRequests/sec: 204752.15\r\nTransfer/sec:     25.19MB\r\n```\r\n\r\nI am surprised it's only 4 times slower on my laptop with an 8 hyper-threads i7... I think it becomes slower as soon as you start adding a real-world amount of headers and browser cookies. I mean yeah compared to some python server it's probably still some magnitudes faster, however I don't think a classical select + read http server would be more code than the current implementation.\r\n\r\nChears.\n@Mic92, thanks for the very helpful information. When I have time, I'll try to implement buffering in `SocketStream` to increase performance. Thanks for your fine contribution!", "created_at": "2021-09-11T21:00:23Z", "version": "0.9"}
{"repo": "yhirose/cpp-httplib", "pull_number": 546, "instance_id": "yhirose__cpp-httplib-546", "issue_numbers": ["534"], "base_commit": "887def949008d8b2ceb3d7d9b001c60f80d5e840", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -152,6 +152,8 @@ using ssize_t = int;\n \n #ifdef _MSC_VER\n #pragma comment(lib, \"ws2_32.lib\")\n+#pragma comment(lib, \"crypt32.lib\")\n+#pragma comment(lib, \"cryptui.lib\")\n #endif\n \n #ifndef strcasecmp\n@@ -1062,6 +1064,8 @@ class SSLClient : public Client {\n   bool connect_with_proxy(Socket &sock, Response &res, bool &success);\n   bool initialize_ssl(Socket &socket);\n \n+  bool load_certs();\n+\n   bool verify_host(X509 *server_cert) const;\n   bool verify_host_with_subject_alt_name(X509 *server_cert) const;\n   bool verify_host_with_common_name(X509 *server_cert) const;\n@@ -1069,12 +1073,14 @@ class SSLClient : public Client {\n \n   SSL_CTX *ctx_;\n   std::mutex ctx_mutex_;\n+  std::once_flag initialize_cert_;\n+\n   std::vector<std::string> host_components_;\n \n   std::string ca_cert_file_path_;\n   std::string ca_cert_dir_path_;\n   X509_STORE *ca_cert_store_ = nullptr;\n-  bool server_certificate_verification_ = false;\n+  bool server_certificate_verification_ = true;\n   long verify_result_ = 0;\n \n   friend class Client;\n@@ -1313,9 +1319,7 @@ class Client2 {\n \n   void stop() { cli_->stop(); }\n \n-  void set_tcp_nodelay(bool on) {\n-    cli_->set_tcp_nodelay(on);\n-  }\n+  void set_tcp_nodelay(bool on) { cli_->set_tcp_nodelay(on); }\n \n   void set_socket_options(SocketOptions socket_options) {\n     cli_->set_socket_options(socket_options);\n@@ -2776,7 +2780,7 @@ inline std::string params_to_query_str(const Params &params) {\n     if (it != params.begin()) { query += \"&\"; }\n     query += it->first;\n     query += \"=\";\n-    query += detail::encode_url(it->second);\n+    query += encode_url(it->second);\n   }\n \n   return query;\n@@ -3223,6 +3227,33 @@ inline std::string SHA_512(const std::string &s) {\n #endif\n \n #ifdef _WIN32\n+#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+// NOTE: This code came up with the following stackoverflow post:\n+// https://stackoverflow.com/questions/9507184/can-openssl-on-windows-use-the-system-certificate-store\n+inline bool load_system_certs_on_windows(X509_STORE *store) {\n+  auto hStore = CertOpenSystemStore((HCRYPTPROV_LEGACY)NULL, L\"ROOT\");\n+\n+  if (!hStore) { return false; }\n+\n+  PCCERT_CONTEXT pContext = NULL;\n+  while (pContext = CertEnumCertificatesInStore(hStore, pContext)) {\n+    auto encoded_cert =\n+        static_cast<const unsigned char *>(pContext->pbCertEncoded);\n+\n+    auto x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);\n+    if (x509) {\n+      X509_STORE_add_cert(store, x509);\n+      X509_free(x509);\n+    }\n+  }\n+\n+  CertFreeCertificateContext(pContext);\n+  CertCloseStore(hStore, 0);\n+\n+  return true;\n+}\n+#endif\n+\n class WSInit {\n public:\n   WSInit() {\n@@ -5543,23 +5574,44 @@ inline bool SSLClient::connect_with_proxy(Socket &socket, Response &res,\n   return true;\n }\n \n+inline bool SSLClient::load_certs() {\n+  bool ret = true;\n+\n+  std::call_once(initialize_cert_, [&]() {\n+    std::lock_guard<std::mutex> guard(ctx_mutex_);\n+    if (!ca_cert_file_path_.empty()) {\n+      if (!SSL_CTX_load_verify_locations(ctx_, ca_cert_file_path_.c_str(),\n+                                         nullptr)) {\n+        ret = false;\n+      }\n+    } else if (!ca_cert_dir_path_.empty()) {\n+      if (!SSL_CTX_load_verify_locations(ctx_, nullptr,\n+                                         ca_cert_dir_path_.c_str())) {\n+        ret = false;\n+      }\n+    } else if (ca_cert_store_ != nullptr) {\n+      if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store_) {\n+        SSL_CTX_set_cert_store(ctx_, ca_cert_store_);\n+      }\n+    } else {\n+#ifdef _WIN32\n+      detail::load_system_certs_on_windows(SSL_CTX_get_cert_store(ctx_));\n+#else\n+      SSL_CTX_set_default_verify_paths(ctx_);\n+#endif\n+    }\n+  });\n+\n+  return ret;\n+}\n+\n inline bool SSLClient::initialize_ssl(Socket &socket) {\n   auto ssl = detail::ssl_new(\n       socket.sock, ctx_, ctx_mutex_,\n       [&](SSL *ssl) {\n-        if (ca_cert_file_path_.empty() && ca_cert_store_ == nullptr) {\n-          SSL_CTX_set_verify(ctx_, SSL_VERIFY_NONE, nullptr);\n-        } else if (!ca_cert_file_path_.empty()) {\n-          if (!SSL_CTX_load_verify_locations(ctx_, ca_cert_file_path_.c_str(),\n-                                             nullptr)) {\n-            return false;\n-          }\n-          SSL_CTX_set_verify(ctx_, SSL_VERIFY_PEER, nullptr);\n-        } else if (ca_cert_store_ != nullptr) {\n-          if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store_) {\n-            SSL_CTX_set_cert_store(ctx_, ca_cert_store_);\n-          }\n-          SSL_CTX_set_verify(ctx_, SSL_VERIFY_PEER, nullptr);\n+        if (server_certificate_verification_) {\n+          if (!load_certs()) { return false; }\n+          SSL_set_verify(ssl, SSL_VERIFY_NONE, nullptr);\n         }\n \n         if (SSL_connect(ssl) != 1) { return false; }\n@@ -5749,3 +5801,5 @@ inline bool SSLClient::check_host_name(const char *pattern,\n } // namespace httplib\n \n #endif // CPPHTTPLIB_HTTPLIB_H\n+\n+\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -765,6 +765,9 @@ class ServerTest : public ::testing::Test {\n         svr_(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE)\n #endif\n   {\n+#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+    cli_.enable_server_certificate_verification(false);\n+#endif\n   }\n \n   virtual void SetUp() {\n@@ -2627,6 +2630,9 @@ class ServerTestWithAI_PASSIVE : public ::testing::Test {\n         svr_(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE)\n #endif\n   {\n+#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+    cli_.enable_server_certificate_verification(false);\n+#endif\n   }\n \n   virtual void SetUp() {\n@@ -2704,6 +2710,9 @@ class PayloadMaxLengthTest : public ::testing::Test {\n         svr_(SERVER_CERT_FILE, SERVER_PRIVATE_KEY_FILE)\n #endif\n   {\n+#ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+    cli_.enable_server_certificate_verification(false);\n+#endif\n   }\n \n   virtual void SetUp() {\n@@ -2763,6 +2772,7 @@ TEST(SSLClientTest, ServerCertificateVerification1) {\n TEST(SSLClientTest, ServerCertificateVerification2) {\n   SSLClient cli(\"google.com\");\n   cli.enable_server_certificate_verification(true);\n+  cli.set_ca_cert_path(\"hello\");\n   auto res = cli.Get(\"/\");\n   ASSERT_TRUE(res == nullptr);\n }\n@@ -2819,8 +2829,10 @@ TEST(SSLClientServerTest, ClientCertPresent) {\n   std::this_thread::sleep_for(std::chrono::milliseconds(1));\n \n   httplib::SSLClient cli(HOST, PORT, CLIENT_CERT_FILE, CLIENT_PRIVATE_KEY_FILE);\n-  auto res = cli.Get(\"/test\");\n+  cli.enable_server_certificate_verification(false);\n   cli.set_connection_timeout(30);\n+\n+  auto res = cli.Get(\"/test\");\n   ASSERT_TRUE(res != nullptr);\n   ASSERT_EQ(200, res->status);\n \n@@ -2888,8 +2900,10 @@ TEST(SSLClientServerTest, MemoryClientCertPresent) {\n   std::this_thread::sleep_for(std::chrono::milliseconds(1));\n \n   httplib::SSLClient cli(HOST, PORT, client_cert, client_private_key);\n-  auto res = cli.Get(\"/test\");\n+  cli.enable_server_certificate_verification(false);\n   cli.set_connection_timeout(30);\n+\n+  auto res = cli.Get(\"/test\");\n   ASSERT_TRUE(res != nullptr);\n   ASSERT_EQ(200, res->status);\n \n@@ -2934,8 +2948,10 @@ TEST(SSLClientServerTest, TrustDirOptional) {\n   std::this_thread::sleep_for(std::chrono::milliseconds(1));\n \n   httplib::SSLClient cli(HOST, PORT, CLIENT_CERT_FILE, CLIENT_PRIVATE_KEY_FILE);\n-  auto res = cli.Get(\"/test\");\n+  cli.enable_server_certificate_verification(false);\n   cli.set_connection_timeout(30);\n+\n+  auto res = cli.Get(\"/test\");\n   ASSERT_TRUE(res != nullptr);\n   ASSERT_EQ(200, res->status);\n \n", "problem_statement": "Use OpenSSL default when certificate location not set\nAlso, do not disable certificate verification when using default OpenSSL\r\ncertificate location. This is a pretty reasonable default setting for\r\nsecurity.\n", "hints_text": "@jp39, thanks for the pull request, but there are a number of unit test cases failed. (Some tests are failing right now due to [the httpbin.org issue](https://github.com/postmanlabs/httpbin/issues/617), but it seems like this pull request breaks other unit tests...)\n@jp39, any update about the build errors? Thanks!\n@yhirose, there are a few tests failing already for me even on the master branch:\r\n\r\n```\r\n[  FAILED  ] 3 tests, listed below:\r\n[  FAILED  ] ChunkedEncodingTest.WithResponseHandlerAndContentReceiver\r\n[  FAILED  ] BaseAuthTest.FromHTTPWatch\r\n[  FAILED  ] DigestAuthTest.FromHTTPWatch\r\n\r\n 3 FAILED TESTS\r\n```\r\n\r\nNow, with my patch, I see these failing:\r\n\r\n```\r\n[  FAILED  ] 8 tests, listed below:\r\n[  FAILED  ] ServerTest.GetMethod302Redirect\r\n[  FAILED  ] ServerTest.PostMethod1\r\n[  FAILED  ] ServerTest.PostMethod2\r\n[  FAILED  ] ServerTest.PutMethod3\r\n[  FAILED  ] ServerTest.PostMethod303Redirect\r\n[  FAILED  ] ServerTest.KeepAlive\r\n[  FAILED  ] PayloadMaxLengthTest.ExceedLimit\r\n[  FAILED  ] SSLClientTest.ServerCertificateVerification2\r\n\r\n 8 FAILED TESTS\r\n```\r\n\r\nThis is very curious because my change is only located in the SSLClient class. So I can't see why it would make the Server fail.\r\n\r\nThe  SSLClientTest.ServerCertificateVerification2 test should probably be removed though because it's asserting that the certificate verfication fails when doing a GET on a google URL.\n@jp39, thanks for the report. But all unit tests in the master branch on CIs (Github actions and AppVeyor) pass successfully. It seems further careful investigation is needed to include the pull request. Thanks for your efforts!\nYeah, I'll take a deeper look into it when I get the chance. Also, I intend to update my PR a little if you agree:\r\n\r\n1) What do you think about enabling server certificate verification by default (`server_certificate_verification_` to `true`) ? I suppose we would need to update some of the test case, and some of the examples in the README too.\r\n\r\n2) The way I understand what `SSL_CTX_set_verify` does (but I may be wrong), is that it forces the TLS handshake to fail if the server certificate verification fails, when set to SSL_VERIFY_PEER. But this is redundant with verifying the server certificate manually, as it's currently done in `SSLClient::initialize_ssl` when we call `SSL_get_verify_result`. What do you think of using `SSL_VERIFY_NONE` everywhere in `SSLClient::initialize_ssl` (unless my understanding of `SSL_CTX_set_verify` is not correct)  ?\r\n\r\n", "created_at": "2020-07-01T00:35:18Z", "version": "0.7"}
{"repo": "yhirose/cpp-httplib", "pull_number": 835, "instance_id": "yhirose__cpp-httplib-835", "issue_numbers": ["831"], "base_commit": "59f5fdbb332d74750b61e7f7255d1ff0f991bf83", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -639,7 +639,7 @@ class Server {\n                        Headers headers = Headers());\n   bool remove_mount_point(const char *mount_point);\n   Server &set_file_extension_and_mimetype_mapping(const char *ext,\n-                                               const char *mime);\n+                                                  const char *mime);\n   Server &set_file_request_handler(Handler handler);\n \n   Server &set_error_handler(HandlerWithReturn handler);\n@@ -835,6 +835,14 @@ class ClientImpl {\n              ResponseHandler response_handler, ContentReceiver content_receiver,\n              Progress progress);\n \n+  Result Get(const char *path, const Params &params, const Headers &headers,\n+             Progress progress = nullptr);\n+  Result Get(const char *path, const Params &params, const Headers &headers,\n+             ContentReceiver content_receiver, Progress progress = nullptr);\n+  Result Get(const char *path, const Params &params, const Headers &headers,\n+             ResponseHandler response_handler, ContentReceiver content_receiver,\n+             Progress progress = nullptr);\n+\n   Result Head(const char *path);\n   Result Head(const char *path, const Headers &headers);\n \n@@ -1128,6 +1136,14 @@ class Client {\n   Result Get(const char *path, ResponseHandler response_handler,\n              ContentReceiver content_receiver, Progress progress);\n \n+  Result Get(const char *path, const Params &params, const Headers &headers,\n+             Progress progress = nullptr);\n+  Result Get(const char *path, const Params &params, const Headers &headers,\n+             ContentReceiver content_receiver, Progress progress = nullptr);\n+  Result Get(const char *path, const Params &params, const Headers &headers,\n+             ResponseHandler response_handler, ContentReceiver content_receiver,\n+             Progress progress = nullptr);\n+\n   Result Head(const char *path);\n   Result Head(const char *path, const Headers &headers);\n \n@@ -3125,6 +3141,14 @@ inline std::string params_to_query_str(const Params &params) {\n   return query;\n }\n \n+inline std::string append_query_params(const char *path, const Params &params) {\n+  std::string path_with_query = path;\n+  const static std::regex re(\"[^?]+\\\\?.*\");\n+  auto delm = std::regex_match(path, re) ? '&' : '?';\n+  path_with_query += delm + params_to_query_str(params);\n+  return path_with_query;\n+}\n+\n inline void parse_query_text(const std::string &s, Params &params) {\n   split(s.data(), s.data() + s.size(), '&', [&](const char *b, const char *e) {\n     std::string key;\n@@ -4222,8 +4246,9 @@ inline bool Server::remove_mount_point(const char *mount_point) {\n   return false;\n }\n \n-inline Server &Server::set_file_extension_and_mimetype_mapping(const char *ext,\n-                                                            const char *mime) {\n+inline Server &\n+Server::set_file_extension_and_mimetype_mapping(const char *ext,\n+                                                const char *mime) {\n   file_extension_and_mimetype_map_[ext] = mime;\n \n   return *this;\n@@ -4264,8 +4289,8 @@ inline Server &Server::set_logger(Logger logger) {\n   return *this;\n }\n \n-inline Server\n-&Server::set_expect_100_continue_handler(Expect100ContinueHandler handler) {\n+inline Server &\n+Server::set_expect_100_continue_handler(Expect100ContinueHandler handler) {\n   expect_100_continue_handler_ = std::move(handler);\n \n   return *this;\n@@ -5796,6 +5821,35 @@ inline Result ClientImpl::Get(const char *path, const Headers &headers,\n   return send(req);\n }\n \n+inline Result ClientImpl::Get(const char *path, const Params &params,\n+                              const Headers &headers, Progress progress) {\n+  if (params.empty()) { return Get(path, headers); }\n+\n+  std::string path_with_query = detail::append_query_params(path, params);\n+  return Get(path_with_query.c_str(), headers, progress);\n+}\n+\n+inline Result ClientImpl::Get(const char *path, const Params &params,\n+                              const Headers &headers,\n+                              ContentReceiver content_receiver,\n+                              Progress progress) {\n+  return Get(path, params, headers, nullptr, content_receiver, progress);\n+}\n+\n+inline Result ClientImpl::Get(const char *path, const Params &params,\n+                              const Headers &headers,\n+                              ResponseHandler response_handler,\n+                              ContentReceiver content_receiver,\n+                              Progress progress) {\n+  if (params.empty()) {\n+    return Get(path, headers, response_handler, content_receiver, progress);\n+  }\n+\n+  std::string path_with_query = detail::append_query_params(path, params);\n+  return Get(path_with_query.c_str(), params, headers, response_handler,\n+             content_receiver, progress);\n+}\n+\n inline Result ClientImpl::Head(const char *path) {\n   return Head(path, Headers());\n }\n@@ -7020,6 +7074,22 @@ inline Result Client::Get(const char *path, const Headers &headers,\n   return cli_->Get(path, headers, std::move(response_handler),\n                    std::move(content_receiver), std::move(progress));\n }\n+inline Result Client::Get(const char *path, const Params &params,\n+                          const Headers &headers, Progress progress) {\n+  return cli_->Get(path, params, headers, progress);\n+}\n+inline Result Client::Get(const char *path, const Params &params,\n+                          const Headers &headers,\n+                          ContentReceiver content_receiver, Progress progress) {\n+  return cli_->Get(path, params, headers, content_receiver, progress);\n+}\n+inline Result Client::Get(const char *path, const Params &params,\n+                          const Headers &headers,\n+                          ResponseHandler response_handler,\n+                          ContentReceiver content_receiver, Progress progress) {\n+  return cli_->Get(path, params, headers, response_handler, content_receiver,\n+                   progress);\n+}\n \n inline Result Client::Head(const char *path) { return cli_->Head(path); }\n inline Result Client::Head(const char *path, const Headers &headers) {\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -816,6 +816,31 @@ TEST(HttpsToHttpRedirectTest, Redirect) {\n   EXPECT_EQ(200, res->status);\n }\n \n+TEST(HttpsToHttpRedirectTest2, Redirect) {\n+  SSLClient cli(\"nghttp2.org\");\n+  cli.set_follow_location(true);\n+\n+  Params params;\n+  params.emplace(\"url\", \"http://www.google.com\");\n+  params.emplace(\"status_code\", \"302\");\n+\n+  auto res = cli.Get(\"/httpbin/redirect-to\", params, Headers{});\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+}\n+\n+TEST(HttpsToHttpRedirectTest3, Redirect) {\n+  SSLClient cli(\"nghttp2.org\");\n+  cli.set_follow_location(true);\n+\n+  Params params;\n+  params.emplace(\"url\", \"http://www.google.com\");\n+\n+  auto res = cli.Get(\"/httpbin/redirect-to?status_code=302\", params, Headers{});\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+}\n+\n TEST(RedirectToDifferentPort, Redirect) {\n   Server svr8080;\n   Server svr8081;\n@@ -956,9 +981,8 @@ TEST(ErrorHandlerTest, ContentLength) {\n TEST(NoContentTest, ContentLength) {\n   Server svr;\n \n-  svr.Get(\"/hi\", [](const Request & /*req*/, Response &res) {\n-    res.status = 204;\n-  });\n+  svr.Get(\"/hi\",\n+          [](const Request & /*req*/, Response &res) { res.status = 204; });\n   auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n \n   // Give GET time to get a few messages.\n@@ -3979,7 +4003,7 @@ TEST(DecodeWithChunkedEncoding, BrotliEncoding) {\n }\n #endif\n \n-TEST(HttpsToHttpRedirectTest2, SimpleInterface) {\n+TEST(HttpsToHttpRedirectTest, SimpleInterface) {\n   Client cli(\"https://nghttp2.org\");\n   cli.set_follow_location(true);\n   auto res =\n@@ -3989,4 +4013,29 @@ TEST(HttpsToHttpRedirectTest2, SimpleInterface) {\n   ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n+\n+TEST(HttpsToHttpRedirectTest2, SimpleInterface) {\n+  Client cli(\"https://nghttp2.org\");\n+  cli.set_follow_location(true);\n+\n+  Params params;\n+  params.emplace(\"url\", \"http://www.google.com\");\n+  params.emplace(\"status_code\", \"302\");\n+\n+  auto res = cli.Get(\"/httpbin/redirect-to\", params, Headers{});\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+}\n+\n+TEST(HttpsToHttpRedirectTest3, SimpleInterface) {\n+  Client cli(\"https://nghttp2.org\");\n+  cli.set_follow_location(true);\n+\n+  Params params;\n+  params.emplace(\"url\", \"http://www.google.com\");\n+\n+  auto res = cli.Get(\"/httpbin/redirect-to?status_code=302\", params, Headers{});\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+}\n #endif\n", "problem_statement": "Params option missing from client Get calls ?\nHi, \r\nNice library :) \r\n\r\nBut it seems there is no support for passing Params using the client Get calls. \r\n\r\nAs far as I can tell this is a valid use of GET. Am I missing something ?\r\n\r\n\n", "hints_text": "Params refers to the html form POST formats, which can be either `application/x-www-form-urlencoded` or `multipart/form-data`. As GET requests should not have a request *body*, these Params cannot be used.\r\n\r\nYou are perhaps thinking of using URL-embedded parameters (where parameters are part of the path string)?\nYep, URL-embedded, does GET support passing them as a structure (like params), or do I manually have to build the string and url encode it.\r\n\r\nta\n@al3ph, as you can see from the @PixlRainbow's comment, GET requests currently need URL-embedded parameters. I know it requires tedious work to concatenate query parameters on our side... If other libraries like curl support it and you think it's a reasonable enhancement, I am ok to look into it.\nIt'd be nice if it did handle it for you, not so much the concatenation, but the url encoding, or does that already happen when you pass the path string ?\n@al3ph, you can see a number of examples of Get requests using the url encoding in `test/test.cc` like the following:\r\nhttps://github.com/yhirose/cpp-httplib/blob/8d9a477edb3e9ae962a9a7aeb20bf70b571093a1/test/test.cc#L367-L369\r\nHope it helps.\n@al3ph, I had to make a number of changes in `test/test.cc` after I added `Result Get(const char *path, const Params &params)`. https://github.com/yhirose/cpp-httplib/pull/835/files\r\n\r\nIt's because the compiler gets confused with `Result Get(const char *path, const Headers &headers)`. Here is an example:\r\n\r\n```cpp\r\n  //auto res = cli_.Get(\"/streamed\", {{make_range_header({{2, 3}})}}); // Current\r\n  auto res = cli_.Get(\"/streamed\", Headers{{make_range_header({{2, 3}})}}); // New code. It requires `Headers`\r\n```\r\n\r\nI would not like to break any existing users codebase with this change.\r\nSo I'll ponder over this change if it's worth to do it. Thanks for your understanding.\n@yhirose\r\nMaybe... introduce something new, like `Server::get_with_params`?\r\nDoesn't sound ideal though.\n@00ff0000red, we are talking about Client::Get, not Server.", "created_at": "2021-01-21T22:09:36Z", "version": "0.8"}
{"repo": "yhirose/cpp-httplib", "pull_number": 295, "instance_id": "yhirose__cpp-httplib-295", "issue_numbers": ["294"], "base_commit": "80202c9f629eb16e524d151b1d2d23a4081c1640", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -614,7 +614,7 @@ class Server {\n \n class Client {\n public:\n-  explicit Client(const char *host, int port = 80, time_t timeout_sec = 300);\n+  explicit Client(const char *host, int port = 80);\n \n   virtual ~Client();\n \n@@ -734,6 +734,8 @@ class Client {\n   bool send(const std::vector<Request> &requests,\n             std::vector<Response> &responses);\n \n+  void set_timeout_sec(time_t timeout_sec);\n+\n   void set_keep_alive_max_count(size_t count);\n \n   void set_read_timeout(time_t sec, time_t usec);\n@@ -752,15 +754,17 @@ class Client {\n \n   const std::string host_;\n   const int port_;\n-  time_t timeout_sec_;\n   const std::string host_and_port_;\n-  size_t keep_alive_max_count_;\n-  time_t read_timeout_sec_;\n-  time_t read_timeout_usec_;\n-  bool follow_location_;\n+\n+  // Options\n+  time_t timeout_sec_ = 300;\n+  size_t keep_alive_max_count_ = CPPHTTPLIB_KEEPALIVE_MAX_COUNT;\n+  time_t read_timeout_sec_ = CPPHTTPLIB_READ_TIMEOUT_SECOND;\n+  time_t read_timeout_usec_ = CPPHTTPLIB_READ_TIMEOUT_USECOND;\n   std::string username_;\n   std::string password_;\n-  bool compress_;\n+  bool follow_location_ = false;\n+  bool compress_ = false;\n   std::string interface_;\n \n private:\n@@ -852,7 +856,7 @@ class SSLServer : public Server {\n \n class SSLClient : public Client {\n public:\n-  SSLClient(const char *host, int port = 443, time_t timeout_sec = 300,\n+  SSLClient(const char *host, int port = 443,\n             const char *client_cert_path = nullptr,\n             const char *client_key_path = nullptr);\n \n@@ -884,6 +888,8 @@ class SSLClient : public Client {\n   SSL_CTX *ctx_;\n   std::mutex ctx_mutex_;\n   std::vector<std::string> host_components_;\n+\n+  // Options\n   std::string ca_cert_file_path_;\n   std::string ca_cert_dir_path_;\n   bool server_certificate_verification_ = false;\n@@ -3355,13 +3361,9 @@ inline bool Server::process_and_close_socket(socket_t sock) {\n }\n \n // HTTP client implementation\n-inline Client::Client(const char *host, int port, time_t timeout_sec)\n-    : host_(host), port_(port), timeout_sec_(timeout_sec),\n-      host_and_port_(host_ + \":\" + std::to_string(port_)),\n-      keep_alive_max_count_(CPPHTTPLIB_KEEPALIVE_MAX_COUNT),\n-      read_timeout_sec_(CPPHTTPLIB_READ_TIMEOUT_SECOND),\n-      read_timeout_usec_(CPPHTTPLIB_READ_TIMEOUT_USECOND),\n-      follow_location_(false), compress_(false) {}\n+inline Client::Client(const char *host, int port)\n+    : host_(host), port_(port),\n+      host_and_port_(host_ + \":\" + std::to_string(port_)) {}\n \n inline Client::~Client() {}\n \n@@ -3988,6 +3990,10 @@ inline std::shared_ptr<Response> Client::Options(const char *path,\n   return send(req, *res) ? res : nullptr;\n }\n \n+inline void Client::set_timeout_sec(time_t timeout_sec) {\n+  timeout_sec_ = timeout_sec;\n+}\n+\n inline void Client::set_keep_alive_max_count(size_t count) {\n   keep_alive_max_count_ = count;\n }\n@@ -4227,10 +4233,10 @@ inline bool SSLServer::process_and_close_socket(socket_t sock) {\n }\n \n // SSL HTTP client implementation\n-inline SSLClient::SSLClient(const char *host, int port, time_t timeout_sec,\n+inline SSLClient::SSLClient(const char *host, int port,\n                             const char *client_cert_path,\n                             const char *client_key_path)\n-    : Client(host, port, timeout_sec) {\n+    : Client(host, port) {\n   ctx_ = SSL_CTX_new(SSLv23_client_method());\n \n   detail::split(&host_[0], &host_[host_.size()], '.',\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -204,15 +204,15 @@ TEST(ParseHeaderValueTest, Range) {\n \n TEST(ChunkedEncodingTest, FromHTTPWatch) {\n   auto host = \"www.httpwatch.com\";\n-  auto sec = 2;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(2);\n \n   auto res =\n       cli.Get(\"/httpgallery/chunked/chunkedimage.aspx?0.4153841143030137\");\n@@ -227,15 +227,15 @@ TEST(ChunkedEncodingTest, FromHTTPWatch) {\n \n TEST(ChunkedEncodingTest, WithContentReceiver) {\n   auto host = \"www.httpwatch.com\";\n-  auto sec = 2;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(2);\n \n   std::string body;\n   auto res =\n@@ -255,15 +255,15 @@ TEST(ChunkedEncodingTest, WithContentReceiver) {\n \n TEST(ChunkedEncodingTest, WithResponseHandlerAndContentReceiver) {\n   auto host = \"www.httpwatch.com\";\n-  auto sec = 2;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(2);\n \n   std::string body;\n   auto res = cli.Get(\n@@ -287,15 +287,15 @@ TEST(ChunkedEncodingTest, WithResponseHandlerAndContentReceiver) {\n \n TEST(RangeTest, FromHTTPBin) {\n   auto host = \"httpbin.org\";\n-  auto sec = 5;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(5);\n \n   {\n     httplib::Headers headers;\n@@ -347,15 +347,15 @@ TEST(RangeTest, FromHTTPBin) {\n \n TEST(ConnectionErrorTest, InvalidHost) {\n   auto host = \"-abcde.com\";\n-  auto sec = 2;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(2);\n \n   auto res = cli.Get(\"/\");\n   ASSERT_TRUE(res == nullptr);\n@@ -363,15 +363,15 @@ TEST(ConnectionErrorTest, InvalidHost) {\n \n TEST(ConnectionErrorTest, InvalidPort) {\n   auto host = \"localhost\";\n-  auto sec = 2;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 44380;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 8080;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(2);\n \n   auto res = cli.Get(\"/\");\n   ASSERT_TRUE(res == nullptr);\n@@ -379,15 +379,15 @@ TEST(ConnectionErrorTest, InvalidPort) {\n \n TEST(ConnectionErrorTest, Timeout) {\n   auto host = \"google.com\";\n-  auto sec = 2;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 44380;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 8080;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(2);\n \n   auto res = cli.Get(\"/\");\n   ASSERT_TRUE(res == nullptr);\n@@ -395,15 +395,15 @@ TEST(ConnectionErrorTest, Timeout) {\n \n TEST(CancelTest, NoCancel) {\n   auto host = \"httpbin.org\";\n-  auto sec = 5;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(5);\n \n   auto res = cli.Get(\"/range/32\", [](uint64_t, uint64_t) { return true; });\n   ASSERT_TRUE(res != nullptr);\n@@ -413,31 +413,31 @@ TEST(CancelTest, NoCancel) {\n \n TEST(CancelTest, WithCancelSmallPayload) {\n   auto host = \"httpbin.org\";\n-  auto sec = 5;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n \n   auto res = cli.Get(\"/range/32\", [](uint64_t, uint64_t) { return false; });\n+  cli.set_timeout_sec(5);\n   ASSERT_TRUE(res == nullptr);\n }\n \n TEST(CancelTest, WithCancelLargePayload) {\n   auto host = \"httpbin.org\";\n-  auto sec = 5;\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n   auto port = 443;\n-  httplib::SSLClient cli(host, port, sec);\n+  httplib::SSLClient cli(host, port);\n #else\n   auto port = 80;\n-  httplib::Client cli(host, port, sec);\n+  httplib::Client cli(host, port);\n #endif\n+  cli.set_timeout_sec(5);\n \n   uint32_t count = 0;\n   httplib::Headers headers;\n@@ -2090,9 +2090,10 @@ TEST(SSLClientServerTest, ClientCertPresent) {\n   thread t = thread([&]() { ASSERT_TRUE(svr.listen(HOST, PORT)); });\n   msleep(1);\n \n-  httplib::SSLClient cli(HOST, PORT, 30, CLIENT_CERT_FILE,\n+  httplib::SSLClient cli(HOST, PORT, CLIENT_CERT_FILE,\n                          CLIENT_PRIVATE_KEY_FILE);\n   auto res = cli.Get(\"/test\");\n+  cli.set_timeout_sec(30);\n   ASSERT_TRUE(res != nullptr);\n   ASSERT_EQ(200, res->status);\n \n@@ -2109,8 +2110,9 @@ TEST(SSLClientServerTest, ClientCertMissing) {\n   thread t = thread([&]() { ASSERT_TRUE(svr.listen(HOST, PORT)); });\n   msleep(1);\n \n-  httplib::SSLClient cli(HOST, PORT, 30);\n+  httplib::SSLClient cli(HOST, PORT);\n   auto res = cli.Get(\"/test\");\n+  cli.set_timeout_sec(30);\n   ASSERT_TRUE(res == nullptr);\n \n   svr.stop();\n@@ -2130,9 +2132,10 @@ TEST(SSLClientServerTest, TrustDirOptional) {\n   thread t = thread([&]() { ASSERT_TRUE(svr.listen(HOST, PORT)); });\n   msleep(1);\n \n-  httplib::SSLClient cli(HOST, PORT, 30, CLIENT_CERT_FILE,\n+  httplib::SSLClient cli(HOST, PORT, CLIENT_CERT_FILE,\n                          CLIENT_PRIVATE_KEY_FILE);\n   auto res = cli.Get(\"/test\");\n+  cli.set_timeout_sec(30);\n   ASSERT_TRUE(res != nullptr);\n   ASSERT_EQ(200, res->status);\n \n", "problem_statement": "Remove timeout_sec parameter from constructor and provide set_timeout_sec method instead\n\n", "hints_text": "", "created_at": "2019-12-18T22:40:56Z", "version": "0.4"}
{"repo": "yhirose/cpp-httplib", "pull_number": 755, "instance_id": "yhirose__cpp-httplib-755", "issue_numbers": ["754"], "base_commit": "9c7d841b37b69cde4ffb7c6d5c1aae6d5d6e1d97", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -480,6 +480,7 @@ class Stream {\n   virtual ssize_t read(char *ptr, size_t size) = 0;\n   virtual ssize_t write(const char *ptr, size_t size) = 0;\n   virtual void get_remote_ip_and_port(std::string &ip, int &port) const = 0;\n+  virtual socket_t socket() const = 0;\n \n   template <typename... Args>\n   ssize_t write_format(const char *fmt, const Args &... args);\n@@ -1627,6 +1628,10 @@ inline ssize_t select_read(socket_t sock, time_t sec, time_t usec) {\n \n   return handle_EINTR([&]() { return poll(&pfd_read, 1, timeout); });\n #else\n+#ifndef _WIN32\n+  if (sock >= FD_SETSIZE) { return 1; }\n+#endif\n+\n   fd_set fds;\n   FD_ZERO(&fds);\n   FD_SET(sock, &fds);\n@@ -1651,6 +1656,10 @@ inline ssize_t select_write(socket_t sock, time_t sec, time_t usec) {\n \n   return handle_EINTR([&]() { return poll(&pfd_read, 1, timeout); });\n #else\n+#ifndef _WIN32\n+  if (sock >= FD_SETSIZE) { return 1; }\n+#endif\n+\n   fd_set fds;\n   FD_ZERO(&fds);\n   FD_SET(sock, &fds);\n@@ -1684,6 +1693,10 @@ inline bool wait_until_socket_is_ready(socket_t sock, time_t sec, time_t usec) {\n   }\n   return false;\n #else\n+#ifndef _WIN32\n+  if (sock >= FD_SETSIZE) { return false; }\n+#endif\n+\n   fd_set fdsr;\n   FD_ZERO(&fdsr);\n   FD_SET(sock, &fdsr);\n@@ -1721,6 +1734,7 @@ class SocketStream : public Stream {\n   ssize_t read(char *ptr, size_t size) override;\n   ssize_t write(const char *ptr, size_t size) override;\n   void get_remote_ip_and_port(std::string &ip, int &port) const override;\n+  socket_t socket() const override;\n \n private:\n   socket_t sock_;\n@@ -1743,6 +1757,7 @@ class SSLSocketStream : public Stream {\n   ssize_t read(char *ptr, size_t size) override;\n   ssize_t write(const char *ptr, size_t size) override;\n   void get_remote_ip_and_port(std::string &ip, int &port) const override;\n+  socket_t socket() const override;\n \n private:\n   socket_t sock_;\n@@ -1764,6 +1779,7 @@ class BufferStream : public Stream {\n   ssize_t read(char *ptr, size_t size) override;\n   ssize_t write(const char *ptr, size_t size) override;\n   void get_remote_ip_and_port(std::string &ip, int &port) const override;\n+  socket_t socket() const override;\n \n   const std::string &get_buffer() const;\n \n@@ -2980,7 +2996,7 @@ class MultipartFormDataParser {\n   bool is_valid() const { return is_valid_; }\n \n   bool parse(const char *buf, size_t n, const ContentReceiver &content_callback,\n-\t  const MultipartContentHeader &header_callback) {\n+             const MultipartContentHeader &header_callback) {\n \n     static const std::regex re_content_disposition(\n         \"^Content-Disposition:\\\\s*form-data;\\\\s*name=\\\"(.*?)\\\"(?:;\\\\s*filename=\"\n@@ -3792,6 +3808,8 @@ inline void SocketStream::get_remote_ip_and_port(std::string &ip,\n   return detail::get_remote_ip_and_port(sock_, ip, port);\n }\n \n+inline socket_t SocketStream::socket() const { return sock_; }\n+\n // Buffer stream implementation\n inline bool BufferStream::is_readable() const { return true; }\n \n@@ -3815,6 +3833,8 @@ inline ssize_t BufferStream::write(const char *ptr, size_t size) {\n inline void BufferStream::get_remote_ip_and_port(std::string & /*ip*/,\n                                                  int & /*port*/) const {}\n \n+inline socket_t BufferStream::socket() const { return 0; }\n+\n inline const std::string &BufferStream::get_buffer() const { return buffer; }\n \n } // namespace detail\n@@ -4614,6 +4634,20 @@ Server::process_request(Stream &strm, bool close_connection,\n \n   res.version = \"HTTP/1.1\";\n \n+#ifdef _WIN32\n+  // TODO: Increase FD_SETSIZE statically (libzmq), dynamically (MySQL).\n+#else\n+#ifndef CPPHTTPLIB_USE_POLL\n+  // Socket file descriptor exceeded FD_SETSIZE...\n+  if (strm.socket() >= FD_SETSIZE) {\n+    Headers dummy;\n+    detail::read_headers(strm, dummy);\n+    res.status = 500;\n+    return write_response(strm, close_connection, req, res);\n+  }\n+#endif\n+#endif\n+\n   // Check if the request URI doesn't exceed the limit\n   if (line_reader.size() > CPPHTTPLIB_REQUEST_URI_MAX_LENGTH) {\n     Headers dummy;\n@@ -5864,6 +5898,8 @@ inline void SSLSocketStream::get_remote_ip_and_port(std::string &ip,\n   detail::get_remote_ip_and_port(sock_, ip, port);\n }\n \n+inline socket_t SSLSocketStream::socket() const { return sock_; }\n+\n static SSLInit sslinit_;\n \n } // namespace detail\n", "test_patch": "diff --git a/test/fuzzing/server_fuzzer.cc b/test/fuzzing/server_fuzzer.cc\n--- a/test/fuzzing/server_fuzzer.cc\n+++ b/test/fuzzing/server_fuzzer.cc\n@@ -35,6 +35,8 @@ class FuzzedStream : public httplib::Stream {\n     port = 8080;\n   }\n \n+  socket_t socket() const override { return 0; }\n+\n  private:\n   const uint8_t* data_;\n   size_t size_;\n", "problem_statement": "Stack smashing due to misuse of select (*** stack smashing detected ***: <unknown> terminated)\nHi @yhirose! \r\nAt our project we have a problem: application crashes with message \"*** stack smashing detected ***: <unknown> terminated\" after some time correctly working.\r\nOS is Ubuntu Linux.\r\nBacktrace shows that problem is in the function `select_read`. After some investigation I found that `select` is misused. According to docs `glibc` imposes constraints on maximum value of fd to be monitored (https://man7.org/linux/man-pages/man2/select.2.html) due to `fd_set` has static array inside. `FD_SET` does not check boundaries and writes outside of array, which leads to stack corruption.\r\n\r\nUsing `CPPHTTPLIB_USE_POLL` fixes the problem\r\n\r\nHere is code which reproduces the problem:\r\n```cpp\r\n\r\n// concept:\r\n// first we exhaust 1090 fds by opening files\r\n// then we process requests whose connection fds will be >1024 (which leads to stack damaging)\r\n// I use 1090 beacause stack damaging is detected only after fd 1087 on my machine\r\n\r\n#include <httplib.h>\r\n\r\n#include <sys/time.h>\r\n#include <sys/resource.h>\r\n\r\nint main(void)\r\n{\r\n\tusing namespace httplib;\r\n\t\r\n\t// increase maximum fds available to expose the problem\r\n\t// on problematic machine RLIMIT_NOFILE is 1048576\r\n\tstruct rlimit rl = {2048, 2048};\r\n\tsetrlimit(RLIMIT_NOFILE, &rl);\r\n\r\n\t// exhaust fds up to 1090\r\n\tfor(int i = 0 ; i < 1090 ; i += 1)\r\n\t{\r\n\t\topen(\"/dev/null\", O_RDONLY);\r\n\t}\r\n\t\r\n\t\r\n\t// work as usual\r\n\tServer svr;\r\n\t\r\n\tsvr.Get(\"/hi\", [](const Request& req, Response& res)\r\n\t{\r\n\t\tres.set_content(\"Hello World!\\n\", \"text/plain\");\r\n\t\tres.status = 524;\r\n\t});\r\n\r\n\t\r\n\tsvr.listen(\"localhost\", 1234);\r\n}\r\n\r\n```\r\n\r\nRequest: `curl -v localhost:1234/hi`.\r\n\r\nAlso there are other issues with same symptoms, I think it is the same problem:\r\nhttps://github.com/yhirose/cpp-httplib/issues/655\r\nhttps://github.com/yhirose/cpp-httplib/issues/654\r\n\n", "hints_text": "@aldoshkind, thanks for the great finding! I checked how other products handle the FD_SETSIZE limitation.\r\n\r\nHere is [the solution in MySQL](https://github.com/mysql/mysql-server/blob/4869291f7ee258e136ef03f5a50135fe7329ffb9/storage/ndb/include/portlib/ndb_socket_poller.h#L198-L204) for non Windows operating systems:\r\n\r\n![image](https://user-images.githubusercontent.com/357397/99159707-1b0d8280-26ad-11eb-96b5-32e77279de16.png)\r\n\r\nI don't think it's a good behavior to call `abort()` to terminate the server as this code does. I am thinking to return a 429 response (Too Many Requests). As you mentioned, the only and real solution on Linux and macOS should to use `poll`. There is no solution for this as long as `select` is used unfortunately.\r\n\r\nI'll try to avoid at least the crash that you found, also encourage users to use `poll` if they expect a large number of request that might exceed FD_SETSIZE on README.\r\n\r\nBy the way, when I was reading source code in MySQL and libzmq, I found that they are applying special treatments to increase FD_SETSIZE for Winsock2. Their approaches are very different from each other though, they both support much larger amount of file/socket descriptors. But these cannot be applied to non Windows environments...\r\n\r\nThank you again for your valuable feedback!", "created_at": "2020-11-15T02:26:03Z", "version": "0.7"}
{"repo": "yhirose/cpp-httplib", "pull_number": 1294, "instance_id": "yhirose__cpp-httplib-1294", "issue_numbers": ["1290"], "base_commit": "4001637beb48fb77f1bb94aa4aa160256a938991", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -4691,7 +4691,7 @@ inline ssize_t SocketStream::read(char *ptr, size_t size) {\n inline ssize_t SocketStream::write(const char *ptr, size_t size) {\n   if (!is_writable()) { return -1; }\n \n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(_WIN64)\n   size =\n       (std::min)(size, static_cast<size_t>((std::numeric_limits<int>::max)()));\n #endif\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -4742,6 +4742,40 @@ TEST(SendAPI, SimpleInterface_Online) {\n   EXPECT_EQ(301, res->status);\n }\n \n+// Disabled due to out-of-memory problem on GitHub Actions\n+#ifdef _WIN64\n+TEST(ServerLargeContentTest, DISABLED_SendLargeContent) {\n+  // allocate content size larger than 2GB in memory\n+  const size_t content_size = 2LL * 1024LL * 1024LL * 1024LL + 1LL;\n+  char *content = (char *)malloc(content_size);\n+  ASSERT_TRUE(content);\n+\n+  Server svr;\n+  svr.Get(\"/foo\", [=](const httplib::Request &req, httplib::Response &resp) {\n+    resp.set_content(content, content_size, \"application/octet-stream\");\n+  });\n+\n+  auto listen_thread = std::thread([&svr]() { svr.listen(HOST, PORT); });\n+  while (!svr.is_running()) {\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+  }\n+\n+  // Give GET time to get a few messages.\n+  std::this_thread::sleep_for(std::chrono::seconds(1));\n+\n+  Client cli(HOST, PORT);\n+  auto res = cli.Get(\"/foo\");\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+  EXPECT_EQ(content_size, res->body.length());\n+\n+  free(content);\n+  svr.stop();\n+  listen_thread.join();\n+  ASSERT_FALSE(svr.is_running());\n+}\n+#endif\n+\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n TEST(YahooRedirectTest2, SimpleInterface_Online) {\n   Client cli(\"http://yahoo.com\");\n", "problem_statement": "http server can't provide zip file large than 2GB with project both defined _WIN32 and _WIN64\nif project both defined _WIN32 and _WIN64, http server can't provide zip file large than 2GB\r\n\r\nin function \"SocketStream::write\", change:\r\n\r\n#ifdef _WIN32\r\n  size =\r\n      (std::min)(size, static_cast<size_t>((std::numeric_limits<int>::max)()));\r\n#endif\r\n\r\nto:\r\n\r\n#if defined(_WIN32) && !defined(_WIN64)\r\n  size =\r\n      (std::min)(size, static_cast<size_t>((std::numeric_limits<int>::max)()));\r\n#endif\r\n\r\nresolve this problem.\n", "hints_text": "@conghuawang, thank you for the feedback. Could you send the patch as a pull request including at least one unit test? Thanks a lot!", "created_at": "2022-05-27T14:18:10Z", "version": "0.10"}
{"repo": "yhirose/cpp-httplib", "pull_number": 671, "instance_id": "yhirose__cpp-httplib-671", "issue_numbers": ["674"], "base_commit": "e2c4e9d95c97cb4a70cd471bfa651307f39b3339", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1171,7 +1171,6 @@ class SSLClient : public ClientImpl {\n \n   std::string ca_cert_file_path_;\n   std::string ca_cert_dir_path_;\n-  X509_STORE *ca_cert_store_ = nullptr;\n   long verify_result_ = 0;\n \n   friend class ClientImpl;\n@@ -5844,7 +5843,16 @@ inline void SSLClient::set_ca_cert_path(const char *ca_cert_file_path,\n }\n \n inline void SSLClient::set_ca_cert_store(X509_STORE *ca_cert_store) {\n-  if (ca_cert_store) { ca_cert_store_ = ca_cert_store; }\n+  if (ca_cert_store) {\n+    if(ctx_) {\n+      if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store) {\n+        // Free memory allocated for old cert and use new store `ca_cert_store`\n+        SSL_CTX_set_cert_store(ctx_, ca_cert_store);\n+      }\n+    } else {\n+      X509_STORE_free(ca_cert_store);\n+    }\n+  }\n }\n \n inline long SSLClient::get_openssl_verify_result() const {\n@@ -5922,10 +5930,6 @@ inline bool SSLClient::load_certs() {\n                                          ca_cert_dir_path_.c_str())) {\n         ret = false;\n       }\n-    } else if (ca_cert_store_ != nullptr) {\n-      if (SSL_CTX_get_cert_store(ctx_) != ca_cert_store_) {\n-        SSL_CTX_set_cert_store(ctx_, ca_cert_store_);\n-      }\n     } else {\n #ifdef _WIN32\n       detail::load_system_certs_on_windows(SSL_CTX_get_cert_store(ctx_));\n", "test_patch": "diff --git a/test/Makefile b/test/Makefile\n--- a/test/Makefile\n+++ b/test/Makefile\n@@ -1,6 +1,6 @@\n \n #CXX = clang++\n-CXXFLAGS = -ggdb -O0 -std=c++11 -DGTEST_USE_OWN_TR1_TUPLE -I.. -I. -Wall -Wextra -Wtype-limits -Wconversion\n+CXXFLAGS = -ggdb -O0 -std=c++11 -DGTEST_USE_OWN_TR1_TUPLE -I.. -I. -Wall -Wextra -Wtype-limits -Wconversion -fsanitize=address\n \n OPENSSL_DIR = /usr/local/opt/openssl@1.1\n OPENSSL_SUPPORT = -DCPPHTTPLIB_OPENSSL_SUPPORT -I$(OPENSSL_DIR)/include -L$(OPENSSL_DIR)/lib -lssl -lcrypto\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -3125,6 +3125,19 @@ TEST_F(PayloadMaxLengthTest, ExceedLimit) {\n }\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n+TEST(SSLClientTest, UpdateCAStore) {\n+  httplib::SSLClient httplib_client(\"www.google.com\");\n+  auto ca_store_1 = X509_STORE_new();\n+  X509_STORE_load_locations(ca_store_1, \"/etc/ssl/certs/ca-certificates.crt\",\n+                            nullptr);\n+  httplib_client.set_ca_cert_store(ca_store_1);\n+\n+  auto ca_store_2 = X509_STORE_new();\n+  X509_STORE_load_locations(ca_store_2, \"/etc/ssl/certs/ca-certificates.crt\",\n+                            nullptr);\n+  httplib_client.set_ca_cert_store(ca_store_2);\n+}\n+\n TEST(SSLClientTest, ServerNameIndication) {\n   SSLClient cli(\"httpbin.org\", 443);\n   auto res = cli.Get(\"/get\");\n", "problem_statement": "Added MACRO for server_certificate_verification\nIf I have a request (made with universal interface httplib::Client) which redirects (set_follow_location) from HTTP to HTTPS and I had server_certificate_verification_ set to false, the redirection won't copy my server_certificate_verification_ setting and will make an erroneous request.\r\n\r\nThis solution allows me to keep server_certificate_verification configuration_ = false for my whole code and surrounds my problem.\r\n\r\nAlso, setting server_certificate_verification_ in the universal interface won't have effect (before it had been redirected from HTTP to HTTPS) and SSLClient instance had been created.\n", "hints_text": "", "created_at": "2020-09-28T05:41:20Z", "version": "0.7"}
{"repo": "yhirose/cpp-httplib", "pull_number": 907, "instance_id": "yhirose__cpp-httplib-907", "issue_numbers": ["873", "900"], "base_commit": "63643e6386653623a39908c095e3a425853cbb36", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -308,7 +308,7 @@ class DataSink {\n   DataSink(DataSink &&) = delete;\n   DataSink &operator=(DataSink &&) = delete;\n \n-  std::function<void(const char *data, size_t data_len)> write;\n+  std::function<bool(const char *data, size_t data_len)> write;\n   std::function<void()> done;\n   std::function<bool()> is_writable;\n   std::ostream os;\n@@ -2091,8 +2091,9 @@ socket_t create_socket(const char *host, int port, int address_family,\n   for (auto rp = result; rp; rp = rp->ai_next) {\n     // Create a socket\n #ifdef _WIN32\n-    auto sock = WSASocketW(rp->ai_family, rp->ai_socktype, rp->ai_protocol,\n-                           nullptr, 0, WSA_FLAG_NO_HANDLE_INHERIT);\n+    auto sock =\n+        WSASocketW(rp->ai_family, rp->ai_socktype, rp->ai_protocol, nullptr, 0,\n+                   WSA_FLAG_NO_HANDLE_INHERIT | WSA_FLAG_OVERLAPPED);\n     /**\n      * Since the WSA_FLAG_NO_HANDLE_INHERIT is only supported on Windows 7 SP1\n      * and above the socket creation fails on older Windows Systems.\n@@ -2214,11 +2215,12 @@ inline std::string if2ip(const std::string &ifn) {\n }\n #endif\n \n-inline socket_t create_client_socket(const char *host, int port,\n-                                     int address_family, bool tcp_nodelay,\n-                                     SocketOptions socket_options,\n-                                     time_t timeout_sec, time_t timeout_usec,\n-                                     const std::string &intf, Error &error) {\n+inline socket_t create_client_socket(\n+    const char *host, int port, int address_family, bool tcp_nodelay,\n+    SocketOptions socket_options, time_t connection_timeout_sec,\n+    time_t connection_timeout_usec, time_t read_timeout_sec,\n+    time_t read_timeout_usec, time_t write_timeout_sec,\n+    time_t write_timeout_usec, const std::string &intf, Error &error) {\n   auto sock = create_socket(\n       host, port, address_family, 0, tcp_nodelay, std::move(socket_options),\n       [&](socket_t sock, struct addrinfo &ai) -> bool {\n@@ -2240,7 +2242,8 @@ inline socket_t create_client_socket(const char *host, int port,\n \n         if (ret < 0) {\n           if (is_connection_error() ||\n-              !wait_until_socket_is_ready(sock, timeout_sec, timeout_usec)) {\n+              !wait_until_socket_is_ready(sock, connection_timeout_sec,\n+                                          connection_timeout_usec)) {\n             close_socket(sock);\n             error = Error::Connection;\n             return false;\n@@ -2248,6 +2251,20 @@ inline socket_t create_client_socket(const char *host, int port,\n         }\n \n         set_nonblocking(sock, false);\n+\n+        {\n+          timeval tv;\n+          tv.tv_sec = static_cast<long>(read_timeout_sec);\n+          tv.tv_usec = static_cast<decltype(tv.tv_usec)>(read_timeout_usec);\n+          setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(tv));\n+        }\n+        {\n+          timeval tv;\n+          tv.tv_sec = static_cast<long>(write_timeout_sec);\n+          tv.tv_usec = static_cast<decltype(tv.tv_usec)>(write_timeout_usec);\n+          setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, sizeof(tv));\n+        }\n+\n         error = Error::Success;\n         return true;\n       });\n@@ -3004,7 +3021,7 @@ inline bool write_content(Stream &strm, const ContentProvider &content_provider,\n   auto ok = true;\n   DataSink data_sink;\n \n-  data_sink.write = [&](const char *d, size_t l) {\n+  data_sink.write = [&](const char *d, size_t l) -> bool {\n     if (ok) {\n       if (write_data(strm, d, l)) {\n         offset += l;\n@@ -3012,6 +3029,7 @@ inline bool write_content(Stream &strm, const ContentProvider &content_provider,\n         ok = false;\n       }\n     }\n+    return ok;\n   };\n \n   data_sink.is_writable = [&](void) { return ok && strm.is_writable(); };\n@@ -3050,11 +3068,12 @@ write_content_without_length(Stream &strm,\n   auto ok = true;\n   DataSink data_sink;\n \n-  data_sink.write = [&](const char *d, size_t l) {\n+  data_sink.write = [&](const char *d, size_t l) -> bool {\n     if (ok) {\n       offset += l;\n       if (!write_data(strm, d, l)) { ok = false; }\n     }\n+    return ok;\n   };\n \n   data_sink.done = [&](void) { data_available = false; };\n@@ -3077,30 +3096,30 @@ write_content_chunked(Stream &strm, const ContentProvider &content_provider,\n   auto ok = true;\n   DataSink data_sink;\n \n-  data_sink.write = [&](const char *d, size_t l) {\n-    if (!ok) { return; }\n-\n-    data_available = l > 0;\n-    offset += l;\n-\n-    std::string payload;\n-    if (!compressor.compress(d, l, false,\n-                             [&](const char *data, size_t data_len) {\n-                               payload.append(data, data_len);\n-                               return true;\n-                             })) {\n-      ok = false;\n-      return;\n-    }\n+  data_sink.write = [&](const char *d, size_t l) -> bool {\n+    if (ok) {\n+      data_available = l > 0;\n+      offset += l;\n \n-    if (!payload.empty()) {\n-      // Emit chunked response header and footer for each chunk\n-      auto chunk = from_i_to_hex(payload.size()) + \"\\r\\n\" + payload + \"\\r\\n\";\n-      if (!write_data(strm, chunk.data(), chunk.size())) {\n+      std::string payload;\n+      if (compressor.compress(d, l, false,\n+                              [&](const char *data, size_t data_len) {\n+                                payload.append(data, data_len);\n+                                return true;\n+                              })) {\n+        if (!payload.empty()) {\n+          // Emit chunked response header and footer for each chunk\n+          auto chunk =\n+              from_i_to_hex(payload.size()) + \"\\r\\n\" + payload + \"\\r\\n\";\n+          if (!write_data(strm, chunk.data(), chunk.size())) {\n+            ok = false;\n+          }\n+        }\n+      } else {\n         ok = false;\n-        return;\n       }\n     }\n+    return ok;\n   };\n \n   data_sink.done = [&](void) {\n@@ -4847,6 +4866,19 @@ inline bool Server::listen_internal() {\n         break;\n       }\n \n+      {\n+        timeval tv;\n+        tv.tv_sec = static_cast<long>(read_timeout_sec_);\n+        tv.tv_usec = static_cast<decltype(tv.tv_usec)>(read_timeout_usec_);\n+        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(tv));\n+      }\n+      {\n+        timeval tv;\n+        tv.tv_sec = static_cast<long>(write_timeout_sec_);\n+        tv.tv_usec = static_cast<decltype(tv.tv_usec)>(write_timeout_usec_);\n+        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, sizeof(tv));\n+      }\n+\n #if __cplusplus > 201703L\n       task_queue->enqueue([=, this]() { process_and_close_socket(sock); });\n #else\n@@ -5263,11 +5295,14 @@ inline socket_t ClientImpl::create_client_socket(Error &error) const {\n     return detail::create_client_socket(\n         proxy_host_.c_str(), proxy_port_, address_family_, tcp_nodelay_,\n         socket_options_, connection_timeout_sec_, connection_timeout_usec_,\n-        interface_, error);\n+        read_timeout_sec_, read_timeout_usec_, write_timeout_sec_,\n+        write_timeout_usec_, interface_, error);\n   }\n   return detail::create_client_socket(\n       host_.c_str(), port_, address_family_, tcp_nodelay_, socket_options_,\n-      connection_timeout_sec_, connection_timeout_usec_, interface_, error);\n+      connection_timeout_sec_, connection_timeout_usec_, read_timeout_sec_,\n+      read_timeout_usec_, write_timeout_sec_, write_timeout_usec_, interface_,\n+      error);\n }\n \n inline bool ClientImpl::create_and_connect_socket(Socket &socket,\n@@ -5713,7 +5748,7 @@ inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n       size_t offset = 0;\n       DataSink data_sink;\n \n-      data_sink.write = [&](const char *data, size_t data_len) {\n+      data_sink.write = [&](const char *data, size_t data_len) -> bool {\n         if (ok) {\n           auto last = offset + data_len == content_length;\n \n@@ -5729,6 +5764,7 @@ inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n             ok = false;\n           }\n         }\n+        return ok;\n       };\n \n       data_sink.is_writable = [&](void) { return ok && true; };\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1366,7 +1366,8 @@ class ServerTest : public ::testing::Test {\n                      const auto &d = *data;\n                      auto out_len =\n                          std::min(static_cast<size_t>(length), DATA_CHUNK_SIZE);\n-                     sink.write(&d[static_cast<size_t>(offset)], out_len);\n+                     auto ret = sink.write(&d[static_cast<size_t>(offset)], out_len);\n+                     EXPECT_TRUE(ret);\n                      return true;\n                    },\n                    [data] { delete data; });\n@@ -2521,7 +2522,8 @@ TEST_F(ServerTest, SlowPost) {\n   auto res = cli_.Post(\n       \"/slowpost\", 64 * 1024 * 1024,\n       [&](size_t /*offset*/, size_t /*length*/, DataSink &sink) {\n-        sink.write(buffer, sizeof(buffer));\n+        auto ret = sink.write(buffer, sizeof(buffer));\n+        EXPECT_TRUE(ret);\n         return true;\n       },\n       \"text/plain\");\n@@ -3145,7 +3147,10 @@ static bool send_request(time_t read_timeout_sec, const std::string &req,\n \n   auto client_sock =\n       detail::create_client_socket(HOST, PORT, AF_UNSPEC, false, nullptr,\n-                                   /*timeout_sec=*/5, 0, std::string(), error);\n+                                   /*connection_timeout_sec=*/5, 0,\n+                                   /*read_timeout_sec=*/5, 0,\n+                                   /*write_timeout_sec=*/5, 0,\n+                                   std::string(), error);\n \n   if (client_sock == INVALID_SOCKET) { return false; }\n \n@@ -3346,7 +3351,8 @@ TEST(ServerStopTest, StopServerWithChunkedTransmission) {\n                                                              DataSink &sink) {\n       char buffer[27];\n       auto size = static_cast<size_t>(sprintf(buffer, \"data:%ld\\n\\n\", offset));\n-      sink.write(buffer, size);\n+      auto ret = sink.write(buffer, size);\n+      EXPECT_TRUE(ret);\n       std::this_thread::sleep_for(std::chrono::seconds(1));\n       return true;\n     });\n", "problem_statement": "SSLSocketStream::read Problem\nI found SSLSocketStream::read whill cause many dead block thread.\r\nI saw SSLSocketStream::read,this function call select function to check is the data is avaliable.I found the reason maybe is  when the socket comming bytes is not enough to produce a ssl record, and this time server or proxy 's connection is lost. \r\n\r\nI don't make sure my this post is correct\uff0ci am not familiar with openssl.\r\n\r\nI found some info aboud SSL_read and select below:\r\nhttp://openssl.6102.n7.nabble.com/Graceful-shutdown-of-TLS-connection-for-blocking-sockets-tp72626p72662.html\r\nhttps://blog.csdn.net/dog250/article/details/5456022\r\nhttps://baijiahao.baidu.com/s?id=1592012048270657934\r\n\r\n\r\nthanks\nHow to set timeout for sink.write() in chunked response?\nI found sometimes doing `sink.write()` in` set_chunked_content_provider` will block the program. I guess it may caused by some network issues like unstable connection. How to set a timeout or catch an exception to avoid this kind of block?\r\nI've tried set_write_timeout. But it does not work.\n", "hints_text": "@xtayaitak, thanks for the report. Could you provide a smallest possible example, so that I can reproduce and debug it? Thanks!\n@yhirose \r\nSorry I 'm new to openssl.Provide a smallest example is difficult.But use some unstable proxy can easyly cause this problem.I can provide a process dump file when this bug is appear.\r\n\r\nMaybe add WSA_FLAG_OVERLAPPED  for WSASocketW param and set socket option SO_RCVTIMEO can solve this problem temporary.\r\n\r\nI have changed my code and testing. Then i'll show you the result.\r\n\r\n\n@yhirose I added WSA_FLAG_OVERLAPPED  for WSASocketW  and set socket option SO_RCVTIMEO.This problem has never appeared again.\n@xtayaitak, glad to hear that. Could you send a pull request, so that I could check what you have done. Thanks!\nI splited the header to .cc and .h file,so i  my pull request is too many diffrence. \r\nchanged code list:\r\n1.\r\n![image](https://user-images.githubusercontent.com/4498459/110430223-02572b80-80e7-11eb-84c5-257c2845bbbb.png)\r\n\r\n2.\r\n![image](https://user-images.githubusercontent.com/4498459/110430257-0f741a80-80e7-11eb-9c2f-d57e35d4ac54.png)\r\n\r\n\n@xtayaitak, thanks for showing your code. Unfortunately, I cannot take the solution because WSA_FLAG_OVERLAPPED is only for non-blocking socket... I actually received the [same comments](https://github.com/yhirose/cpp-httplib/search?q=WSA_FLAG_OVERLAPPED&type=issues) before.\r\n\r\n@miketsts, do you have any clue on this issue? I thought the above problem has been fixed with #728. Any comments from you are appreciated!\n@yhirose I also tested CPPHTTPLIB_USE_POLL before .But that not work.This problem occured too.\n@yhirose  I'm sorry for not answering this issue before, I was a bit busy this week. \r\nAs I can see (I forgot a bit about my fix, it was a few months ago already :) ), my solution was to convert the socket to nonblocking while waiting for SSL connection to complete, and setting it back to blocking at the end.\r\nThis was in line with the previous call of `set_nonblocking()` in `create_client_socket()`, which we can see in line 808 of the snippet by @xtayaitak. So maybe the solution is to move this call before the call to `create_socket()` ?\r\n\r\nUnfortunately, my working environment is on Linux and I can't check if the solution by @xtayaitak works. I believe a good unit test could help.\r\nI know it's hard to think about a good test setup. For my fix I've created `SSLClientServerTest::SSLConnectTimeout` test which actually does not listen to socket, thus causing a timeout for a client. Maybe this may be a hint to @xtayaitak for a test for his case.\nJust to add to the previous answer. I am not an openssl specialist either.\r\nNow I see that in my solution in #728 I've also used a call to `BIO_set_nbio` which is an openssl counterpart of `set_nonblocking`. So maybe @xtayaitak should consider this as well, depending on the case.\r\nAlso, `set_nonblocking` is a generalization function for Windows/Linux compatibility. So if the solution is for Windows Sockets only, it probably should come in this or similar helper function. Just pay attention to the separation between SSL and non-SSL connections.\n@miketsts, thanks for the very helpful information.\r\n@xtayaitak, could you try with what @miketsts suggests on your Windows environment? Thanks for our help!\n@yhirose Since we already handle connection to SSL server in non-blocking mode, and now it seems like @xtayaitak will need to implement non-blocking SSL read/write. It might happen that the entire SSL sockets should be handled in non-blocking mode. I think this requires your \"strategic\" view.\n@xtayaitak, could you tell me which line is blocked in `SSLSocketStream::read` on your environment?\r\n\r\n![image](https://user-images.githubusercontent.com/357397/111055461-0fa44b00-8444-11eb-9735-f1e1b8cce4ef.png)\r\n\n@xtayaitak, any response?\n@yhirose Hello, I have the same problem, line 6533 is blocked in SSLSocketStream::read on my environment.\r\n\r\nAs @xtayaitak said\uff0csome unstable website can easyly cause this problem.For example, the following code:\r\n\r\n\thttplib::Client cli(\"https://read.aixdzs.com\");\r\n\thttplib::Result resp = cli.Get(\"/258/258745\");\r\n\tif (0 == resp.error() && 200 == resp->status)\r\n\t{\r\n\t\tsize_t len = strlen(\"https://read.aixdzs.com\");\r\n\t\tstd::string urltxt, content = utf82Gbk(resp->body);\r\n\t\tstd::string::size_type fpos = content.find(\"chapter\");\r\n\t\tif (fpos != std::string::npos)\r\n\t\t{\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\t\t\t\tstd::string::size_type spos = content.find(\"<a href=\\\"\", fpos);\r\n\t\t\t\tif (spos != std::string::npos)\r\n\t\t\t\t{\r\n\t\t\t\t\tspos += strlen(\"<a href=\\\"\");\r\n\t\t\t\t\tstd::string::size_type epos = content.find(\"\\\"\", spos);\r\n\t\t\t\t\tif (epos != std::string::npos)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\turltxt = \"/258/258745/\";\r\n\t\t\t\t\t\turltxt.append(content.substr(spos, epos - spos));\r\n\t\t\t\t\t\tfpos = epos;\r\n\r\n\t\t\t\t\t\thttplib::Client clir(\"https://read.aixdzs.com\");\r\n                                                // next line is blocked\r\n\t\t\t\t\t\thttplib::Result res = clir.Get(urltxt.c_str());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\nI agree with the following views\uff1a\r\nJust because select() says that something is readable (or writable) does not actually make it so.  The function only makes sense for non-blocking descriptors.  The use of select() with a blocking descriptor is always wrong.\n@yhirose \r\nblocked at this line.\r\n![image](https://user-images.githubusercontent.com/4498459/111463679-cd884b80-875a-11eb-87f8-d09d8bb092b3.png)\r\n\n@lrh450330, thanks for the detailed and helpful info.\r\n\r\n>  The use of select() with a blocking descriptor is always wrong.\r\n\r\nI think that `select()` can be used with a blocking socket according to the following stackoverflow post. \r\nhttps://stackoverflow.com/questions/28627804/can-select-be-used-with-blocking-sockets\n@xtayaitak, thanks!\nHowdy friends, we're running into this as well - the exact circumstances of the hang aren't clear since we're just working with crash dumps taken from production servers, but here's the relevant part of the backtrace:\r\n\r\n```bt\r\nThread 8 (Thread 0x7fd6a7fff700 (LWP 758584)):\r\n#0  __libc_read (nbytes=460, buf=0x7fd69ccb2571, fd=18) at ../sysdeps/unix/sysv/linux/read.c:26\r\n#1  __libc_read (fd=18, buf=0x7fd69ccb2571, nbytes=460) at ../sysdeps/unix/sysv/linux/read.c:24\r\n#2  0x00007fd6c4a7f389 in  () at /lib/x86_64-linux-gnu/libcrypto.so.1.1\r\n#3  0x00007fd6c4a7a62e in  () at /lib/x86_64-linux-gnu/libcrypto.so.1.1\r\n#4  0x00007fd6c4a79484 in  () at /lib/x86_64-linux-gnu/libcrypto.so.1.1\r\n#5  0x00007fd6c4a79a57 in BIO_read () at /lib/x86_64-linux-gnu/libcrypto.so.1.1\r\n#6  0x00007fd6c4d00b91 in  () at /lib/x86_64-linux-gnu/libssl.so.1.1\r\n#7  0x00007fd6c4d055b6 in  () at /lib/x86_64-linux-gnu/libssl.so.1.1\r\n#8  0x00007fd6c4d026d0 in  () at /lib/x86_64-linux-gnu/libssl.so.1.1\r\n#9  0x00007fd6c4d09c45 in  () at /lib/x86_64-linux-gnu/libssl.so.1.1\r\n#10 0x00007fd6c4d14a1f in  () at /lib/x86_64-linux-gnu/libssl.so.1.1\r\n#11 0x00007fd6c4d14b27 in SSL_read () at /lib/x86_64-linux-gnu/libssl.so.1.1\r\n#12 0x00007fd6c1e27991 in httplib::detail::SSLSocketStream::read(char*, unsigned long) (this=0x7fd6a7ffd920, ptr=0x7fd6a7ffc7b7 \"\", size=1) at ../vendor/cpp-httplib/httplib.h:6532\r\n#13 0x00007fd6c1e2f60c in httplib::detail::stream_line_reader::getline() (this=0x7fd6a7ffc8e0) at ../vendor/cpp-httplib/httplib.h:1736\r\n#14 0x00007fd6c1e55563 in httplib::ClientImpl::read_response_line(httplib::Stream&, httplib::Request const&, httplib::Response&) (strm=..., req=..., res=..., this=0x7fd69c1c6cd0) at ../vendor/cpp-httplib/httplib.h:5258\r\n[...]\r\n```\n@ZacheryGuan, `set_write_timeout` is the one to set timeout sec/usec. Since `sink.write()` will end up calling `select_write()`, could you take a look at the code in the function to get more information? If `select` system call doesn't work on the OS that you are working on, you may want to try `poll` with CPPHTTPLIB_USE_POLL.\r\n\r\nhttps://github.com/yhirose/cpp-httplib/blob/faa5f1d8023746a3da9f275c51867ded2a672ee9/httplib.h#L1849-L1875\r\n\r\nHope it helps.\r\n\nI've tried CPPHTTPLIB_USE_POLL and it will also block. By debugging the program, I find the program stucks here:\r\nhttps://github.com/yhirose/cpp-httplib/blob/faa5f1d8023746a3da9f275c51867ded2a672ee9/httplib.h#L4139-L4140\n@ZacheryGuan, thanks for the information. Do you think that it's easy to reproduce the condition on someone's machine like my machine? Otherwise, it's too hard for me to debug it. Or could you try to fix it on your machine and send a pull request? Thanks!\nSorry for the inconvenience. To reproduce this, it may require additional network components, a load balancer in my case. \r\n\r\nGenerally, I need to transfer a lot data (like 1M) to the client. The client failed to read socket so its receive buffer is full. In the meantime, the server's send buffer is also full. The socket `send` will block under such circumstance.\r\n\r\nI found [a helpful post discussing about this](https://www.softlab.ntua.gr/facilities/documentation/unix/unix-socket-faq/unix-socket-faq-2.html). You can locate related discussion by searching `The sender blocks when the socket send buffer is full, so buffers will be full at both ends.` in the browser.\n@ZacheryGuan, sorry that the helpful post that you mentioned is reported as \"Your connection is not fully secure\" on my Chrome... I feel like it's a general socket issue which can happen in whatever HTTP libraries. Could you try with other HTTP client like curl to verify it on your machine? Thanks!\n@yhirose, Thanks for your opinion! Though I have not tried other http server lib, I also feel like this may be a general socket issue. \r\nI have managed to reproduce it using following code. The server writes big chunk(like 100K) of data and the client is not reading socket buffer. Client code is using Java.\r\nhttps://github.com/ZacheryGuan/cpp-httplib-900/tree/main\r\n\r\nAfter running the server and the client, the server only outputs 4 lines on my machine, while the server should print 1024*1024 lines:\r\n```\r\nwrite 0 th\r\nwrite 1 th\r\nwrite 2 th\r\nwrite 3 th\r\nwrite 4 th\r\n```\r\n----\r\n\r\nBTW, an unrelated question: what will happen when many clients send requests simultaneously to a server using only 1 thread (by `svr.new_task_queue = [] { return new httplib::ThreadPool(1); };`)? It seems that the server only responses the first request and ignores the others. The server will recover to listen until the first response finishes.\n@ZacheryGuan, thanks for the sample code. I am able to reproduce the problem on my macOS. I'll take a look at it when I have time. Thank you!", "created_at": "2021-04-17T02:05:39Z", "version": "0.8"}
{"repo": "yhirose/cpp-httplib", "pull_number": 374, "instance_id": "yhirose__cpp-httplib-374", "issue_numbers": ["372"], "base_commit": "18e750b4e7fd221831d5e642887f6415e7d06972", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -349,14 +349,14 @@ class Stream {\n   virtual bool is_readable() const = 0;\n   virtual bool is_writable() const = 0;\n \n-  virtual int read(char *ptr, size_t size) = 0;\n-  virtual int write(const char *ptr, size_t size) = 0;\n+  virtual ssize_t read(char *ptr, size_t size) = 0;\n+  virtual ssize_t write(const char *ptr, size_t size) = 0;\n   virtual std::string get_remote_addr() const = 0;\n \n   template <typename... Args>\n-  int write_format(const char *fmt, const Args &... args);\n-  int write(const char *ptr);\n-  int write(const std::string &s);\n+  ssize_t write_format(const char *fmt, const Args &... args);\n+  ssize_t write(const char *ptr);\n+  ssize_t write(const std::string &s);\n };\n \n class TaskQueue {\n@@ -953,26 +953,26 @@ inline size_t to_utf8(int code, char *buff) {\n     buff[0] = (code & 0x7F);\n     return 1;\n   } else if (code < 0x0800) {\n-    buff[0] = (0xC0 | ((code >> 6) & 0x1F));\n-    buff[1] = (0x80 | (code & 0x3F));\n+    buff[0] = static_cast<char>(0xC0 | ((code >> 6) & 0x1F));\n+    buff[1] = static_cast<char>(0x80 | (code & 0x3F));\n     return 2;\n   } else if (code < 0xD800) {\n-    buff[0] = (0xE0 | ((code >> 12) & 0xF));\n-    buff[1] = (0x80 | ((code >> 6) & 0x3F));\n-    buff[2] = (0x80 | (code & 0x3F));\n+    buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));\n+    buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));\n+    buff[2] = static_cast<char>(0x80 | (code & 0x3F));\n     return 3;\n   } else if (code < 0xE000) { // D800 - DFFF is invalid...\n     return 0;\n   } else if (code < 0x10000) {\n-    buff[0] = (0xE0 | ((code >> 12) & 0xF));\n-    buff[1] = (0x80 | ((code >> 6) & 0x3F));\n-    buff[2] = (0x80 | (code & 0x3F));\n+    buff[0] = static_cast<char>(0xE0 | ((code >> 12) & 0xF));\n+    buff[1] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));\n+    buff[2] = static_cast<char>(0x80 | (code & 0x3F));\n     return 3;\n   } else if (code < 0x110000) {\n-    buff[0] = (0xF0 | ((code >> 18) & 0x7));\n-    buff[1] = (0x80 | ((code >> 12) & 0x3F));\n-    buff[2] = (0x80 | ((code >> 6) & 0x3F));\n-    buff[3] = (0x80 | (code & 0x3F));\n+    buff[0] = static_cast<char>(0xF0 | ((code >> 18) & 0x7));\n+    buff[1] = static_cast<char>(0x80 | ((code >> 12) & 0x3F));\n+    buff[2] = static_cast<char>(0x80 | ((code >> 6) & 0x3F));\n+    buff[3] = static_cast<char>(0x80 | (code & 0x3F));\n     return 4;\n   }\n \n@@ -992,8 +992,8 @@ inline std::string base64_encode(const std::string &in) {\n   int val = 0;\n   int valb = -6;\n \n-  for (uint8_t c : in) {\n-    val = (val << 8) + c;\n+  for (auto c : in) {\n+    val = (val << 8) + static_cast<uint8_t>(c);\n     valb += 8;\n     while (valb >= 0) {\n       out.push_back(lookup[(val >> valb) & 0x3F]);\n@@ -1188,7 +1188,7 @@ inline int select_read(socket_t sock, time_t sec, time_t usec) {\n \n   timeval tv;\n   tv.tv_sec = static_cast<long>(sec);\n-  tv.tv_usec = static_cast<long>(usec);\n+  tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);\n \n   return select(static_cast<int>(sock + 1), &fds, nullptr, nullptr, &tv);\n #endif\n@@ -1210,7 +1210,7 @@ inline int select_write(socket_t sock, time_t sec, time_t usec) {\n \n   timeval tv;\n   tv.tv_sec = static_cast<long>(sec);\n-  tv.tv_usec = static_cast<long>(usec);\n+  tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);\n \n   return select(static_cast<int>(sock + 1), nullptr, &fds, nullptr, &tv);\n #endif\n@@ -1243,7 +1243,7 @@ inline bool wait_until_socket_is_ready(socket_t sock, time_t sec, time_t usec) {\n \n   timeval tv;\n   tv.tv_sec = static_cast<long>(sec);\n-  tv.tv_usec = static_cast<long>(usec);\n+  tv.tv_usec = static_cast<decltype(tv.tv_usec)>(usec);\n \n   if (select(static_cast<int>(sock + 1), &fdsr, &fdsw, &fdse, &tv) > 0 &&\n       (FD_ISSET(sock, &fdsr) || FD_ISSET(sock, &fdsw))) {\n@@ -1265,8 +1265,8 @@ class SocketStream : public Stream {\n \n   bool is_readable() const override;\n   bool is_writable() const override;\n-  int read(char *ptr, size_t size) override;\n-  int write(const char *ptr, size_t size) override;\n+  ssize_t read(char *ptr, size_t size) override;\n+  ssize_t write(const char *ptr, size_t size) override;\n   std::string get_remote_addr() const override;\n \n private:\n@@ -1284,8 +1284,8 @@ class SSLSocketStream : public Stream {\n \n   bool is_readable() const override;\n   bool is_writable() const override;\n-  int read(char *ptr, size_t size) override;\n-  int write(const char *ptr, size_t size) override;\n+  ssize_t read(char *ptr, size_t size) override;\n+  ssize_t write(const char *ptr, size_t size) override;\n   std::string get_remote_addr() const override;\n \n private:\n@@ -1303,15 +1303,15 @@ class BufferStream : public Stream {\n \n   bool is_readable() const override;\n   bool is_writable() const override;\n-  int read(char *ptr, size_t size) override;\n-  int write(const char *ptr, size_t size) override;\n+  ssize_t read(char *ptr, size_t size) override;\n+  ssize_t write(const char *ptr, size_t size) override;\n   std::string get_remote_addr() const override;\n \n   const std::string &get_buffer() const;\n \n private:\n   std::string buffer;\n-  int position = 0;\n+  size_t position = 0;\n };\n \n template <typename T>\n@@ -1479,7 +1479,7 @@ inline bool bind_ip_address(socket_t sock, const char *host) {\n   auto ret = false;\n   for (auto rp = result; rp; rp = rp->ai_next) {\n     const auto &ai = *rp;\n-    if (!::bind(sock, ai.ai_addr, static_cast<int>(ai.ai_addrlen))) {\n+    if (!::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {\n       ret = true;\n       break;\n     }\n@@ -1523,7 +1523,8 @@ inline socket_t create_client_socket(const char *host, int port,\n \n         set_nonblocking(sock, true);\n \n-        auto ret = ::connect(sock, ai.ai_addr, static_cast<int>(ai.ai_addrlen));\n+        auto ret =\n+            ::connect(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen));\n         if (ret < 0) {\n           if (is_connection_error() ||\n               !wait_until_socket_is_ready(sock, timeout_sec, 0)) {\n@@ -1640,7 +1641,7 @@ inline bool compress(std::string &content) {\n                           Z_DEFAULT_STRATEGY);\n   if (ret != Z_OK) { return false; }\n \n-  strm.avail_in = content.size();\n+  strm.avail_in = static_cast<decltype(strm.avail_in)>(content.size());\n   strm.next_in =\n       const_cast<Bytef *>(reinterpret_cast<const Bytef *>(content.data()));\n \n@@ -1687,7 +1688,7 @@ class decompressor {\n   bool decompress(const char *data, size_t data_length, T callback) {\n     int ret = Z_OK;\n \n-    strm.avail_in = data_length;\n+    strm.avail_in = static_cast<decltype(strm.avail_in)>(data_length);\n     strm.next_in = const_cast<Bytef *>(reinterpret_cast<const Bytef *>(data));\n \n     std::array<char, 16384> buff{};\n@@ -1724,13 +1725,13 @@ inline bool has_header(const Headers &headers, const char *key) {\n inline const char *get_header_value(const Headers &headers, const char *key,\n                                     size_t id = 0, const char *def = nullptr) {\n   auto it = headers.find(key);\n-  std::advance(it, id);\n+  std::advance(it, static_cast<int>(id));\n   if (it != headers.end()) { return it->second.c_str(); }\n   return def;\n }\n \n inline uint64_t get_header_value_uint64(const Headers &headers, const char *key,\n-                                        int def = 0) {\n+                                        uint64_t def = 0) {\n   auto it = headers.find(key);\n   if (it != headers.end()) {\n     return std::strtoull(it->second.data(), nullptr, 10);\n@@ -1787,9 +1788,9 @@ inline bool read_content_with_length(Stream &strm, uint64_t len,\n     auto n = strm.read(buf, std::min(read_len, CPPHTTPLIB_RECV_BUFSIZ));\n     if (n <= 0) { return false; }\n \n-    if (!out(buf, n)) { return false; }\n+    if (!out(buf, static_cast<size_t>(n))) { return false; }\n \n-    r += n;\n+    r += static_cast<uint64_t>(n);\n \n     if (progress) {\n       if (!progress(r, len)) { return false; }\n@@ -1806,7 +1807,7 @@ inline void skip_content_with_length(Stream &strm, uint64_t len) {\n     auto read_len = static_cast<size_t>(len - r);\n     auto n = strm.read(buf, std::min(read_len, CPPHTTPLIB_RECV_BUFSIZ));\n     if (n <= 0) { return; }\n-    r += n;\n+    r += static_cast<uint64_t>(n);\n   }\n }\n \n@@ -1819,7 +1820,7 @@ inline bool read_content_without_length(Stream &strm, ContentReceiver out) {\n     } else if (n == 0) {\n       return true;\n     }\n-    if (!out(buf, n)) { return false; }\n+    if (!out(buf, static_cast<size_t>(n))) { return false; }\n   }\n \n   return true;\n@@ -1833,7 +1834,7 @@ inline bool read_content_chunked(Stream &strm, ContentReceiver out) {\n \n   if (!line_reader.getline()) { return false; }\n \n-  auto chunk_len = std::stoi(line_reader.ptr(), 0, 16);\n+  auto chunk_len = std::stoul(line_reader.ptr(), 0, 16);\n \n   while (chunk_len > 0) {\n     if (!read_content_with_length(strm, chunk_len, nullptr, out)) {\n@@ -1846,7 +1847,7 @@ inline bool read_content_chunked(Stream &strm, ContentReceiver out) {\n \n     if (!line_reader.getline()) { return false; }\n \n-    chunk_len = std::stoi(line_reader.ptr(), 0, 16);\n+    chunk_len = std::stoul(line_reader.ptr(), 0, 16);\n   }\n \n   if (chunk_len == 0) {\n@@ -1918,7 +1919,8 @@ bool read_content(Stream &strm, T &x, size_t payload_max_length, int &status,\n }\n \n template <typename T>\n-inline int write_headers(Stream &strm, const T &info, const Headers &headers) {\n+inline ssize_t write_headers(Stream &strm, const T &info,\n+                             const Headers &headers) {\n   auto write_len = 0;\n   for (const auto &x : info.headers) {\n     auto len =\n@@ -2009,7 +2011,7 @@ inline bool redirect(T &cli, const Request &req, Response &res,\n inline std::string encode_url(const std::string &s) {\n   std::string result;\n \n-  for (auto i = 0; s[i]; i++) {\n+  for (size_t i = 0; s[i]; i++) {\n     switch (s[i]) {\n     case ' ': result += \"%20\"; break;\n     case '+': result += \"%2B\"; break;\n@@ -2024,9 +2026,9 @@ inline std::string encode_url(const std::string &s) {\n       if (c >= 0x80) {\n         result += '%';\n         char hex[4];\n-        size_t len = snprintf(hex, sizeof(hex) - 1, \"%02X\", c);\n+        auto len = snprintf(hex, sizeof(hex) - 1, \"%02X\", c);\n         assert(len == 2);\n-        result.append(hex, len);\n+        result.append(hex, static_cast<size_t>(len));\n       } else {\n         result += s[i];\n       }\n@@ -2114,8 +2116,8 @@ inline bool parse_range_header(const std::string &s, Ranges &ranges) {\n   static auto re_first_range = std::regex(R\"(bytes=(\\d*-\\d*(?:,\\s*\\d*-\\d*)*))\");\n   std::smatch m;\n   if (std::regex_match(s, m, re_first_range)) {\n-    auto pos = m.position(1);\n-    auto len = m.length(1);\n+    auto pos = static_cast<size_t>(m.position(1));\n+    auto len = static_cast<size_t>(m.length(1));\n     bool all_valid_ranges = true;\n     split(&s[pos], &s[pos + len], ',', [&](const char *b, const char *e) {\n       if (!all_valid_ranges) return;\n@@ -2347,12 +2349,14 @@ get_range_offset_and_length(const Request &req, size_t content_length,\n     return std::make_pair(0, content_length);\n   }\n \n+  auto slen = static_cast<ssize_t>(content_length);\n+\n   if (r.first == -1) {\n-    r.first = content_length - r.second;\n-    r.second = content_length - 1;\n+    r.first = slen - r.second;\n+    r.second = slen - 1;\n   }\n \n-  if (r.second == -1) { r.second = content_length - 1; }\n+  if (r.second == -1) { r.second = slen - 1; }\n \n   return std::make_pair(r.first, r.second - r.first + 1);\n }\n@@ -2456,7 +2460,9 @@ get_range_offset_and_length(const Request &req, const Response &res,\n                             size_t index) {\n   auto r = req.ranges[index];\n \n-  if (r.second == -1) { r.second = res.content_length - 1; }\n+  if (r.second == -1) {\n+    r.second = static_cast<ssize_t>(res.content_length) - 1;\n+  }\n \n   return std::make_pair(r.first, r.second - r.first + 1);\n }\n@@ -2611,9 +2617,13 @@ inline bool parse_www_authenticate(const httplib::Response &res,\n         auto beg = std::sregex_iterator(s.begin(), s.end(), re);\n         for (auto i = beg; i != std::sregex_iterator(); ++i) {\n           auto m = *i;\n-          auto key = s.substr(m.position(1), m.length(1));\n-          auto val = m.length(2) > 0 ? s.substr(m.position(2), m.length(2))\n-                                     : s.substr(m.position(3), m.length(3));\n+          auto key = s.substr(static_cast<size_t>(m.position(1)),\n+                              static_cast<size_t>(m.length(1)));\n+          auto val = m.length(2) > 0\n+                         ? s.substr(static_cast<size_t>(m.position(2)),\n+                                    static_cast<size_t>(m.length(2)))\n+                         : s.substr(static_cast<size_t>(m.position(3)),\n+                                    static_cast<size_t>(m.length(3)));\n           auth[key] = val;\n         }\n         return true;\n@@ -2630,7 +2640,7 @@ inline std::string random_string(size_t length) {\n                            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                            \"abcdefghijklmnopqrstuvwxyz\";\n     const size_t max_index = (sizeof(charset) - 1);\n-    return charset[rand() % max_index];\n+    return charset[static_cast<size_t>(rand()) % max_index];\n   };\n   std::string str(length, 0);\n   std::generate_n(str.begin(), length, randchar);\n@@ -2648,7 +2658,7 @@ inline std::string Request::get_header_value(const char *key, size_t id) const {\n \n inline size_t Request::get_header_value_count(const char *key) const {\n   auto r = headers.equal_range(key);\n-  return std::distance(r.first, r.second);\n+  return static_cast<size_t>(std::distance(r.first, r.second));\n }\n \n inline void Request::set_header(const char *key, const char *val) {\n@@ -2665,14 +2675,14 @@ inline bool Request::has_param(const char *key) const {\n \n inline std::string Request::get_param_value(const char *key, size_t id) const {\n   auto it = params.find(key);\n-  std::advance(it, id);\n+  std::advance(it, static_cast<ssize_t>(id));\n   if (it != params.end()) { return it->second; }\n   return std::string();\n }\n \n inline size_t Request::get_param_value_count(const char *key) const {\n   auto r = params.equal_range(key);\n-  return std::distance(r.first, r.second);\n+  return static_cast<size_t>(std::distance(r.first, r.second));\n }\n \n inline bool Request::is_multipart_form_data() const {\n@@ -2702,7 +2712,7 @@ inline std::string Response::get_header_value(const char *key,\n \n inline size_t Response::get_header_value_count(const char *key) const {\n   auto r = headers.equal_range(key);\n-  return std::distance(r.first, r.second);\n+  return static_cast<size_t>(std::distance(r.first, r.second));\n }\n \n inline void Response::set_header(const char *key, const char *val) {\n@@ -2753,33 +2763,39 @@ inline void Response::set_chunked_content_provider(\n }\n \n // Rstream implementation\n-inline int Stream::write(const char *ptr) { return write(ptr, strlen(ptr)); }\n+inline ssize_t Stream::write(const char *ptr) {\n+  return write(ptr, strlen(ptr));\n+}\n \n-inline int Stream::write(const std::string &s) {\n+inline ssize_t Stream::write(const std::string &s) {\n   return write(s.data(), s.size());\n }\n \n template <typename... Args>\n-inline int Stream::write_format(const char *fmt, const Args &... args) {\n+inline ssize_t Stream::write_format(const char *fmt, const Args &... args) {\n   std::array<char, 2048> buf;\n \n #if defined(_MSC_VER) && _MSC_VER < 1900\n-  auto n = _snprintf_s(buf, bufsiz, buf.size() - 1, fmt, args...);\n+  auto sn = _snprintf_s(buf, bufsiz, buf.size() - 1, fmt, args...);\n #else\n-  auto n = snprintf(buf.data(), buf.size() - 1, fmt, args...);\n+  auto sn = snprintf(buf.data(), buf.size() - 1, fmt, args...);\n #endif\n-  if (n <= 0) { return n; }\n+  if (sn <= 0) { return sn; }\n \n-  if (n >= static_cast<int>(buf.size()) - 1) {\n+  auto n = static_cast<size_t>(sn);\n+\n+  if (n >= buf.size() - 1) {\n     std::vector<char> glowable_buf(buf.size());\n \n-    while (n >= static_cast<int>(glowable_buf.size() - 1)) {\n+    while (n >= glowable_buf.size() - 1) {\n       glowable_buf.resize(glowable_buf.size() * 2);\n #if defined(_MSC_VER) && _MSC_VER < 1900\n-      n = _snprintf_s(&glowable_buf[0], glowable_buf.size(),\n-                      glowable_buf.size() - 1, fmt, args...);\n+      n = static_cast<size_t>(_snprintf_s(&glowable_buf[0], glowable_buf.size(),\n+                                          glowable_buf.size() - 1, fmt,\n+                                          args...));\n #else\n-      n = snprintf(&glowable_buf[0], glowable_buf.size() - 1, fmt, args...);\n+      n = static_cast<size_t>(\n+          snprintf(&glowable_buf[0], glowable_buf.size() - 1, fmt, args...));\n #endif\n     }\n     return write(&glowable_buf[0], n);\n@@ -2806,13 +2822,13 @@ inline bool SocketStream::is_writable() const {\n   return detail::select_write(sock_, 0, 0) > 0;\n }\n \n-inline int SocketStream::read(char *ptr, size_t size) {\n-  if (is_readable()) { return recv(sock_, ptr, static_cast<int>(size), 0); }\n+inline ssize_t SocketStream::read(char *ptr, size_t size) {\n+  if (is_readable()) { return recv(sock_, ptr, size, 0); }\n   return -1;\n }\n \n-inline int SocketStream::write(const char *ptr, size_t size) {\n-  if (is_writable()) { return send(sock_, ptr, static_cast<int>(size), 0); }\n+inline ssize_t SocketStream::write(const char *ptr, size_t size) {\n+  if (is_writable()) { return send(sock_, ptr, size, 0); }\n   return -1;\n }\n \n@@ -2825,19 +2841,19 @@ inline bool BufferStream::is_readable() const { return true; }\n \n inline bool BufferStream::is_writable() const { return true; }\n \n-inline int BufferStream::read(char *ptr, size_t size) {\n+inline ssize_t BufferStream::read(char *ptr, size_t size) {\n #if defined(_MSC_VER) && _MSC_VER < 1900\n-  int len_read = static_cast<int>(buffer._Copy_s(ptr, size, size, position));\n+  auto len_read = buffer._Copy_s(ptr, size, size, position);\n #else\n-  int len_read = static_cast<int>(buffer.copy(ptr, size, position));\n+  auto len_read = buffer.copy(ptr, size, position);\n #endif\n-  position += len_read;\n-  return len_read;\n+  position += static_cast<size_t>(len_read);\n+  return static_cast<ssize_t>(len_read);\n }\n \n-inline int BufferStream::write(const char *ptr, size_t size) {\n+inline ssize_t BufferStream::write(const char *ptr, size_t size) {\n   buffer.append(ptr, size);\n-  return static_cast<int>(size);\n+  return static_cast<ssize_t>(size);\n }\n \n inline std::string BufferStream::get_remote_addr() const { return \"\"; }\n@@ -3297,7 +3313,7 @@ inline socket_t Server::create_server_socket(const char *host, int port,\n   return detail::create_socket(\n       host, port,\n       [](socket_t sock, struct addrinfo &ai) -> bool {\n-        if (::bind(sock, ai.ai_addr, static_cast<int>(ai.ai_addrlen))) {\n+        if (::bind(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen))) {\n           return false;\n         }\n         if (::listen(sock, 5)) { // Listen through 5 channels\n@@ -3875,7 +3891,7 @@ inline bool Client::write_request(Stream &strm, const Request &req,\n       DataSink data_sink;\n       data_sink.write = [&](const char *d, size_t l) {\n         auto written_length = strm.write(d, l);\n-        offset += written_length;\n+        offset += static_cast<size_t>(written_length);\n       };\n       data_sink.is_writable = [&](void) { return strm.is_writable(); };\n \n@@ -4476,7 +4492,7 @@ inline bool SSLSocketStream::is_writable() const {\n   return detail::select_write(sock_, 0, 0) > 0;\n }\n \n-inline int SSLSocketStream::read(char *ptr, size_t size) {\n+inline ssize_t SSLSocketStream::read(char *ptr, size_t size) {\n   if (SSL_pending(ssl_) > 0 ||\n       select_read(sock_, read_timeout_sec_, read_timeout_usec_) > 0) {\n     return SSL_read(ssl_, ptr, static_cast<int>(size));\n@@ -4484,7 +4500,7 @@ inline int SSLSocketStream::read(char *ptr, size_t size) {\n   return -1;\n }\n \n-inline int SSLSocketStream::write(const char *ptr, size_t size) {\n+inline ssize_t SSLSocketStream::write(const char *ptr, size_t size) {\n   if (is_writable()) { return SSL_write(ssl_, ptr, static_cast<int>(size)); }\n   return -1;\n }\n@@ -4744,7 +4760,9 @@ inline bool SSLClient::verify_host_with_common_name(X509 *server_cert) const {\n     auto name_len = X509_NAME_get_text_by_NID(subject_name, NID_commonName,\n                                               name, sizeof(name));\n \n-    if (name_len != -1) { return check_host_name(name, name_len); }\n+    if (name_len != -1) {\n+      return check_host_name(name, static_cast<size_t>(name_len));\n+    }\n   }\n \n   return false;\n", "test_patch": "diff --git a/test/Makefile b/test/Makefile\n--- a/test/Makefile\n+++ b/test/Makefile\n@@ -1,6 +1,6 @@\n \n #CXX = clang++\n-CXXFLAGS = -ggdb -O0 -std=c++11 -DGTEST_USE_OWN_TR1_TUPLE -I.. -I. -Wall -Wextra -Wtype-limits\n+CXXFLAGS = -ggdb -O0 -std=c++11 -DGTEST_USE_OWN_TR1_TUPLE -I.. -I. -Wall -Wextra -Wtype-limits -Wconversion\n OPENSSL_DIR = /usr/local/opt/openssl\n OPENSSL_SUPPORT = -DCPPHTTPLIB_OPENSSL_SUPPORT -I$(OPENSSL_DIR)/include -L$(OPENSSL_DIR)/lib -lssl -lcrypto\n ZLIB_SUPPORT = -DCPPHTTPLIB_ZLIB_SUPPORT -lz\ndiff --git a/test/gtest/gtest-all.cc b/test/gtest/gtest-all.cc\n--- a/test/gtest/gtest-all.cc\n+++ b/test/gtest/gtest-all.cc\n@@ -38,6 +38,14 @@\n // when it's fused.\n #include \"gtest/gtest.h\"\n \n+#if __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wsign-conversion\"\n+#elif __GNUC__\n+#pragma gcc diagnostic push\n+#pragma gcc diagnostic ignored \"-Wsign-conversion\"\n+#endif\n+\n // The following lines pull in the real gtest *.cc files.\n // Copyright 2005, Google Inc.\n // All rights reserved.\n@@ -9039,7 +9047,6 @@ void HasNewFatalFailureHelper::ReportTestPartResult(\n //\n // Author: wan@google.com (Zhanyong Wan)\n \n-\n namespace testing {\n namespace internal {\n \n@@ -9116,3 +9123,9 @@ const char* TypedTestCasePState::VerifyRegisteredTestNames(\n \n }  // namespace internal\n }  // namespace testing\n+\n+#if __clang__\n+#pragma clang diagnostic pop\n+#elif __GNUC__\n+#pragma gcc diagnostic pop\n+#endif\ndiff --git a/test/gtest/gtest.h b/test/gtest/gtest.h\n--- a/test/gtest/gtest.h\n+++ b/test/gtest/gtest.h\n@@ -59,6 +59,14 @@\n #pragma warning(disable : 4996)\n #endif\n \n+#if __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wsign-compare\"\n+#elif __GNUC__\n+#pragma gcc diagnostic push\n+#pragma gcc diagnostic ignored \"-Wsign-compare\"\n+#endif\n+\n // Copyright 2005, Google Inc.\n // All rights reserved.\n //\n@@ -7311,7 +7319,7 @@ inline const char* SkipComma(const char* str) {\n // the entire string if it contains no comma.\n inline String GetPrefixUntilComma(const char* str) {\n   const char* comma = strchr(str, ',');\n-  return comma == NULL ? String(str) : String(str, comma - str);\n+  return comma == NULL ? String(str) : String(str, static_cast<size_t>(comma - str));\n }\n \n // TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n@@ -19553,4 +19561,10 @@ bool StaticAssertTypeEq() {\n #pragma warning( pop )\n #endif\n \n+#if __clang__\n+#pragma clang diagnostic pop\n+#elif __GNUC__\n+#pragma gcc diagnostic pop\n+#endif\n+\n #endif  // GTEST_INCLUDE_GTEST_GTEST_H_\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1858,7 +1858,7 @@ TEST_F(ServerTest, KeepAlive) {\n   ASSERT_TRUE(ret == true);\n   ASSERT_TRUE(requests.size() == responses.size());\n \n-  for (int i = 0; i < 3; i++) {\n+  for (size_t i = 0; i < 3; i++) {\n     auto &res = responses[i];\n     EXPECT_EQ(200, res.status);\n     EXPECT_EQ(\"text/plain\", res.get_header_value(\"Content-Type\"));\n@@ -2129,7 +2129,7 @@ TEST(ServerStopTest, StopServerWithChunkedTransmission) {\n     res.set_header(\"Cache-Control\", \"no-cache\");\n     res.set_chunked_content_provider([](size_t offset, const DataSink &sink) {\n       char buffer[27];\n-      int size = sprintf(buffer, \"data:%ld\\n\\n\", offset);\n+      auto size = static_cast<size_t>(sprintf(buffer, \"data:%ld\\n\\n\", offset));\n       sink.write(buffer, size);\n       std::this_thread::sleep_for(std::chrono::seconds(1));\n     });\n@@ -2389,7 +2389,7 @@ TEST(SSLClientServerTest, ClientCertPresent) {\n       char name[BUFSIZ];\n       auto name_len = X509_NAME_get_text_by_NID(subject_name, NID_commonName,\n                                                 name, sizeof(name));\n-      common_name.assign(name, name_len);\n+      common_name.assign(name, static_cast<size_t>(name_len));\n     }\n \n     EXPECT_EQ(\"Common Name\", common_name);\n", "problem_statement": "Warnings when compiling with -Wconversion\nThere are few warnings when compiling the code with httplib.h included in gcc with -Wconversion flag.\r\n\r\n```\r\ng++ -o hello -std=c++14 -I.. -Wall -Wextra -Wconversion -pthread hello.cc -DCPPHTTPLIB_OPENSSL_SUPPORT -I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib -lssl -lcrypto -DCPPHTTPLIB_ZLIB_SUPPORT -lz\r\nIn file included from hello.cc:8:0:\r\n../httplib.h: In function \u2018size_t httplib::detail::to_utf8(int, char*)\u2019:\r\n../httplib.h:956:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[0] = (0xC0 | ((code >> 6) & 0x1F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:957:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[1] = (0x80 | (code & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~\r\n../httplib.h:960:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[0] = (0xE0 | ((code >> 12) & 0xF));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:961:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[1] = (0x80 | ((code >> 6) & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:962:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[2] = (0x80 | (code & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~\r\n../httplib.h:967:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[0] = (0xE0 | ((code >> 12) & 0xF));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:968:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[1] = (0x80 | ((code >> 6) & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:969:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[2] = (0x80 | (code & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~\r\n../httplib.h:972:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[0] = (0xF0 | ((code >> 18) & 0x7));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:973:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[1] = (0x80 | ((code >> 12) & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:974:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[2] = (0x80 | ((code >> 6) & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h:975:21: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\r\n     buff[3] = (0x80 | (code & 0x3F));\r\n               ~~~~~~^~~~~~~~~~~~~~~~\r\n../httplib.h: In function \u2018bool httplib::detail::compress(std::__cxx11::string&)\u2019:\r\n../httplib.h:1643:31: warning: conversion to \u2018uInt {aka unsigned int}\u2019 from \u2018std::__cxx11::basic_string<char>::size_type {aka long unsigned int}\u2019 may alter its value [-Wconversion]\r\n   strm.avail_in = content.size();\r\n                   ~~~~~~~~~~~~^~\r\n../httplib.h: In member function \u2018virtual int httplib::detail::SocketStream::read(char*, size_t)\u2019:\r\n../httplib.h:2810:35: warning: conversion to \u2018int\u2019 from \u2018ssize_t {aka long int}\u2019 may alter its value [-Wconversion]\r\n   if (is_readable()) { return recv(sock_, ptr, static_cast<int>(size), 0); }\r\n                               ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h: In member function \u2018virtual int httplib::detail::SocketStream::write(const char*, size_t)\u2019:\r\n../httplib.h:2815:35: warning: conversion to \u2018int\u2019 from \u2018ssize_t {aka long int}\u2019 may alter its value [-Wconversion]\r\n   if (is_writable()) { return send(sock_, ptr, static_cast<int>(size), 0); }\r\n                               ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n../httplib.h: In instantiation of \u2018bool httplib::detail::decompressor::decompress(const char*, size_t, T) [with T = httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver)::<lambda(const char*, size_t)> [with T = httplib::Request; size_t = long unsigned int]::<lambda(const char*, size_t)>; size_t = long unsigned int]\u2019:\r\n../httplib.h:1888:5:   required from \u2018httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver)::<lambda(const char*, size_t)> [with T = httplib::Request; size_t = long unsigned int]\u2019\r\n../httplib.h:1887:59:   required from \u2018struct httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver) [with T = httplib::Request; size_t = long unsigned int; httplib::Progress = std::function<bool(long unsigned int, long unsigned int)>; httplib::ContentReceiver = std::function<bool(const char*, long unsigned int)>]::<lambda(const char*, size_t)>\u2019\r\n../httplib.h:1885:9:   required from \u2018bool httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver) [with T = httplib::Request; size_t = long unsigned int; httplib::Progress = std::function<bool(long unsigned int, long unsigned int)>; httplib::ContentReceiver = std::function<bool(const char*, long unsigned int)>]\u2019\r\n../httplib.h:3251:44:   required from here\r\n../httplib.h:1690:19: warning: conversion to \u2018uInt {aka unsigned int}\u2019 from \u2018size_t {aka long unsigned int}\u2019 may alter its value [-Wconversion]\r\n     strm.avail_in = data_length;\r\n     ~~~~~~~~~~~~~~^~~~~~~~~~~~~\r\n../httplib.h: In instantiation of \u2018bool httplib::detail::decompressor::decompress(const char*, size_t, T) [with T = httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver)::<lambda(const char*, size_t)> [with T = httplib::Response; size_t = long unsigned int]::<lambda(const char*, size_t)>; size_t = long unsigned int]\u2019:\r\n../httplib.h:1888:5:   required from \u2018httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver)::<lambda(const char*, size_t)> [with T = httplib::Response; size_t = long unsigned int]\u2019\r\n../httplib.h:1887:59:   required from \u2018struct httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver) [with T = httplib::Response; size_t = long unsigned int; httplib::Progress = std::function<bool(long unsigned int, long unsigned int)>; httplib::ContentReceiver = std::function<bool(const char*, long unsigned int)>]::<lambda(const char*, size_t)>\u2019\r\n../httplib.h:1885:9:   required from \u2018bool httplib::detail::read_content(httplib::Stream&, T&, size_t, int&, httplib::Progress, httplib::ContentReceiver) [with T = httplib::Response; size_t = long unsigned int; httplib::Progress = std::function<bool(long unsigned int, long unsigned int)>; httplib::ContentReceiver = std::function<bool(const char*, long unsigned int)>]\u2019\r\n../httplib.h:3978:62:   required from here\r\n../httplib.h:1690:19: warning: conversion to \u2018uInt {aka unsigned int}\u2019 from \u2018size_t {aka long unsigned int}\u2019 may alter its value [-Wconversion]\r\n```\r\n\r\nThese don't look like real problems but clutter the compiler output.\r\n\r\nThanks\r\n\n", "hints_text": "", "created_at": "2020-03-10T03:55:32Z", "version": "0.5"}
{"repo": "yhirose/cpp-httplib", "pull_number": 290, "instance_id": "yhirose__cpp-httplib-290", "issue_numbers": ["285"], "base_commit": "10759f0a38fa2ed0ba2235b5b07ecda07dfe970e", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -114,6 +114,7 @@ using socket_t = SOCKET;\n \n #include <arpa/inet.h>\n #include <cstring>\n+#include <ifaddrs.h>\n #include <netdb.h>\n #include <netinet/in.h>\n #ifdef CPPHTTPLIB_USE_POLL\n@@ -743,6 +744,8 @@ class Client {\n \n   void set_compress(bool on);\n \n+  void set_interface(const char *intf);\n+\n protected:\n   bool process_request(Stream &strm, const Request &req, Response &res,\n                        bool last_connection, bool &connection_close);\n@@ -758,6 +761,7 @@ class Client {\n   std::string username_;\n   std::string password_;\n   bool compress_;\n+  std::string interface_;\n \n private:\n   socket_t create_client_socket() const;\n@@ -1348,10 +1352,62 @@ inline bool is_connection_error() {\n #endif\n }\n \n+inline bool bind_ip_address(socket_t sock, const char *host) {\n+  struct addrinfo hints;\n+  struct addrinfo *result;\n+\n+  memset(&hints, 0, sizeof(struct addrinfo));\n+  hints.ai_family = AF_UNSPEC;\n+  hints.ai_socktype = SOCK_STREAM;\n+  hints.ai_protocol = 0;\n+\n+  if (getaddrinfo(host, \"0\", &hints, &result)) { return false; }\n+\n+  bool ret = false;\n+  for (auto rp = result; rp; rp = rp->ai_next) {\n+    const auto &ai = *rp;\n+    if (!::bind(sock, ai.ai_addr, static_cast<int>(ai.ai_addrlen))) {\n+      ret = true;\n+      break;\n+    }\n+  }\n+\n+  freeaddrinfo(result);\n+  return ret;\n+}\n+\n+inline std::string if2ip(const std::string &ifn) {\n+#ifndef _WIN32\n+  struct ifaddrs *ifap;\n+  getifaddrs(&ifap);\n+  for (auto ifa = ifap; ifa; ifa = ifa->ifa_next) {\n+    if (ifa->ifa_addr && ifn == ifa->ifa_name) {\n+      if (ifa->ifa_addr->sa_family == AF_INET) {\n+        auto sa = reinterpret_cast<struct sockaddr_in *>(ifa->ifa_addr);\n+        char buf[INET_ADDRSTRLEN];\n+        if (inet_ntop(AF_INET, &sa->sin_addr, buf, INET_ADDRSTRLEN)) {\n+          freeifaddrs(ifap);\n+          return std::string(buf, INET_ADDRSTRLEN);\n+        }\n+      }\n+    }\n+  }\n+  freeifaddrs(ifap);\n+#endif\n+  return std::string();\n+}\n+\n inline socket_t create_client_socket(const char *host, int port,\n-                                     time_t timeout_sec) {\n+                                     time_t timeout_sec,\n+                                     const std::string &intf) {\n   return create_socket(\n-      host, port, [=](socket_t sock, struct addrinfo &ai) -> bool {\n+      host, port, [&](socket_t sock, struct addrinfo &ai) -> bool {\n+        if (!intf.empty()) {\n+          auto ip = if2ip(intf);\n+          if (ip.empty()) { ip = intf; }\n+          if (!bind_ip_address(sock, ip.c_str())) { return false; }\n+        }\n+\n         set_nonblocking(sock, true);\n \n         auto ret = ::connect(sock, ai.ai_addr, static_cast<int>(ai.ai_addrlen));\n@@ -3312,7 +3368,8 @@ inline Client::~Client() {}\n inline bool Client::is_valid() const { return true; }\n \n inline socket_t Client::create_client_socket() const {\n-  return detail::create_client_socket(host_.c_str(), port_, timeout_sec_);\n+  return detail::create_client_socket(host_.c_str(), port_, timeout_sec_,\n+                                      interface_);\n }\n \n inline bool Client::read_response_line(Stream &strm, Response &res) {\n@@ -3942,6 +3999,10 @@ inline void Client::set_follow_location(bool on) { follow_location_ = on; }\n \n inline void Client::set_compress(bool on) { compress_ = on; }\n \n+inline void Client::set_interface(const char *intf) {\n+  interface_ = intf;\n+}\n+\n /*\n  * SSL Implementation\n  */\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1817,8 +1817,8 @@ TEST_F(ServerTest, MultipartFormDataGzip) {\n \n // Sends a raw request to a server listening at HOST:PORT.\n static bool send_request(time_t read_timeout_sec, const std::string &req) {\n-  auto client_sock =\n-      detail::create_client_socket(HOST, PORT, /*timeout_sec=*/5);\n+  auto client_sock = detail::create_client_socket(HOST, PORT, /*timeout_sec=*/5,\n+                                                  std::string());\n \n   if (client_sock == INVALID_SOCKET) { return false; }\n \n", "problem_statement": "Q: Client request through specific network interface.\nHello, let me ask:\r\nmy PC has 3 internet connections (different providers),  so\r\nhow I can send requests by httplib::Client  through specific interface? \r\n// I known httplib::Server  supports it but what's about for Client...\n", "hints_text": "@m-garanin, thanks for the question. cpp-httplib doesn't support the feature right now. But I know curl supports `--interface` option that does what you are asking for. I'll consider to implement it when I have time.", "created_at": "2019-12-15T22:48:21Z", "version": "0.4"}
{"repo": "yhirose/cpp-httplib", "pull_number": 601, "instance_id": "yhirose__cpp-httplib-601", "issue_numbers": ["498"], "base_commit": "cf084e1db14f1f7ebff25d7ed8e9c52776ddaaab", "patch": "diff --git a/example/client.cc b/example/client.cc\n--- a/example/client.cc\n+++ b/example/client.cc\n@@ -23,12 +23,12 @@ int main(void) {\n   httplib::Client cli(\"localhost\", 8080);\n #endif\n \n-  auto res = cli.Get(\"/hi\");\n-  if (res) {\n+  if (auto res = cli.Get(\"/hi\")) {\n     cout << res->status << endl;\n     cout << res->get_header_value(\"Content-Type\") << endl;\n     cout << res->body << endl;\n   } else {\n+    cout << \"error code: \" << res.error() << std::endl;\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n     auto result = cli.get_openssl_verify_result();\n     if (result) {\ndiff --git a/example/simplecli.cc b/example/simplecli.cc\n--- a/example/simplecli.cc\n+++ b/example/simplecli.cc\n@@ -17,12 +17,12 @@ int main(void) {\n   auto scheme_host_port = \"http://localhost:8080\";\n #endif\n \n-  auto res = httplib::Client(scheme_host_port).Get(\"/hi\");\n-\n-  if (res) {\n+  if (auto res = httplib::Client(scheme_host_port).Get(\"/hi\")) {\n     cout << res->status << endl;\n     cout << res->get_header_value(\"Content-Type\") << endl;\n     cout << res->body << endl;\n+  } else {\n+    cout << res.error() << endl;\n   }\n \n   return 0;\ndiff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -396,6 +396,7 @@ struct Response {\n   void set_header(const char *key, const std::string &val);\n \n   void set_redirect(const char *url, int status = 302);\n+  void set_redirect(const std::string &url, int status = 302);\n   void set_content(const char *s, size_t n, const char *content_type);\n   void set_content(std::string s, const char *content_type);\n \n@@ -674,6 +675,36 @@ class Server {\n   SocketOptions socket_options_ = default_socket_options;\n };\n \n+enum Error {\n+  Success = 0,\n+  Unknown,\n+  Connection,\n+  BindIPAddress,\n+  Read,\n+  Write,\n+  ExceedRedirectCount,\n+  Canceled,\n+  SSLConnection,\n+  SSLLoadingCerts,\n+  SSLServerVerification\n+};\n+\n+class Result {\n+public:\n+  Result(std::shared_ptr<Response> res, Error err) : res_(res), err_(err) {}\n+  operator bool() { return res_ != nullptr; }\n+  bool operator==(nullptr_t) const { return res_ == nullptr; }\n+  bool operator!=(nullptr_t) const { return res_ != nullptr; }\n+  const Response &value() { return *res_; }\n+  const Response &operator*() { return *res_; }\n+  const Response *operator->() { return res_.get(); }\n+  Error error() { return err_; }\n+\n+private:\n+  std::shared_ptr<Response> res_;\n+  Error err_;\n+};\n+\n class ClientImpl {\n public:\n   explicit ClientImpl(const std::string &host);\n@@ -688,99 +719,76 @@ class ClientImpl {\n \n   virtual bool is_valid() const;\n \n-  std::shared_ptr<Response> Get(const char *path);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers);\n-  std::shared_ptr<Response> Get(const char *path, Progress progress);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                Progress progress);\n-  std::shared_ptr<Response> Get(const char *path,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response>\n-  Get(const char *path, ContentReceiver content_receiver, Progress progress);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ContentReceiver content_receiver,\n-                                Progress progress);\n-  std::shared_ptr<Response> Get(const char *path,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response> Get(const char *path,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver,\n-                                Progress progress);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver,\n-                                Progress progress);\n-\n-  std::shared_ptr<Response> Head(const char *path);\n-  std::shared_ptr<Response> Head(const char *path, const Headers &headers);\n-\n-  std::shared_ptr<Response> Post(const char *path);\n-  std::shared_ptr<Response> Post(const char *path, const std::string &body,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 const std::string &body,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, size_t content_length,\n-                                 ContentProvider content_provider,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 size_t content_length,\n-                                 ContentProvider content_provider,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, const Params &params);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 const Params &params);\n-  std::shared_ptr<Response> Post(const char *path,\n-                                 const MultipartFormDataItems &items);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 const MultipartFormDataItems &items);\n-\n-  std::shared_ptr<Response> Put(const char *path);\n-  std::shared_ptr<Response> Put(const char *path, const std::string &body,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, const Headers &headers,\n-                                const std::string &body,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, size_t content_length,\n-                                ContentProvider content_provider,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, const Headers &headers,\n-                                size_t content_length,\n-                                ContentProvider content_provider,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, const Params &params);\n-  std::shared_ptr<Response> Put(const char *path, const Headers &headers,\n-                                const Params &params);\n-\n-  std::shared_ptr<Response> Patch(const char *path, const std::string &body,\n-                                  const char *content_type);\n-  std::shared_ptr<Response> Patch(const char *path, const Headers &headers,\n-                                  const std::string &body,\n-                                  const char *content_type);\n-  std::shared_ptr<Response> Patch(const char *path, size_t content_length,\n-                                  ContentProvider content_provider,\n-                                  const char *content_type);\n-  std::shared_ptr<Response> Patch(const char *path, const Headers &headers,\n-                                  size_t content_length,\n-                                  ContentProvider content_provider,\n-                                  const char *content_type);\n-\n-  std::shared_ptr<Response> Delete(const char *path);\n-  std::shared_ptr<Response> Delete(const char *path, const std::string &body,\n-                                   const char *content_type);\n-  std::shared_ptr<Response> Delete(const char *path, const Headers &headers);\n-  std::shared_ptr<Response> Delete(const char *path, const Headers &headers,\n-                                   const std::string &body,\n-                                   const char *content_type);\n-\n-  std::shared_ptr<Response> Options(const char *path);\n-  std::shared_ptr<Response> Options(const char *path, const Headers &headers);\n+  Result Get(const char *path);\n+  Result Get(const char *path, const Headers &headers);\n+  Result Get(const char *path, Progress progress);\n+  Result Get(const char *path, const Headers &headers, Progress progress);\n+  Result Get(const char *path, ContentReceiver content_receiver);\n+  Result Get(const char *path, const Headers &headers,\n+             ContentReceiver content_receiver);\n+  Result Get(const char *path, ContentReceiver content_receiver,\n+             Progress progress);\n+  Result Get(const char *path, const Headers &headers,\n+             ContentReceiver content_receiver, Progress progress);\n+  Result Get(const char *path, ResponseHandler response_handler,\n+             ContentReceiver content_receiver);\n+  Result Get(const char *path, const Headers &headers,\n+             ResponseHandler response_handler,\n+             ContentReceiver content_receiver);\n+  Result Get(const char *path, ResponseHandler response_handler,\n+             ContentReceiver content_receiver, Progress progress);\n+  Result Get(const char *path, const Headers &headers,\n+             ResponseHandler response_handler, ContentReceiver content_receiver,\n+             Progress progress);\n+\n+  Result Head(const char *path);\n+  Result Head(const char *path, const Headers &headers);\n+\n+  Result Post(const char *path);\n+  Result Post(const char *path, const std::string &body,\n+              const char *content_type);\n+  Result Post(const char *path, const Headers &headers, const std::string &body,\n+              const char *content_type);\n+  Result Post(const char *path, size_t content_length,\n+              ContentProvider content_provider, const char *content_type);\n+  Result Post(const char *path, const Headers &headers, size_t content_length,\n+              ContentProvider content_provider, const char *content_type);\n+  Result Post(const char *path, const Params &params);\n+  Result Post(const char *path, const Headers &headers, const Params &params);\n+  Result Post(const char *path, const MultipartFormDataItems &items);\n+  Result Post(const char *path, const Headers &headers,\n+              const MultipartFormDataItems &items);\n+\n+  Result Put(const char *path);\n+  Result Put(const char *path, const std::string &body,\n+             const char *content_type);\n+  Result Put(const char *path, const Headers &headers, const std::string &body,\n+             const char *content_type);\n+  Result Put(const char *path, size_t content_length,\n+             ContentProvider content_provider, const char *content_type);\n+  Result Put(const char *path, const Headers &headers, size_t content_length,\n+             ContentProvider content_provider, const char *content_type);\n+  Result Put(const char *path, const Params &params);\n+  Result Put(const char *path, const Headers &headers, const Params &params);\n+\n+  Result Patch(const char *path, const std::string &body,\n+               const char *content_type);\n+  Result Patch(const char *path, const Headers &headers,\n+               const std::string &body, const char *content_type);\n+  Result Patch(const char *path, size_t content_length,\n+               ContentProvider content_provider, const char *content_type);\n+  Result Patch(const char *path, const Headers &headers, size_t content_length,\n+               ContentProvider content_provider, const char *content_type);\n+\n+  Result Delete(const char *path);\n+  Result Delete(const char *path, const std::string &body,\n+                const char *content_type);\n+  Result Delete(const char *path, const Headers &headers);\n+  Result Delete(const char *path, const Headers &headers,\n+                const std::string &body, const char *content_type);\n+\n+  Result Options(const char *path);\n+  Result Options(const char *path, const Headers &headers);\n \n   bool send(const Request &req, Response &res);\n \n@@ -837,6 +845,11 @@ class ClientImpl {\n   bool process_request(Stream &strm, const Request &req, Response &res,\n                        bool close_connection);\n \n+  Error get_last_error() const;\n+\n+  // Error state\n+  mutable Error error_ = Error::Success;\n+\n   // Socket endoint information\n   const std::string host_;\n   const int port_;\n@@ -934,7 +947,7 @@ class ClientImpl {\n   bool redirect(const Request &req, Response &res);\n   bool handle_request(Stream &strm, const Request &req, Response &res,\n                       bool close_connection);\n-\n+  void stop_core();\n   std::shared_ptr<Response> send_with_content_provider(\n       const char *method, const char *path, const Headers &headers,\n       const std::string &body, size_t content_length,\n@@ -961,101 +974,78 @@ class Client {\n                   const std::string &client_cert_path,\n                   const std::string &client_key_path);\n \n-  virtual ~Client();\n-\n-  virtual bool is_valid() const;\n-\n-  std::shared_ptr<Response> Get(const char *path);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers);\n-  std::shared_ptr<Response> Get(const char *path, Progress progress);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                Progress progress);\n-  std::shared_ptr<Response> Get(const char *path,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response>\n-  Get(const char *path, ContentReceiver content_receiver, Progress progress);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ContentReceiver content_receiver,\n-                                Progress progress);\n-  std::shared_ptr<Response> Get(const char *path,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver);\n-  std::shared_ptr<Response> Get(const char *path, const Headers &headers,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver,\n-                                Progress progress);\n-  std::shared_ptr<Response> Get(const char *path,\n-                                ResponseHandler response_handler,\n-                                ContentReceiver content_receiver,\n-                                Progress progress);\n-\n-  std::shared_ptr<Response> Head(const char *path);\n-  std::shared_ptr<Response> Head(const char *path, const Headers &headers);\n-\n-  std::shared_ptr<Response> Post(const char *path);\n-  std::shared_ptr<Response> Post(const char *path, const std::string &body,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 const std::string &body,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, size_t content_length,\n-                                 ContentProvider content_provider,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 size_t content_length,\n-                                 ContentProvider content_provider,\n-                                 const char *content_type);\n-  std::shared_ptr<Response> Post(const char *path, const Params &params);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 const Params &params);\n-  std::shared_ptr<Response> Post(const char *path,\n-                                 const MultipartFormDataItems &items);\n-  std::shared_ptr<Response> Post(const char *path, const Headers &headers,\n-                                 const MultipartFormDataItems &items);\n-  std::shared_ptr<Response> Put(const char *path);\n-  std::shared_ptr<Response> Put(const char *path, const std::string &body,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, const Headers &headers,\n-                                const std::string &body,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, size_t content_length,\n-                                ContentProvider content_provider,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, const Headers &headers,\n-                                size_t content_length,\n-                                ContentProvider content_provider,\n-                                const char *content_type);\n-  std::shared_ptr<Response> Put(const char *path, const Params &params);\n-  std::shared_ptr<Response> Put(const char *path, const Headers &headers,\n-                                const Params &params);\n-  std::shared_ptr<Response> Patch(const char *path, const std::string &body,\n-                                  const char *content_type);\n-  std::shared_ptr<Response> Patch(const char *path, const Headers &headers,\n-                                  const std::string &body,\n-                                  const char *content_type);\n-  std::shared_ptr<Response> Patch(const char *path, size_t content_length,\n-                                  ContentProvider content_provider,\n-                                  const char *content_type);\n-  std::shared_ptr<Response> Patch(const char *path, const Headers &headers,\n-                                  size_t content_length,\n-                                  ContentProvider content_provider,\n-                                  const char *content_type);\n-\n-  std::shared_ptr<Response> Delete(const char *path);\n-  std::shared_ptr<Response> Delete(const char *path, const std::string &body,\n-                                   const char *content_type);\n-  std::shared_ptr<Response> Delete(const char *path, const Headers &headers);\n-  std::shared_ptr<Response> Delete(const char *path, const Headers &headers,\n-                                   const std::string &body,\n-                                   const char *content_type);\n-\n-  std::shared_ptr<Response> Options(const char *path);\n-  std::shared_ptr<Response> Options(const char *path, const Headers &headers);\n+  ~Client();\n+\n+  bool is_valid() const;\n+\n+  Result Get(const char *path);\n+  Result Get(const char *path, const Headers &headers);\n+  Result Get(const char *path, Progress progress);\n+  Result Get(const char *path, const Headers &headers, Progress progress);\n+  Result Get(const char *path, ContentReceiver content_receiver);\n+  Result Get(const char *path, const Headers &headers,\n+             ContentReceiver content_receiver);\n+  Result Get(const char *path, ContentReceiver content_receiver,\n+             Progress progress);\n+  Result Get(const char *path, const Headers &headers,\n+             ContentReceiver content_receiver, Progress progress);\n+  Result Get(const char *path, ResponseHandler response_handler,\n+             ContentReceiver content_receiver);\n+  Result Get(const char *path, const Headers &headers,\n+             ResponseHandler response_handler,\n+             ContentReceiver content_receiver);\n+  Result Get(const char *path, const Headers &headers,\n+             ResponseHandler response_handler, ContentReceiver content_receiver,\n+             Progress progress);\n+  Result Get(const char *path, ResponseHandler response_handler,\n+             ContentReceiver content_receiver, Progress progress);\n+\n+  Result Head(const char *path);\n+  Result Head(const char *path, const Headers &headers);\n+\n+  Result Post(const char *path);\n+  Result Post(const char *path, const std::string &body,\n+              const char *content_type);\n+  Result Post(const char *path, const Headers &headers, const std::string &body,\n+              const char *content_type);\n+  Result Post(const char *path, size_t content_length,\n+              ContentProvider content_provider, const char *content_type);\n+  Result Post(const char *path, const Headers &headers, size_t content_length,\n+              ContentProvider content_provider, const char *content_type);\n+  Result Post(const char *path, const Params &params);\n+  Result Post(const char *path, const Headers &headers, const Params &params);\n+  Result Post(const char *path, const MultipartFormDataItems &items);\n+  Result Post(const char *path, const Headers &headers,\n+              const MultipartFormDataItems &items);\n+  Result Put(const char *path);\n+  Result Put(const char *path, const std::string &body,\n+             const char *content_type);\n+  Result Put(const char *path, const Headers &headers, const std::string &body,\n+             const char *content_type);\n+  Result Put(const char *path, size_t content_length,\n+             ContentProvider content_provider, const char *content_type);\n+  Result Put(const char *path, const Headers &headers, size_t content_length,\n+             ContentProvider content_provider, const char *content_type);\n+  Result Put(const char *path, const Params &params);\n+  Result Put(const char *path, const Headers &headers, const Params &params);\n+  Result Patch(const char *path, const std::string &body,\n+               const char *content_type);\n+  Result Patch(const char *path, const Headers &headers,\n+               const std::string &body, const char *content_type);\n+  Result Patch(const char *path, size_t content_length,\n+               ContentProvider content_provider, const char *content_type);\n+  Result Patch(const char *path, const Headers &headers, size_t content_length,\n+               ContentProvider content_provider, const char *content_type);\n+\n+  Result Delete(const char *path);\n+  Result Delete(const char *path, const std::string &body,\n+                const char *content_type);\n+  Result Delete(const char *path, const Headers &headers);\n+  Result Delete(const char *path, const Headers &headers,\n+                const std::string &body, const char *content_type);\n+\n+  Result Options(const char *path);\n+  Result Options(const char *path, const Headers &headers);\n \n   bool send(const Request &req, Response &res);\n \n@@ -1941,15 +1931,18 @@ inline socket_t create_client_socket(const char *host, int port,\n                                      bool tcp_nodelay,\n                                      SocketOptions socket_options,\n                                      time_t timeout_sec, time_t timeout_usec,\n-                                     const std::string &intf) {\n-  return create_socket(\n+                                     const std::string &intf, Error &error) {\n+  auto sock = create_socket(\n       host, port, 0, tcp_nodelay, socket_options,\n       [&](socket_t sock, struct addrinfo &ai) -> bool {\n         if (!intf.empty()) {\n #ifndef _WIN32\n           auto ip = if2ip(intf);\n           if (ip.empty()) { ip = intf; }\n-          if (!bind_ip_address(sock, ip.c_str())) { return false; }\n+          if (!bind_ip_address(sock, ip.c_str())) {\n+            error = Error::BindIPAddress;\n+            return false;\n+          }\n #endif\n         }\n \n@@ -1957,17 +1950,28 @@ inline socket_t create_client_socket(const char *host, int port,\n \n         auto ret =\n             ::connect(sock, ai.ai_addr, static_cast<socklen_t>(ai.ai_addrlen));\n+\n         if (ret < 0) {\n           if (is_connection_error() ||\n               !wait_until_socket_is_ready(sock, timeout_sec, timeout_usec)) {\n             close_socket(sock);\n+            error = Error::Connection;\n             return false;\n           }\n         }\n \n         set_nonblocking(sock, false);\n+        error = Error::Success;\n         return true;\n       });\n+\n+  if (sock != INVALID_SOCKET) {\n+    if (error != Error::Success) { error = Error::Success; }\n+  } else {\n+    if (error == Error::Success) { error = Error::Connection; }\n+  }\n+\n+  return sock;\n }\n \n inline void get_remote_ip_and_port(const struct sockaddr_storage &addr,\n@@ -3515,6 +3519,10 @@ inline void Response::set_redirect(const char *url, int stat) {\n   }\n }\n \n+inline void Response::set_redirect(const std::string &url, int stat) {\n+  set_redirect(url.c_str(), stat);\n+}\n+\n inline void Response::set_content(const char *s, size_t n,\n                                   const char *content_type) {\n   body.assign(s, n);\n@@ -4145,8 +4153,8 @@ inline bool Server::read_content_core(Stream &strm, Request &req, Response &res,\n     out = receiver;\n   }\n \n-  if (!detail::read_content(strm, req, payload_max_length_, res.status,\n-                            Progress(), out, true)) {\n+  if (!detail::read_content(strm, req, payload_max_length_, res.status, nullptr,\n+                            out, true)) {\n     return false;\n   }\n \n@@ -4496,19 +4504,21 @@ inline ClientImpl::ClientImpl(const std::string &host, int port,\n       host_and_port_(host_ + \":\" + std::to_string(port_)),\n       client_cert_path_(client_cert_path), client_key_path_(client_key_path) {}\n \n-inline ClientImpl::~ClientImpl() { stop(); }\n+inline ClientImpl::~ClientImpl() { stop_core(); }\n \n inline bool ClientImpl::is_valid() const { return true; }\n \n+inline Error ClientImpl::get_last_error() const { return error_; }\n+\n inline socket_t ClientImpl::create_client_socket() const {\n   if (!proxy_host_.empty()) {\n     return detail::create_client_socket(\n         proxy_host_.c_str(), proxy_port_, tcp_nodelay_, socket_options_,\n-        connection_timeout_sec_, connection_timeout_usec_, interface_);\n+        connection_timeout_sec_, connection_timeout_usec_, interface_, error_);\n   }\n-  return detail::create_client_socket(host_.c_str(), port_, tcp_nodelay_,\n-                                      socket_options_, connection_timeout_sec_,\n-                                      connection_timeout_usec_, interface_);\n+  return detail::create_client_socket(\n+      host_.c_str(), port_, tcp_nodelay_, socket_options_,\n+      connection_timeout_sec_, connection_timeout_usec_, interface_, error_);\n }\n \n inline bool ClientImpl::create_and_connect_socket(Socket &socket) {\n@@ -4583,14 +4593,21 @@ inline bool ClientImpl::send(const Request &req, Response &res) {\n     return handle_request(strm, req, res, close_connection);\n   });\n \n-  if (close_connection || !ret) { stop(); }\n+  if (close_connection || !ret) { stop_core(); }\n+\n+  if (!ret) {\n+    if (error_ == Error::Success) { error_ = Error::Unknown; }\n+  }\n \n   return ret;\n }\n \n inline bool ClientImpl::handle_request(Stream &strm, const Request &req,\n                                        Response &res, bool close_connection) {\n-  if (req.path.empty()) { return false; }\n+  if (req.path.empty()) {\n+    error_ = Error::Connection;\n+    return false;\n+  }\n \n   bool ret;\n \n@@ -4641,7 +4658,10 @@ inline bool ClientImpl::handle_request(Stream &strm, const Request &req,\n }\n \n inline bool ClientImpl::redirect(const Request &req, Response &res) {\n-  if (req.redirect_count == 0) { return false; }\n+  if (req.redirect_count == 0) {\n+    error_ = Error::ExceedRedirectCount;\n+    return false;\n+  }\n \n   auto location = res.get_header_value(\"location\");\n   if (location.empty()) { return false; }\n@@ -4677,14 +4697,18 @@ inline bool ClientImpl::redirect(const Request &req, Response &res) {\n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n       SSLClient cli(next_host.c_str(), next_port);\n       cli.copy_settings(*this);\n-      return detail::redirect(cli, req, res, next_path);\n+      auto ret = detail::redirect(cli, req, res, next_path);\n+      if (!ret) { error_ = cli.get_last_error(); }\n+      return ret;\n #else\n       return false;\n #endif\n     } else {\n       ClientImpl cli(next_host.c_str(), next_port);\n       cli.copy_settings(*this);\n-      return detail::redirect(cli, req, res, next_path);\n+      auto ret = detail::redirect(cli, req, res, next_path);\n+      if (!ret) { error_ = cli.get_last_error(); }\n+      return ret;\n     }\n   }\n }\n@@ -4767,7 +4791,10 @@ inline bool ClientImpl::write_request(Stream &strm, const Request &req,\n \n   // Flush buffer\n   auto &data = bstrm.get_buffer();\n-  if (!detail::write_data(strm, data.data(), data.size())) { return false; }\n+  if (!detail::write_data(strm, data.data(), data.size())) {\n+    error_ = Error::Write;\n+    return false;\n+  }\n \n   // Body\n   if (req.body.empty()) {\n@@ -4791,9 +4818,13 @@ inline bool ClientImpl::write_request(Stream &strm, const Request &req,\n \n       while (offset < end_offset) {\n         if (!req.content_provider(offset, end_offset - offset, data_sink)) {\n+          error_ = Error::Canceled;\n+          return false;\n+        }\n+        if (!ok) {\n+          error_ = Error::Write;\n           return false;\n         }\n-        if (!ok) { return false; }\n       }\n     }\n   } else {\n@@ -4807,6 +4838,7 @@ inline std::shared_ptr<Response> ClientImpl::send_with_content_provider(\n     const char *method, const char *path, const Headers &headers,\n     const std::string &body, size_t content_length,\n     ContentProvider content_provider, const char *content_type) {\n+\n   Request req;\n   req.method = method;\n   req.headers = default_headers_;\n@@ -4845,6 +4877,7 @@ inline std::shared_ptr<Response> ClientImpl::send_with_content_provider(\n \n       while (ok && offset < content_length) {\n         if (!content_provider(offset, content_length - offset, data_sink)) {\n+          error_ = Error::Canceled;\n           return nullptr;\n         }\n       }\n@@ -4883,11 +4916,15 @@ inline bool ClientImpl::process_request(Stream &strm, const Request &req,\n   // Receive response and headers\n   if (!read_response_line(strm, res) ||\n       !detail::read_headers(strm, res.headers)) {\n+    error_ = Error::Read;\n     return false;\n   }\n \n   if (req.response_handler) {\n-    if (!req.response_handler(res)) { return false; }\n+    if (!req.response_handler(res)) {\n+      error_ = Error::Canceled;\n+      return false;\n+    }\n   }\n \n   // Body\n@@ -4895,7 +4932,9 @@ inline bool ClientImpl::process_request(Stream &strm, const Request &req,\n     auto out =\n         req.content_receiver\n             ? static_cast<ContentReceiver>([&](const char *buf, size_t n) {\n-                return req.content_receiver(buf, n);\n+                auto ret = req.content_receiver(buf, n);\n+                if (!ret) { error_ = Error::Canceled; }\n+                return ret;\n               })\n             : static_cast<ContentReceiver>([&](const char *buf, size_t n) {\n                 if (res.body.size() + n > res.body.max_size()) { return false; }\n@@ -4903,16 +4942,24 @@ inline bool ClientImpl::process_request(Stream &strm, const Request &req,\n                 return true;\n               });\n \n+    auto progress = [&](uint64_t current, uint64_t total) {\n+      if (!req.progress) { return true; }\n+      auto ret = req.progress(current, total);\n+      if (!ret) { error_ = Error::Canceled; }\n+      return ret;\n+    };\n+\n     int dummy_status;\n     if (!detail::read_content(strm, res, (std::numeric_limits<size_t>::max)(),\n-                              dummy_status, req.progress, out, decompress_)) {\n+                              dummy_status, progress, out, decompress_)) {\n+      if (error_ != Error::Canceled) { error_ = Error::Read; }\n       return false;\n     }\n   }\n \n   if (res.get_header_value(\"Connection\") == \"close\" ||\n       res.version == \"HTTP/1.0\") {\n-    stop();\n+    stop_core();\n   }\n \n   // Log\n@@ -4931,22 +4978,20 @@ ClientImpl::process_socket(Socket &socket,\n \n inline bool ClientImpl::is_ssl() const { return false; }\n \n-inline std::shared_ptr<Response> ClientImpl::Get(const char *path) {\n+inline Result ClientImpl::Get(const char *path) {\n   return Get(path, Headers(), Progress());\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Get(const char *path,\n-                                                 Progress progress) {\n+inline Result ClientImpl::Get(const char *path, Progress progress) {\n   return Get(path, Headers(), std::move(progress));\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Get(const char *path,\n-                                                 const Headers &headers) {\n+inline Result ClientImpl::Get(const char *path, const Headers &headers) {\n   return Get(path, headers, Progress());\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, const Headers &headers, Progress progress) {\n+inline Result ClientImpl::Get(const char *path, const Headers &headers,\n+                              Progress progress) {\n   Request req;\n   req.method = \"GET\";\n   req.path = path;\n@@ -4955,60 +5000,59 @@ ClientImpl::Get(const char *path, const Headers &headers, Progress progress) {\n   req.progress = std::move(progress);\n \n   auto res = std::make_shared<Response>();\n-  return send(req, *res) ? res : nullptr;\n+  return Result{send(req, *res) ? res : nullptr, get_last_error()};\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, ContentReceiver content_receiver) {\n-  return Get(path, Headers(), nullptr, std::move(content_receiver), Progress());\n+inline Result ClientImpl::Get(const char *path,\n+                              ContentReceiver content_receiver) {\n+  return Get(path, Headers(), nullptr, std::move(content_receiver), nullptr);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, ContentReceiver content_receiver,\n-                Progress progress) {\n+inline Result ClientImpl::Get(const char *path,\n+                              ContentReceiver content_receiver,\n+                              Progress progress) {\n   return Get(path, Headers(), nullptr, std::move(content_receiver),\n              std::move(progress));\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, const Headers &headers,\n-                ContentReceiver content_receiver) {\n-  return Get(path, headers, nullptr, std::move(content_receiver), Progress());\n+inline Result ClientImpl::Get(const char *path, const Headers &headers,\n+                              ContentReceiver content_receiver) {\n+  return Get(path, headers, nullptr, std::move(content_receiver), nullptr);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, const Headers &headers,\n-                ContentReceiver content_receiver, Progress progress) {\n+inline Result ClientImpl::Get(const char *path, const Headers &headers,\n+                              ContentReceiver content_receiver,\n+                              Progress progress) {\n   return Get(path, headers, nullptr, std::move(content_receiver),\n              std::move(progress));\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, ResponseHandler response_handler,\n-                ContentReceiver content_receiver) {\n+inline Result ClientImpl::Get(const char *path,\n+                              ResponseHandler response_handler,\n+                              ContentReceiver content_receiver) {\n   return Get(path, Headers(), std::move(response_handler), content_receiver,\n-             Progress());\n+             nullptr);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, const Headers &headers,\n-                ResponseHandler response_handler,\n-                ContentReceiver content_receiver) {\n+inline Result ClientImpl::Get(const char *path, const Headers &headers,\n+                              ResponseHandler response_handler,\n+                              ContentReceiver content_receiver) {\n   return Get(path, headers, std::move(response_handler), content_receiver,\n-             Progress());\n+             nullptr);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, ResponseHandler response_handler,\n-                ContentReceiver content_receiver, Progress progress) {\n+inline Result ClientImpl::Get(const char *path,\n+                              ResponseHandler response_handler,\n+                              ContentReceiver content_receiver,\n+                              Progress progress) {\n   return Get(path, Headers(), std::move(response_handler), content_receiver,\n              progress);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Get(const char *path, const Headers &headers,\n-                ResponseHandler response_handler,\n-                ContentReceiver content_receiver, Progress progress) {\n+inline Result ClientImpl::Get(const char *path, const Headers &headers,\n+                              ResponseHandler response_handler,\n+                              ContentReceiver content_receiver,\n+                              Progress progress) {\n   Request req;\n   req.method = \"GET\";\n   req.path = path;\n@@ -5019,15 +5063,14 @@ ClientImpl::Get(const char *path, const Headers &headers,\n   req.progress = std::move(progress);\n \n   auto res = std::make_shared<Response>();\n-  return send(req, *res) ? res : nullptr;\n+  return Result{send(req, *res) ? res : nullptr, get_last_error()};\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Head(const char *path) {\n+inline Result ClientImpl::Head(const char *path) {\n   return Head(path, Headers());\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Head(const char *path,\n-                                                  const Headers &headers) {\n+inline Result ClientImpl::Head(const char *path, const Headers &headers) {\n   Request req;\n   req.method = \"HEAD\";\n   req.headers = default_headers_;\n@@ -5035,63 +5078,59 @@ inline std::shared_ptr<Response> ClientImpl::Head(const char *path,\n   req.path = path;\n \n   auto res = std::make_shared<Response>();\n-\n-  return send(req, *res) ? res : nullptr;\n+  return Result{send(req, *res) ? res : nullptr, get_last_error()};\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Post(const char *path) {\n+inline Result ClientImpl::Post(const char *path) {\n   return Post(path, std::string(), nullptr);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Post(const char *path,\n-                                                  const std::string &body,\n-                                                  const char *content_type) {\n+inline Result ClientImpl::Post(const char *path, const std::string &body,\n+                               const char *content_type) {\n   return Post(path, Headers(), body, content_type);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Post(const char *path,\n-                                                  const Headers &headers,\n-                                                  const std::string &body,\n-                                                  const char *content_type) {\n-  return send_with_content_provider(\"POST\", path, headers, body, 0, nullptr,\n-                                    content_type);\n+inline Result ClientImpl::Post(const char *path, const Headers &headers,\n+                               const std::string &body,\n+                               const char *content_type) {\n+  return Result{send_with_content_provider(\"POST\", path, headers, body, 0,\n+                                           nullptr, content_type),\n+                get_last_error()};\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Post(const char *path,\n-                                                  const Params &params) {\n+inline Result ClientImpl::Post(const char *path, const Params &params) {\n   return Post(path, Headers(), params);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Post(const char *path, size_t content_length,\n-                 ContentProvider content_provider, const char *content_type) {\n+inline Result ClientImpl::Post(const char *path, size_t content_length,\n+                               ContentProvider content_provider,\n+                               const char *content_type) {\n   return Post(path, Headers(), content_length, content_provider, content_type);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Post(const char *path, const Headers &headers,\n-                 size_t content_length, ContentProvider content_provider,\n-                 const char *content_type) {\n-  return send_with_content_provider(\"POST\", path, headers, std::string(),\n-                                    content_length, content_provider,\n-                                    content_type);\n+inline Result ClientImpl::Post(const char *path, const Headers &headers,\n+                               size_t content_length,\n+                               ContentProvider content_provider,\n+                               const char *content_type) {\n+  return Result{send_with_content_provider(\"POST\", path, headers, std::string(),\n+                                           content_length, content_provider,\n+                                           content_type),\n+                get_last_error()};\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Post(const char *path,\n-                                                  const Headers &headers,\n-                                                  const Params &params) {\n+inline Result ClientImpl::Post(const char *path, const Headers &headers,\n+                               const Params &params) {\n   auto query = detail::params_to_query_str(params);\n   return Post(path, headers, query, \"application/x-www-form-urlencoded\");\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Post(const char *path, const MultipartFormDataItems &items) {\n+inline Result ClientImpl::Post(const char *path,\n+                               const MultipartFormDataItems &items) {\n   return Post(path, Headers(), items);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Post(const char *path, const Headers &headers,\n-                 const MultipartFormDataItems &items) {\n+inline Result ClientImpl::Post(const char *path, const Headers &headers,\n+                               const MultipartFormDataItems &items) {\n   auto boundary = detail::make_multipart_data_boundary();\n \n   std::string body;\n@@ -5116,98 +5155,94 @@ ClientImpl::Post(const char *path, const Headers &headers,\n   return Post(path, headers, body, content_type.c_str());\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Put(const char *path) {\n+inline Result ClientImpl::Put(const char *path) {\n   return Put(path, std::string(), nullptr);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Put(const char *path,\n-                                                 const std::string &body,\n-                                                 const char *content_type) {\n+inline Result ClientImpl::Put(const char *path, const std::string &body,\n+                              const char *content_type) {\n   return Put(path, Headers(), body, content_type);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Put(const char *path,\n-                                                 const Headers &headers,\n-                                                 const std::string &body,\n-                                                 const char *content_type) {\n-  return send_with_content_provider(\"PUT\", path, headers, body, 0, nullptr,\n-                                    content_type);\n+inline Result ClientImpl::Put(const char *path, const Headers &headers,\n+                              const std::string &body,\n+                              const char *content_type) {\n+  return Result{send_with_content_provider(\"PUT\", path, headers, body, 0,\n+                                           nullptr, content_type),\n+                get_last_error()};\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Put(const char *path, size_t content_length,\n-                ContentProvider content_provider, const char *content_type) {\n+inline Result ClientImpl::Put(const char *path, size_t content_length,\n+                              ContentProvider content_provider,\n+                              const char *content_type) {\n   return Put(path, Headers(), content_length, content_provider, content_type);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Put(const char *path, const Headers &headers, size_t content_length,\n-                ContentProvider content_provider, const char *content_type) {\n-  return send_with_content_provider(\"PUT\", path, headers, std::string(),\n-                                    content_length, content_provider,\n-                                    content_type);\n+inline Result ClientImpl::Put(const char *path, const Headers &headers,\n+                              size_t content_length,\n+                              ContentProvider content_provider,\n+                              const char *content_type) {\n+  return Result{send_with_content_provider(\"PUT\", path, headers, std::string(),\n+                                           content_length, content_provider,\n+                                           content_type),\n+                get_last_error()};\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Put(const char *path,\n-                                                 const Params &params) {\n+inline Result ClientImpl::Put(const char *path, const Params &params) {\n   return Put(path, Headers(), params);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Put(const char *path,\n-                                                 const Headers &headers,\n-                                                 const Params &params) {\n+inline Result ClientImpl::Put(const char *path, const Headers &headers,\n+                              const Params &params) {\n   auto query = detail::params_to_query_str(params);\n   return Put(path, headers, query, \"application/x-www-form-urlencoded\");\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Patch(const char *path,\n-                                                   const std::string &body,\n-                                                   const char *content_type) {\n+inline Result ClientImpl::Patch(const char *path, const std::string &body,\n+                                const char *content_type) {\n   return Patch(path, Headers(), body, content_type);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Patch(const char *path,\n-                                                   const Headers &headers,\n-                                                   const std::string &body,\n-                                                   const char *content_type) {\n-  return send_with_content_provider(\"PATCH\", path, headers, body, 0, nullptr,\n-                                    content_type);\n+inline Result ClientImpl::Patch(const char *path, const Headers &headers,\n+                                const std::string &body,\n+                                const char *content_type) {\n+  return Result{send_with_content_provider(\"PATCH\", path, headers, body, 0,\n+                                           nullptr, content_type),\n+                get_last_error()};\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Patch(const char *path, size_t content_length,\n-                  ContentProvider content_provider, const char *content_type) {\n+inline Result ClientImpl::Patch(const char *path, size_t content_length,\n+                                ContentProvider content_provider,\n+                                const char *content_type) {\n   return Patch(path, Headers(), content_length, content_provider, content_type);\n }\n \n-inline std::shared_ptr<Response>\n-ClientImpl::Patch(const char *path, const Headers &headers,\n-                  size_t content_length, ContentProvider content_provider,\n-                  const char *content_type) {\n-  return send_with_content_provider(\"PATCH\", path, headers, std::string(),\n-                                    content_length, content_provider,\n-                                    content_type);\n+inline Result ClientImpl::Patch(const char *path, const Headers &headers,\n+                                size_t content_length,\n+                                ContentProvider content_provider,\n+                                const char *content_type) {\n+  return Result{send_with_content_provider(\"PATCH\", path, headers,\n+                                           std::string(), content_length,\n+                                           content_provider, content_type),\n+                get_last_error()};\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Delete(const char *path) {\n+inline Result ClientImpl::Delete(const char *path) {\n   return Delete(path, Headers(), std::string(), nullptr);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Delete(const char *path,\n-                                                    const std::string &body,\n-                                                    const char *content_type) {\n+inline Result ClientImpl::Delete(const char *path, const std::string &body,\n+                                 const char *content_type) {\n   return Delete(path, Headers(), body, content_type);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Delete(const char *path,\n-                                                    const Headers &headers) {\n+inline Result ClientImpl::Delete(const char *path, const Headers &headers) {\n   return Delete(path, headers, std::string(), nullptr);\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Delete(const char *path,\n-                                                    const Headers &headers,\n-                                                    const std::string &body,\n-                                                    const char *content_type) {\n+inline Result ClientImpl::Delete(const char *path, const Headers &headers,\n+                                 const std::string &body,\n+                                 const char *content_type) {\n   Request req;\n   req.method = \"DELETE\";\n   req.headers = default_headers_;\n@@ -5218,16 +5253,14 @@ inline std::shared_ptr<Response> ClientImpl::Delete(const char *path,\n   req.body = body;\n \n   auto res = std::make_shared<Response>();\n-\n-  return send(req, *res) ? res : nullptr;\n+  return Result{send(req, *res) ? res : nullptr, get_last_error()};\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Options(const char *path) {\n+inline Result ClientImpl::Options(const char *path) {\n   return Options(path, Headers());\n }\n \n-inline std::shared_ptr<Response> ClientImpl::Options(const char *path,\n-                                                     const Headers &headers) {\n+inline Result ClientImpl::Options(const char *path, const Headers &headers) {\n   Request req;\n   req.method = \"OPTIONS\";\n   req.headers = default_headers_;\n@@ -5235,8 +5268,7 @@ inline std::shared_ptr<Response> ClientImpl::Options(const char *path,\n   req.path = path;\n \n   auto res = std::make_shared<Response>();\n-\n-  return send(req, *res) ? res : nullptr;\n+  return Result{send(req, *res) ? res : nullptr, get_last_error()};\n }\n \n inline size_t ClientImpl::is_socket_open() const {\n@@ -5245,6 +5277,11 @@ inline size_t ClientImpl::is_socket_open() const {\n }\n \n inline void ClientImpl::stop() {\n+  stop_core();\n+  error_ = Error::Canceled;\n+}\n+\n+inline void ClientImpl::stop_core() {\n   std::lock_guard<std::mutex> guard(socket_mutex_);\n   if (socket_.is_open()) {\n     detail::shutdown_socket(socket_.sock);\n@@ -5768,23 +5805,36 @@ inline bool SSLClient::initialize_ssl(Socket &socket) {\n       socket.sock, ctx_, ctx_mutex_,\n       [&](SSL *ssl) {\n         if (server_certificate_verification_) {\n-          if (!load_certs()) { return false; }\n+          if (!load_certs()) {\n+            error_ = Error::SSLLoadingCerts;\n+            return false;\n+          }\n           SSL_set_verify(ssl, SSL_VERIFY_NONE, nullptr);\n         }\n \n-        if (SSL_connect(ssl) != 1) { return false; }\n+        if (SSL_connect(ssl) != 1) {\n+          error_ = Error::SSLConnection;\n+          return false;\n+        }\n \n         if (server_certificate_verification_) {\n           verify_result_ = SSL_get_verify_result(ssl);\n \n-          if (verify_result_ != X509_V_OK) { return false; }\n+          if (verify_result_ != X509_V_OK) {\n+            error_ = Error::SSLServerVerification;\n+            return false;\n+          }\n \n           auto server_cert = SSL_get_peer_certificate(ssl);\n \n-          if (server_cert == nullptr) { return false; }\n+          if (server_cert == nullptr) {\n+            error_ = Error::SSLServerVerification;\n+            return false;\n+          }\n \n           if (!verify_host(server_cert)) {\n             X509_free(server_cert);\n+            error_ = Error::SSLServerVerification;\n             return false;\n           }\n           X509_free(server_cert);\n@@ -5968,10 +6018,12 @@ inline Client::Client(const char *scheme_host_port,\n     auto scheme = m[1].str();\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n-    if (!scheme.empty() && (scheme != \"http\" && scheme != \"https\")) { return; }\n+    if (!scheme.empty() && (scheme != \"http\" && scheme != \"https\")) {\n #else\n-    if (!scheme.empty() && scheme != \"http\") { return; }\n+    if (!scheme.empty() && scheme != \"http\") {\n #endif\n+      return;\n+    }\n \n     auto is_ssl = scheme == \"https\";\n \n@@ -6011,198 +6063,159 @@ inline bool Client::is_valid() const {\n   return cli_ != nullptr && cli_->is_valid();\n }\n \n-inline std::shared_ptr<Response> Client::Get(const char *path) {\n-  return cli_->Get(path);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             const Headers &headers) {\n+inline Result Client::Get(const char *path) { return cli_->Get(path); }\n+inline Result Client::Get(const char *path, const Headers &headers) {\n   return cli_->Get(path, headers);\n }\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             Progress progress) {\n+inline Result Client::Get(const char *path, Progress progress) {\n   return cli_->Get(path, progress);\n }\n-inline std::shared_ptr<Response>\n-Client::Get(const char *path, const Headers &headers, Progress progress) {\n+inline Result Client::Get(const char *path, const Headers &headers,\n+                          Progress progress) {\n   return cli_->Get(path, headers, progress);\n }\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             ContentReceiver content_receiver) {\n-  return cli_->Get(path, content_receiver);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             const Headers &headers,\n-                                             ContentReceiver content_receiver) {\n-  return cli_->Get(path, headers, content_receiver);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             ContentReceiver content_receiver,\n-                                             Progress progress) {\n-  return cli_->Get(path, content_receiver, progress);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             const Headers &headers,\n-                                             ContentReceiver content_receiver,\n-                                             Progress progress) {\n-  return cli_->Get(path, headers, content_receiver, progress);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             ResponseHandler response_handler,\n-                                             ContentReceiver content_receiver) {\n-  return cli_->Get(path, Headers(), response_handler, content_receiver);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             const Headers &headers,\n-                                             ResponseHandler response_handler,\n-                                             ContentReceiver content_receiver) {\n-  return cli_->Get(path, headers, response_handler, content_receiver);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             ResponseHandler response_handler,\n-                                             ContentReceiver content_receiver,\n-                                             Progress progress) {\n-  return cli_->Get(path, Headers(), response_handler, content_receiver,\n-                   progress);\n-}\n-inline std::shared_ptr<Response> Client::Get(const char *path,\n-                                             const Headers &headers,\n-                                             ResponseHandler response_handler,\n-                                             ContentReceiver content_receiver,\n-                                             Progress progress) {\n+inline Result Client::Get(const char *path, ContentReceiver content_receiver) {\n+  return cli_->Get(path, std::move(content_receiver));\n+}\n+inline Result Client::Get(const char *path, const Headers &headers,\n+                          ContentReceiver content_receiver) {\n+  return cli_->Get(path, headers, std::move(content_receiver));\n+}\n+inline Result Client::Get(const char *path, ContentReceiver content_receiver,\n+                          Progress progress) {\n+  return cli_->Get(path, std::move(content_receiver), std::move(progress));\n+}\n+inline Result Client::Get(const char *path, const Headers &headers,\n+                          ContentReceiver content_receiver, Progress progress) {\n+  return cli_->Get(path, headers, std::move(content_receiver),\n+                   std::move(progress));\n+}\n+inline Result Client::Get(const char *path, ResponseHandler response_handler,\n+                          ContentReceiver content_receiver) {\n+  return cli_->Get(path, std::move(response_handler),\n+                   std::move(content_receiver));\n+}\n+inline Result Client::Get(const char *path, const Headers &headers,\n+                          ResponseHandler response_handler,\n+                          ContentReceiver content_receiver) {\n+  return cli_->Get(path, headers, std::move(response_handler),\n+                   std::move(content_receiver));\n+}\n+inline Result Client::Get(const char *path, ResponseHandler response_handler,\n+                          ContentReceiver content_receiver, Progress progress) {\n+  return cli_->Get(path, std::move(response_handler),\n+                   std::move(content_receiver), std::move(progress));\n+}\n+inline Result Client::Get(const char *path, const Headers &headers,\n+                          ResponseHandler response_handler,\n+                          ContentReceiver content_receiver, Progress progress) {\n   return cli_->Get(path, headers, response_handler, content_receiver, progress);\n }\n \n-inline std::shared_ptr<Response> Client::Head(const char *path) {\n-  return cli_->Head(path);\n-}\n-inline std::shared_ptr<Response> Client::Head(const char *path,\n-                                              const Headers &headers) {\n+inline Result Client::Head(const char *path) { return cli_->Head(path); }\n+inline Result Client::Head(const char *path, const Headers &headers) {\n   return cli_->Head(path, headers);\n }\n \n-inline std::shared_ptr<Response> Client::Post(const char *path) {\n-  return cli_->Post(path);\n-}\n-inline std::shared_ptr<Response> Client::Post(const char *path,\n-                                              const std::string &body,\n-                                              const char *content_type) {\n+inline Result Client::Post(const char *path) { return cli_->Post(path); }\n+inline Result Client::Post(const char *path, const std::string &body,\n+                           const char *content_type) {\n   return cli_->Post(path, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Post(const char *path,\n-                                              const Headers &headers,\n-                                              const std::string &body,\n-                                              const char *content_type) {\n+inline Result Client::Post(const char *path, const Headers &headers,\n+                           const std::string &body, const char *content_type) {\n   return cli_->Post(path, headers, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Post(const char *path,\n-                                              size_t content_length,\n-                                              ContentProvider content_provider,\n-                                              const char *content_type) {\n+inline Result Client::Post(const char *path, size_t content_length,\n+                           ContentProvider content_provider,\n+                           const char *content_type) {\n   return cli_->Post(path, content_length, content_provider, content_type);\n }\n-inline std::shared_ptr<Response>\n-Client::Post(const char *path, const Headers &headers, size_t content_length,\n-             ContentProvider content_provider, const char *content_type) {\n+inline Result Client::Post(const char *path, const Headers &headers,\n+                           size_t content_length,\n+                           ContentProvider content_provider,\n+                           const char *content_type) {\n   return cli_->Post(path, headers, content_length, content_provider,\n                     content_type);\n }\n-inline std::shared_ptr<Response> Client::Post(const char *path,\n-                                              const Params &params) {\n+inline Result Client::Post(const char *path, const Params &params) {\n   return cli_->Post(path, params);\n }\n-inline std::shared_ptr<Response>\n-Client::Post(const char *path, const Headers &headers, const Params &params) {\n+inline Result Client::Post(const char *path, const Headers &headers,\n+                           const Params &params) {\n   return cli_->Post(path, headers, params);\n }\n-inline std::shared_ptr<Response>\n-Client::Post(const char *path, const MultipartFormDataItems &items) {\n+inline Result Client::Post(const char *path,\n+                           const MultipartFormDataItems &items) {\n   return cli_->Post(path, items);\n }\n-inline std::shared_ptr<Response>\n-Client::Post(const char *path, const Headers &headers,\n-             const MultipartFormDataItems &items) {\n+inline Result Client::Post(const char *path, const Headers &headers,\n+                           const MultipartFormDataItems &items) {\n   return cli_->Post(path, headers, items);\n }\n-inline std::shared_ptr<Response> Client::Put(const char *path) {\n-  return cli_->Put(path);\n-}\n-inline std::shared_ptr<Response> Client::Put(const char *path,\n-                                             const std::string &body,\n-                                             const char *content_type) {\n+inline Result Client::Put(const char *path) { return cli_->Put(path); }\n+inline Result Client::Put(const char *path, const std::string &body,\n+                          const char *content_type) {\n   return cli_->Put(path, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Put(const char *path,\n-                                             const Headers &headers,\n-                                             const std::string &body,\n-                                             const char *content_type) {\n+inline Result Client::Put(const char *path, const Headers &headers,\n+                          const std::string &body, const char *content_type) {\n   return cli_->Put(path, headers, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Put(const char *path,\n-                                             size_t content_length,\n-                                             ContentProvider content_provider,\n-                                             const char *content_type) {\n+inline Result Client::Put(const char *path, size_t content_length,\n+                          ContentProvider content_provider,\n+                          const char *content_type) {\n   return cli_->Put(path, content_length, content_provider, content_type);\n }\n-inline std::shared_ptr<Response>\n-Client::Put(const char *path, const Headers &headers, size_t content_length,\n-            ContentProvider content_provider, const char *content_type) {\n+inline Result Client::Put(const char *path, const Headers &headers,\n+                          size_t content_length,\n+                          ContentProvider content_provider,\n+                          const char *content_type) {\n   return cli_->Put(path, headers, content_length, content_provider,\n                    content_type);\n }\n-inline std::shared_ptr<Response> Client::Put(const char *path,\n-                                             const Params &params) {\n+inline Result Client::Put(const char *path, const Params &params) {\n   return cli_->Put(path, params);\n }\n-inline std::shared_ptr<Response>\n-Client::Put(const char *path, const Headers &headers, const Params &params) {\n+inline Result Client::Put(const char *path, const Headers &headers,\n+                          const Params &params) {\n   return cli_->Put(path, headers, params);\n }\n-inline std::shared_ptr<Response> Client::Patch(const char *path,\n-                                               const std::string &body,\n-                                               const char *content_type) {\n+inline Result Client::Patch(const char *path, const std::string &body,\n+                            const char *content_type) {\n   return cli_->Patch(path, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Patch(const char *path,\n-                                               const Headers &headers,\n-                                               const std::string &body,\n-                                               const char *content_type) {\n+inline Result Client::Patch(const char *path, const Headers &headers,\n+                            const std::string &body, const char *content_type) {\n   return cli_->Patch(path, headers, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Patch(const char *path,\n-                                               size_t content_length,\n-                                               ContentProvider content_provider,\n-                                               const char *content_type) {\n+inline Result Client::Patch(const char *path, size_t content_length,\n+                            ContentProvider content_provider,\n+                            const char *content_type) {\n   return cli_->Patch(path, content_length, content_provider, content_type);\n }\n-inline std::shared_ptr<Response>\n-Client::Patch(const char *path, const Headers &headers, size_t content_length,\n-              ContentProvider content_provider, const char *content_type) {\n+inline Result Client::Patch(const char *path, const Headers &headers,\n+                            size_t content_length,\n+                            ContentProvider content_provider,\n+                            const char *content_type) {\n   return cli_->Patch(path, headers, content_length, content_provider,\n                      content_type);\n }\n-inline std::shared_ptr<Response> Client::Delete(const char *path) {\n-  return cli_->Delete(path);\n-}\n-inline std::shared_ptr<Response> Client::Delete(const char *path,\n-                                                const std::string &body,\n-                                                const char *content_type) {\n+inline Result Client::Delete(const char *path) { return cli_->Delete(path); }\n+inline Result Client::Delete(const char *path, const std::string &body,\n+                             const char *content_type) {\n   return cli_->Delete(path, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Delete(const char *path,\n-                                                const Headers &headers) {\n+inline Result Client::Delete(const char *path, const Headers &headers) {\n   return cli_->Delete(path, headers);\n }\n-inline std::shared_ptr<Response> Client::Delete(const char *path,\n-                                                const Headers &headers,\n-                                                const std::string &body,\n-                                                const char *content_type) {\n+inline Result Client::Delete(const char *path, const Headers &headers,\n+                             const std::string &body,\n+                             const char *content_type) {\n   return cli_->Delete(path, headers, body, content_type);\n }\n-inline std::shared_ptr<Response> Client::Options(const char *path) {\n-  return cli_->Options(path);\n-}\n-inline std::shared_ptr<Response> Client::Options(const char *path,\n-                                                 const Headers &headers) {\n+inline Result Client::Options(const char *path) { return cli_->Options(path); }\n+inline Result Client::Options(const char *path, const Headers &headers) {\n   return cli_->Options(path, headers);\n }\n \n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -303,7 +303,7 @@ TEST(ChunkedEncodingTest, FromHTTPWatch) {\n \n   auto res =\n       cli.Get(\"/httpgallery/chunked/chunkedimage.aspx?0.4153841143030137\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n \n   std::string out;\n   detail::read_file(\"./image.jpg\", out);\n@@ -331,7 +331,7 @@ TEST(ChunkedEncodingTest, WithContentReceiver) {\n                 body.append(data, data_length);\n                 return true;\n               });\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n \n   std::string out;\n   detail::read_file(\"./image.jpg\", out);\n@@ -363,7 +363,7 @@ TEST(ChunkedEncodingTest, WithResponseHandlerAndContentReceiver) {\n         body.append(data, data_length);\n         return true;\n       });\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n \n   std::string out;\n   detail::read_file(\"./image.jpg\", out);\n@@ -379,14 +379,14 @@ TEST(DefaultHeadersTest, FromHTTPBin) {\n \n   {\n     auto res = cli.Get(\"/range/32\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"bcdefghijk\", res->body);\n     EXPECT_EQ(206, res->status);\n   }\n \n   {\n     auto res = cli.Get(\"/range/32\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"bcdefghijk\", res->body);\n     EXPECT_EQ(206, res->status);\n   }\n@@ -406,7 +406,7 @@ TEST(RangeTest, FromHTTPBin) {\n \n   {\n     auto res = cli.Get(\"/range/32\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"abcdefghijklmnopqrstuvwxyzabcdef\", res->body);\n     EXPECT_EQ(200, res->status);\n   }\n@@ -414,7 +414,7 @@ TEST(RangeTest, FromHTTPBin) {\n   {\n     Headers headers = {make_range_header({{1, -1}})};\n     auto res = cli.Get(\"/range/32\", headers);\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"bcdefghijklmnopqrstuvwxyzabcdef\", res->body);\n     EXPECT_EQ(206, res->status);\n   }\n@@ -422,7 +422,7 @@ TEST(RangeTest, FromHTTPBin) {\n   {\n     Headers headers = {make_range_header({{1, 10}})};\n     auto res = cli.Get(\"/range/32\", headers);\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"bcdefghijk\", res->body);\n     EXPECT_EQ(206, res->status);\n   }\n@@ -430,7 +430,7 @@ TEST(RangeTest, FromHTTPBin) {\n   {\n     Headers headers = {make_range_header({{0, 31}})};\n     auto res = cli.Get(\"/range/32\", headers);\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"abcdefghijklmnopqrstuvwxyzabcdef\", res->body);\n     EXPECT_EQ(200, res->status);\n   }\n@@ -438,7 +438,7 @@ TEST(RangeTest, FromHTTPBin) {\n   {\n     Headers headers = {make_range_header({{0, -1}})};\n     auto res = cli.Get(\"/range/32\", headers);\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"abcdefghijklmnopqrstuvwxyzabcdef\", res->body);\n     EXPECT_EQ(200, res->status);\n   }\n@@ -446,7 +446,7 @@ TEST(RangeTest, FromHTTPBin) {\n   {\n     Headers headers = {make_range_header({{0, 32}})};\n     auto res = cli.Get(\"/range/32\", headers);\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(416, res->status);\n   }\n }\n@@ -464,7 +464,8 @@ TEST(ConnectionErrorTest, InvalidHost) {\n   cli.set_connection_timeout(2);\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Connection, res.error());\n }\n \n TEST(ConnectionErrorTest, InvalidHost2) {\n@@ -478,7 +479,8 @@ TEST(ConnectionErrorTest, InvalidHost2) {\n   cli.set_connection_timeout(2);\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Connection, res.error());\n }\n \n TEST(ConnectionErrorTest, InvalidPort) {\n@@ -494,7 +496,8 @@ TEST(ConnectionErrorTest, InvalidPort) {\n   cli.set_connection_timeout(2);\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Connection, res.error());\n }\n \n TEST(ConnectionErrorTest, Timeout) {\n@@ -510,7 +513,8 @@ TEST(ConnectionErrorTest, Timeout) {\n   cli.set_connection_timeout(2);\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_TRUE(res.error() == Error::Connection);\n }\n \n TEST(CancelTest, NoCancel) {\n@@ -526,7 +530,7 @@ TEST(CancelTest, NoCancel) {\n   cli.set_connection_timeout(5);\n \n   auto res = cli.Get(\"/range/32\", [](uint64_t, uint64_t) { return true; });\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(\"abcdefghijklmnopqrstuvwxyzabcdef\", res->body);\n   EXPECT_EQ(200, res->status);\n }\n@@ -544,7 +548,8 @@ TEST(CancelTest, WithCancelSmallPayload) {\n \n   auto res = cli.Get(\"/range/32\", [](uint64_t, uint64_t) { return false; });\n   cli.set_connection_timeout(5);\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n }\n \n TEST(CancelTest, WithCancelLargePayload) {\n@@ -562,7 +567,8 @@ TEST(CancelTest, WithCancelLargePayload) {\n   uint32_t count = 0;\n   auto res = cli.Get(\"/range/65536\",\n                      [&count](uint64_t, uint64_t) { return (count++ == 0); });\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n }\n \n TEST(BaseAuthTest, FromHTTPWatch) {\n@@ -578,14 +584,14 @@ TEST(BaseAuthTest, FromHTTPWatch) {\n \n   {\n     auto res = cli.Get(\"/basic-auth/hello/world\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(401, res->status);\n   }\n \n   {\n     auto res = cli.Get(\"/basic-auth/hello/world\",\n                        {make_basic_authentication_header(\"hello\", \"world\")});\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"{\\n  \\\"authenticated\\\": true, \\n  \\\"user\\\": \\\"hello\\\"\\n}\\n\",\n               res->body);\n     EXPECT_EQ(200, res->status);\n@@ -594,7 +600,7 @@ TEST(BaseAuthTest, FromHTTPWatch) {\n   {\n     cli.set_basic_auth(\"hello\", \"world\");\n     auto res = cli.Get(\"/basic-auth/hello/world\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(\"{\\n  \\\"authenticated\\\": true, \\n  \\\"user\\\": \\\"hello\\\"\\n}\\n\",\n               res->body);\n     EXPECT_EQ(200, res->status);\n@@ -603,14 +609,14 @@ TEST(BaseAuthTest, FromHTTPWatch) {\n   {\n     cli.set_basic_auth(\"hello\", \"bad\");\n     auto res = cli.Get(\"/basic-auth/hello/world\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(401, res->status);\n   }\n \n   {\n     cli.set_basic_auth(\"bad\", \"world\");\n     auto res = cli.Get(\"/basic-auth/hello/world\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(401, res->status);\n   }\n }\n@@ -623,7 +629,7 @@ TEST(DigestAuthTest, FromHTTPWatch) {\n \n   {\n     auto res = cli.Get(\"/digest-auth/auth/hello/world\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(401, res->status);\n   }\n \n@@ -638,7 +644,7 @@ TEST(DigestAuthTest, FromHTTPWatch) {\n     cli.set_digest_auth(\"hello\", \"world\");\n     for (auto path : paths) {\n       auto res = cli.Get(path.c_str());\n-      ASSERT_TRUE(res != nullptr);\n+      ASSERT_TRUE(res);\n       EXPECT_EQ(\"{\\n  \\\"authenticated\\\": true, \\n  \\\"user\\\": \\\"hello\\\"\\n}\\n\",\n                 res->body);\n       EXPECT_EQ(200, res->status);\n@@ -647,7 +653,7 @@ TEST(DigestAuthTest, FromHTTPWatch) {\n     cli.set_digest_auth(\"hello\", \"bad\");\n     for (auto path : paths) {\n       auto res = cli.Get(path.c_str());\n-      ASSERT_TRUE(res != nullptr);\n+      ASSERT_TRUE(res);\n       EXPECT_EQ(401, res->status);\n     }\n \n@@ -656,7 +662,7 @@ TEST(DigestAuthTest, FromHTTPWatch) {\n     // cli.set_digest_auth(\"bad\", \"world\");\n     // for (auto path : paths) {\n     //   auto res = cli.Get(path.c_str());\n-    //   ASSERT_TRUE(res != nullptr);\n+    //   ASSERT_TRUE(res);\n     //   EXPECT_EQ(400, res->status);\n     // }\n   }\n@@ -675,7 +681,7 @@ TEST(AbsoluteRedirectTest, Redirect) {\n \n   cli.set_follow_location(true);\n   auto res = cli.Get(\"/absolute-redirect/3\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -690,7 +696,7 @@ TEST(RedirectTest, Redirect) {\n \n   cli.set_follow_location(true);\n   auto res = cli.Get(\"/redirect/3\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -705,7 +711,7 @@ TEST(RelativeRedirectTest, Redirect) {\n \n   cli.set_follow_location(true);\n   auto res = cli.Get(\"/relative-redirect/3\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -720,7 +726,8 @@ TEST(TooManyRedirectTest, Redirect) {\n \n   cli.set_follow_location(true);\n   auto res = cli.Get(\"/redirect/21\");\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::ExceedRedirectCount, res.error());\n }\n #endif\n \n@@ -729,12 +736,12 @@ TEST(YahooRedirectTest, Redirect) {\n   Client cli(\"yahoo.com\");\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(301, res->status);\n \n   cli.set_follow_location(true);\n   res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -744,7 +751,7 @@ TEST(HttpsToHttpRedirectTest, Redirect) {\n   cli.set_follow_location(true);\n   auto res =\n       cli.Get(\"/redirect-to?url=http%3A%2F%2Fwww.google.com&status_code=302\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n #endif\n@@ -776,7 +783,7 @@ TEST(RedirectToDifferentPort, Redirect) {\n   cli.set_follow_location(true);\n \n   auto res = cli.Get(\"/1\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"Hello World!\", res->body);\n \n@@ -793,7 +800,7 @@ TEST(UrlWithSpace, Redirect) {\n   cli.set_follow_location(true);\n \n   auto res = cli.Get(\"/files/2595/310/Neat 1.4-17.jar\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(18527, res->get_header_value<uint64_t>(\"Content-Length\"));\n }\n@@ -815,7 +822,7 @@ TEST(Server, BindDualStack) {\n     Client cli(\"127.0.0.1\", PORT);\n \n     auto res = cli.Get(\"/1\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(200, res->status);\n     EXPECT_EQ(\"Hello World!\", res->body);\n   }\n@@ -823,7 +830,7 @@ TEST(Server, BindDualStack) {\n     Client cli(\"::1\", PORT);\n \n     auto res = cli.Get(\"/1\");\n-    ASSERT_TRUE(res != nullptr);\n+    ASSERT_TRUE(res);\n     EXPECT_EQ(200, res->status);\n     EXPECT_EQ(\"Hello World!\", res->body);\n   }\n@@ -1244,6 +1251,12 @@ class ServerTest : public ::testing::Test {\n              [&](const Request &req, Response & /*res*/) {\n                EXPECT_EQ(\"close\", req.get_header_value(\"Connection\"));\n              })\n+        .Get(R\"(/redirect/(\\d+))\",\n+             [&](const Request &req, Response &res) {\n+               auto num = std::stoi(req.matches[1]) + 1;\n+               std::string url = \"/redirect/\" + std::to_string(num);\n+               res.set_redirect(url);\n+             })\n #if defined(CPPHTTPLIB_ZLIB_SUPPORT) || defined(CPPHTTPLIB_BROTLI_SUPPORT)\n         .Get(\"/compress\",\n              [&](const Request & /*req*/, Response &res) {\n@@ -1310,7 +1323,7 @@ class ServerTest : public ::testing::Test {\n \n TEST_F(ServerTest, GetMethod200) {\n   auto res = cli_.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(\"HTTP/1.1\", res->version);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n@@ -1320,7 +1333,7 @@ TEST_F(ServerTest, GetMethod200) {\n \n TEST_F(ServerTest, GetMethod200withPercentEncoding) {\n   auto res = cli_.Get(\"/%68%69\"); // auto res = cli_.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(\"HTTP/1.1\", res->version);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n@@ -1330,7 +1343,7 @@ TEST_F(ServerTest, GetMethod200withPercentEncoding) {\n \n TEST_F(ServerTest, GetMethod302) {\n   auto res = cli_.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(302, res->status);\n   EXPECT_EQ(\"/hi\", res->get_header_value(\"Location\"));\n }\n@@ -1338,20 +1351,20 @@ TEST_F(ServerTest, GetMethod302) {\n TEST_F(ServerTest, GetMethod302Redirect) {\n   cli_.set_follow_location(true);\n   auto res = cli_.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"Hello World!\", res->body);\n }\n \n TEST_F(ServerTest, GetMethod404) {\n   auto res = cli_.Get(\"/invalid\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, HeadMethod200) {\n   auto res = cli_.Head(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_TRUE(res->body.empty());\n@@ -1359,7 +1372,7 @@ TEST_F(ServerTest, HeadMethod200) {\n \n TEST_F(ServerTest, HeadMethod200Static) {\n   auto res = cli_.Head(\"/mount/dir/index.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/html\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(104, std::stoi(res->get_header_value(\"Content-Length\")));\n@@ -1368,14 +1381,14 @@ TEST_F(ServerTest, HeadMethod200Static) {\n \n TEST_F(ServerTest, HeadMethod404) {\n   auto res = cli_.Head(\"/invalid\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n   EXPECT_TRUE(res->body.empty());\n }\n \n TEST_F(ServerTest, GetMethodPersonJohn) {\n   auto res = cli_.Get(\"/person/john\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"programmer\", res->body);\n@@ -1383,16 +1396,16 @@ TEST_F(ServerTest, GetMethodPersonJohn) {\n \n TEST_F(ServerTest, PostMethod1) {\n   auto res = cli_.Get(\"/person/john1\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(404, res->status);\n \n   res = cli_.Post(\"/person\", \"name=john1&note=coder\",\n                   \"application/x-www-form-urlencoded\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n \n   res = cli_.Get(\"/person/john1\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   ASSERT_EQ(\"coder\", res->body);\n@@ -1400,7 +1413,7 @@ TEST_F(ServerTest, PostMethod1) {\n \n TEST_F(ServerTest, PostMethod2) {\n   auto res = cli_.Get(\"/person/john2\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(404, res->status);\n \n   Params params;\n@@ -1408,11 +1421,11 @@ TEST_F(ServerTest, PostMethod2) {\n   params.emplace(\"note\", \"coder\");\n \n   res = cli_.Post(\"/person\", params);\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n \n   res = cli_.Get(\"/person/john2\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   ASSERT_EQ(\"coder\", res->body);\n@@ -1420,7 +1433,7 @@ TEST_F(ServerTest, PostMethod2) {\n \n TEST_F(ServerTest, PutMethod3) {\n   auto res = cli_.Get(\"/person/john3\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(404, res->status);\n \n   Params params;\n@@ -1428,11 +1441,11 @@ TEST_F(ServerTest, PutMethod3) {\n   params.emplace(\"note\", \"coder\");\n \n   res = cli_.Put(\"/person\", params);\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n \n   res = cli_.Get(\"/person/john3\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   ASSERT_EQ(\"coder\", res->body);\n@@ -1444,35 +1457,35 @@ TEST_F(ServerTest, PostWwwFormUrlEncodedJson) {\n \n   auto res = cli_.Post(\"/x-www-form-urlencoded-json\", params);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(JSON_DATA, res->body);\n }\n \n TEST_F(ServerTest, PostEmptyContent) {\n   auto res = cli_.Post(\"/empty\", \"\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"empty\", res->body);\n }\n \n TEST_F(ServerTest, PostEmptyContentWithNoContentType) {\n   auto res = cli_.Post(\"/empty-no-content-type\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"empty-no-content-type\", res->body);\n }\n \n TEST_F(ServerTest, PutEmptyContentWithNoContentType) {\n   auto res = cli_.Put(\"/empty-no-content-type\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"empty-no-content-type\", res->body);\n }\n \n TEST_F(ServerTest, GetMethodDir) {\n   auto res = cli_.Get(\"/dir/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/html\", res->get_header_value(\"Content-Type\"));\n \n@@ -1490,7 +1503,7 @@ TEST_F(ServerTest, GetMethodDir) {\n \n TEST_F(ServerTest, GetMethodDirTest) {\n   auto res = cli_.Get(\"/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/html\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"test.html\", res->body);\n@@ -1498,7 +1511,7 @@ TEST_F(ServerTest, GetMethodDirTest) {\n \n TEST_F(ServerTest, GetMethodDirTestWithDoubleDots) {\n   auto res = cli_.Get(\"/dir/../dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/html\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"test.html\", res->body);\n@@ -1506,25 +1519,25 @@ TEST_F(ServerTest, GetMethodDirTestWithDoubleDots) {\n \n TEST_F(ServerTest, GetMethodInvalidPath) {\n   auto res = cli_.Get(\"/dir/../test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, GetMethodOutOfBaseDir) {\n   auto res = cli_.Get(\"/../www/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, GetMethodOutOfBaseDir2) {\n   auto res = cli_.Get(\"/dir/../../www/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, GetMethodDirMountTest) {\n   auto res = cli_.Get(\"/mount/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/html\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"test.html\", res->body);\n@@ -1532,7 +1545,7 @@ TEST_F(ServerTest, GetMethodDirMountTest) {\n \n TEST_F(ServerTest, GetMethodDirMountTestWithDoubleDots) {\n   auto res = cli_.Get(\"/mount/dir/../dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/html\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"test.html\", res->body);\n@@ -1540,25 +1553,25 @@ TEST_F(ServerTest, GetMethodDirMountTestWithDoubleDots) {\n \n TEST_F(ServerTest, GetMethodInvalidMountPath) {\n   auto res = cli_.Get(\"/mount/dir/../test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, GetMethodOutOfBaseDirMount) {\n   auto res = cli_.Get(\"/mount/../www2/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, GetMethodOutOfBaseDirMount2) {\n   auto res = cli_.Get(\"/mount/dir/../../www2/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, PostMethod303) {\n   auto res = cli_.Post(\"/1\", \"body\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(303, res->status);\n   EXPECT_EQ(\"/2\", res->get_header_value(\"Location\"));\n }\n@@ -1566,14 +1579,14 @@ TEST_F(ServerTest, PostMethod303) {\n TEST_F(ServerTest, PostMethod303Redirect) {\n   cli_.set_follow_location(true);\n   auto res = cli_.Post(\"/1\", \"body\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"redirected.\", res->body);\n }\n \n TEST_F(ServerTest, UserDefinedMIMETypeMapping) {\n   auto res = cli_.Get(\"/dir/test.abcde\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/abcde\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"abcde\", res->body);\n@@ -1585,7 +1598,8 @@ TEST_F(ServerTest, InvalidBaseDirMount) {\n \n TEST_F(ServerTest, EmptyRequest) {\n   auto res = cli_.Get(\"\");\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Connection, res.error());\n }\n \n TEST_F(ServerTest, LongRequest) {\n@@ -1597,7 +1611,7 @@ TEST_F(ServerTest, LongRequest) {\n \n   auto res = cli_.Get(request.c_str());\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n@@ -1610,7 +1624,7 @@ TEST_F(ServerTest, TooLongRequest) {\n \n   auto res = cli_.Get(request.c_str());\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(414, res->status);\n }\n \n@@ -1670,7 +1684,7 @@ TEST_F(ServerTest, LongHeader) {\n TEST_F(ServerTest, LongQueryValue) {\n   auto res = cli_.Get(LONG_QUERY_URL.c_str());\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(414, res->status);\n }\n \n@@ -1729,37 +1743,37 @@ TEST_F(ServerTest, TooLongHeader) {\n \n TEST_F(ServerTest, PercentEncoding) {\n   auto res = cli_.Get(\"/e%6edwith%\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n TEST_F(ServerTest, PercentEncodingUnicode) {\n   auto res = cli_.Get(\"/e%u006edwith%\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n TEST_F(ServerTest, InvalidPercentEncoding) {\n   auto res = cli_.Get(\"/%endwith%\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, InvalidPercentEncodingUnicode) {\n   auto res = cli_.Get(\"/%uendwith%\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, EndWithPercentCharacterInQuery) {\n   auto res = cli_.Get(\"/hello?aaa=bbb%\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n }\n \n TEST_F(ServerTest, PlusSignEncoding) {\n   auto res = cli_.Get(\"/a+%2Bb?a %2bb=a %2Bb\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"a +b\", res->body);\n }\n@@ -1775,13 +1789,13 @@ TEST_F(ServerTest, MultipartFormData) {\n \n   auto res = cli_.Post(\"/multipart\", items);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n TEST_F(ServerTest, CaseInsensitiveHeaderName) {\n   auto res = cli_.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"content-type\"));\n   EXPECT_EQ(\"Hello World!\", res->body);\n@@ -1818,7 +1832,7 @@ TEST_F(ServerTest, CaseInsensitiveTransferEncoding) {\n \n TEST_F(ServerTest, GetStreamed2) {\n   auto res = cli_.Get(\"/streamed\", {{make_range_header({{2, 3}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"2\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(std::string(\"ab\"), res->body);\n@@ -1826,7 +1840,7 @@ TEST_F(ServerTest, GetStreamed2) {\n \n TEST_F(ServerTest, GetStreamed) {\n   auto res = cli_.Get(\"/streamed\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"6\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(std::string(\"aaabbb\"), res->body);\n@@ -1834,7 +1848,7 @@ TEST_F(ServerTest, GetStreamed) {\n \n TEST_F(ServerTest, GetStreamedWithRange1) {\n   auto res = cli_.Get(\"/streamed-with-range\", {{make_range_header({{3, 5}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"3\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(true, res->has_header(\"Content-Range\"));\n@@ -1843,7 +1857,7 @@ TEST_F(ServerTest, GetStreamedWithRange1) {\n \n TEST_F(ServerTest, GetStreamedWithRange2) {\n   auto res = cli_.Get(\"/streamed-with-range\", {{make_range_header({{1, -1}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"6\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(true, res->has_header(\"Content-Range\"));\n@@ -1853,7 +1867,7 @@ TEST_F(ServerTest, GetStreamedWithRange2) {\n TEST_F(ServerTest, GetStreamedWithRangeMultipart) {\n   auto res =\n       cli_.Get(\"/streamed-with-range\", {{make_range_header({{1, 2}, {4, 5}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"269\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(false, res->has_header(\"Content-Range\"));\n@@ -1870,7 +1884,8 @@ TEST_F(ServerTest, GetStreamedEndless) {\n                         }\n                         return false;\n                       });\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n }\n \n TEST_F(ServerTest, ClientStop) {\n@@ -1879,7 +1894,9 @@ TEST_F(ServerTest, ClientStop) {\n     threads.emplace_back(thread([&]() {\n       auto res = cli_.Get(\"/streamed-cancel\",\n                           [&](const char *, uint64_t) { return true; });\n-      ASSERT_TRUE(res == nullptr);\n+      ASSERT_TRUE(!res);\n+      EXPECT_TRUE(res.error() == Error::Canceled ||\n+                  res.error() == Error::Read);\n     }));\n   }\n \n@@ -1896,7 +1913,7 @@ TEST_F(ServerTest, ClientStop) {\n \n TEST_F(ServerTest, GetWithRange1) {\n   auto res = cli_.Get(\"/with-range\", {{make_range_header({{3, 5}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"3\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(true, res->has_header(\"Content-Range\"));\n@@ -1905,7 +1922,7 @@ TEST_F(ServerTest, GetWithRange1) {\n \n TEST_F(ServerTest, GetWithRange2) {\n   auto res = cli_.Get(\"/with-range\", {{make_range_header({{1, -1}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"6\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(true, res->has_header(\"Content-Range\"));\n@@ -1914,7 +1931,7 @@ TEST_F(ServerTest, GetWithRange2) {\n \n TEST_F(ServerTest, GetWithRange3) {\n   auto res = cli_.Get(\"/with-range\", {{make_range_header({{0, 0}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"1\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(true, res->has_header(\"Content-Range\"));\n@@ -1923,7 +1940,7 @@ TEST_F(ServerTest, GetWithRange3) {\n \n TEST_F(ServerTest, GetWithRange4) {\n   auto res = cli_.Get(\"/with-range\", {{make_range_header({{-1, 2}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"2\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(true, res->has_header(\"Content-Range\"));\n@@ -1932,7 +1949,7 @@ TEST_F(ServerTest, GetWithRange4) {\n \n TEST_F(ServerTest, GetWithRangeMultipart) {\n   auto res = cli_.Get(\"/with-range\", {{make_range_header({{1, 2}, {4, 5}})}});\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(206, res->status);\n   EXPECT_EQ(\"269\", res->get_header_value(\"Content-Length\"));\n   EXPECT_EQ(false, res->has_header(\"Content-Range\"));\n@@ -1941,14 +1958,14 @@ TEST_F(ServerTest, GetWithRangeMultipart) {\n \n TEST_F(ServerTest, GetStreamedChunked) {\n   auto res = cli_.Get(\"/streamed-chunked\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(std::string(\"123456789\"), res->body);\n }\n \n TEST_F(ServerTest, GetStreamedChunked2) {\n   auto res = cli_.Get(\"/streamed-chunked2\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(std::string(\"123456789\"), res->body);\n }\n@@ -1986,7 +2003,7 @@ TEST_F(ServerTest, LargeChunkedPost) {\n \n TEST_F(ServerTest, GetMethodRemoteAddr) {\n   auto res = cli_.Get(\"/remote_addr\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_TRUE(res->body == \"::1\" || res->body == \"127.0.0.1\");\n@@ -1994,7 +2011,7 @@ TEST_F(ServerTest, GetMethodRemoteAddr) {\n \n TEST_F(ServerTest, HTTPResponseSplitting) {\n   auto res = cli_.Get(\"/http_response_splitting\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -2020,7 +2037,7 @@ TEST_F(ServerTest, SlowPost) {\n       },\n       \"text/plain\");\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n \n   cli_.set_write_timeout(0, 0);\n@@ -2032,12 +2049,13 @@ TEST_F(ServerTest, SlowPost) {\n       },\n       \"text/plain\");\n \n-  ASSERT_FALSE(res != nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Write, res.error());\n }\n \n TEST_F(ServerTest, Put) {\n   auto res = cli_.Put(\"/put\", \"PUT\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"PUT\", res->body);\n }\n@@ -2052,7 +2070,7 @@ TEST_F(ServerTest, PutWithContentProvider) {\n       },\n       \"text/plain\");\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"PUT\", res->body);\n }\n@@ -2065,7 +2083,8 @@ TEST_F(ServerTest, PostWithContentProviderAbort) {\n       },\n       \"text/plain\");\n \n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n }\n \n #ifdef CPPHTTPLIB_ZLIB_SUPPORT\n@@ -2080,7 +2099,7 @@ TEST_F(ServerTest, PutWithContentProviderWithGzip) {\n       },\n       \"text/plain\");\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"PUT\", res->body);\n }\n@@ -2094,14 +2113,15 @@ TEST_F(ServerTest, PostWithContentProviderWithGzipAbort) {\n       },\n       \"text/plain\");\n \n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::Canceled, res.error());\n }\n \n TEST_F(ServerTest, PutLargeFileWithGzip) {\n   cli_.set_compress(true);\n   auto res = cli_.Put(\"/put-large\", LARGE_DATA, \"text/plain\");\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(LARGE_DATA, res->body);\n }\n@@ -2114,7 +2134,7 @@ TEST_F(ServerTest, PutContentWithDeflate) {\n   auto res = cli_.Put(\"/put\", headers,\n                       \"\\170\\234\\013\\010\\015\\001\\0\\001\\361\\0\\372\", \"text/plain\");\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"PUT\", res->body);\n }\n@@ -2124,7 +2144,7 @@ TEST_F(ServerTest, GetStreamedChunkedWithGzip) {\n   headers.emplace(\"Accept-Encoding\", \"gzip, deflate\");\n \n   auto res = cli_.Get(\"/streamed-chunked\", headers);\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(std::string(\"123456789\"), res->body);\n }\n@@ -2134,7 +2154,7 @@ TEST_F(ServerTest, GetStreamedChunkedWithGzip2) {\n   headers.emplace(\"Accept-Encoding\", \"gzip, deflate\");\n \n   auto res = cli_.Get(\"/streamed-chunked2\", headers);\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(std::string(\"123456789\"), res->body);\n }\n@@ -2146,7 +2166,7 @@ TEST_F(ServerTest, GetStreamedChunkedWithBrotli) {\n   headers.emplace(\"Accept-Encoding\", \"brotli\");\n \n   auto res = cli_.Get(\"/streamed-chunked\", headers);\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(std::string(\"123456789\"), res->body);\n }\n@@ -2156,7 +2176,7 @@ TEST_F(ServerTest, GetStreamedChunkedWithBrotli2) {\n   headers.emplace(\"Accept-Encoding\", \"brotli\");\n \n   auto res = cli_.Get(\"/streamed-chunked2\", headers);\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(std::string(\"123456789\"), res->body);\n }\n@@ -2164,28 +2184,28 @@ TEST_F(ServerTest, GetStreamedChunkedWithBrotli2) {\n \n TEST_F(ServerTest, Patch) {\n   auto res = cli_.Patch(\"/patch\", \"PATCH\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"PATCH\", res->body);\n }\n \n TEST_F(ServerTest, Delete) {\n   auto res = cli_.Delete(\"/delete\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"DELETE\", res->body);\n }\n \n TEST_F(ServerTest, DeleteContentReceiver) {\n   auto res = cli_.Delete(\"/delete-body\", \"content\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"content\", res->body);\n }\n \n TEST_F(ServerTest, Options) {\n   auto res = cli_.Options(\"*\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"GET, POST, HEAD, OPTIONS\", res->get_header_value(\"Allow\"));\n   EXPECT_TRUE(res->body.empty());\n@@ -2193,13 +2213,13 @@ TEST_F(ServerTest, Options) {\n \n TEST_F(ServerTest, URL) {\n   auto res = cli_.Get(\"/request-target?aaa=bbb&ccc=ddd\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n TEST_F(ServerTest, ArrayParam) {\n   auto res = cli_.Get(\"/array-param?array=value1&array=value2&array=value3\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -2207,13 +2227,13 @@ TEST_F(ServerTest, NoMultipleHeaders) {\n   Headers headers = {{\"Content-Length\", \"5\"}};\n   auto res = cli_.Post(\"/validate-no-multiple-headers\", headers, \"hello\",\n                        \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n TEST_F(ServerTest, PostContentReceiver) {\n   auto res = cli_.Post(\"/content_receiver\", \"content\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"content\", res->body);\n }\n@@ -2229,28 +2249,28 @@ TEST_F(ServerTest, PostMulitpartFilsContentReceiver) {\n \n   auto res = cli_.Post(\"/content_receiver\", items);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n TEST_F(ServerTest, PostContentReceiverGzip) {\n   cli_.set_compress(true);\n   auto res = cli_.Post(\"/content_receiver\", \"content\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"content\", res->body);\n }\n \n TEST_F(ServerTest, PutContentReceiver) {\n   auto res = cli_.Put(\"/content_receiver\", \"content\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"content\", res->body);\n }\n \n TEST_F(ServerTest, PatchContentReceiver) {\n   auto res = cli_.Patch(\"/content_receiver\", \"content\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n   ASSERT_EQ(\"content\", res->body);\n }\n@@ -2258,7 +2278,7 @@ TEST_F(ServerTest, PatchContentReceiver) {\n TEST_F(ServerTest, PostQueryStringAndBody) {\n   auto res =\n       cli_.Post(\"/query-string-and-body?key=value\", \"content\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n }\n \n@@ -2277,29 +2297,29 @@ TEST_F(ServerTest, HTTP2Magic) {\n \n TEST_F(ServerTest, KeepAlive) {\n   auto res = cli_.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"Hello World!\", res->body);\n \n   res = cli_.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"Hello World!\", res->body);\n \n   res = cli_.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"Hello World!\", res->body);\n \n   res = cli_.Get(\"/not-exist\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n \n   res = cli_.Post(\"/empty\", \"\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"empty\", res->body);\n@@ -2308,25 +2328,32 @@ TEST_F(ServerTest, KeepAlive) {\n   res = cli_.Post(\n       \"/empty\", 0, [&](size_t, size_t, DataSink &) { return true; },\n       \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"empty\", res->body);\n \n   cli_.set_keep_alive(false);\n   res = cli_.Get(\"/last-request\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"close\", res->get_header_value(\"Connection\"));\n }\n \n+TEST_F(ServerTest, TooManyRedirect) {\n+  cli_.set_follow_location(true);\n+  auto res = cli_.Get(\"/redirect/0\");\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::ExceedRedirectCount, res.error());\n+}\n+\n #ifdef CPPHTTPLIB_ZLIB_SUPPORT\n TEST_F(ServerTest, Gzip) {\n   Headers headers;\n   headers.emplace(\"Accept-Encoding\", \"gzip, deflate\");\n   auto res = cli_.Get(\"/compress\", headers);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(\"gzip\", res->get_header_value(\"Content-Encoding\"));\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"33\", res->get_header_value(\"Content-Length\"));\n@@ -2339,7 +2366,7 @@ TEST_F(ServerTest, Gzip) {\n TEST_F(ServerTest, GzipWithoutAcceptEncoding) {\n   auto res = cli_.Get(\"/compress\");\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_TRUE(res->get_header_value(\"Content-Encoding\").empty());\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"100\", res->get_header_value(\"Content-Length\"));\n@@ -2360,7 +2387,7 @@ TEST_F(ServerTest, GzipWithContentReceiver) {\n                         return true;\n                       });\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(\"gzip\", res->get_header_value(\"Content-Encoding\"));\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"33\", res->get_header_value(\"Content-Length\"));\n@@ -2377,7 +2404,7 @@ TEST_F(ServerTest, GzipWithoutDecompressing) {\n   cli_.set_decompress(false);\n   auto res = cli_.Get(\"/compress\", headers);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(\"gzip\", res->get_header_value(\"Content-Encoding\"));\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"33\", res->get_header_value(\"Content-Length\"));\n@@ -2387,14 +2414,13 @@ TEST_F(ServerTest, GzipWithoutDecompressing) {\n \n TEST_F(ServerTest, GzipWithContentReceiverWithoutAcceptEncoding) {\n   std::string body;\n-  auto res = cli_.Get(\"/compress\",\n-                      [&](const char *data, uint64_t data_length) {\n-                        EXPECT_EQ(data_length, 100);\n-                        body.append(data, data_length);\n-                        return true;\n-                      });\n+  auto res = cli_.Get(\"/compress\", [&](const char *data, uint64_t data_length) {\n+    EXPECT_EQ(data_length, 100);\n+    body.append(data, data_length);\n+    return true;\n+  });\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_TRUE(res->get_header_value(\"Content-Encoding\").empty());\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"100\", res->get_header_value(\"Content-Length\"));\n@@ -2409,7 +2435,7 @@ TEST_F(ServerTest, NoGzip) {\n   headers.emplace(\"Accept-Encoding\", \"gzip, deflate\");\n   auto res = cli_.Get(\"/nocompress\", headers);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(false, res->has_header(\"Content-Encoding\"));\n   EXPECT_EQ(\"application/octet-stream\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"100\", res->get_header_value(\"Content-Length\"));\n@@ -2430,7 +2456,7 @@ TEST_F(ServerTest, NoGzipWithContentReceiver) {\n                         return true;\n                       });\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(false, res->has_header(\"Content-Encoding\"));\n   EXPECT_EQ(\"application/octet-stream\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"100\", res->get_header_value(\"Content-Length\"));\n@@ -2449,7 +2475,7 @@ TEST_F(ServerTest, MultipartFormDataGzip) {\n   cli_.set_compress(true);\n   auto res = cli_.Post(\"/compress-multipart\", items);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n #endif\n@@ -2460,7 +2486,7 @@ TEST_F(ServerTest, Brotli) {\n   headers.emplace(\"Accept-Encoding\", \"br\");\n   auto res = cli_.Get(\"/compress\", headers);\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(\"brotli\", res->get_header_value(\"Content-Encoding\"));\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"19\", res->get_header_value(\"Content-Length\"));\n@@ -2474,9 +2500,11 @@ TEST_F(ServerTest, Brotli) {\n // Sends a raw request to a server listening at HOST:PORT.\n static bool send_request(time_t read_timeout_sec, const std::string &req,\n                          std::string *resp = nullptr) {\n+  Error error = Error::Success;\n+\n   auto client_sock =\n       detail::create_client_socket(HOST, PORT, false, nullptr,\n-                                   /*timeout_sec=*/5, 0, std::string());\n+                                   /*timeout_sec=*/5, 0, std::string(), error);\n \n   if (client_sock == INVALID_SOCKET) { return false; }\n \n@@ -2686,7 +2714,7 @@ TEST(ServerStopTest, StopServerWithChunkedTransmission) {\n   const Headers headers = {{\"Accept\", \"text/event-stream\"}};\n \n   auto get_thread = std::thread([&client, &headers]() {\n-    std::shared_ptr<Response> res = client.Get(\n+    auto res = client.Get(\n         \"/events\", headers,\n         [](const char * /*data*/, size_t /*len*/) -> bool { return true; });\n   });\n@@ -2718,27 +2746,27 @@ TEST(MountTest, Unmount) {\n   svr.set_mount_point(\"/mount2\", \"./www2\");\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n \n   res = cli.Get(\"/mount2/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n \n   svr.set_mount_point(\"/\", \"./www\");\n \n   res = cli.Get(\"/dir/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n \n   svr.remove_mount_point(\"/\");\n   res = cli.Get(\"/dir/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n \n   svr.remove_mount_point(\"/mount2\");\n   res = cli.Get(\"/mount2/dir/test.html\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(404, res->status);\n \n   svr.stop();\n@@ -2765,7 +2793,7 @@ TEST(ExceptionTest, ThrowExceptionInHandler) {\n   Client cli(\"localhost\", PORT);\n \n   auto res = cli.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(500, res->status);\n   ASSERT_FALSE(res->has_header(\"EXCEPTION_WHAT\"));\n \n@@ -2799,10 +2827,11 @@ TEST(KeepAliveTest, ReadTimeout) {\n   cli.set_read_timeout(1);\n \n   auto resa = cli.Get(\"/a\");\n-  ASSERT_TRUE(resa == nullptr);\n+  ASSERT_TRUE(!resa);\n+  EXPECT_EQ(Error::Read, resa.error());\n \n   auto resb = cli.Get(\"/b\");\n-  ASSERT_TRUE(resb != nullptr);\n+  ASSERT_TRUE(resb);\n   EXPECT_EQ(200, resb->status);\n   EXPECT_EQ(\"b\", resb->body);\n \n@@ -2854,7 +2883,7 @@ class ServerTestWithAI_PASSIVE : public ::testing::Test {\n \n TEST_F(ServerTestWithAI_PASSIVE, GetMethod200) {\n   auto res = cli_.Get(\"/hi\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(\"text/plain\", res->get_header_value(\"Content-Type\"));\n   EXPECT_EQ(\"Hello World!\", res->body);\n@@ -2936,11 +2965,11 @@ class PayloadMaxLengthTest : public ::testing::Test {\n \n TEST_F(PayloadMaxLengthTest, ExceedLimit) {\n   auto res = cli_.Post(\"/test\", \"123456789\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(413, res->status);\n \n   res = cli_.Post(\"/test\", \"12345678\", \"text/plain\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -2948,14 +2977,14 @@ TEST_F(PayloadMaxLengthTest, ExceedLimit) {\n TEST(SSLClientTest, ServerNameIndication) {\n   SSLClient cli(\"httpbin.org\", 443);\n   auto res = cli.Get(\"/get\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n }\n \n TEST(SSLClientTest, ServerCertificateVerification1) {\n   SSLClient cli(\"google.com\");\n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(301, res->status);\n }\n \n@@ -2964,14 +2993,15 @@ TEST(SSLClientTest, ServerCertificateVerification2) {\n   cli.enable_server_certificate_verification(true);\n   cli.set_ca_cert_path(\"hello\");\n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::SSLLoadingCerts, res.error());\n }\n \n TEST(SSLClientTest, ServerCertificateVerification3) {\n   SSLClient cli(\"google.com\");\n   cli.set_ca_cert_path(CA_CERT_FILE);\n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(301, res->status);\n }\n \n@@ -2982,7 +3012,7 @@ TEST(SSLClientTest, WildcardHostNameMatch) {\n   cli.enable_server_certificate_verification(true);\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n }\n \n@@ -3023,7 +3053,7 @@ TEST(SSLClientServerTest, ClientCertPresent) {\n   cli.set_connection_timeout(30);\n \n   auto res = cli.Get(\"/test\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n \n   t.join();\n@@ -3094,7 +3124,7 @@ TEST(SSLClientServerTest, MemoryClientCertPresent) {\n   cli.set_connection_timeout(30);\n \n   auto res = cli.Get(\"/test\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n \n   X509_free(server_cert);\n@@ -3118,7 +3148,8 @@ TEST(SSLClientServerTest, ClientCertMissing) {\n   SSLClient cli(HOST, PORT);\n   auto res = cli.Get(\"/test\");\n   cli.set_connection_timeout(30);\n-  ASSERT_TRUE(res == nullptr);\n+  ASSERT_TRUE(!res);\n+  EXPECT_EQ(Error::SSLServerVerification, res.error());\n \n   svr.stop();\n \n@@ -3142,7 +3173,7 @@ TEST(SSLClientServerTest, TrustDirOptional) {\n   cli.set_connection_timeout(30);\n \n   auto res = cli.Get(\"/test\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   ASSERT_EQ(200, res->status);\n \n   t.join();\n@@ -3178,12 +3209,12 @@ TEST(YahooRedirectTest2, SimpleInterface) {\n   Client cli(\"http://yahoo.com\");\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(301, res->status);\n \n   cli.set_follow_location(true);\n   res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -3191,12 +3222,35 @@ TEST(YahooRedirectTest3, SimpleInterface) {\n   Client cli(\"https://yahoo.com\");\n \n   auto res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(301, res->status);\n \n   cli.set_follow_location(true);\n   res = cli.Get(\"/\");\n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(200, res->status);\n+}\n+\n+TEST(YahooRedirectTest3, NewResultInterface) {\n+  Client cli(\"https://yahoo.com\");\n+\n+  auto res = cli.Get(\"/\");\n+  ASSERT_TRUE(res);\n+  ASSERT_FALSE(!res);\n+  ASSERT_TRUE(res);\n+  ASSERT_FALSE(res == nullptr);\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(Error::Success, res.error());\n+  EXPECT_EQ(301, res.value().status);\n+  EXPECT_EQ(301, (*res).status);\n+  EXPECT_EQ(301, res->status);\n+\n+  cli.set_follow_location(true);\n+  res = cli.Get(\"/\");\n+  ASSERT_TRUE(res);\n+  EXPECT_EQ(Error::Success, res.error());\n+  EXPECT_EQ(200, res.value().status);\n+  EXPECT_EQ(200, (*res).status);\n   EXPECT_EQ(200, res->status);\n }\n \n@@ -3206,7 +3260,7 @@ TEST(DecodeWithChunkedEncoding, BrotliEncoding) {\n   auto res = cli.Get(\"/ajax/libs/jquery/3.5.1/jquery.js\",\n                      {{\"Accept-Encoding\", \"brotli\"}});\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n   EXPECT_EQ(287630, res->body.size());\n   EXPECT_EQ(\"application/javascript; charset=utf-8\",\n@@ -3221,7 +3275,7 @@ TEST(HttpsToHttpRedirectTest2, SimpleInterface) {\n           .set_follow_location(true)\n           .Get(\"/redirect-to?url=http%3A%2F%2Fwww.google.com&status_code=302\");\n \n-  ASSERT_TRUE(res != nullptr);\n+  ASSERT_TRUE(res);\n   EXPECT_EQ(200, res->status);\n }\n #endif\n", "problem_statement": "Better error handling on Client\nCurrently, the client API returns `std::shared<httplib::Response>` if the request succeeds. Otherwise , API returns just `nullptr` and doesn't give any additional error information such as connection timeout.\r\n\r\nIt is desirable to add an error report mechanism to the existing client API without breaking existing users' code.\n", "hints_text": "`get_last_error` could be added which simply returns `errno` on non Windows and calls `WSAGetLastError` on Windows.\nhope this feature can be develop as soon as possible. otherwise, it's hard to know why res is nullptr.\n### 1.  .One solution would be to always return a concrete  `httplib::Response` object and to overload equality operators with nullptr_t\r\nIt should be marked deprecated upfront so users would know not to use that as the compiler generates a warning.\r\n\r\nThe implementation of `nullptr_t` operator will check whether connection has failed, in that case comparison against null will return true.\r\n\r\nPlease review the following example:\r\n\r\n\r\n\r\n```\r\nclass Response\r\n{\r\npublic:\r\n\tResponse(int status) : mStatus(status) \t{}\r\n\t[[deprecated(\"nullptr comparison is deprecated please use getStatus() instead\")]]\r\n\tbool operator==([[maybe_unused]] nullptr_t null) const\r\n\t{\r\n\t\treturn mStatus == 0;\r\n\t}\r\n\r\n\t[[deprecated(\"nullptr comparison is deprecated please use getStatus() instead\")]]\r\n\tbool operator!=([[maybe_unused]] nullptr_t null) const\r\n\t{\r\n\t\treturn mStatus != 0;\r\n\t}\r\n\r\n\tint getStatus() const { return mStatus; }\r\nprivate:\r\n\tint mStatus = 0;\r\n\r\n```\r\n## usage\r\n```\r\n\tResponse res(3);\r\n\tif (res != nullptr)\r\n\t{\r\n          // do stuff with the valid response\r\n\t}\r\n```\r\n------------------------\r\n### 2. Another more comprehensive solution would be to carefully rethink the error handling system.\r\nBranch the library to a new major version. refactor and apply any desired changes. Most of the effort would go to the new branch, while some effort that will fade over time would go to the current branch, so virtually there are no breaking changes.\r\n\r\n\n```cpp\r\n#include <iostream>\r\n\r\nstruct Body {\r\n  Body() = default;\r\n  Body(Body&& rhs) = default;\r\n  Body& operator=(const Body& rhs) {\r\n    std::cout << \"assignment operator is invoked...\" << std::endl;\r\n    std::cout << \"unnecessary copy takes place...\" << std::endl;\r\n    return *this;\r\n  }\r\n};\r\n\r\nstruct Response {\r\n  Body body;\r\n};\r\n\r\nstruct Client {\r\n  bool send(Response& res) { return true; }\r\n  Response Get() { Response res; send(res); return std::move(res); }\r\n};\r\n\r\nstruct Client2 : public Client {\r\n  Response Get() { return cli_.Get(); }\r\n  Client cli_;\r\n};\r\n\r\nint main() {\r\n  Client2 cli;\r\n\r\n  Response res;\r\n  res = cli.Get();\r\n}\r\n```\r\n\r\n```bash\r\n ~/tmp$ g++ -std=c++11 a.cpp && ./a.out \r\nassignment operator is invoked...\r\nunnecessary copy takes place...\r\n```\nSeparating deceleration from initialization when declaring 'Response' prevents RVO from kicking in, copy assignment shouldn't occur and in general it's preferable.\r\n\r\nAs depicted in the following snippet:\r\nhttps://godbolt.org/z/b7KGhs\r\n\r\nOne thing that I left out for full backward compatibility was also to overload the dereference operator.\r\nIf declaring it const break changes then constness can be removed:\r\n```\r\n[[deprecated(\"Structure dereference operator (->) is deprecated, for accesing members please use the Structure reference operator (.) instead.\")]]\r\nconst Response* operator->() const\r\n{\r\n\treturn this;\r\n}\r\n```\n@TheNicker, I was using `Response res; res = cli.Get();` just as an example that users may easily fall into unknowingly. That's why I don't prefer returning an object instead of a smart pointer that will never cause such unintentional copying of body text which might contain Giga bytes. Anyway, thanks for your suggestions!\nIn principle compilers nowdays would warn you about such behaviour, but I can see that this path won't bear fruit as new to some experienced developers usually don't pay attentions to these nuances, thus I would greatly would like to see the code gets internally forked, for maybe even a substantial make over.\r\n\n`std::expected` or `throw`:\r\nhttps://www.reddit.com/r/cpp/comments/c75ipk/why_stdexpected_is_not_in_the_standard_yet_is_it/\nI think that the fundamental idea of std::expected is very good , but I would bet against it getting into the standard.\r\nThe C++ committee is taking the dual exception handling system very seriously, but according to progress I would except to see a solution maybe in C++(26).\r\n\r\n`std::expected` - I believe not.\r\n`throw` -  If it was (allegedly) 2026 and Herb Sutter's ideas from his talk last year at CPP con would come to realization then throw all the way, but currently the library **doesn't actively throw even once**, so it might be worth keep it that way and even remove the API calls that do throw and mark noexcept whenever possible.\r\n\r\n\r\n\r\n\r\n", "created_at": "2020-08-04T21:13:26Z", "version": "0.7"}
{"repo": "yhirose/cpp-httplib", "pull_number": 304, "instance_id": "yhirose__cpp-httplib-304", "issue_numbers": ["306"], "base_commit": "aa543240dbf3a5a5c860065a375e47bf3a54076b", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -528,6 +528,8 @@ class Server {\n   Server &Options(const char *pattern, Handler handler);\n \n   bool set_base_dir(const char *dir, const char *mount_point = nullptr);\n+  void set_file_extension_and_mimetype_mapping(const char *ext,\n+                                               const char *mime);\n   void set_file_request_handler(Handler handler);\n \n   void set_error_handler(Handler handler);\n@@ -597,6 +599,7 @@ class Server {\n   std::atomic<bool> is_running_;\n   std::atomic<socket_t> svr_sock_;\n   std::vector<std::pair<std::string, std::string>> base_dirs_;\n+  std::map<std::string, std::string> file_extension_and_mimetype_map_;\n   Handler file_request_handler_;\n   Handlers get_handlers_;\n   Handlers post_handlers_;\n@@ -1526,8 +1529,14 @@ inline std::string get_remote_addr(socket_t sock) {\n   return std::string();\n }\n \n-inline const char *find_content_type(const std::string &path) {\n+inline const char *\n+find_content_type(const std::string &path,\n+                  const std::map<std::string, std::string> &user_data) {\n   auto ext = file_extension(path);\n+\n+  auto it = user_data.find(ext);\n+  if (it != user_data.end()) { return it->second.c_str(); }\n+\n   if (ext == \"txt\") {\n     return \"text/plain\";\n   } else if (ext == \"html\" || ext == \"htm\") {\n@@ -1550,6 +1559,8 @@ inline const char *find_content_type(const std::string &path) {\n     return \"application/pdf\";\n   } else if (ext == \"js\") {\n     return \"application/javascript\";\n+  } else if (ext == \"wasm\") {\n+    return \"application/wasm\";\n   } else if (ext == \"xml\") {\n     return \"application/xml\";\n   } else if (ext == \"xhtml\") {\n@@ -1967,7 +1978,7 @@ inline std::string encode_url(const std::string &s) {\n     case '\\n': result += \"%0A\"; break;\n     case '\\'': result += \"%27\"; break;\n     case ',': result += \"%2C\"; break;\n-    case ':': result += \"%3A\"; break;\n+    // case ':': result += \"%3A\"; break; // ok? probably...\n     case ';': result += \"%3B\"; break;\n     default:\n       auto c = static_cast<uint8_t>(s[i]);\n@@ -2860,6 +2871,11 @@ inline bool Server::set_base_dir(const char *dir, const char *mount_point) {\n   return false;\n }\n \n+inline void Server::set_file_extension_and_mimetype_mapping(const char *ext,\n+                                                            const char *mime) {\n+  file_extension_and_mimetype_map_[ext] = mime;\n+}\n+\n inline void Server::set_file_request_handler(Handler handler) {\n   file_request_handler_ = std::move(handler);\n }\n@@ -3178,7 +3194,8 @@ inline bool Server::handle_file_request(Request &req, Response &res) {\n \n         if (detail::is_file(path)) {\n           detail::read_file(path, res.body);\n-          auto type = detail::find_content_type(path);\n+          auto type =\n+              detail::find_content_type(path, file_extension_and_mimetype_map_);\n           if (type) { res.set_header(\"Content-Type\", type); }\n           res.status = 200;\n           if (file_request_handler_) { file_request_handler_(req, res); }\n@@ -3666,13 +3683,7 @@ inline bool Client::write_request(Stream &strm, const Request &req,\n   BufferStream bstrm;\n \n   // Request line\n-  const static std::regex re(\n-      R\"(^((?:[^:/?#]+://)?(?:[^/?#]*)?)?([^?#]*(?:\\?[^#]*)?(?:#.*)?))\");\n-\n-  std::smatch m;\n-  if (!regex_match(req.path, m, re)) { return false; }\n-\n-  auto path = m[1].str() + detail::encode_url(m[2].str());\n+  const auto &path = detail::encode_url(req.path);\n \n   bstrm.write_format(\"%s %s HTTP/1.1\\r\\n\", req.method.c_str(), path.c_str());\n \n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -647,6 +647,7 @@ class ServerTest : public ::testing::Test {\n   virtual void SetUp() {\n     svr_.set_base_dir(\"./www\");\n     svr_.set_base_dir(\"./www2\", \"/mount\");\n+    svr_.set_file_extension_and_mimetype_mapping(\"abcde\", \"text/abcde\");\n \n     svr_.Get(\"/hi\",\n              [&](const Request & /*req*/, Response &res) {\n@@ -1161,6 +1162,14 @@ TEST_F(ServerTest, GetMethodOutOfBaseDirMount2) {\n   EXPECT_EQ(404, res->status);\n }\n \n+TEST_F(ServerTest, UserDefinedMIMETypeMapping) {\n+  auto res = cli_.Get(\"/dir/test.abcde\");\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(200, res->status);\n+  EXPECT_EQ(\"text/abcde\", res->get_header_value(\"Content-Type\"));\n+  EXPECT_EQ(\"abcde\\n\", res->body);\n+}\n+\n TEST_F(ServerTest, InvalidBaseDirMount) {\n   EXPECT_EQ(false, svr_.set_base_dir(\"./www3\", \"invalid_mount_point\"));\n }\n", "problem_statement": "custom mimetype mappings for `set_base_dir`\nWhen using `set_base_dir` to automatically serve files, there should be an option to provide extra file extension -> mimetype mappings. When custom mappings are provided, they should not delete *all* existing mappings, but rather continue to use existing mappings as a fallback if a file extension cannot be found in the custom mappings.  \r\n\r\nOn an unrelated note, you should add `application/wasm` for `.wasm` files to your default list of recognized extensions. That is the mimetype for WebAssembly files and will likely be more frequently used by front-end developers in the future.\n", "hints_text": "", "created_at": "2019-12-25T03:47:56Z", "version": "0.5"}
{"repo": "yhirose/cpp-httplib", "pull_number": 279, "instance_id": "yhirose__cpp-httplib-279", "issue_numbers": ["241"], "base_commit": "5e37e383982c3bda0535c61c31e79e3829b0d684", "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -119,8 +119,8 @@ using socket_t = SOCKET;\n #ifdef CPPHTTPLIB_USE_POLL\n #include <poll.h>\n #endif\n-#include <pthread.h>\n #include <csignal>\n+#include <pthread.h>\n #include <sys/select.h>\n #include <sys/socket.h>\n #include <unistd.h>\n@@ -196,13 +196,11 @@ using DataSink = std::function<void(const char *data, size_t data_len)>;\n \n using Done = std::function<void()>;\n \n-using ContentProvider = std::function<void(size_t offset, size_t length, DataSink sink)>;\n-\n-using ContentProviderWithCloser = std::function<void(size_t offset, size_t length, DataSink sink, Done done)>;\n+using ContentProvider =\n+    std::function<void(size_t offset, size_t length, DataSink sink)>;\n \n-using ContentReceiver = std::function<bool(const char *data, size_t data_length)>;\n-\n-using ContentReader = std::function<bool(ContentReceiver receiver)>;\n+using ContentProviderWithCloser =\n+    std::function<void(size_t offset, size_t length, DataSink sink, Done done)>;\n \n using Progress = std::function<bool(uint64_t current, uint64_t total)>;\n \n@@ -212,8 +210,7 @@ using ResponseHandler = std::function<bool(const Response &response)>;\n struct MultipartFile {\n   std::string filename;\n   std::string content_type;\n-  size_t offset = 0;\n-  size_t length = 0;\n+  std::string content;\n };\n using MultipartFiles = std::multimap<std::string, MultipartFile>;\n \n@@ -225,6 +222,35 @@ struct MultipartFormData {\n };\n using MultipartFormDataItems = std::vector<MultipartFormData>;\n \n+using ContentReceiver =\n+    std::function<bool(const char *data, size_t data_length)>;\n+\n+using MultipartContentReceiver =\n+    std::function<bool(const std::string& name, const char *data, size_t data_length)>;\n+\n+using MultipartContentHeader =\n+    std::function<bool(const std::string &name, const MultipartFile &file)>;\n+\n+class ContentReader {\n+  public:\n+    using Reader = std::function<bool(ContentReceiver receiver)>;\n+    using MultipartReader = std::function<bool(MultipartContentReceiver receiver, MultipartContentHeader header)>;\n+\n+    ContentReader(Reader reader, MultipartReader muitlpart_reader)\n+      : reader_(reader), muitlpart_reader_(muitlpart_reader) {}\n+\n+    bool operator()(MultipartContentReceiver receiver, MultipartContentHeader header) const {\n+      return muitlpart_reader_(receiver, header);\n+    }\n+\n+    bool operator()(ContentReceiver receiver) const {\n+      return reader_(receiver);\n+    }\n+\n+    Reader reader_;\n+    MultipartReader muitlpart_reader_;\n+};\n+\n using Range = std::pair<ssize_t, ssize_t>;\n using Ranges = std::vector<Range>;\n \n@@ -262,6 +288,8 @@ struct Request {\n   std::string get_param_value(const char *key, size_t id = 0) const;\n   size_t get_param_value_count(const char *key) const;\n \n+  bool is_multipart_form_data() const;\n+\n   bool has_file(const char *key) const;\n   MultipartFile get_file_value(const char *key) const;\n \n@@ -394,7 +422,7 @@ class ThreadPool : public TaskQueue {\n     cond_.notify_all();\n \n     // Join...\n-    for (auto& t : threads_) {\n+    for (auto &t : threads_) {\n       t.join();\n     }\n   }\n@@ -475,20 +503,17 @@ class NoThread : public TaskQueue {\n   NoThread() {}\n   virtual ~NoThread() {}\n \n-  virtual void enqueue(std::function<void()> fn) override {\n-    fn();\n-  }\n+  virtual void enqueue(std::function<void()> fn) override { fn(); }\n \n-  virtual void shutdown() override {\n-  }\n+  virtual void shutdown() override {}\n };\n #endif\n \n class Server {\n public:\n   using Handler = std::function<void(const Request &, Response &)>;\n-  using HandlerWithContentReader = std::function<void(const Request &, Response &,\n-                             const ContentReader &content_reader)>;\n+  using HandlerWithContentReader = std::function<void(\n+      const Request &, Response &, const ContentReader &content_reader)>;\n   using Logger = std::function<void(const Request &, const Response &)>;\n \n   Server();\n@@ -531,7 +556,7 @@ class Server {\n protected:\n   bool process_request(Stream &strm, bool last_connection,\n                        bool &connection_close,\n-                       const std::function<void(Request &)>& setup_request);\n+                       const std::function<void(Request &)> &setup_request);\n \n   size_t keep_alive_max_count_;\n   time_t read_timeout_sec_;\n@@ -540,7 +565,8 @@ class Server {\n \n private:\n   using Handlers = std::vector<std::pair<std::regex, Handler>>;\n-  using HandersForContentReader = std::vector<std::pair<std::regex, HandlerWithContentReader>>;\n+  using HandersForContentReader =\n+      std::vector<std::pair<std::regex, HandlerWithContentReader>>;\n \n   socket_t create_server_socket(const char *host, int port,\n                                 int socket_flags) const;\n@@ -564,7 +590,14 @@ class Server {\n                     Response &res);\n   bool read_content_with_content_receiver(Stream &strm, bool last_connection,\n                                           Request &req, Response &res,\n-                                          ContentReceiver reveiver);\n+                                          ContentReceiver receiver,\n+                                          MultipartContentReceiver multipart_receiver,\n+                                          MultipartContentHeader multipart_header);\n+  bool read_content_core(Stream &strm, bool last_connection,\n+                         Request &req, Response &res,\n+                         ContentReceiver receiver,\n+                         MultipartContentReceiver multipart_receiver,\n+                         MultipartContentHeader mulitpart_header);\n \n   virtual bool process_and_close_socket(socket_t sock);\n \n@@ -574,11 +607,11 @@ class Server {\n   Handler file_request_handler_;\n   Handlers get_handlers_;\n   Handlers post_handlers_;\n-  HandersForContentReader post_handlers_for_content_reader;\n+  HandersForContentReader post_handlers_for_content_reader_;\n   Handlers put_handlers_;\n-  HandersForContentReader put_handlers_for_content_reader;\n+  HandersForContentReader put_handlers_for_content_reader_;\n   Handlers patch_handlers_;\n-  HandersForContentReader patch_handlers_for_content_reader;\n+  HandersForContentReader patch_handlers_for_content_reader_;\n   Handlers delete_handlers_;\n   Handlers options_handlers_;\n   Handler error_handler_;\n@@ -1191,7 +1224,8 @@ inline bool wait_until_socket_is_ready(socket_t sock, time_t sec, time_t usec) {\n       (FD_ISSET(sock, &fdsr) || FD_ISSET(sock, &fdsw))) {\n     int error = 0;\n     socklen_t len = sizeof(error);\n-    return getsockopt(sock, SOL_SOCKET, SO_ERROR, reinterpret_cast<char*>(&error), &len) >= 0 &&\n+    return getsockopt(sock, SOL_SOCKET, SO_ERROR,\n+                      reinterpret_cast<char *>(&error), &len) >= 0 &&\n            !error;\n   }\n   return false;\n@@ -1330,8 +1364,8 @@ inline std::string get_remote_addr(socket_t sock) {\n   if (!getpeername(sock, reinterpret_cast<struct sockaddr *>(&addr), &len)) {\n     std::array<char, NI_MAXHOST> ipstr{};\n \n-    if (!getnameinfo(reinterpret_cast<struct sockaddr *>(&addr), len, ipstr.data(), ipstr.size(),\n-                     nullptr, 0, NI_NUMERICHOST)) {\n+    if (!getnameinfo(reinterpret_cast<struct sockaddr *>(&addr), len,\n+                     ipstr.data(), ipstr.size(), nullptr, 0, NI_NUMERICHOST)) {\n       return ipstr.data();\n     }\n   }\n@@ -1420,7 +1454,7 @@ inline bool compress(std::string &content) {\n   std::array<char, 16384> buff{};\n   do {\n     strm.avail_out = buff.size();\n-    strm.next_out = reinterpret_cast<Bytef*>(buff.data());\n+    strm.next_out = reinterpret_cast<Bytef *>(buff.data());\n     ret = deflate(&strm, Z_FINISH);\n     assert(ret != Z_STREAM_ERROR);\n     compressed.append(buff.data(), buff.size() - strm.avail_out);\n@@ -1462,7 +1496,7 @@ class decompressor {\n     std::array<char, 16384> buff{};\n     do {\n       strm.avail_out = buff.size();\n-      strm.next_out = reinterpret_cast<Bytef*>(buff.data());\n+      strm.next_out = reinterpret_cast<Bytef *>(buff.data());\n \n       ret = inflate(&strm, Z_NO_FLUSH);\n       assert(ret != Z_STREAM_ERROR);\n@@ -1472,7 +1506,9 @@ class decompressor {\n       case Z_MEM_ERROR: inflateEnd(&strm); return false;\n       }\n \n-      if (!callback(buff.data(), buff.size() - strm.avail_out)) { return false; }\n+      if (!callback(buff.data(), buff.size() - strm.avail_out)) {\n+        return false;\n+      }\n     } while (strm.avail_out == 0);\n \n     return ret == Z_OK || ret == Z_STREAM_END;\n@@ -1844,79 +1880,6 @@ inline bool parse_multipart_boundary(const std::string &content_type,\n   return true;\n }\n \n-inline bool parse_multipart_formdata(const std::string &boundary,\n-                                     const std::string &body,\n-                                     MultipartFiles &files) {\n-  static std::string dash = \"--\";\n-  static std::string crlf = \"\\r\\n\";\n-\n-  static std::regex re_content_type(\"Content-Type: (.*?)$\",\n-                                    std::regex_constants::icase);\n-\n-  static std::regex re_content_disposition(\n-      \"Content-Disposition: form-data; name=\\\"(.*?)\\\"(?:; filename=\\\"(.*?)\\\")?\",\n-      std::regex_constants::icase);\n-\n-  auto dash_boundary = dash + boundary;\n-\n-  auto pos = body.find(dash_boundary);\n-  if (pos != 0) { return false; }\n-\n-  pos += dash_boundary.size();\n-\n-  auto next_pos = body.find(crlf, pos);\n-  if (next_pos == std::string::npos) { return false; }\n-\n-  pos = next_pos + crlf.size();\n-\n-  while (pos < body.size()) {\n-    next_pos = body.find(crlf, pos);\n-    if (next_pos == std::string::npos) { return false; }\n-\n-    std::string name;\n-    MultipartFile file;\n-\n-    auto header = body.substr(pos, (next_pos - pos));\n-\n-    while (pos != next_pos) {\n-      std::smatch m;\n-      if (std::regex_match(header, m, re_content_type)) {\n-        file.content_type = m[1];\n-      } else if (std::regex_match(header, m, re_content_disposition)) {\n-        name = m[1];\n-        file.filename = m[2];\n-      }\n-\n-      pos = next_pos + crlf.size();\n-\n-      next_pos = body.find(crlf, pos);\n-      if (next_pos == std::string::npos) { return false; }\n-\n-      header = body.substr(pos, (next_pos - pos));\n-    }\n-\n-    pos = next_pos + crlf.size();\n-\n-    next_pos = body.find(crlf + dash_boundary, pos);\n-\n-    if (next_pos == std::string::npos) { return false; }\n-\n-    file.offset = pos;\n-    file.length = next_pos - pos;\n-\n-    pos = next_pos + crlf.size() + dash_boundary.size();\n-\n-    next_pos = body.find(crlf, pos);\n-    if (next_pos == std::string::npos) { return false; }\n-\n-    files.emplace(name, file);\n-\n-    pos = next_pos + crlf.size();\n-  }\n-\n-  return true;\n-}\n-\n inline bool parse_range_header(const std::string &s, Ranges &ranges) {\n   try {\n     static auto re_first_range =\n@@ -1952,6 +1915,178 @@ inline bool parse_range_header(const std::string &s, Ranges &ranges) {\n   } catch (...) { return false; }\n }\n \n+class MultipartFormDataParser {\n+public:\n+  MultipartFormDataParser() {}\n+\n+  void set_boundary(const std::string &boundary) {\n+    boundary_ = boundary;\n+  }\n+\n+  bool is_valid() const { return is_valid_; }\n+\n+  template <typename T, typename U>\n+  bool parse(const char *buf, size_t n, T content_callback, U header_callback) {\n+    static const std::regex re_content_type(R\"(^Content-Type:\\s*(.*?)\\s*$)\",\n+                                            std::regex_constants::icase);\n+\n+    static const std::regex re_content_disposition(\n+        \"^Content-Disposition:\\\\s*form-data;\\\\s*name=\\\"(.*?)\\\"(?:;\\\\s*filename=\"\n+        \"\\\"(.*?)\\\")?\\\\s*$\",\n+        std::regex_constants::icase);\n+\n+    buf_.append(buf, n); // TODO: performance improvement\n+\n+    while (!buf_.empty()) {\n+      switch (state_) {\n+      case 0: { // Initial boundary\n+        auto pattern = dash_ + boundary_ + crlf_;\n+        if (pattern.size() > buf_.size()) { return true; }\n+        auto pos = buf_.find(pattern);\n+        if (pos != 0) {\n+          is_done_ = true;\n+          return false;\n+        }\n+        buf_.erase(0, pattern.size());\n+        off_ += pattern.size();\n+        state_ = 1;\n+        break;\n+      }\n+      case 1: { // New entry\n+        clear_file_info();\n+        state_ = 2;\n+        break;\n+      }\n+      case 2: { // Headers\n+        auto pos = buf_.find(crlf_);\n+        while (pos != std::string::npos) {\n+          if (pos == 0) {\n+            if (!header_callback(name_, file_)) {\n+              is_valid_ = false;\n+              is_done_ = false;\n+              return false;\n+            }\n+            buf_.erase(0, crlf_.size());\n+            off_ += crlf_.size();\n+            state_ = 3;\n+            break;\n+          }\n+\n+          auto header = buf_.substr(0, pos);\n+          {\n+            std::smatch m;\n+            if (std::regex_match(header, m, re_content_type)) {\n+              file_.content_type = m[1];\n+            } else if (std::regex_match(header, m, re_content_disposition)) {\n+              name_ = m[1];\n+              file_.filename = m[2];\n+            }\n+          }\n+\n+          buf_.erase(0, pos + crlf_.size());\n+          off_ += pos + crlf_.size();\n+          pos = buf_.find(crlf_);\n+        }\n+        break;\n+      }\n+      case 3: { // Body\n+        {\n+          auto pattern = crlf_ + dash_;\n+          auto pos = buf_.find(pattern);\n+          if (pos == std::string::npos) {\n+            pos = buf_.size();\n+          }\n+          if (!content_callback(name_, buf_.data(), pos)) {\n+            is_valid_ = false;\n+            is_done_ = false;\n+            return false;\n+          }\n+\n+          off_ += pos;\n+          buf_.erase(0, pos);\n+        }\n+\n+        {\n+          auto pattern = crlf_ + dash_ + boundary_;\n+          if (pattern.size() > buf_.size()) { return true; }\n+\n+          auto pos = buf_.find(pattern);\n+          if (pos != std::string::npos) {\n+            if (!content_callback(name_, buf_.data(), pos)) {\n+              is_valid_ = false;\n+              is_done_ = false;\n+              return false;\n+            }\n+\n+            off_ += pos + pattern.size();\n+            buf_.erase(0, pos + pattern.size());\n+            state_ = 4;\n+          } else {\n+            if (!content_callback(name_, buf_.data(), pattern.size())) {\n+              is_valid_ = false;\n+              is_done_ = false;\n+              return false;\n+            }\n+\n+            off_ += pattern.size();\n+            buf_.erase(0, pattern.size());\n+          }\n+        }\n+        break;\n+      }\n+      case 4: { // Boundary\n+        auto pos = buf_.find(crlf_);\n+        if (crlf_.size() > buf_.size()) { return true; }\n+        if (pos == 0) {\n+          buf_.erase(0, crlf_.size());\n+          off_ += crlf_.size();\n+          state_ = 1;\n+        } else {\n+          auto pattern = dash_ + crlf_;\n+          if (pattern.size() > buf_.size()) { return true; }\n+          auto pos = buf_.find(pattern);\n+          if (pos == 0) {\n+            buf_.erase(0, pattern.size());\n+            off_ += pattern.size();\n+            is_valid_ = true;\n+            state_ = 5;\n+          } else {\n+            is_done_ = true;\n+            return true;\n+          }\n+        }\n+        break;\n+      }\n+      case 5: { // Done\n+        is_valid_ = false;\n+        return false;\n+      }\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+private:\n+  void clear_file_info() {\n+    name_.clear();\n+    file_.filename.clear();\n+    file_.content_type.clear();\n+  }\n+\n+  const std::string dash_ = \"--\";\n+  const std::string crlf_ = \"\\r\\n\";\n+  std::string boundary_;\n+\n+  std::string buf_;\n+  size_t state_ = 0;\n+  size_t is_valid_ = false;\n+  size_t is_done_ = false;\n+  size_t off_ = 0;\n+  std::string name_;\n+  MultipartFile file_;\n+};\n+\n inline std::string to_lower(const char *beg, const char *end) {\n   std::string out;\n   auto it = beg;\n@@ -2102,6 +2237,15 @@ get_range_offset_and_length(const Request &req, const Response &res,\n   return std::make_pair(r.first, r.second - r.first + 1);\n }\n \n+inline bool expect_content(const Request &req) {\n+  if (req.method == \"POST\" || req.method == \"PUT\" || req.method == \"PATCH\" ||\n+      req.method == \"PRI\") {\n+    return true;\n+  }\n+  // TODO: check if Content-Length is set\n+  return false;\n+}\n+\n #ifdef _WIN32\n class WSInit {\n public:\n@@ -2177,6 +2321,11 @@ inline size_t Request::get_param_value_count(const char *key) const {\n   return std::distance(r.first, r.second);\n }\n \n+inline bool Request::is_multipart_form_data() const {\n+  const auto &content_type = get_header_value(\"Content-Type\");\n+  return !content_type.find(\"multipart/form-data\");\n+}\n+\n inline bool Request::has_file(const char *key) const {\n   return files.find(key) != files.end();\n }\n@@ -2369,7 +2518,7 @@ inline Server &Server::Post(const char *pattern, Handler handler) {\n \n inline Server &Server::Post(const char *pattern,\n                             HandlerWithContentReader handler) {\n-  post_handlers_for_content_reader.push_back(\n+  post_handlers_for_content_reader_.push_back(\n       std::make_pair(std::regex(pattern), handler));\n   return *this;\n }\n@@ -2381,7 +2530,7 @@ inline Server &Server::Put(const char *pattern, Handler handler) {\n \n inline Server &Server::Put(const char *pattern,\n                            HandlerWithContentReader handler) {\n-  put_handlers_for_content_reader.push_back(\n+  put_handlers_for_content_reader_.push_back(\n       std::make_pair(std::regex(pattern), handler));\n   return *this;\n }\n@@ -2393,7 +2542,7 @@ inline Server &Server::Patch(const char *pattern, Handler handler) {\n \n inline Server &Server::Patch(const char *pattern,\n                              HandlerWithContentReader handler) {\n-  patch_handlers_for_content_reader.push_back(\n+  patch_handlers_for_content_reader_.push_back(\n       std::make_pair(std::regex(pattern), handler));\n   return *this;\n }\n@@ -2646,50 +2795,88 @@ Server::write_content_with_provider(Stream &strm, const Request &req,\n \n inline bool Server::read_content(Stream &strm, bool last_connection,\n                                  Request &req, Response &res) {\n-  if (!detail::read_content(strm, req, payload_max_length_, res.status,\n-                            Progress(), [&](const char *buf, size_t n) {\n-                              if (req.body.size() + n > req.body.max_size()) {\n-                                return false;\n-                              }\n-                              req.body.append(buf, n);\n-                              return true;\n-                            })) {\n-    return write_response(strm, last_connection, req, res);\n-  }\n+  auto ret = read_content_core(strm, last_connection, req, res,\n+    [&](const char *buf, size_t n) {\n+      if (req.body.size() + n > req.body.max_size()) { return false; }\n+      req.body.append(buf, n);\n+      return true;\n+    },\n+    [&](const std::string &name, const char *buf, size_t n) {\n+      // TODO: handle elements with a same key\n+      auto it = req.files.find(name);\n+      auto &content = it->second.content;\n+      if (content.size() + n > content.max_size()) { return false; }\n+      content.append(buf, n);\n+      return true;\n+    },\n+    [&](const std::string &name, const MultipartFile &file) {\n+      req.files.emplace(name, file);\n+      return true;\n+    }\n+  );\n \n   const auto &content_type = req.get_header_value(\"Content-Type\");\n-\n   if (!content_type.find(\"application/x-www-form-urlencoded\")) {\n     detail::parse_query_text(req.body, req.params);\n-  } else if (!content_type.find(\"multipart/form-data\")) {\n-    std::string boundary;\n-    if (!detail::parse_multipart_boundary(content_type, boundary) ||\n-        !detail::parse_multipart_formdata(boundary, req.body, req.files)) {\n-      res.status = 400;\n-      return write_response(strm, last_connection, req, res);\n-    }\n   }\n \n-  return true;\n+  return ret;\n }\n \n inline bool\n Server::read_content_with_content_receiver(Stream &strm, bool last_connection,\n                                            Request &req, Response &res,\n-                                           ContentReceiver receiver) {\n-  if (!detail::read_content(\n-          strm, req, payload_max_length_, res.status, Progress(),\n-          [&](const char *buf, size_t n) { return receiver(buf, n); })) {\n+                                           ContentReceiver receiver,\n+                                           MultipartContentReceiver multipart_receiver,\n+                                           MultipartContentHeader multipart_header) {\n+  return read_content_core(strm, last_connection, req, res,\n+      receiver, multipart_receiver, multipart_header);\n+}\n+\n+inline bool\n+Server::read_content_core(Stream &strm, bool last_connection,\n+                          Request &req, Response &res,\n+                          ContentReceiver receiver,\n+                          MultipartContentReceiver multipart_receiver,\n+                          MultipartContentHeader mulitpart_header) {\n+  detail::MultipartFormDataParser multipart_form_data_parser;\n+  ContentReceiver out;\n+\n+  if (req.is_multipart_form_data()) {\n+    const auto &content_type = req.get_header_value(\"Content-Type\");\n+    std::string boundary;\n+    if (!detail::parse_multipart_boundary(content_type, boundary)) {\n+      res.status = 400;\n+      return write_response(strm, last_connection, req, res);\n+    }\n+\n+    multipart_form_data_parser.set_boundary(boundary);\n+    out = [&](const char *buf, size_t n) {\n+      return multipart_form_data_parser.parse(buf, n, multipart_receiver, mulitpart_header);\n+    };\n+  } else {\n+    out = receiver;\n+  }\n+\n+  if (!detail::read_content(strm, req, payload_max_length_, res.status,\n+                            Progress(), out)) {\n     return write_response(strm, last_connection, req, res);\n   }\n \n+  if (req.is_multipart_form_data()) {\n+    if (!multipart_form_data_parser.is_valid()) {\n+      res.status = 400;\n+      return write_response(strm, last_connection, req, res);\n+    }\n+  }\n+\n   return true;\n }\n \n inline bool Server::handle_file_request(Request &req, Response &res) {\n-  for (const auto& kv: base_dirs_) {\n-    const auto& mount_point = kv.first;\n-    const auto& base_dir = kv.second;\n+  for (const auto &kv : base_dirs_) {\n+    const auto &mount_point = kv.first;\n+    const auto &base_dir = kv.second;\n \n     // Prefix match\n     if (!req.path.find(mount_point)) {\n@@ -2744,7 +2931,8 @@ inline int Server::bind_internal(const char *host, int port, int socket_flags) {\n     if (address.ss_family == AF_INET) {\n       return ntohs(reinterpret_cast<struct sockaddr_in *>(&address)->sin_port);\n     } else if (address.ss_family == AF_INET6) {\n-      return ntohs(reinterpret_cast<struct sockaddr_in6 *>(&address)->sin6_port);\n+      return ntohs(\n+          reinterpret_cast<struct sockaddr_in6 *>(&address)->sin6_port);\n     } else {\n       return -1;\n     }\n@@ -2800,39 +2988,45 @@ inline bool Server::listen_internal() {\n   return ret;\n }\n \n-inline bool Server::routing(Request &req, Response &res, Stream &strm, bool last_connection) {\n+inline bool Server::routing(Request &req, Response &res, Stream &strm,\n+                            bool last_connection) {\n   // File handler\n   if (req.method == \"GET\" && handle_file_request(req, res)) { return true; }\n \n-  // Content reader handler\n-  if (req.method == \"POST\" || req.method == \"PUT\" || req.method == \"PATCH\") {\n-    ContentReader content_reader = [&](ContentReceiver receiver) {\n-      return read_content_with_content_receiver(strm, last_connection, req, res, receiver);\n-    };\n+  if (detail::expect_content(req)) {\n+    // Content reader handler\n+    {\n+      ContentReader reader(\n+        [&](ContentReceiver receiver) {\n+          return read_content_with_content_receiver(strm, last_connection, req, res,\n+                                                    receiver, nullptr, nullptr);\n+        },\n+        [&](MultipartContentReceiver receiver, MultipartContentHeader header) {\n+          return read_content_with_content_receiver(strm, last_connection, req, res,\n+                                                    nullptr, receiver, header);\n+        }\n+      );\n \n-    if (req.method == \"POST\") {\n-      if (dispatch_request_for_content_reader(req, res, content_reader,\n-                                              post_handlers_for_content_reader)) {\n-        return true;\n-      }\n-    } else if (req.method == \"PUT\") {\n-      if (dispatch_request_for_content_reader(req, res, content_reader,\n-                                              put_handlers_for_content_reader)) {\n-        return true;\n-      }\n-    } else if (req.method == \"PATCH\") {\n-      if (dispatch_request_for_content_reader(\n-              req, res, content_reader, patch_handlers_for_content_reader)) {\n-        return true;\n+      if (req.method == \"POST\") {\n+        if (dispatch_request_for_content_reader(\n+                req, res, reader, post_handlers_for_content_reader_)) {\n+          return true;\n+        }\n+      } else if (req.method == \"PUT\") {\n+        if (dispatch_request_for_content_reader(\n+                req, res, reader, put_handlers_for_content_reader_)) {\n+          return true;\n+        }\n+      } else if (req.method == \"PATCH\") {\n+        if (dispatch_request_for_content_reader(\n+                req, res, reader, patch_handlers_for_content_reader_)) {\n+          return true;\n+        }\n       }\n     }\n-  }\n \n-  // Read content into `req.body`\n-  if (req.method == \"POST\" || req.method == \"PUT\" || req.method == \"PATCH\" || req.method == \"PRI\") {\n-    if (!read_content(strm, last_connection, req, res)) {\n-      return false;\n-    }\n+    // Read content into `req.body`\n+    if (!read_content(strm, last_connection, req, res)) { return false; }\n   }\n \n   // Regular handler\n@@ -2887,7 +3081,7 @@ Server::dispatch_request_for_content_reader(Request &req, Response &res,\n inline bool\n Server::process_request(Stream &strm, bool last_connection,\n                         bool &connection_close,\n-                        const std::function<void(Request &)>& setup_request) {\n+                        const std::function<void(Request &)> &setup_request) {\n   std::array<char, 2048> buf{};\n \n   detail::stream_line_reader line_reader(strm, buf.data(), buf.size());\n@@ -3342,7 +3536,8 @@ inline std::shared_ptr<Response> Client::Get(const char *path,\n                                              ResponseHandler response_handler,\n                                              ContentReceiver content_receiver) {\n   Progress dummy;\n-  return Get(path, headers, std::move(response_handler), content_receiver, dummy);\n+  return Get(path, headers, std::move(response_handler), content_receiver,\n+             dummy);\n }\n \n inline std::shared_ptr<Response> Client::Get(const char *path,\n", "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -30,6 +30,12 @@ const std::string JSON_DATA = \"{\\\"hello\\\":\\\"world\\\"}\";\n \n const string LARGE_DATA = string(1024 * 1024 * 100, '@'); // 100MB\n \n+MultipartFile& get_file_value(MultipartFiles &files, const char *key) {\n+  auto it = files.find(key);\n+  if (it != files.end()) { return it->second; }\n+  throw std::runtime_error(\"invalid mulitpart form data name error\");\n+}\n+\n #ifdef _WIN32\n TEST(StartupTest, WSAStartup) {\n   WSADATA wsaData;\n@@ -676,29 +682,27 @@ class ServerTest : public ::testing::Test {\n                 {\n                   const auto &file = req.get_file_value(\"text1\");\n                   EXPECT_EQ(\"\", file.filename);\n-                  EXPECT_EQ(\"text default\",\n-                            req.body.substr(file.offset, file.length));\n+                  EXPECT_EQ(\"text default\", file.content);\n                 }\n \n                 {\n                   const auto &file = req.get_file_value(\"text2\");\n                   EXPECT_EQ(\"\", file.filename);\n-                  EXPECT_EQ(\"a\u03c9b\", req.body.substr(file.offset, file.length));\n+                  EXPECT_EQ(\"a\u03c9b\", file.content);\n                 }\n \n                 {\n                   const auto &file = req.get_file_value(\"file1\");\n                   EXPECT_EQ(\"hello.txt\", file.filename);\n                   EXPECT_EQ(\"text/plain\", file.content_type);\n-                  EXPECT_EQ(\"h\\ne\\n\\nl\\nl\\no\\n\",\n-                            req.body.substr(file.offset, file.length));\n+                  EXPECT_EQ(\"h\\ne\\n\\nl\\nl\\no\\n\", file.content);\n                 }\n \n                 {\n                   const auto &file = req.get_file_value(\"file3\");\n                   EXPECT_EQ(\"\", file.filename);\n                   EXPECT_EQ(\"application/octet-stream\", file.content_type);\n-                  EXPECT_EQ(0u, file.length);\n+                  EXPECT_EQ(0u, file.content.size());\n                 }\n               })\n         .Post(\"/empty\",\n@@ -753,16 +757,57 @@ class ServerTest : public ::testing::Test {\n                 EXPECT_EQ(\"5\", req.get_header_value(\"Content-Length\"));\n               })\n         .Post(\"/content_receiver\",\n-              [&](const Request & /*req*/, Response &res,\n-                  const ContentReader &content_reader) {\n-                std::string body;\n-                content_reader([&](const char *data, size_t data_length) {\n-                  EXPECT_EQ(data_length, 7);\n-                  body.append(data, data_length);\n-                  return true;\n-                });\n-                EXPECT_EQ(body, \"content\");\n-                res.set_content(body, \"text/plain\");\n+              [&](const Request & req, Response &res, const ContentReader &content_reader) {\n+                if (req.is_multipart_form_data()) {\n+                  MultipartFiles files;\n+                  content_reader(\n+                    [&](const std::string &name, const char *data, size_t data_length) {\n+                      auto &file = files.find(name)->second;\n+                      file.content.append(data, data_length);\n+                      return true;\n+                    },\n+                    [&](const std::string &name, const MultipartFile &file) {\n+                      files.emplace(name, file);\n+                      return true;\n+                    });\n+\n+                  EXPECT_EQ(5u, files.size());\n+\n+                  {\n+                    const auto &file = get_file_value(files, \"text1\");\n+                    EXPECT_EQ(\"\", file.filename);\n+                    EXPECT_EQ(\"text default\", file.content);\n+                  }\n+\n+                  {\n+                    const auto &file = get_file_value(files, \"text2\");\n+                    EXPECT_EQ(\"\", file.filename);\n+                    EXPECT_EQ(\"a\u03c9b\", file.content);\n+                  }\n+\n+                  {\n+                    const auto &file = get_file_value(files, \"file1\");\n+                    EXPECT_EQ(\"hello.txt\", file.filename);\n+                    EXPECT_EQ(\"text/plain\", file.content_type);\n+                    EXPECT_EQ(\"h\\ne\\n\\nl\\nl\\no\\n\", file.content);\n+                  }\n+\n+                  {\n+                    const auto &file = get_file_value(files, \"file3\");\n+                    EXPECT_EQ(\"\", file.filename);\n+                    EXPECT_EQ(\"application/octet-stream\", file.content_type);\n+                    EXPECT_EQ(0u, file.content.size());\n+                  }\n+                } else {\n+                  std::string body;\n+                  content_reader([&](const char *data, size_t data_length) {\n+                    EXPECT_EQ(data_length, 7);\n+                    body.append(data, data_length);\n+                    return true;\n+                  });\n+                  EXPECT_EQ(body, \"content\");\n+                  res.set_content(body, \"text/plain\");\n+                }\n               })\n         .Put(\"/content_receiver\",\n              [&](const Request & /*req*/, Response &res,\n@@ -809,14 +854,13 @@ class ServerTest : public ::testing::Test {\n                 {\n                   const auto &file = req.get_file_value(\"key1\");\n                   EXPECT_EQ(\"\", file.filename);\n-                  EXPECT_EQ(\"test\", req.body.substr(file.offset, file.length));\n+                  EXPECT_EQ(\"test\", file.content);\n                 }\n \n                 {\n                   const auto &file = req.get_file_value(\"key2\");\n                   EXPECT_EQ(\"\", file.filename);\n-                  EXPECT_EQ(\"--abcdefg123\",\n-                            req.body.substr(file.offset, file.length));\n+                  EXPECT_EQ(\"--abcdefg123\", file.content);\n                 }\n               })\n #endif\n@@ -1518,6 +1562,21 @@ TEST_F(ServerTest, PostContentReceiver) {\n   ASSERT_EQ(\"content\", res->body);\n }\n \n+TEST_F(ServerTest, PostMulitpartFilsContentReceiver) {\n+  MultipartFormDataItems items = {\n+      {\"text1\", \"text default\", \"\", \"\"},\n+      {\"text2\", \"a\u03c9b\", \"\", \"\"},\n+      {\"file1\", \"h\\ne\\n\\nl\\nl\\no\\n\", \"hello.txt\", \"text/plain\"},\n+      {\"file2\", \"{\\n  \\\"world\\\", true\\n}\\n\", \"world.json\", \"application/json\"},\n+      {\"file3\", \"\", \"\", \"application/octet-stream\"},\n+  };\n+\n+  auto res = cli_.Post(\"/content_receiver\", items);\n+\n+  ASSERT_TRUE(res != nullptr);\n+  EXPECT_EQ(200, res->status);\n+}\n+\n TEST_F(ServerTest, PostContentReceiverGzip) {\n   auto res = cli_.Post(\"/content_receiver\", \"content\", \"text/plain\", true);\n   ASSERT_TRUE(res != nullptr);\n", "problem_statement": "streaming post requests in http server\nHi\r\n\r\nI'd like the server to handle huge post requests like big file uploads.\r\nI'm looking at the source, and it seems that in process_request, read_content reads the whole request body and loads it into a string, before calling the request handler.\r\n\r\nIt would have been nice if the handler could register a content receiver. \r\n\r\nI made a pull request where you can register a streamHandler, the handler receives an additionnal argument which is the stream, and it is called before the request body is read.\r\nIt is the handler that reads the request body.\r\nThe simpleSvr example is updated with a stream handler.\r\n\r\nThanks\n", "hints_text": "referenced PR: #242 \n@sophana, thank you for bringing up this thing. I'll try to implement it when I have time. \nOk thanks. \r\nI also have the same problem on the client side post.\r\nI also need to upload very large files with on the fly gzipping to the server.\r\nCurl doesn't perform gzipping. I can pipe the file through gzip to curl, but unfortunately, it seems that curl must store the whole file before sending it on the network, probably because it must compute the size before sending it.\r\n\r\nThe client doesn't accept a content provider for Post request.\r\n\r\nI also corrected a small bug in the decompressor which doesn't work with large splitted (multiple socket read) body. The inflate return value is 0 when the decompression is not over, then it goes to 1 (STREAM_END) for the last packet. So Decompressor::decompress should return true at the end.\r\n\r\nI tested with a server that computes md5 of posted files, and tested hundred of megabytes files uploads with curl (gzipped and not)\n@sophana, thanks for the reply. Could you make a pull request about your fix for the decompressor bug, since it's a separate issue?\r\n\r\n> I also corrected a small bug in the decompressor which doesn't work with large splitted (multiple socket read) body. The inflate return value is 0 when the decompression is not over, then it goes to 1 (STREAM_END) for the last packet. So Decompressor::decompress should return true at the end.\r\n> \r\n> I tested with a server that computes md5 of posted files, and tested hundred of megabytes files uploads with curl (gzipped and not)\n> The client doesn't accept a content provider for Post request.\r\n\r\nAdded in 5f32c424c2d819a74bf00851b1fb5e1b28a88e57\nYes, I implemented the feature to accept a content provider for Post/Put/Patch requests.\r\nWhen it comes to content receiver on server handler, it's a bit more difficult to implement it properly. But I'll get back to you when it completes. Thanks for your patience!\nI independently found and fixed the same issue as @sophana:-\r\n\r\n> I also corrected a small bug in the decompressor which doesn't work with large splitted (multiple socket read) body. The inflate return value is 0 when the decompression is not over, then it goes to 1 (STREAM_END) for the last packet. So Decompressor::decompress should return true at the end.\r\n\r\nIt's a bit of a showstopper for anyone implementing receipt of large compressed post data and took a bit of finding...\n@DaveBlakeman (also @sophana), could you make a pull request for the decompress problem, or show me the code snippet? I'll gladly merge it to the master, so that anyone could benefit from the fix. Thanks!\nPlease have a look at this commit in httplib:\r\nhttps://github.com/sophana/cpp-httplib/commit/0423358b662076e8b1fa70ae7a63c59afd2727de\r\n\r\nPlease note that it could check 2 possible return values: I think they are Z_STREAM_END or Z_STREAM_OK\r\nBut there are enough error checks just before, I think.\n@sophana and @DaveBlakeman, since the decompressor problem is a different issue, I opened a separate issue #273. Please respond there regarding this matter. Thanks!", "created_at": "2019-12-02T03:06:01Z", "version": "0.2"}
