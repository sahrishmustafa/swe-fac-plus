{"repo": "gabime/spdlog", "pull_number": 3398, "instance_id": "gabime__spdlog-3398", "issue_numbers": ["3391"], "base_commit": "7e022c430053f71c3db80bf0eb3432392932f7e3", "patch": "diff --git a/include/spdlog/details/registry-inl.h b/include/spdlog/details/registry-inl.h\n--- a/include/spdlog/details/registry-inl.h\n+++ b/include/spdlog/details/registry-inl.h\n@@ -54,6 +54,11 @@ SPDLOG_INLINE void registry::register_logger(std::shared_ptr<logger> new_logger)\n     register_logger_(std::move(new_logger));\n }\n \n+SPDLOG_INLINE void registry::register_or_replace(std::shared_ptr<logger> new_logger) {\n+    std::lock_guard<std::mutex> lock(logger_map_mutex_);\n+    register_or_replace_(std::move(new_logger));\n+}\n+\n SPDLOG_INLINE void registry::initialize_logger(std::shared_ptr<logger> new_logger) {\n     std::lock_guard<std::mutex> lock(logger_map_mutex_);\n     new_logger->set_formatter(formatter_->clone());\n@@ -252,10 +257,14 @@ SPDLOG_INLINE void registry::throw_if_exists_(const std::string &logger_name) {\n }\n \n SPDLOG_INLINE void registry::register_logger_(std::shared_ptr<logger> new_logger) {\n-    auto logger_name = new_logger->name();\n+    auto &logger_name = new_logger->name();\n     throw_if_exists_(logger_name);\n     loggers_[logger_name] = std::move(new_logger);\n }\n \n+SPDLOG_INLINE void registry::register_or_replace_(std::shared_ptr<logger> new_logger) {\n+    loggers_[new_logger->name()] = std::move(new_logger);\n+}\n+\n }  // namespace details\n }  // namespace spdlog\ndiff --git a/include/spdlog/details/registry.h b/include/spdlog/details/registry.h\n--- a/include/spdlog/details/registry.h\n+++ b/include/spdlog/details/registry.h\n@@ -31,6 +31,7 @@ class SPDLOG_API registry {\n     registry &operator=(const registry &) = delete;\n \n     void register_logger(std::shared_ptr<logger> new_logger);\n+    void register_or_replace(std::shared_ptr<logger> new_logger);\n     void initialize_logger(std::shared_ptr<logger> new_logger);\n     std::shared_ptr<logger> get(const std::string &logger_name);\n     std::shared_ptr<logger> default_logger();\n@@ -105,6 +106,7 @@ class SPDLOG_API registry {\n \n     void throw_if_exists_(const std::string &logger_name);\n     void register_logger_(std::shared_ptr<logger> new_logger);\n+    void register_or_replace_(std::shared_ptr<logger> new_logger);\n     bool set_level_from_cfg_(logger *logger);\n     std::mutex logger_map_mutex_, flusher_mutex_;\n     std::recursive_mutex tp_mutex_;\ndiff --git a/include/spdlog/spdlog-inl.h b/include/spdlog/spdlog-inl.h\n--- a/include/spdlog/spdlog-inl.h\n+++ b/include/spdlog/spdlog-inl.h\n@@ -59,6 +59,10 @@ SPDLOG_INLINE void register_logger(std::shared_ptr<logger> logger) {\n     details::registry::instance().register_logger(std::move(logger));\n }\n \n+SPDLOG_INLINE void register_or_replace(std::shared_ptr<logger> logger) {\n+    details::registry::instance().register_or_replace(std::move(logger));\n+}\n+\n SPDLOG_INLINE void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun) {\n     details::registry::instance().apply_all(fun);\n }\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -25,7 +25,7 @@ namespace spdlog {\n using default_factory = synchronous_factory;\n \n // Create and register a logger with a templated sink type\n-// The logger's level, formatter and flush level will be set according the\n+// The logger's level, formatter and flush level will be set according to the\n // global settings.\n //\n // Example:\n@@ -46,7 +46,7 @@ inline std::shared_ptr<spdlog::logger> create(std::string logger_name, SinkArgs\n //   spdlog::initialize_logger(mylogger);\n SPDLOG_API void initialize_logger(std::shared_ptr<logger> logger);\n \n-// Return an existing logger or nullptr if a logger with such name doesn't\n+// Return an existing logger or nullptr if a logger with such a name doesn't\n // exist.\n // example: spdlog::get(\"my_logger\")->info(\"hello {}\", \"world\");\n SPDLOG_API std::shared_ptr<logger> get(const std::string &name);\n@@ -71,13 +71,13 @@ SPDLOG_API void dump_backtrace();\n // Get global logging level\n SPDLOG_API level::level_enum get_level();\n \n-// Set global logging level\n+// Set the global logging level\n SPDLOG_API void set_level(level::level_enum log_level);\n \n // Determine whether the default logger should log messages with a certain level\n SPDLOG_API bool should_log(level::level_enum lvl);\n \n-// Set global flush level\n+// Set a global flush level\n SPDLOG_API void flush_on(level::level_enum log_level);\n \n // Start/Restart a periodic flusher thread\n@@ -91,9 +91,14 @@ inline void flush_every(std::chrono::duration<Rep, Period> interval) {\n SPDLOG_API void set_error_handler(void (*handler)(const std::string &msg));\n \n // Register the given logger with the given name\n+// Will throw if a logger with the same name already exists.\n SPDLOG_API void register_logger(std::shared_ptr<logger> logger);\n \n-// Apply a user defined function on all registered loggers\n+// Register the given logger with the given name\n+// Will replace any the existing logger with the same name if exists.\n+SPDLOG_API void register_or_replace(std::shared_ptr<logger> logger);\n+\n+// Apply a user-defined function on all registered loggers\n // Example:\n // spdlog::apply_all([&](std::shared_ptr<spdlog::logger> l) {l->flush();});\n SPDLOG_API void apply_all(const std::function<void(std::shared_ptr<logger>)> &fun);\n@@ -111,19 +116,19 @@ SPDLOG_API void shutdown();\n SPDLOG_API void set_automatic_registration(bool automatic_registration);\n \n // API for using default logger (stdout_color_mt),\n-// e.g: spdlog::info(\"Message {}\", 1);\n+// e.g.: spdlog::info(\"Message {}\", 1);\n //\n // The default logger object can be accessed using the spdlog::default_logger():\n // For example, to add another sink to it:\n // spdlog::default_logger()->sinks().push_back(some_sink);\n //\n-// The default logger can replaced using spdlog::set_default_logger(new_logger).\n+// The default logger can be replaced using spdlog::set_default_logger(new_logger).\n // For example, to replace it with a file logger.\n //\n // IMPORTANT:\n // The default API is thread safe (for _mt loggers), but:\n // set_default_logger() *should not* be used concurrently with the default API.\n-// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.\n+// e.g., do not call set_default_logger() from one thread while calling spdlog::info() from another.\n \n SPDLOG_API std::shared_ptr<spdlog::logger> default_logger();\n \n", "test_patch": "diff --git a/tests/test_registry.cpp b/tests/test_registry.cpp\n--- a/tests/test_registry.cpp\n+++ b/tests/test_registry.cpp\n@@ -25,6 +25,18 @@ TEST_CASE(\"explicit register\", \"[registry]\") {\n }\n #endif\n \n+TEST_CASE(\"register_or_replace\", \"[registry]\") {\n+    spdlog::drop_all();\n+    auto logger1 = std::make_shared<spdlog::logger>(tested_logger_name,\n+                                                   std::make_shared<spdlog::sinks::null_sink_st>());\n+    spdlog::register_logger(logger1);\n+    REQUIRE(spdlog::get(tested_logger_name) == logger1);\n+\n+    auto logger2 = std::make_shared<spdlog::logger>(tested_logger_name, std::make_shared<spdlog::sinks::null_sink_st>());\n+    spdlog::register_or_replace(logger2);\n+    REQUIRE(spdlog::get(tested_logger_name) == logger2);\n+}\n+\n TEST_CASE(\"apply_all\", \"[registry]\") {\n     spdlog::drop_all();\n     auto logger = std::make_shared<spdlog::logger>(tested_logger_name,\n", "problem_statement": "How can I safely replace a registered logger?\nThis issue is related to #820 and #3014.\n\nI have an already initialized and registered logger that may already be in use in several threads. The logger is retrieved by calling `spdlog::get(\"mylibraryname\")`. I wish to overwrite the sink list with a different set of sinks. As noted in https://github.com/gabime/spdlog/issues/820#issuecomment-418174191, this operation is not thread safe, so my library would have to implement a global spdlog mutex on top of spdlog's own mutexes, which is highly impractical.\n\nA safer option is to create a new logger, fill it with the desired sinks, unregister the old one and register the new logger under the same name. Any functions (possibly running in different threads while the logger exchange is taking place) which still have a `std::shared_ptr<spdlog::logger>` reference to the old logger will still use it after the new logger is registered. I believe that this is unavoidable and safe behavior.\n\nThe old logger will eventually be destructed once the functions in different threads which hold a reference to it return (unless they store the shared pointer somewhere; spdlog's documentation recommends storing such references as private members of classes; this can be highly problematic in this scenario, but it is easier to fix than to mutex everything spdlog related manually).\n\nThe problem is that spdlog (to my knowledge) provides no \"overwrite register\" function. Functions can only be registered and unregistered, not assigned into. This can lead to the following problem:\n\n```cpp\nstd::shared_ptr<spdlog::logger> new_logger = ...;\nspdlog::drop(\"mylibraryname\");\n// Here a second thread calls spdlog::get(\"mylibraryname\"), which fails\nspdlog::register_logger(std::move(new_logger));\n```\n\n**Desired solution:**\nAdd a function to the `spdlog` namespace implementing this functionality and document the issues with replacing sinks/loggers somewhere.\n", "hints_text": "Right, PR is welcome\nFYI.\nI believe that the request to replace the logger means that you want to replace sinks in most cases.\nIf so, `spdlog::sinks::dist_sink::set_sink(std::vector<std::shared_ptr<sink>>)` should be able to accomplish that.\n\nhttps://github.com/gabime/spdlog/blob/847db3375f35dca23e45f9daf7ad3c7b19027f8b/include/spdlog/sinks/dist_sink.h#L42-L45\n\n```cpp\nauto sinks = ...\nauto dist_sink = std::make_shared<spdlog::sinks::dist_sink_mt>(sinks);\nauto logger = std::make_shared<spdlog::logger>(\"dist_logger\", dist_sink);\nspdlog::register_logger(logger);\n\n// Replace sinks;\nauto new_sinks = ...\ndist_sink->set_sink(new_sinks);\n```\n@tt4g You are right, this seems to be the best solution. Adding one level of indirection (having logger -> dist_sink -> sinks... instead of logger -> sinks...) should solve this problem. It also doesn't suffer from the primary drawback of my approach, the old logger still lingering.\n\n`spdlog::sinks::dist_sink::add_sink()`, `spdlog::sinks::dist_sink::remove_sink()` and `spdlog::sinks::dist_sink::set_sinks()` seem to be thread safe, they use the base_sink's mutex.\n\nEven though my specific issue is solved, being able to overwrite/swap a registered logger may still prove to be useful to someone.\n\n> I believe that the request to replace the logger means that you want to replace sinks in most cases.\n\nIf that is indeed the case, providing a function to replace a registered logger may not be necessary, the solution you have provided covers that.\nRight, though I still think having a way to atomically change a logger in registry is an easier solution. \n\nWhy was this issue closed?\nBecause there is a solution using the dist sink. ", "created_at": "2025-05-08T12:34:24Z", "version": "1.15"}
{"repo": "gabime/spdlog", "pull_number": 3235, "instance_id": "gabime__spdlog-3235", "issue_numbers": ["3221"], "base_commit": "b6da59447f165ad70a4e3ca1c575b14ea66d92c9", "patch": "diff --git a/include/spdlog/async_logger-inl.h b/include/spdlog/async_logger-inl.h\n--- a/include/spdlog/async_logger-inl.h\n+++ b/include/spdlog/async_logger-inl.h\n@@ -32,30 +32,26 @@ SPDLOG_INLINE spdlog::async_logger::async_logger(std::string logger_name,\n \n // send the log message to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::sink_it_(const details::log_msg &msg){\n-    SPDLOG_TRY {\n-        if (auto pool_ptr = thread_pool_.lock()){\n-            pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n-        }\n-        else {\n-            throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n-        }\n-    }\n-    SPDLOG_LOGGER_CATCH(msg.source)\n+    SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n+        pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n+}\n+else {\n+    throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n+}\n+}\n+SPDLOG_LOGGER_CATCH(msg.source)\n }\n \n // send flush request to the thread pool\n-SPDLOG_INLINE void spdlog::async_logger::flush_() {\n-    SPDLOG_TRY {\n-        auto pool_ptr = thread_pool_.lock();\n-        if (!pool_ptr) {\n-            throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n-        }\n-\n-        // Wait for the flush operation to complete.\n-        // This might throw exception if the flush message get dropped because of overflow.\n-        pool_ptr->post_and_wait_for_flush(shared_from_this(), overflow_policy_);\n-    }\n-    SPDLOG_LOGGER_CATCH(source_loc())\n+SPDLOG_INLINE void spdlog::async_logger::flush_(){\n+    SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n+        pool_ptr->post_flush(shared_from_this(), overflow_policy_);\n+}\n+else {\n+    throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\n+}\n+}\n+SPDLOG_LOGGER_CATCH(source_loc())\n }\n \n //\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -62,25 +62,9 @@ void SPDLOG_INLINE thread_pool::post_log(async_logger_ptr &&worker_ptr,\n     post_async_msg_(std::move(async_m), overflow_policy);\n }\n \n-void SPDLOG_INLINE thread_pool::post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n-                                                        async_overflow_policy overflow_policy) {\n-    std::mutex m;\n-    std::unique_lock<std::mutex> l(m);\n-    std::condition_variable cv;\n-    std::atomic<async_msg_flush> cv_flag{async_msg_flush::not_synced};\n-    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush, [&cv, &cv_flag](async_msg_flush flushed) {\n-        cv_flag.store(flushed, std::memory_order_relaxed);\n-        cv.notify_all();\n-    }), overflow_policy);\n-    while(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::not_synced) {\n-        cv.wait_for(l, std::chrono::milliseconds(100), [&cv_flag]() {\n-            return cv_flag.load(std::memory_order_relaxed) != async_msg_flush::not_synced;\n-        });\n-    }\n-\n-    if(cv_flag.load(std::memory_order_relaxed) == async_msg_flush::synced_not_flushed) {\n-        throw spdlog_ex(\"Request for flushing got dropped.\");\n-    }\n+void SPDLOG_INLINE thread_pool::post_flush(async_logger_ptr &&worker_ptr,\n+                                           async_overflow_policy overflow_policy) {\n+    post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush), overflow_policy);\n }\n \n size_t SPDLOG_INLINE thread_pool::overrun_counter() { return q_.overrun_counter(); }\n@@ -124,10 +108,6 @@ bool SPDLOG_INLINE thread_pool::process_next_msg_() {\n         }\n         case async_msg_type::flush: {\n             incoming_async_msg.worker_ptr->backend_flush_();\n-            if(incoming_async_msg.flush_callback) {\n-                incoming_async_msg.flush_callback(async_msg_flush::synced_flushed);\n-                incoming_async_msg.flush_callback = nullptr;\n-            }\n             return true;\n         }\n \ndiff --git a/include/spdlog/details/thread_pool.h b/include/spdlog/details/thread_pool.h\n--- a/include/spdlog/details/thread_pool.h\n+++ b/include/spdlog/details/thread_pool.h\n@@ -22,60 +22,46 @@ using async_logger_ptr = std::shared_ptr<spdlog::async_logger>;\n \n enum class async_msg_type { log, flush, terminate };\n \n-enum class async_msg_flush { not_synced, synced_flushed, synced_not_flushed };\n-\n // Async msg to move to/from the queue\n // Movable only. should never be copied\n struct async_msg : log_msg_buffer {\n     async_msg_type msg_type{async_msg_type::log};\n     async_logger_ptr worker_ptr;\n-    std::function<void(async_msg_flush)> flush_callback;\n \n     async_msg() = default;\n-    ~async_msg() {\n-        if (flush_callback) {\n-            flush_callback(async_msg_flush::synced_not_flushed);\n-            flush_callback = nullptr;\n-        }\n-    }\n+    ~async_msg() = default;\n \n     // should only be moved in or out of the queue..\n     async_msg(const async_msg &) = delete;\n \n-    async_msg(async_msg &&other) SPDLOG_NOEXCEPT\n+// support for vs2013 move\n+#if defined(_MSC_VER) && _MSC_VER <= 1800\n+    async_msg(async_msg &&other)\n         : log_msg_buffer(std::move(other)),\n           msg_type(other.msg_type),\n-          worker_ptr(std::move(other.worker_ptr)),\n-          flush_callback(std::move(other.flush_callback)) {\n-        other.flush_callback = nullptr;\n-    }\n+          worker_ptr(std::move(other.worker_ptr)) {}\n \n-    async_msg &operator=(async_msg &&other) SPDLOG_NOEXCEPT {\n-        *static_cast<log_msg_buffer *>(this) = static_cast<log_msg_buffer&&>(other);\n+    async_msg &operator=(async_msg &&other) {\n+        *static_cast<log_msg_buffer *>(this) = std::move(other);\n         msg_type = other.msg_type;\n         worker_ptr = std::move(other.worker_ptr);\n-        std::swap(flush_callback, other.flush_callback);\n         return *this;\n     }\n+#else  // (_MSC_VER) && _MSC_VER <= 1800\n+    async_msg(async_msg &&) = default;\n+    async_msg &operator=(async_msg &&) = default;\n+#endif\n \n     // construct from log_msg with given type\n     async_msg(async_logger_ptr &&worker, async_msg_type the_type, const details::log_msg &m)\n         : log_msg_buffer{m},\n           msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{} {}\n+          worker_ptr{std::move(worker)} {}\n \n     async_msg(async_logger_ptr &&worker, async_msg_type the_type)\n         : log_msg_buffer{},\n           msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{} {}\n-\n-    async_msg(async_logger_ptr &&worker, async_msg_type the_type, std::function<void(async_msg_flush)> &&callback)\n-        : log_msg_buffer{},\n-          msg_type{the_type},\n-          worker_ptr{std::move(worker)},\n-          flush_callback{std::move(callback)} {}\n+          worker_ptr{std::move(worker)} {}\n \n     explicit async_msg(async_msg_type the_type)\n         : async_msg{nullptr, the_type} {}\n@@ -102,8 +88,7 @@ class SPDLOG_API thread_pool {\n     void post_log(async_logger_ptr &&worker_ptr,\n                   const details::log_msg &msg,\n                   async_overflow_policy overflow_policy);\n-    void post_and_wait_for_flush(async_logger_ptr &&worker_ptr,\n-                                 async_overflow_policy overflow_policy);\n+    void post_flush(async_logger_ptr &&worker_ptr, async_overflow_policy overflow_policy);\n     size_t overrun_counter();\n     void reset_overrun_counter();\n     size_t discard_counter();\n", "test_patch": "diff --git a/tests/test_async.cpp b/tests/test_async.cpp\n--- a/tests/test_async.cpp\n+++ b/tests/test_async.cpp\n@@ -93,50 +93,6 @@ TEST_CASE(\"flush\", \"[async]\") {\n     REQUIRE(test_sink->flush_counter() == 1);\n }\n \n-TEST_CASE(\"multithread flush\", \"[async]\") {\n-    auto test_sink = std::make_shared<spdlog::sinks::test_sink_mt>();\n-    size_t queue_size = 2;\n-    size_t messages = 10;\n-    size_t n_threads = 10;\n-    size_t flush_count = 1024;\n-    std::mutex mtx;\n-    std::vector<std::string> errmsgs;\n-    {\n-        auto tp = std::make_shared<spdlog::details::thread_pool>(queue_size, 1);\n-        auto logger = std::make_shared<spdlog::async_logger>(\n-            \"as\", test_sink, tp, spdlog::async_overflow_policy::discard_new);\n-\n-        logger->set_error_handler([&](const std::string &) {\n-            std::unique_lock<std::mutex> lock(mtx);\n-            errmsgs.push_back(\"Broken promise\");\n-        });\n-\n-        for (size_t i = 0; i < messages; i++) {\n-            logger->info(\"Hello message #{}\", i);\n-        }\n-\n-        std::vector<std::thread> threads;\n-        for (size_t i = 0; i < n_threads; i++) {\n-            threads.emplace_back([logger, flush_count] {\n-                for (size_t j = 0; j < flush_count; j++) {\n-                    // flush does not throw exception even if failed.\n-                    // Instead, the error handler is invoked.\n-                    logger->flush();\n-                }\n-            });\n-        }\n-\n-        for (auto &t : threads) {\n-            t.join();\n-        }\n-    }\n-    REQUIRE(test_sink->flush_counter() >= 1);\n-    REQUIRE(test_sink->flush_counter() + errmsgs.size() == n_threads * flush_count);\n-    if (errmsgs.size() > 0) {\n-        REQUIRE(errmsgs[0] == \"Broken promise\");\n-    }\n-}\n-\n TEST_CASE(\"async periodic flush\", \"[async]\") {\n     auto logger = spdlog::create_async<spdlog::sinks::test_sink_mt>(\"as\");\n     auto test_sink = std::static_pointer_cast<spdlog::sinks::test_sink_mt>(logger->sinks()[0]);\n", "problem_statement": "1.14.1 unresolvable R_X86_64_TPOFF32 relocation \nUpdating spdlog to 1.14.1, I get the following linker error:\r\n```\r\n/usr/bin/c++ -Wno-maybe-uninitialized  -ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries test/CMakeFiles/EtcdTests.dir/EtcdTests.cpp.o -o /opt/ichor/src/bin/EtcdTests  /opt/ichor/src/bin/libichor.a  /opt/ichor/src/bin/libCatch2Main.a  -lsystemd  /usr/lib/libboost_coroutine.a  /usr/lib/libboost_fiber.a  /usr/lib/libboost_context.a  /usr/lib/libboost_filesystem.a  /usr/lib/libssl.a  /usr/lib/libcrypto.a  -ldl  -lhiredis  -ldl  -lrt  /opt/ichor/src/bin/libCatch2.a && :\r\n/usr/bin/ld: /opt/ichor/src/bin/libichor.a(async.cpp.o)(.text+0x266e): unresolvable R_X86_64_TPOFF32 relocation against symbol `_ZSt15__once_callable@@GLIBCXX_3.4.11'\r\n```\r\n\r\nThis doesn't happen with 1.13.0, or when `ftls-model=local-exec` is removed from the compiler flags.\r\n\r\nCompiler: gcc 12.3.0\r\nLinux: Ubuntu Jammy\r\ncxxflags: `-O2 -std=c++20 -fpie -fstack-protector-strong -fcf-protection -fstack-clash-protection -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=3 -D_GLIBCXX_ASSERTIONS -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_FAST -ftls-model=local-exec`\r\nlinkflags: `-ggdb -O3 -DNDEBUG -pie -Wl,-z,nodlopen -Wl,-z,noexecstack -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -Wl,--no-copy-dt-needed-entries`\n", "hints_text": "It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\nMaybe duplicate #1405\n> It doesn't look like the spdlog symbol, maybe you should ask the question in the GCC or Ubuntu community.\r\n\r\nonce_callable is likely a thread_local related symbol, which glibc uses. The error shows that this happens in [async.cpp](https://github.com/gabime/spdlog/blob/v1.x/src/async.cpp), which includes a bunch of spdlog related files. \r\n\r\n\r\n\r\n> Maybe duplicate #1405\r\n\r\n`-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\n> `-fPIC` didn't change anything, which is because I'm not creating or linking into a shared library. Instead, I'm making a PIE executable with the PIE static library. Regardless, I'll bisect it later.\r\n\r\nAs far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\n> As far as I know, the `-fPIC` option causes relocation problems when using the static library: [c++ - \"relocation R_X86_64_32S against \" linking Error - Stack Overflow](https://stackoverflow.com/questions/19768267/relocation-r-x86-64-32s-against-linking-error)\r\n\r\nYour linked stackoverflow is saying the same thing as I am. As long as the end result is a dynamic library (either directly, or by first creating a static library which is then linked into a dynamic library), `-fPIC` is useful. This can also be gleaned from the [gcc manual](https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html): \r\n\r\n> Generate position-independent code (PIC) suitable for use in a shared library ...\r\n\r\nHowever, I am not creating a shared library anywhere in my workflow. I make a static library and link it directly into an executable. Therefore, I use `-fpie` (since my GOT tables aren't too big to need to use `-fPIE`) and `-fPIC` has no effect on the problem at hand. I know, because I've added it to the compiler flags and it resulted in the same error I mentioned above.\r\n\r\nI have bisected the problem to [6725584e27ca93f50527165696d7cf34e3978373](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373). And specifically, the call to `set_value()` in [thread_pool-inl.h:115](https://github.com/gabime/spdlog/commit/6725584e27ca93f50527165696d7cf34e3978373#diff-6c9b5dd2454f632886023e6bc86e7b04fe7d0f1be5c25d505679987a7da7b05dR115). \r\n\r\n`promise<>::set_value()` ends up calling [std::call_once](https://github.com/gcc-mirror/gcc/blob/8fc1a49c9312b05d925b7d21f1d2145d70818151/libstdc%2B%2B-v3/include/std/future#L426), which requires thread local storage and GCC requires the glibcxx once_callable symbol (which is probably some pthread_once alias). `ftls-model=local-exec` disables the usage of `thread_local` storage which has not been defined inside the executable itself. And the `once_callable` symbol resides in `libc.so.6`. \r\n\r\nOn top of that, unfortunately, gcc has had a [pretty bad bug](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66146) with `std::call_once` and exceptions since gcc 5.x, making it impossible to support handling exceptions during a `std::call_once` call on musl and other non-glibc, non-x86 targets. Not the case here, but certainly something to consider.\r\n\r\nThe options I see are as follows:\r\n* Change compiler flags to `ftls-model=initial-exec`, losing some performance whenever I access `thread_local` variables\r\n* Refactor the `std::promise`/`std::future` to a `std::function` of sorts.\r\n* Patch out the specific commit in my own fork\nThanks for the accurate investigation.\r\nI had never heard of the `std::call_once` bug in GCC.\r\nIt would be helpful if you could send the PR.\nSure, I'll take a stab when I have some free time. It would likely be a backwards incompatible change though. Or should I put in a `#ifdef` to control the function signature?\nPersonally, I think it is a bug and should be fixed even if it is not compatible.\r\nHowever, I am not this repository maintainer, so the final decision is up to @gabime.", "created_at": "2024-11-01T09:13:47Z", "version": "1.14"}
{"repo": "gabime/spdlog", "pull_number": 3244, "instance_id": "gabime__spdlog-3244", "issue_numbers": ["3241"], "base_commit": "63f0875000bf90867aa7c76a831bd834cb7d4b5e", "patch": "diff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -483,12 +483,12 @@ SPDLOG_INLINE void utf8_to_wstrbuf(string_view_t str, wmemory_buf_t &target) {\n \n     // find the size to allocate for the result buffer\n     int result_size =\n-        ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size, NULL, 0);\n+        ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, NULL, 0);\n \n     if (result_size > 0) {\n         target.resize(result_size);\n-        result_size = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size,\n-                                            target.data(), result_size);\n+        result_size = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, target.data(),\n+                                            result_size);\n         if (result_size > 0) {\n             assert(result_size == target.size());\n             return;\n", "test_patch": "diff --git a/tests/includes.h b/tests/includes.h\n--- a/tests/includes.h\n+++ b/tests/includes.h\n@@ -26,6 +26,7 @@\n #include \"spdlog/spdlog.h\"\n #include \"spdlog/async.h\"\n #include \"spdlog/details/fmt_helper.h\"\n+#include \"spdlog/details/os.h\"\n \n #ifndef SPDLOG_NO_TLS\n     #include \"spdlog/mdc.h\"\ndiff --git a/tests/test_misc.cpp b/tests/test_misc.cpp\n--- a/tests/test_misc.cpp\n+++ b/tests/test_misc.cpp\n@@ -167,3 +167,21 @@ TEST_CASE(\"default logger API\", \"[default logger]\") {\n     spdlog::drop_all();\n     spdlog::set_pattern(\"%v\");\n }\n+\n+#if (defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT) || defined(SPDLOG_WCHAR_FILENAMES)) && defined(_WIN32)\n+TEST_CASE(\"utf8 to utf16 conversion using windows api\", \"[windows utf]\") {\n+    spdlog::wmemory_buf_t buffer;\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"\", buffer);\n+    REQUIRE(buffer.data() == std::wstring(L\"\"));\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"abc\", buffer);\n+    REQUIRE(buffer.data() == std::wstring(L\"abc\"));\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xc3\\x28\", buffer); // Invalid UTF-8 sequence.\n+    REQUIRE(buffer.data() == std::wstring(L\"\\xfffd(\"));\n+\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xe3\\x81\\xad\\xe3\\x81\\x93\", buffer); // \"Neko\" in hiragana.\n+    REQUIRE(buffer.data() == std::wstring(L\"\\x306d\\x3053\"));\n+}\n+#endif\n", "problem_statement": "msvc_sink throws on invalid utf-8\nThis is what `msvc_sink` is doing:\r\n```cpp\r\n    #if defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)\r\n        wmemory_buf_t wformatted;\r\n        details::os::utf8_to_wstrbuf(string_view_t(formatted.data(), formatted.size()), wformatted);\r\n        OutputDebugStringW(wformatted.data());\r\n    #else\r\n        OutputDebugStringA(formatted.data());\r\n    #endif\r\n```\r\n\r\nThen in `utf8_to_wstrbuf` we have:\r\n```cpp\r\n    int result_size =\r\n        ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str.data(), str_size, NULL, 0);\r\n```\r\n\r\n`MB_ERR_INVALID_CHARS` causes the function to fail on invalid characters, and then `utf8_to_wstrbuf` throws.\r\n\r\nWe've run into this when trying to output game data that wasn't utf-8 encoded, had to roll out our own implementation of `msvc_sink` (https://github.com/OpenEnroth/OpenEnroth/pull/1825).\r\n\r\nMy feel here is that logging should work at best effort basis and should not throw unless absolutely necessary (as exception can lead to `std::terminate`). Log calls can be buried somewhere deep in error handling code, and the usual expectation there is that logging calls don't throw.\r\n\r\nIn this particular case writing out text that's a bit garbled is perfectly OK.\n", "hints_text": "Loggers never throw. The sinks might throw but loggers catch everything, so I am not sure what is the problem\n\nAh OK. Then please disregard my comments on safety.\r\n\r\nWhat do you think about just logging the text that's a bit garbled in this case instead of throwing?\nI don't think it's a good idea. Might lead to undefined behavior. \nThere is no UB involved, `MultiByteToWideChar` w/o `MB_ERR_INVALID_CHARS` will just replace invalid code points with `U+FFFD` (\ufffd), or drop them if we're talking older Windows versions.\r\n\r\nThe change is safe, the only concern there is about the difference in behavior. The options are:\r\n1. Throw, potentially causing other loggers in the enclosing `dist_sink` not to run, and write an error to `stderr`.\r\n2. Write out text with \ufffds to msvc debug console.\r\n\r\nMy opinion is that the latter option is strictly better. What am I missing?\nI agree. PR is welcome. Could you also add a simple test for this ?\nSure, will do a PR with a test. Thanks!", "created_at": "2024-11-05T20:10:10Z", "version": "1.14"}
{"repo": "gabime/spdlog", "pull_number": 3397, "instance_id": "gabime__spdlog-3397", "issue_numbers": ["3379", "3379"], "base_commit": "548b264254b7cbbf68f9003315ea958edacb91e5", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -18,39 +18,38 @@ include(GNUInstallDirs)\n # ---------------------------------------------------------------------------------------\n # Set default build to release\n # ---------------------------------------------------------------------------------------\n-if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n+if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n     set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING \"Choose Release or Debug\" FORCE)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Compiler config\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_USE_STD_FORMAT)\n+if(SPDLOG_USE_STD_FORMAT)\n     set(CMAKE_CXX_STANDARD 20)\n     set(CMAKE_CXX_STANDARD_REQUIRED ON)\n-elseif (NOT CMAKE_CXX_STANDARD)\n+elseif(NOT CMAKE_CXX_STANDARD)\n     set(CMAKE_CXX_STANDARD 11)\n     set(CMAKE_CXX_STANDARD_REQUIRED ON)\n-endif ()\n-\n+endif()\n \n set(CMAKE_CXX_EXTENSIONS OFF)\n \n-if (CMAKE_SYSTEM_NAME MATCHES \"CYGWIN\" OR CMAKE_SYSTEM_NAME MATCHES \"MSYS\" OR CMAKE_SYSTEM_NAME MATCHES \"MINGW\")\n+if(CMAKE_SYSTEM_NAME MATCHES \"CYGWIN\" OR CMAKE_SYSTEM_NAME MATCHES \"MSYS\" OR CMAKE_SYSTEM_NAME MATCHES \"MINGW\")\n     set(CMAKE_CXX_EXTENSIONS ON)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Set SPDLOG_MASTER_PROJECT to ON if we are building spdlog\n # ---------------------------------------------------------------------------------------\n # Check if spdlog is being used directly or via add_subdirectory, but allow overriding\n-if (NOT DEFINED SPDLOG_MASTER_PROJECT)\n-    if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n+if(NOT DEFINED SPDLOG_MASTER_PROJECT)\n+    if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n         set(SPDLOG_MASTER_PROJECT ON)\n-    else ()\n+    else()\n         set(SPDLOG_MASTER_PROJECT OFF)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n \n option(SPDLOG_BUILD_ALL \"Build all artifacts\" OFF)\n \n@@ -77,9 +76,9 @@ option(SPDLOG_BUILD_BENCH \"Build benchmarks (Requires https://github.com/google/\n # sanitizer options\n option(SPDLOG_SANITIZE_ADDRESS \"Enable address sanitizer in tests\" OFF)\n option(SPDLOG_SANITIZE_THREAD \"Enable thread sanitizer in tests\" OFF)\n-if (SPDLOG_SANITIZE_ADDRESS AND SPDLOG_SANITIZE_THREAD)\n+if(SPDLOG_SANITIZE_ADDRESS AND SPDLOG_SANITIZE_THREAD)\n     message(FATAL_ERROR \"SPDLOG_SANITIZE_ADDRESS and SPDLOG_SANITIZE_THREAD are mutually exclusive\")\n-endif ()\n+endif()\n \n # warning options\n option(SPDLOG_BUILD_WARNINGS \"Enable compiler warnings\" OFF)\n@@ -92,61 +91,61 @@ option(SPDLOG_FMT_EXTERNAL \"Use external fmt library instead of bundled\" OFF)\n option(SPDLOG_FMT_EXTERNAL_HO \"Use external fmt header-only library instead of bundled\" OFF)\n option(SPDLOG_NO_EXCEPTIONS \"Compile with -fno-exceptions. Call abort() on any spdlog exceptions\" OFF)\n \n-if (SPDLOG_FMT_EXTERNAL AND SPDLOG_FMT_EXTERNAL_HO)\n+if(SPDLOG_FMT_EXTERNAL AND SPDLOG_FMT_EXTERNAL_HO)\n     message(FATAL_ERROR \"SPDLOG_FMT_EXTERNAL and SPDLOG_FMT_EXTERNAL_HO are mutually exclusive\")\n-endif ()\n+endif()\n \n-if (SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL_HO)\n+if(SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL_HO)\n     message(FATAL_ERROR \"SPDLOG_USE_STD_FORMAT and SPDLOG_FMT_EXTERNAL_HO are mutually exclusive\")\n-endif ()\n+endif()\n \n-if (SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL)\n+if(SPDLOG_USE_STD_FORMAT AND SPDLOG_FMT_EXTERNAL)\n     message(FATAL_ERROR \"SPDLOG_USE_STD_FORMAT and SPDLOG_FMT_EXTERNAL are mutually exclusive\")\n-endif ()\n+endif()\n \n # misc tweakme options\n-if (WIN32)\n+if(WIN32)\n     option(SPDLOG_WCHAR_SUPPORT \"Support wchar api\" OFF)\n     option(SPDLOG_WCHAR_FILENAMES \"Support wchar filenames\" OFF)\n     option(SPDLOG_WCHAR_CONSOLE \"Support wchar output to console\" OFF)\n-else ()\n+else()\n     set(SPDLOG_WCHAR_SUPPORT OFF CACHE BOOL \"non supported option\" FORCE)\n     set(SPDLOG_WCHAR_FILENAMES OFF CACHE BOOL \"non supported option\" FORCE)\n     set(SPDLOG_WCHAR_CONSOLE OFF CACHE BOOL \"non supported option\" FORCE)\n-endif ()\n+endif()\n \n-if (MSVC)\n+if(MSVC)\n     option(SPDLOG_MSVC_UTF8 \"Enable/disable msvc /utf-8 flag required by fmt lib\" ON)\n-endif ()\n+endif()\n \n-if (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n+if(${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n     option(SPDLOG_CLOCK_COARSE \"Use CLOCK_REALTIME_COARSE instead of the regular clock,\" OFF)\n-else ()\n+else()\n     set(SPDLOG_CLOCK_COARSE OFF CACHE BOOL \"non supported option\" FORCE)\n-endif ()\n+endif()\n \n option(SPDLOG_PREVENT_CHILD_FD \"Prevent from child processes to inherit log file descriptors\" OFF)\n option(SPDLOG_NO_THREAD_ID \"prevent spdlog from querying the thread id on each log call if thread id is not needed\" OFF)\n option(SPDLOG_NO_TLS \"prevent spdlog from using thread local storage\" OFF)\n option(\n-        SPDLOG_NO_ATOMIC_LEVELS\n-        \"prevent spdlog from using of std::atomic log levels (use only if your code never modifies log levels concurrently\"\n-        OFF)\n+    SPDLOG_NO_ATOMIC_LEVELS\n+    \"prevent spdlog from using of std::atomic log levels (use only if your code never modifies log levels concurrently\"\n+    OFF)\n option(SPDLOG_DISABLE_DEFAULT_LOGGER \"Disable default logger creation\" OFF)\n option(SPDLOG_FWRITE_UNLOCKED \"Use the unlocked variant of fwrite. Leave this on unless your libc doesn't have it\" ON)\n \n # clang-tidy\n option(SPDLOG_TIDY \"run clang-tidy\" OFF)\n \n-if (SPDLOG_TIDY)\n+if(SPDLOG_TIDY)\n     set(CMAKE_CXX_CLANG_TIDY \"clang-tidy\")\n     set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n     message(STATUS \"Enabled clang-tidy\")\n-endif ()\n+endif()\n \n-if (SPDLOG_BUILD_PIC)\n+if(SPDLOG_BUILD_PIC)\n     set(CMAKE_POSITION_INDEPENDENT_CODE ON)\n-endif ()\n+endif()\n \n find_package(Threads REQUIRED)\n message(STATUS \"Build type: \" ${CMAKE_BUILD_TYPE})\n@@ -155,56 +154,56 @@ message(STATUS \"Build type: \" ${CMAKE_BUILD_TYPE})\n # ---------------------------------------------------------------------------------------\n set(SPDLOG_SRCS src/spdlog.cpp src/stdout_sinks.cpp src/color_sinks.cpp src/file_sinks.cpp src/async.cpp src/cfg.cpp)\n \n-if (NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+if(NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n     list(APPEND SPDLOG_SRCS src/bundled_fmtlib_format.cpp)\n-endif ()\n+endif()\n \n-if (SPDLOG_BUILD_SHARED OR BUILD_SHARED_LIBS)\n-    if (WIN32)\n+if(SPDLOG_BUILD_SHARED OR BUILD_SHARED_LIBS)\n+    if(WIN32)\n         configure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/version.rc.in ${CMAKE_CURRENT_BINARY_DIR}/version.rc @ONLY)\n         list(APPEND SPDLOG_SRCS ${CMAKE_CURRENT_BINARY_DIR}/version.rc)\n-    endif ()\n+    endif()\n     add_library(spdlog SHARED ${SPDLOG_SRCS} ${SPDLOG_ALL_HEADERS})\n     target_compile_definitions(spdlog PUBLIC SPDLOG_SHARED_LIB)\n-    if (CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n+    if(CMAKE_CXX_COMPILER_ID STREQUAL \"MSVC\")\n         target_compile_options(spdlog PUBLIC $<$<AND:$<CXX_COMPILER_ID:MSVC>,$<NOT:$<COMPILE_LANGUAGE:CUDA>>>:/wd4251\n-                /wd4275>)\n-    endif ()\n-    if (NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+                                             /wd4275>)\n+    endif()\n+    if(NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n         target_compile_definitions(spdlog PRIVATE FMT_LIB_EXPORT PUBLIC FMT_SHARED)\n-    endif ()\n-else ()\n+    endif()\n+else()\n     add_library(spdlog STATIC ${SPDLOG_SRCS} ${SPDLOG_ALL_HEADERS})\n-endif ()\n+endif()\n \n add_library(spdlog::spdlog ALIAS spdlog)\n \n set(SPDLOG_INCLUDES_LEVEL \"\")\n-if (SPDLOG_SYSTEM_INCLUDES)\n+if(SPDLOG_SYSTEM_INCLUDES)\n     set(SPDLOG_INCLUDES_LEVEL \"SYSTEM\")\n-endif ()\n+endif()\n \n target_compile_definitions(spdlog PUBLIC SPDLOG_COMPILED_LIB)\n target_include_directories(spdlog ${SPDLOG_INCLUDES_LEVEL} PUBLIC \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>\"\n-        \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n+                                                                  \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n target_link_libraries(spdlog PUBLIC Threads::Threads)\n spdlog_enable_warnings(spdlog)\n \n set_target_properties(spdlog PROPERTIES VERSION ${SPDLOG_VERSION} SOVERSION\n-        ${SPDLOG_VERSION_MAJOR}.${SPDLOG_VERSION_MINOR})\n+                                                                  ${SPDLOG_VERSION_MAJOR}.${SPDLOG_VERSION_MINOR})\n set_target_properties(spdlog PROPERTIES DEBUG_POSTFIX d)\n \n-if (COMMAND target_precompile_headers AND SPDLOG_ENABLE_PCH)\n+if(COMMAND target_precompile_headers AND SPDLOG_ENABLE_PCH)\n     configure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/pch.h.in ${PROJECT_BINARY_DIR}/spdlog_pch.h @ONLY)\n     target_precompile_headers(spdlog PRIVATE ${PROJECT_BINARY_DIR}/spdlog_pch.h)\n-endif ()\n+endif()\n \n # sanitizer support\n-if (SPDLOG_SANITIZE_ADDRESS)\n+if(SPDLOG_SANITIZE_ADDRESS)\n     spdlog_enable_addr_sanitizer(spdlog)\n-elseif (SPDLOG_SANITIZE_THREAD)\n+elseif(SPDLOG_SANITIZE_THREAD)\n     spdlog_enable_thread_sanitizer(spdlog)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Header only version\n@@ -213,133 +212,134 @@ add_library(spdlog_header_only INTERFACE)\n add_library(spdlog::spdlog_header_only ALIAS spdlog_header_only)\n \n target_include_directories(\n-        spdlog_header_only ${SPDLOG_INCLUDES_LEVEL} INTERFACE \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>\"\n-        \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n+    spdlog_header_only ${SPDLOG_INCLUDES_LEVEL} INTERFACE \"$<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>\"\n+                                                          \"$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\")\n target_link_libraries(spdlog_header_only INTERFACE Threads::Threads)\n \n # ---------------------------------------------------------------------------------------\n # Use fmt package if using external fmt\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_FMT_EXTERNAL OR SPDLOG_FMT_EXTERNAL_HO)\n-    if (NOT TARGET fmt::fmt)\n+if(SPDLOG_FMT_EXTERNAL OR SPDLOG_FMT_EXTERNAL_HO)\n+    if(NOT TARGET fmt::fmt)\n         find_package(fmt CONFIG REQUIRED)\n-    endif ()\n+    endif()\n     target_compile_definitions(spdlog PUBLIC SPDLOG_FMT_EXTERNAL)\n     target_compile_definitions(spdlog_header_only INTERFACE SPDLOG_FMT_EXTERNAL)\n \n     # use external fmt-header-only\n-    if (SPDLOG_FMT_EXTERNAL_HO)\n+    if(SPDLOG_FMT_EXTERNAL_HO)\n         target_link_libraries(spdlog PUBLIC fmt::fmt-header-only)\n         target_link_libraries(spdlog_header_only INTERFACE fmt::fmt-header-only)\n-    else () # use external compile fmt\n+    else() # use external compile fmt\n         target_link_libraries(spdlog PUBLIC fmt::fmt)\n         target_link_libraries(spdlog_header_only INTERFACE fmt::fmt)\n-    endif ()\n+    endif()\n \n     set(PKG_CONFIG_REQUIRES fmt) # add dependency to pkg-config\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Check if fwrite_unlocked/_fwrite_nolock is available\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_FWRITE_UNLOCKED)\n+if(SPDLOG_FWRITE_UNLOCKED)\n     include(CheckSymbolExists)\n-    if (WIN32)\n+    if(WIN32)\n         check_symbol_exists(_fwrite_nolock \"stdio.h\" HAVE_FWRITE_UNLOCKED)\n-    else ()\n+    else()\n         check_symbol_exists(fwrite_unlocked \"stdio.h\" HAVE_FWRITE_UNLOCKED)\n-    endif ()\n-    if (HAVE_FWRITE_UNLOCKED)\n+    endif()\n+    if(HAVE_FWRITE_UNLOCKED)\n         target_compile_definitions(spdlog PRIVATE SPDLOG_FWRITE_UNLOCKED)\n         target_compile_definitions(spdlog_header_only INTERFACE SPDLOG_FWRITE_UNLOCKED)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Add required libraries for Android CMake build\n # ---------------------------------------------------------------------------------------\n-if (ANDROID)\n+if(ANDROID)\n     target_link_libraries(spdlog PUBLIC log)\n     target_link_libraries(spdlog_header_only INTERFACE log)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Misc definitions according to tweak options\n # ---------------------------------------------------------------------------------------\n set(SPDLOG_WCHAR_TO_UTF8_SUPPORT ${SPDLOG_WCHAR_SUPPORT})\n set(SPDLOG_UTF8_TO_WCHAR_CONSOLE ${SPDLOG_WCHAR_CONSOLE})\n-foreach (\n-        SPDLOG_OPTION\n-        SPDLOG_WCHAR_TO_UTF8_SUPPORT\n-        SPDLOG_UTF8_TO_WCHAR_CONSOLE\n-        SPDLOG_WCHAR_FILENAMES\n-        SPDLOG_NO_EXCEPTIONS\n-        SPDLOG_CLOCK_COARSE\n-        SPDLOG_PREVENT_CHILD_FD\n-        SPDLOG_NO_THREAD_ID\n-        SPDLOG_NO_TLS\n-        SPDLOG_NO_ATOMIC_LEVELS\n-        SPDLOG_DISABLE_DEFAULT_LOGGER\n-        SPDLOG_USE_STD_FORMAT)\n-    if (${SPDLOG_OPTION})\n+foreach(\n+    SPDLOG_OPTION\n+    SPDLOG_WCHAR_TO_UTF8_SUPPORT\n+    SPDLOG_UTF8_TO_WCHAR_CONSOLE\n+    SPDLOG_WCHAR_FILENAMES\n+    SPDLOG_NO_EXCEPTIONS\n+    SPDLOG_CLOCK_COARSE\n+    SPDLOG_PREVENT_CHILD_FD\n+    SPDLOG_NO_THREAD_ID\n+    SPDLOG_NO_TLS\n+    SPDLOG_NO_ATOMIC_LEVELS\n+    SPDLOG_DISABLE_DEFAULT_LOGGER\n+    SPDLOG_USE_STD_FORMAT)\n+    if(${SPDLOG_OPTION})\n         target_compile_definitions(spdlog PUBLIC ${SPDLOG_OPTION})\n         target_compile_definitions(spdlog_header_only INTERFACE ${SPDLOG_OPTION})\n-    endif ()\n-endforeach ()\n+    endif()\n+endforeach()\n \n-if (MSVC)\n+if(MSVC)\n     target_compile_options(spdlog PRIVATE \"/Zc:__cplusplus\")\n     target_compile_options(spdlog_header_only INTERFACE \"/Zc:__cplusplus\")\n-    if (SPDLOG_MSVC_UTF8)\n-        # fmtlib requires the /utf-8 flag when building with msvc.\n-        # see https://github.com/fmtlib/fmt/pull/4159 on the purpose of the additional\n+    if(SPDLOG_MSVC_UTF8)\n+        # fmtlib requires the /utf-8 flag when building with msvc. see https://github.com/fmtlib/fmt/pull/4159 on the\n+        # purpose of the additional\n         # \"$<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>\"\n         target_compile_options(spdlog PUBLIC $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)\n-        target_compile_options(spdlog_header_only INTERFACE $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)\n-    endif ()\n-endif ()\n+        target_compile_options(spdlog_header_only\n+                               INTERFACE $<$<AND:$<COMPILE_LANGUAGE:CXX>,$<CXX_COMPILER_ID:MSVC>>:/utf-8>)\n+    endif()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # If exceptions are disabled, disable them in the bundled fmt as well\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_NO_EXCEPTIONS)\n-    if (NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+if(SPDLOG_NO_EXCEPTIONS)\n+    if(NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n         target_compile_definitions(spdlog PUBLIC FMT_USE_EXCEPTIONS=0)\n-    endif ()\n-    if (NOT MSVC)\n+    endif()\n+    if(NOT MSVC)\n         target_compile_options(spdlog PRIVATE -fno-exceptions)\n-    else ()\n+    else()\n         target_compile_options(spdlog PRIVATE /EHs-c-)\n         target_compile_definitions(spdlog PRIVATE _HAS_EXCEPTIONS=0)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n # ---------------------------------------------------------------------------------------\n # Build binaries\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_BUILD_EXAMPLE OR SPDLOG_BUILD_EXAMPLE_HO OR SPDLOG_BUILD_ALL)\n+if(SPDLOG_BUILD_EXAMPLE OR SPDLOG_BUILD_EXAMPLE_HO OR SPDLOG_BUILD_ALL)\n     message(STATUS \"Generating example(s)\")\n     add_subdirectory(example)\n     spdlog_enable_warnings(example)\n-    if (SPDLOG_BUILD_EXAMPLE_HO)\n+    if(SPDLOG_BUILD_EXAMPLE_HO)\n         spdlog_enable_warnings(example_header_only)\n-    endif ()\n-endif ()\n+    endif()\n+endif()\n \n-if (SPDLOG_BUILD_TESTS OR SPDLOG_BUILD_TESTS_HO OR SPDLOG_BUILD_ALL)\n+if(SPDLOG_BUILD_TESTS OR SPDLOG_BUILD_TESTS_HO OR SPDLOG_BUILD_ALL)\n     message(STATUS \"Generating tests\")\n     enable_testing()\n     add_subdirectory(tests)\n-endif ()\n+endif()\n \n-if (SPDLOG_BUILD_BENCH OR SPDLOG_BUILD_ALL)\n+if(SPDLOG_BUILD_BENCH OR SPDLOG_BUILD_ALL)\n     message(STATUS \"Generating benchmarks\")\n     add_subdirectory(bench)\n-endif ()\n+endif()\n \n # ---------------------------------------------------------------------------------------\n # Install\n # ---------------------------------------------------------------------------------------\n-if (SPDLOG_INSTALL)\n+if(SPDLOG_INSTALL)\n     message(STATUS \"Generating install\")\n     set(project_config_in \"${CMAKE_CURRENT_LIST_DIR}/cmake/spdlogConfig.cmake.in\")\n     set(project_config_out \"${CMAKE_CURRENT_BINARY_DIR}/spdlogConfig.cmake\")\n@@ -354,30 +354,30 @@ if (SPDLOG_INSTALL)\n     # ---------------------------------------------------------------------------------------\n     install(DIRECTORY include/ DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\" PATTERN \"fmt/bundled\" EXCLUDE)\n     install(\n-            TARGETS spdlog spdlog_header_only\n-            EXPORT spdlog\n-            LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-            ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n-            RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n+        TARGETS spdlog spdlog_header_only\n+        EXPORT spdlog\n+        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n+        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n+        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n \n-    if (NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n+    if(NOT SPDLOG_USE_STD_FORMAT AND NOT SPDLOG_FMT_EXTERNAL AND NOT SPDLOG_FMT_EXTERNAL_HO)\n         install(DIRECTORY include/${PROJECT_NAME}/fmt/bundled/\n                 DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME}/fmt/bundled/\")\n-    endif ()\n+    endif()\n \n     # ---------------------------------------------------------------------------------------\n     # Install pkg-config file\n     # ---------------------------------------------------------------------------------------\n-    if (IS_ABSOLUTE \"${CMAKE_INSTALL_INCLUDEDIR}\")\n+    if(IS_ABSOLUTE \"${CMAKE_INSTALL_INCLUDEDIR}\")\n         set(PKG_CONFIG_INCLUDEDIR \"${CMAKE_INSTALL_INCLUDEDIR}\")\n-    else ()\n+    else()\n         set(PKG_CONFIG_INCLUDEDIR \"\\${prefix}/${CMAKE_INSTALL_INCLUDEDIR}\")\n-    endif ()\n-    if (IS_ABSOLUTE \"${CMAKE_INSTALL_LIBDIR}\")\n+    endif()\n+    if(IS_ABSOLUTE \"${CMAKE_INSTALL_LIBDIR}\")\n         set(PKG_CONFIG_LIBDIR \"${CMAKE_INSTALL_LIBDIR}\")\n-    else ()\n+    else()\n         set(PKG_CONFIG_LIBDIR \"\\${exec_prefix}/${CMAKE_INSTALL_LIBDIR}\")\n-    endif ()\n+    endif()\n     get_target_property(PKG_CONFIG_DEFINES spdlog INTERFACE_COMPILE_DEFINITIONS)\n     string(REPLACE \";\" \" -D\" PKG_CONFIG_DEFINES \"${PKG_CONFIG_DEFINES}\")\n     string(CONCAT PKG_CONFIG_DEFINES \"-D\" \"${PKG_CONFIG_DEFINES}\")\n@@ -388,7 +388,7 @@ if (SPDLOG_INSTALL)\n     # Install CMake config files\n     # ---------------------------------------------------------------------------------------\n     export(TARGETS spdlog spdlog_header_only NAMESPACE spdlog::\n-            FILE \"${CMAKE_CURRENT_BINARY_DIR}/${config_targets_file}\")\n+           FILE \"${CMAKE_CURRENT_BINARY_DIR}/${config_targets_file}\")\n     install(EXPORT spdlog DESTINATION ${export_dest_dir} NAMESPACE spdlog:: FILE ${config_targets_file})\n \n     include(CMakePackageConfigHelpers)\n@@ -401,4 +401,4 @@ if (SPDLOG_INSTALL)\n     # Support creation of installable packages\n     # ---------------------------------------------------------------------------------------\n     include(cmake/spdlogCPack.cmake)\n-endif ()\n+endif()\ndiff --git a/example/example.cpp b/example/example.cpp\n--- a/example/example.cpp\n+++ b/example/example.cpp\n@@ -269,7 +269,7 @@ void multi_sink_example() {\n struct my_type {\n     int i = 0;\n     explicit my_type(int i)\n-        : i(i){}\n+        : i(i) {}\n };\n \n #ifndef SPDLOG_USE_STD_FORMAT  // when using fmtlib\n@@ -382,14 +382,14 @@ void replace_default_logger_example() {\n     spdlog::set_default_logger(old_logger);\n }\n \n-// Mapped Diagnostic Context (MDC) is a map that stores key-value pairs (string values) in thread local storage.\n-// Each thread maintains its own MDC, which loggers use to append diagnostic information to log outputs.\n-// Note: it is not supported in asynchronous mode due to its reliance on thread-local storage.\n+// Mapped Diagnostic Context (MDC) is a map that stores key-value pairs (string values) in thread\n+// local storage. Each thread maintains its own MDC, which loggers use to append diagnostic\n+// information to log outputs. Note: it is not supported in asynchronous mode due to its reliance on\n+// thread-local storage.\n \n #ifndef SPDLOG_NO_TLS\n     #include \"spdlog/mdc.h\"\n-void mdc_example()\n-{\n+void mdc_example() {\n     spdlog::mdc::put(\"key1\", \"value1\");\n     spdlog::mdc::put(\"key2\", \"value2\");\n     // if not using the default format, you can use the %& formatter to print mdc data as well\ndiff --git a/include/spdlog/async.h b/include/spdlog/async.h\n--- a/include/spdlog/async.h\n+++ b/include/spdlog/async.h\n@@ -89,8 +89,7 @@ inline void init_thread_pool(size_t q_size,\n }\n \n inline void init_thread_pool(size_t q_size, size_t thread_count) {\n-    init_thread_pool(\n-        q_size, thread_count, [] {}, [] {});\n+    init_thread_pool(q_size, thread_count, [] {}, [] {});\n }\n \n // get the global thread pool.\ndiff --git a/include/spdlog/async_logger-inl.h b/include/spdlog/async_logger-inl.h\n--- a/include/spdlog/async_logger-inl.h\n+++ b/include/spdlog/async_logger-inl.h\n@@ -33,7 +33,7 @@ SPDLOG_INLINE spdlog::async_logger::async_logger(std::string logger_name,\n // send the log message to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::sink_it_(const details::log_msg &msg){\n     SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n-        pool_ptr->post_log(shared_from_this(), msg, overflow_policy_);\n+        pool_ptr -> post_log(shared_from_this(), msg, overflow_policy_);\n }\n else {\n     throw_spdlog_ex(\"async log: thread pool doesn't exist anymore\");\n@@ -45,7 +45,7 @@ SPDLOG_LOGGER_CATCH(msg.source)\n // send flush request to the thread pool\n SPDLOG_INLINE void spdlog::async_logger::flush_(){\n     SPDLOG_TRY{if (auto pool_ptr = thread_pool_.lock()){\n-        pool_ptr->post_flush(shared_from_this(), overflow_policy_);\n+        pool_ptr -> post_flush(shared_from_this(), overflow_policy_);\n }\n else {\n     throw_spdlog_ex(\"async flush: thread pool doesn't exist anymore\");\ndiff --git a/include/spdlog/common.h b/include/spdlog/common.h\n--- a/include/spdlog/common.h\n+++ b/include/spdlog/common.h\n@@ -364,7 +364,7 @@ SPDLOG_CONSTEXPR_FUNC spdlog::wstring_view_t to_string_view(spdlog::wstring_view\n }\n #endif\n \n-#if defined(SPDLOG_USE_STD_FORMAT) &&  __cpp_lib_format >= 202207L\n+#if defined(SPDLOG_USE_STD_FORMAT) && __cpp_lib_format >= 202207L\n template <typename T, typename... Args>\n SPDLOG_CONSTEXPR_FUNC std::basic_string_view<T> to_string_view(\n     std::basic_format_string<T, Args...> fmt) SPDLOG_NOEXCEPT {\ndiff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -265,10 +265,10 @@ SPDLOG_INLINE int utc_minutes_offset(const std::tm &tm) {\n     return offset;\n #else\n \n-    #if defined(sun) || defined(__sun) || defined(_AIX) || \\\n-        (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||  \\\n+    #if defined(sun) || defined(__sun) || defined(_AIX) ||                        \\\n+        (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||                         \\\n         (!defined(__APPLE__) && !defined(_BSD_SOURCE) && !defined(_GNU_SOURCE) && \\\n-            (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n+         (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n     // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris\n     struct helper {\n         static long int calculate_gmt_offset(const std::tm &localtm = details::os::localtime(),\n@@ -483,13 +483,12 @@ SPDLOG_INLINE void utf8_to_wstrbuf(string_view_t str, wmemory_buf_t &target) {\n     }\n \n     // find the size to allocate for the result buffer\n-    int result_size =\n-        ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, NULL, 0);\n+    int result_size = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, NULL, 0);\n \n     if (result_size > 0) {\n         target.resize(result_size);\n-        result_size = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, target.data(),\n-                                            result_size);\n+        result_size =\n+            ::MultiByteToWideChar(CP_UTF8, 0, str.data(), str_size, target.data(), result_size);\n         if (result_size > 0) {\n             assert(result_size == target.size());\n             return;\n@@ -593,13 +592,13 @@ SPDLOG_INLINE bool fsync(FILE *fp) {\n // Do non-locking fwrite if possible by the os or use the regular locking fwrite\n // Return true on success.\n SPDLOG_INLINE bool fwrite_bytes(const void *ptr, const size_t n_bytes, FILE *fp) {\n-    #if defined(_WIN32) && defined(SPDLOG_FWRITE_UNLOCKED)\n+#if defined(_WIN32) && defined(SPDLOG_FWRITE_UNLOCKED)\n     return _fwrite_nolock(ptr, 1, n_bytes, fp) == n_bytes;\n-    #elif defined(SPDLOG_FWRITE_UNLOCKED)\n+#elif defined(SPDLOG_FWRITE_UNLOCKED)\n     return ::fwrite_unlocked(ptr, 1, n_bytes, fp) == n_bytes;\n-    #else\n+#else\n     return std::fwrite(ptr, 1, n_bytes, fp) == n_bytes;\n-    #endif\n+#endif\n }\n \n }  // namespace os\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -38,8 +38,7 @@ SPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items,\n     : thread_pool(q_max_items, threads_n, on_thread_start, [] {}) {}\n \n SPDLOG_INLINE thread_pool::thread_pool(size_t q_max_items, size_t threads_n)\n-    : thread_pool(\n-          q_max_items, threads_n, [] {}, [] {}) {}\n+    : thread_pool(q_max_items, threads_n, [] {}, [] {}) {}\n \n // message all threads to terminate gracefully join them\n SPDLOG_INLINE thread_pool::~thread_pool() {\ndiff --git a/include/spdlog/fmt/bin_to_hex.h b/include/spdlog/fmt/bin_to_hex.h\n--- a/include/spdlog/fmt/bin_to_hex.h\n+++ b/include/spdlog/fmt/bin_to_hex.h\n@@ -142,8 +142,8 @@ struct formatter<spdlog::details::dump_info<T>, char> {\n \n     // format the given bytes range as hex\n     template <typename FormatContext, typename Container>\n-    auto format(const spdlog::details::dump_info<Container> &the_range, FormatContext &ctx) const\n-        -> decltype(ctx.out()) {\n+    auto format(const spdlog::details::dump_info<Container> &the_range,\n+                FormatContext &ctx) const -> decltype(ctx.out()) {\n         SPDLOG_CONSTEXPR const char *hex_upper = \"0123456789ABCDEF\";\n         SPDLOG_CONSTEXPR const char *hex_lower = \"0123456789abcdef\";\n         const char *hex_chars = use_uppercase ? hex_upper : hex_lower;\ndiff --git a/include/spdlog/mdc.h b/include/spdlog/mdc.h\n--- a/include/spdlog/mdc.h\n+++ b/include/spdlog/mdc.h\n@@ -12,12 +12,14 @@\n \n #include <spdlog/common.h>\n \n-// MDC is a simple map of key->string values stored in thread local storage whose content will be printed by the loggers.\n-// Note: Not supported in async mode (thread local storage - so the async thread pool have different copy).\n+// MDC is a simple map of key->string values stored in thread local storage whose content will be\n+// printed by the loggers. Note: Not supported in async mode (thread local storage - so the async\n+// thread pool have different copy).\n //\n // Usage example:\n // spdlog::mdc::put(\"mdc_key_1\", \"mdc_value_1\");\n-// spdlog::info(\"Hello, {}\", \"World!\");  // => [2024-04-26 02:08:05.040] [info] [mdc_key_1:mdc_value_1] Hello, World!\n+// spdlog::info(\"Hello, {}\", \"World!\");  // => [2024-04-26 02:08:05.040] [info]\n+// [mdc_key_1:mdc_value_1] Hello, World!\n \n namespace spdlog {\n class SPDLOG_API mdc {\ndiff --git a/include/spdlog/sinks/ansicolor_sink-inl.h b/include/spdlog/sinks/ansicolor_sink-inl.h\n--- a/include/spdlog/sinks/ansicolor_sink-inl.h\n+++ b/include/spdlog/sinks/ansicolor_sink-inl.h\n@@ -111,7 +111,8 @@ SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::set_color_mode_(color_mode mode\n }\n \n template <typename ConsoleMutex>\n-SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_ccode_(const string_view_t &color_code) const {\n+SPDLOG_INLINE void ansicolor_sink<ConsoleMutex>::print_ccode_(\n+    const string_view_t &color_code) const {\n     details::os::fwrite_bytes(color_code.data(), color_code.size(), target_file_);\n }\n \ndiff --git a/include/spdlog/sinks/callback_sink.h b/include/spdlog/sinks/callback_sink.h\n--- a/include/spdlog/sinks/callback_sink.h\n+++ b/include/spdlog/sinks/callback_sink.h\n@@ -27,7 +27,7 @@ class callback_sink final : public base_sink<Mutex> {\n \n protected:\n     void sink_it_(const details::log_msg &msg) override { callback_(msg); }\n-    void flush_() override{}\n+    void flush_() override {}\n \n private:\n     custom_log_callback callback_;\ndiff --git a/include/spdlog/sinks/rotating_file_sink-inl.h b/include/spdlog/sinks/rotating_file_sink-inl.h\n--- a/include/spdlog/sinks/rotating_file_sink-inl.h\n+++ b/include/spdlog/sinks/rotating_file_sink-inl.h\n@@ -14,7 +14,6 @@\n #include <spdlog/fmt/fmt.h>\n \n #include <cerrno>\n-#include <chrono>\n #include <ctime>\n #include <mutex>\n #include <string>\n@@ -38,8 +37,8 @@ SPDLOG_INLINE rotating_file_sink<Mutex>::rotating_file_sink(\n         throw_spdlog_ex(\"rotating sink constructor: max_size arg cannot be zero\");\n     }\n \n-    if (max_files > 200000) {\n-        throw_spdlog_ex(\"rotating sink constructor: max_files arg cannot exceed 200000\");\n+    if (max_files > MaxFiles) {\n+        throw_spdlog_ex(\"rotating sink constructor: max_files arg cannot exceed MaxFiles\");\n     }\n     file_helper_.open(calc_filename(base_filename_, 0));\n     current_size_ = file_helper_.size();  // expensive. called only once\n@@ -54,11 +53,12 @@ SPDLOG_INLINE rotating_file_sink<Mutex>::rotating_file_sink(\n template <typename Mutex>\n SPDLOG_INLINE filename_t rotating_file_sink<Mutex>::calc_filename(const filename_t &filename,\n                                                                   std::size_t index) {\n-    if (index == 0u) {\n+    if (index == 0U) {\n         return filename;\n     }\n \n-    filename_t basename, ext;\n+    filename_t basename;\n+    filename_t ext;\n     std::tie(basename, ext) = details::file_helper::split_by_extension(filename);\n     return fmt_lib::format(SPDLOG_FMT_STRING(SPDLOG_FILENAME_T(\"{}.{}{}\")), basename, index, ext);\n }\n@@ -74,6 +74,35 @@ SPDLOG_INLINE void rotating_file_sink<Mutex>::rotate_now() {\n     std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n     rotate_();\n }\n+template <typename Mutex>\n+SPDLOG_INLINE void rotating_file_sink<Mutex>::set_max_size(std::size_t max_size) {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    if (max_size == 0) {\n+        throw_spdlog_ex(\"rotating sink set_max_size: max_size arg cannot be zero\");\n+    }\n+    max_size_ = max_size;\n+}\n+\n+template <typename Mutex>\n+SPDLOG_INLINE std::size_t rotating_file_sink<Mutex>::get_max_size() {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    return max_size_;\n+}\n+\n+template <typename Mutex>\n+SPDLOG_INLINE void rotating_file_sink<Mutex>::set_max_files(std::size_t max_files) {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    if (max_files > MaxFiles) {\n+        throw_spdlog_ex(\"rotating sink set_max_files: max_files arg cannot exceed 200000\");\n+    }\n+    max_files_ = max_files;\n+}\n+\n+template <typename Mutex>\n+std::size_t rotating_file_sink<Mutex>::get_max_files() {\n+    std::lock_guard<Mutex> lock(base_sink<Mutex>::mutex_);\n+    return max_files_;\n+}\n \n template <typename Mutex>\n SPDLOG_INLINE void rotating_file_sink<Mutex>::sink_it_(const details::log_msg &msg) {\ndiff --git a/include/spdlog/sinks/rotating_file_sink.h b/include/spdlog/sinks/rotating_file_sink.h\n--- a/include/spdlog/sinks/rotating_file_sink.h\n+++ b/include/spdlog/sinks/rotating_file_sink.h\n@@ -8,7 +8,6 @@\n #include <spdlog/details/synchronous_factory.h>\n #include <spdlog/sinks/base_sink.h>\n \n-#include <chrono>\n #include <mutex>\n #include <string>\n \n@@ -21,6 +20,7 @@ namespace sinks {\n template <typename Mutex>\n class rotating_file_sink final : public base_sink<Mutex> {\n public:\n+    static constexpr size_t MaxFiles = 200000;\n     rotating_file_sink(filename_t base_filename,\n                        std::size_t max_size,\n                        std::size_t max_files,\n@@ -29,6 +29,10 @@ class rotating_file_sink final : public base_sink<Mutex> {\n     static filename_t calc_filename(const filename_t &filename, std::size_t index);\n     filename_t filename();\n     void rotate_now();\n+    void set_max_size(std::size_t max_size);\n+    std::size_t get_max_size();\n+    void set_max_files(std::size_t max_files);\n+    std::size_t get_max_files();\n \n protected:\n     void sink_it_(const details::log_msg &msg) override;\n@@ -42,7 +46,7 @@ class rotating_file_sink final : public base_sink<Mutex> {\n     // log.3.txt -> delete\n     void rotate_();\n \n-    // delete the target if exists, and rename the src file  to target\n+    // delete the target if exists, and rename the src file to target\n     // return true on success, false otherwise.\n     bool rename_file_(const filename_t &src_filename, const filename_t &target_filename);\n \n@@ -61,25 +65,24 @@ using rotating_file_sink_st = rotating_file_sink<details::null_mutex>;\n //\n // factory functions\n //\n-\n template <typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> rotating_logger_mt(const std::string &logger_name,\n-                                                  const filename_t &filename,\n-                                                  size_t max_file_size,\n-                                                  size_t max_files,\n-                                                  bool rotate_on_open = false,\n-                                                  const file_event_handlers &event_handlers = {}) {\n+std::shared_ptr<logger> rotating_logger_mt(const std::string &logger_name,\n+                                           const filename_t &filename,\n+                                           size_t max_file_size,\n+                                           size_t max_files,\n+                                           bool rotate_on_open = false,\n+                                           const file_event_handlers &event_handlers = {}) {\n     return Factory::template create<sinks::rotating_file_sink_mt>(\n         logger_name, filename, max_file_size, max_files, rotate_on_open, event_handlers);\n }\n \n template <typename Factory = spdlog::synchronous_factory>\n-inline std::shared_ptr<logger> rotating_logger_st(const std::string &logger_name,\n-                                                  const filename_t &filename,\n-                                                  size_t max_file_size,\n-                                                  size_t max_files,\n-                                                  bool rotate_on_open = false,\n-                                                  const file_event_handlers &event_handlers = {}) {\n+std::shared_ptr<logger> rotating_logger_st(const std::string &logger_name,\n+                                           const filename_t &filename,\n+                                           size_t max_file_size,\n+                                           size_t max_files,\n+                                           bool rotate_on_open = false,\n+                                           const file_event_handlers &event_handlers = {}) {\n     return Factory::template create<sinks::rotating_file_sink_st>(\n         logger_name, filename, max_file_size, max_files, rotate_on_open, event_handlers);\n }\ndiff --git a/include/spdlog/sinks/wincolor_sink-inl.h b/include/spdlog/sinks/wincolor_sink-inl.h\n--- a/include/spdlog/sinks/wincolor_sink-inl.h\n+++ b/include/spdlog/sinks/wincolor_sink-inl.h\n@@ -137,10 +137,10 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::print_range_(const memory_buf_t\n #if defined(SPDLOG_UTF8_TO_WCHAR_CONSOLE)\n         wmemory_buf_t wformatted;\n         details::os::utf8_to_wstrbuf(string_view_t(formatted.data() + start, end - start),\n-            wformatted);\n+                                     wformatted);\n         auto size = static_cast<DWORD>(wformatted.size());\n         auto ignored = ::WriteConsoleW(static_cast<HANDLE>(out_handle_), wformatted.data(), size,\n-            nullptr, nullptr);\n+                                       nullptr, nullptr);\n #else\n         auto size = static_cast<DWORD>(end - start);\n         auto ignored = ::WriteConsoleA(static_cast<HANDLE>(out_handle_), formatted.data() + start,\ndiff --git a/include/spdlog/tweakme.h b/include/spdlog/tweakme.h\n--- a/include/spdlog/tweakme.h\n+++ b/include/spdlog/tweakme.h\n@@ -109,8 +109,8 @@\n //\n // #include <string_view>\n // using namespace std::string_view_literals;\n-// #define SPDLOG_LEVEL_NAMES { \"MY TRACE\"sv, \"MY DEBUG\"sv, \"MY INFO\"sv, \"MY WARNING\"sv, \"MY ERROR\"sv, \"MY\n-// CRITICAL\"sv, \"OFF\"sv }\n+// #define SPDLOG_LEVEL_NAMES { \"MY TRACE\"sv, \"MY DEBUG\"sv, \"MY INFO\"sv, \"MY WARNING\"sv, \"MY\n+// ERROR\"sv, \"MY CRITICAL\"sv, \"OFF\"sv }\n ///////////////////////////////////////////////////////////////////////////////\n \n ///////////////////////////////////////////////////////////////////////////////\ndiff --git a/src/bundled_fmtlib_format.cpp b/src/bundled_fmtlib_format.cpp\n--- a/src/bundled_fmtlib_format.cpp\n+++ b/src/bundled_fmtlib_format.cpp\n@@ -13,34 +13,32 @@\n FMT_BEGIN_NAMESPACE\n namespace detail {\n \n-template FMT_API auto dragonbox::to_decimal(float x) noexcept\n-    -> dragonbox::decimal_fp<float>;\n-template FMT_API auto dragonbox::to_decimal(double x) noexcept\n-    -> dragonbox::decimal_fp<double>;\n+template FMT_API auto dragonbox::to_decimal(float x) noexcept -> dragonbox::decimal_fp<float>;\n+template FMT_API auto dragonbox::to_decimal(double x) noexcept -> dragonbox::decimal_fp<double>;\n \n-#if FMT_USE_LOCALE\n+    #if FMT_USE_LOCALE\n // DEPRECATED! locale_ref in the detail namespace\n template FMT_API locale_ref::locale_ref(const std::locale& loc);\n template FMT_API auto locale_ref::get<std::locale>() const -> std::locale;\n-#endif\n+    #endif\n \n // Explicit instantiations for char.\n \n-template FMT_API auto thousands_sep_impl(locale_ref)\n-    -> thousands_sep_result<char>;\n+template FMT_API auto thousands_sep_impl(locale_ref) -> thousands_sep_result<char>;\n template FMT_API auto decimal_point_impl(locale_ref) -> char;\n \n // DEPRECATED!\n template FMT_API void buffer<char>::append(const char*, const char*);\n \n // DEPRECATED!\n-template FMT_API void vformat_to(buffer<char>&, string_view,\n-                                 typename vformat_args<>::type, locale_ref);\n+template FMT_API void vformat_to(buffer<char>&,\n+                                 string_view,\n+                                 typename vformat_args<>::type,\n+                                 locale_ref);\n \n // Explicit instantiations for wchar_t.\n \n-template FMT_API auto thousands_sep_impl(locale_ref)\n-    -> thousands_sep_result<wchar_t>;\n+template FMT_API auto thousands_sep_impl(locale_ref) -> thousands_sep_result<wchar_t>;\n template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;\n \n template FMT_API void buffer<wchar_t>::append(const wchar_t*, const wchar_t*);\n@@ -48,5 +46,4 @@ template FMT_API void buffer<wchar_t>::append(const wchar_t*, const wchar_t*);\n }  // namespace detail\n FMT_END_NAMESPACE\n \n-\n #endif  // !SPDLOG_FMT_EXTERNAL\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -19,9 +19,9 @@ if(Catch2_FOUND)\n else()\n     message(STATUS \"Bundled version of Catch will be downloaded and used.\")\n     include(FetchContent)\n-    FetchContent_Declare(Catch2\n-            GIT_REPOSITORY https://github.com/catchorg/Catch2.git\n-            GIT_TAG 53d0d913a422d356b23dd927547febdf69ee9081 # v3.5.0\n+    FetchContent_Declare(\n+        Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2.git\n+        GIT_TAG 53d0d913a422d356b23dd927547febdf69ee9081 # v3.5.0\n     )\n     FetchContent_MakeAvailable(Catch2)\n endif()\n@@ -71,9 +71,9 @@ function(spdlog_prepare_test test_target spdlog_lib)\n     target_link_libraries(${test_target} PRIVATE Catch2::Catch2WithMain)\n     if(SPDLOG_SANITIZE_ADDRESS)\n         spdlog_enable_addr_sanitizer(${test_target})\n-    elseif (SPDLOG_SANITIZE_THREAD)\n+    elseif(SPDLOG_SANITIZE_THREAD)\n         spdlog_enable_thread_sanitizer(${test_target})\n-    endif ()\n+    endif()\n     add_test(NAME ${test_target} COMMAND ${test_target})\n     set_tests_properties(${test_target} PROPERTIES RUN_SERIAL ON)\n endfunction()\ndiff --git a/tests/test_custom_callbacks.cpp b/tests/test_custom_callbacks.cpp\n--- a/tests/test_custom_callbacks.cpp\n+++ b/tests/test_custom_callbacks.cpp\n@@ -16,7 +16,8 @@ TEST_CASE(\"custom_callback_logger\", \"[custom_callback_logger]\") {\n             spdlog::memory_buf_t formatted;\n             formatter.format(msg, formatted);\n             auto eol_len = strlen(spdlog::details::os::default_eol);\n-            using diff_t = typename std::iterator_traits<decltype(formatted.end())>::difference_type; \n+            using diff_t =\n+                typename std::iterator_traits<decltype(formatted.end())>::difference_type;\n             lines.emplace_back(formatted.begin(), formatted.end() - static_cast<diff_t>(eol_len));\n         });\n     std::shared_ptr<spdlog::sinks::test_sink_st> test_sink(new spdlog::sinks::test_sink_st);\ndiff --git a/tests/test_daily_logger.cpp b/tests/test_daily_logger.cpp\n--- a/tests/test_daily_logger.cpp\n+++ b/tests/test_daily_logger.cpp\n@@ -46,10 +46,8 @@ TEST_CASE(\"daily_logger with dateonly calculator\", \"[daily_logger]\") {\n \n struct custom_daily_file_name_calculator {\n     static spdlog::filename_t calc_filename(const spdlog::filename_t &basename, const tm &now_tm) {\n-        \n-        return spdlog::fmt_lib::format(SPDLOG_FILENAME_T(\"{}{:04d}{:02d}{:02d}\"),\n-                                   basename, now_tm.tm_year + 1900, now_tm.tm_mon + 1,\n-                                   now_tm.tm_mday);        \n+        return spdlog::fmt_lib::format(SPDLOG_FILENAME_T(\"{}{:04d}{:02d}{:02d}\"), basename,\n+                                       now_tm.tm_year + 1900, now_tm.tm_mon + 1, now_tm.tm_mday);\n     }\n };\n \ndiff --git a/tests/test_file_logging.cpp b/tests/test_file_logging.cpp\n--- a/tests/test_file_logging.cpp\n+++ b/tests/test_file_logging.cpp\n@@ -56,7 +56,7 @@ TEST_CASE(\"simple_file_logger\", \"[truncate]\") {\n     logger->info(\"Test message {}\", 2.71);\n     logger->flush();\n     REQUIRE(count_lines(SIMPLE_LOG) == 2);\n-    \n+\n     sink->truncate();\n     REQUIRE(count_lines(SIMPLE_LOG) == 0);\n \n@@ -94,14 +94,11 @@ TEST_CASE(\"rotating_file_logger2\", \"[rotating_logger]\") {\n         // next logger can rename the first output file.\n         spdlog::drop(logger->name());\n     }\n-\n     auto logger = spdlog::rotating_logger_mt(\"logger\", basename, max_size, 2, true);\n     for (int i = 0; i < 10; ++i) {\n         logger->info(\"Test message {}\", i);\n     }\n-\n     logger->flush();\n-\n     require_message_count(ROTATING_LOG, 10);\n \n     for (int i = 0; i < 1000; i++) {\n@@ -141,3 +138,50 @@ TEST_CASE(\"rotating_file_logger4\", \"[rotating_logger]\") {\n     REQUIRE(get_filesize(ROTATING_LOG) > 0);\n     REQUIRE(get_filesize(ROTATING_LOG \".1\") > 0);\n }\n+\n+// test changing the max size of the rotating file sink\n+TEST_CASE(\"rotating_file_logger5\", \"[rotating_logger]\") {\n+    prepare_logdir();\n+    size_t max_size = 5 * 1024;\n+    size_t max_files = 2;\n+    spdlog::filename_t basename = SPDLOG_FILENAME_T(ROTATING_LOG);\n+    auto sink =\n+        std::make_shared<spdlog::sinks::rotating_file_sink_st>(basename, max_size, max_files);\n+    auto logger = std::make_shared<spdlog::logger>(\"rotating_sink_logger\", sink);\n+    logger->set_pattern(\"%v\");\n+\n+    REQUIRE(sink->get_max_size() == max_size);\n+    REQUIRE(sink->get_max_files() == max_files);\n+    max_size = 7 * 1024;\n+    max_files = 3;\n+\n+    sink->set_max_size(max_size);\n+    sink->set_max_files(max_files);\n+    REQUIRE(sink->get_max_size() == max_size);\n+    REQUIRE(sink->get_max_files() == max_files);\n+\n+    const auto message = std::string(200, 'x');\n+    assert(message.size() < max_size);\n+    const auto n_messages = max_files * max_size / message.size();\n+    for (size_t i = 0; i < n_messages; ++i) {\n+        logger->info(message);\n+    }\n+    logger.reset();  // force flush and close the file\n+\n+    // validate that the files were rotated correctly with the new max size and max files\n+    for (size_t i = 0; i <= max_files; i++) {\n+        // calc filenames\n+        // e.g. rotating_log, rotating_log.0 rotating_log.1, rotating_log.2, etc.\n+        std::ostringstream oss;\n+        oss << ROTATING_LOG;\n+        if (i > 0) {\n+            oss << '.' << i;\n+        }\n+        const auto filename = oss.str();\n+        const auto filesize = get_filesize(filename);\n+        REQUIRE(filesize <= max_size);\n+        if (i > 0) {\n+            REQUIRE(filesize >= max_size - message.size() - 2);\n+        }\n+    }\n+}\ndiff --git a/tests/test_misc.cpp b/tests/test_misc.cpp\n--- a/tests/test_misc.cpp\n+++ b/tests/test_misc.cpp\n@@ -1,12 +1,12 @@\n-#ifdef _WIN32 // to prevent fopen warning on windows\n-#define _CRT_SECURE_NO_WARNINGS\n+#ifdef _WIN32  // to prevent fopen warning on windows\n+    #define _CRT_SECURE_NO_WARNINGS\n #endif\n \n #include \"includes.h\"\n #include \"test_sink.h\"\n \n template <class T>\n-std::string log_info(const T &what, spdlog::level::level_enum logger_level = spdlog::level::info) {\n+std::string log_info(const T& what, spdlog::level::level_enum logger_level = spdlog::level::info) {\n     std::ostringstream oss;\n     auto oss_sink = std::make_shared<spdlog::sinks::ostream_sink_mt>(oss);\n \n@@ -182,17 +182,19 @@ TEST_CASE(\"utf8 to utf16 conversion using windows api\", \"[windows utf]\") {\n     spdlog::details::os::utf8_to_wstrbuf(\"abc\", buffer);\n     REQUIRE(std::wstring(buffer.data(), buffer.size()) == std::wstring(L\"abc\"));\n \n-    spdlog::details::os::utf8_to_wstrbuf(\"\\xc3\\x28\", buffer); // Invalid UTF-8 sequence.\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xc3\\x28\", buffer);  // Invalid UTF-8 sequence.\n     REQUIRE(std::wstring(buffer.data(), buffer.size()) == std::wstring(L\"\\xfffd(\"));\n \n-    spdlog::details::os::utf8_to_wstrbuf(\"\\xe3\\x81\\xad\\xe3\\x81\\x93\", buffer); // \"Neko\" in hiragana.\n+    spdlog::details::os::utf8_to_wstrbuf(\"\\xe3\\x81\\xad\\xe3\\x81\\x93\",\n+                                         buffer);  // \"Neko\" in hiragana.\n     REQUIRE(std::wstring(buffer.data(), buffer.size()) == std::wstring(L\"\\x306d\\x3053\"));\n }\n #endif\n \n struct auto_closer {\n     FILE* fp = nullptr;\n-    explicit auto_closer(FILE* f) : fp(f) {}\n+    explicit auto_closer(FILE* f)\n+        : fp(f) {}\n     auto_closer(const auto_closer&) = delete;\n     auto_closer& operator=(const auto_closer&) = delete;\n     ~auto_closer() {\n@@ -201,10 +203,10 @@ struct auto_closer {\n };\n \n TEST_CASE(\"os::fwrite_bytes\", \"[os]\") {\n-    using spdlog::details::os::fwrite_bytes;\n     using spdlog::details::os::create_dir;\n+    using spdlog::details::os::fwrite_bytes;\n     const char* filename = \"log_tests/test_fwrite_bytes.txt\";\n-    const char *msg = \"hello\";\n+    const char* msg = \"hello\";\n     prepare_logdir();\n     REQUIRE(create_dir(SPDLOG_FILENAME_T(\"log_tests\")) == true);\n     {\ndiff --git a/tests/test_pattern_formatter.cpp b/tests/test_pattern_formatter.cpp\n--- a/tests/test_pattern_formatter.cpp\n+++ b/tests/test_pattern_formatter.cpp\n@@ -23,7 +23,9 @@ static std::string log_to_str(const std::string &msg, const Args &...args) {\n \n // log to str and return it with time\n template <typename... Args>\n-static std::string log_to_str_with_time(spdlog::log_clock::time_point log_time, const std::string &msg, const Args &...args) {\n+static std::string log_to_str_with_time(spdlog::log_clock::time_point log_time,\n+                                        const std::string &msg,\n+                                        const Args &...args) {\n     std::ostringstream oss;\n     auto oss_sink = std::make_shared<spdlog::sinks::ostream_sink_mt>(oss);\n     spdlog::logger oss_logger(\"pattern_tester\", oss_sink);\n@@ -80,8 +82,8 @@ TEST_CASE(\"GMT offset \", \"[pattern_formatter]\") {\n     const auto now = std::chrono::system_clock::now();\n     const auto yesterday = now - 24h;\n \n-    REQUIRE(log_to_str_with_time(yesterday, \"Some message\", \"%z\", spdlog::pattern_time_type::utc, \"\\n\") ==\n-            \"+00:00\\n\");\n+    REQUIRE(log_to_str_with_time(yesterday, \"Some message\", \"%z\", spdlog::pattern_time_type::utc,\n+                                 \"\\n\") == \"+00:00\\n\");\n }\n \n TEST_CASE(\"color range test1\", \"[pattern_formatter]\") {\ndiff --git a/tests/test_sink.h b/tests/test_sink.h\n--- a/tests/test_sink.h\n+++ b/tests/test_sink.h\n@@ -47,7 +47,7 @@ class test_sink : public base_sink<Mutex> {\n         base_sink<Mutex>::formatter_->format(msg, formatted);\n         // save the line without the eol\n         auto eol_len = strlen(details::os::default_eol);\n-        using diff_t = typename std::iterator_traits<decltype(formatted.end())>::difference_type; \n+        using diff_t = typename std::iterator_traits<decltype(formatted.end())>::difference_type;\n         if (lines_.size() < lines_to_save) {\n             lines_.emplace_back(formatted.begin(), formatted.end() - static_cast<diff_t>(eol_len));\n         }\ndiff --git a/tests/utils.cpp b/tests/utils.cpp\n--- a/tests/utils.cpp\n+++ b/tests/utils.cpp\n@@ -50,9 +50,8 @@ void require_message_count(const std::string &filename, const std::size_t messag\n std::size_t get_filesize(const std::string &filename) {\n     std::ifstream ifs(filename, std::ifstream::ate | std::ifstream::binary);\n     if (!ifs) {\n-        throw std::runtime_error(\"Failed open file \");\n+        throw std::runtime_error(\"Failed open file \" + filename);\n     }\n-\n     return static_cast<std::size_t>(ifs.tellg());\n }\n \n", "problem_statement": "(Probably minor) feature request: It should be possible to change the max_size for rotating_file_sink, after it has been constructed.\nPretty much what the title says.\n\nI imagine such a function would need to trigger a manual rotation first to keep things sane, of course. Why did I think of this? My app has a \"profiling mode\" where it spits time spent doing different things to the log.\n\nI initiallly implemented a logger with rotation a 2 MB, but the other day I turned this mode on and realized that a very short run basically obliterated all previous logs, which is very much not ideal. For now, I think maybe I'll direct these messsages to a separate file, but it would be nice if in the future, I could just change the max_size whenever this gets turned on.\n(Probably minor) feature request: It should be possible to change the max_size for rotating_file_sink, after it has been constructed.\nPretty much what the title says.\n\nI imagine such a function would need to trigger a manual rotation first to keep things sane, of course. Why did I think of this? My app has a \"profiling mode\" where it spits time spent doing different things to the log.\n\nI initiallly implemented a logger with rotation a 2 MB, but the other day I turned this mode on and realized that a very short run basically obliterated all previous logs, which is very much not ideal. For now, I think maybe I'll direct these messsages to a separate file, but it would be nice if in the future, I could just change the max_size whenever this gets turned on.\n", "hints_text": "The same feature request was received: #2288\n\nThe workaround in the current API is the method described in [this comment](https://github.com/gabime/spdlog/issues/2288#issuecomment-1049933773)\nThe same feature request was received: #2288\n\nThe workaround in the current API is the method described in [this comment](https://github.com/gabime/spdlog/issues/2288#issuecomment-1049933773)", "created_at": "2025-05-08T10:37:16Z", "version": "1.15"}
{"repo": "gabime/spdlog", "pull_number": 3366, "instance_id": "gabime__spdlog-3366", "issue_numbers": ["3352"], "base_commit": "faa0a7a9c5a3550ed5461fab7d8e31c37fd1a2ef", "patch": "diff --git a/include/spdlog/details/os-inl.h b/include/spdlog/details/os-inl.h\n--- a/include/spdlog/details/os-inl.h\n+++ b/include/spdlog/details/os-inl.h\n@@ -267,7 +267,8 @@ SPDLOG_INLINE int utc_minutes_offset(const std::tm &tm) {\n \n     #if defined(sun) || defined(__sun) || defined(_AIX) || \\\n         (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||  \\\n-        (!defined(_BSD_SOURCE) && !defined(_GNU_SOURCE))\n+        (!defined(__APPLE__) && !defined(_BSD_SOURCE) && !defined(_GNU_SOURCE) && \\\n+            (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n     // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris\n     struct helper {\n         static long int calculate_gmt_offset(const std::tm &localtm = details::os::localtime(),\n", "test_patch": "diff --git a/tests/test_pattern_formatter.cpp b/tests/test_pattern_formatter.cpp\n--- a/tests/test_pattern_formatter.cpp\n+++ b/tests/test_pattern_formatter.cpp\n@@ -1,6 +1,8 @@\n #include \"includes.h\"\n #include \"test_sink.h\"\n \n+#include <chrono>\n+\n using spdlog::memory_buf_t;\n using spdlog::details::to_string_view;\n \n@@ -19,6 +21,21 @@ static std::string log_to_str(const std::string &msg, const Args &...args) {\n     return oss.str();\n }\n \n+// log to str and return it with time\n+template <typename... Args>\n+static std::string log_to_str_with_time(spdlog::log_clock::time_point log_time, const std::string &msg, const Args &...args) {\n+    std::ostringstream oss;\n+    auto oss_sink = std::make_shared<spdlog::sinks::ostream_sink_mt>(oss);\n+    spdlog::logger oss_logger(\"pattern_tester\", oss_sink);\n+    oss_logger.set_level(spdlog::level::info);\n+\n+    oss_logger.set_formatter(\n+        std::unique_ptr<spdlog::formatter>(new spdlog::pattern_formatter(args...)));\n+\n+    oss_logger.log(log_time, {}, spdlog::level::info, msg);\n+    return oss.str();\n+}\n+\n TEST_CASE(\"custom eol\", \"[pattern_formatter]\") {\n     std::string msg = \"Hello custom eol test\";\n     std::string eol = \";)\";\n@@ -58,6 +75,15 @@ TEST_CASE(\"date MM/DD/YY \", \"[pattern_formatter]\") {\n             oss.str());\n }\n \n+TEST_CASE(\"GMT offset \", \"[pattern_formatter]\") {\n+    using namespace std::chrono_literals;\n+    const auto now = std::chrono::system_clock::now();\n+    const auto yesterday = now - 24h;\n+\n+    REQUIRE(log_to_str_with_time(yesterday, \"Some message\", \"%z\", spdlog::pattern_time_type::utc, \"\\n\") ==\n+            \"+00:00\\n\");\n+}\n+\n TEST_CASE(\"color range test1\", \"[pattern_formatter]\") {\n     auto formatter = std::make_shared<spdlog::pattern_formatter>(\n         \"%^%v%$\", spdlog::pattern_time_type::local, \"\\n\");\n", "problem_statement": "Missing test for __APPLE__ chooses buggy SunOS/Solaris workaround in utc_minutes_offset\nspdlog uses the function `utc_minutes_offset` in the `z_formatter` to format the `'%z'`-part of a format string (UTC-offset) when logging time. The function has three implementations, one of which is chosen at compile time via marcro defines (Windows, SunOS/Solaris, default):\n\nhttps://github.com/gabime/spdlog/blob/3335c380a08c5e0f5117a66622df6afdb3d74959/include/spdlog/details/os-inl.h#L268-L271\n\nThis test doesn't detect Apple platforms, which have had the `tm_gmtoff`-field at least since [Mac OS X 10.0](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/ctime.3.html), and also doesn't detect [POSIX.1-2024](https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/time.h.html) conforming systems, which are also required to support `tm_gmtoff`.\n\nOn Apple and POSIX1.-2024 platforms, this has the unfortunate effect to use the SunOS/Solaris fallback, which doesn't compute the correct value if the passed value of `tm` isn't the current system time, i.e. `localtime(::time())` (#3351).\n\nI suggest to fix this by changing the test to something like\n```c++\n    #if defined(sun) || defined(__sun) || defined(_AIX) || \\\n        (defined(__NEWLIB__) && !defined(__TM_GMTOFF)) ||  \\\n        (!defined(__APPLE__) && !defined(_BSD_SOURCE) && !defined(_GNU_SOURCE) && \\\n            (!defined(_POSIX_VERSION) || (_POSIX_VERSION < 202405L)))\n    // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris\n```\n", "hints_text": "Thanks for the report. Is there a test that can be added to tests/ to reproduce this?\nPR is always welcome.", "created_at": "2025-03-29T10:10:34Z", "version": "1.15"}
{"repo": "gabime/spdlog", "pull_number": 2588, "instance_id": "gabime__spdlog-2588", "issue_numbers": ["2587"], "base_commit": "edc51df1bdad8667b628999394a1e7c4dc6f3658", "patch": "diff --git a/include/spdlog/details/mpmc_blocking_q.h b/include/spdlog/details/mpmc_blocking_q.h\n--- a/include/spdlog/details/mpmc_blocking_q.h\n+++ b/include/spdlog/details/mpmc_blocking_q.h\n@@ -49,7 +49,7 @@ class mpmc_blocking_queue\n         push_cv_.notify_one();\n     }\n \n-    // try to dequeue item. if no item found. wait up to timeout and try again\n+    // dequeue with a timeout.\n     // Return true, if succeeded dequeue item, false otherwise\n     bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)\n     {\n@@ -66,6 +66,18 @@ class mpmc_blocking_queue\n         return true;\n     }\n \n+    // blocking dequeue without a timeout.\n+    void dequeue(T &popped_item)\n+    {\n+        {\n+            std::unique_lock<std::mutex> lock(queue_mutex_);\n+            push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n+            popped_item = std::move(q_.front());\n+            q_.pop_front();\n+        }\n+        pop_cv_.notify_one();\n+    }\n+\n #else\n     // apparently mingw deadlocks if the mutex is released before cv.notify_one(),\n     // so release the mutex at the very end each function.\n@@ -87,7 +99,7 @@ class mpmc_blocking_queue\n         push_cv_.notify_one();\n     }\n \n-    // try to dequeue item. if no item found. wait up to timeout and try again\n+    // dequeue with a timeout.\n     // Return true, if succeeded dequeue item, false otherwise\n     bool dequeue_for(T &popped_item, std::chrono::milliseconds wait_duration)\n     {\n@@ -102,6 +114,16 @@ class mpmc_blocking_queue\n         return true;\n     }\n \n+    // blocking dequeue without a timeout.\n+    void dequeue(T &popped_item)\n+    {\n+        std::unique_lock<std::mutex> lock(queue_mutex_);\n+        push_cv_.wait(lock, [this] { return !this->q_.empty(); });\n+        popped_item = std::move(q_.front());\n+        q_.pop_front();\n+        pop_cv_.notify_one();\n+    }\n+\n #endif\n \n     size_t overrun_counter()\ndiff --git a/include/spdlog/details/thread_pool-inl.h b/include/spdlog/details/thread_pool-inl.h\n--- a/include/spdlog/details/thread_pool-inl.h\n+++ b/include/spdlog/details/thread_pool-inl.h\n@@ -108,11 +108,7 @@ void SPDLOG_INLINE thread_pool::worker_loop_()\n bool SPDLOG_INLINE thread_pool::process_next_msg_()\n {\n     async_msg incoming_async_msg;\n-    bool dequeued = q_.dequeue_for(incoming_async_msg, std::chrono::seconds(10));\n-    if (!dequeued)\n-    {\n-        return true;\n-    }\n+    q_.dequeue(incoming_async_msg);\n \n     switch (incoming_async_msg.msg_type)\n     {\n", "test_patch": "diff --git a/tests/test_mpmc_q.cpp b/tests/test_mpmc_q.cpp\n--- a/tests/test_mpmc_q.cpp\n+++ b/tests/test_mpmc_q.cpp\n@@ -43,6 +43,26 @@ TEST_CASE(\"dequeue-empty-wait\", \"[mpmc_blocking_q]\")\n     REQUIRE(delta_ms <= wait_ms + tolerance_wait);\n }\n \n+TEST_CASE(\"dequeue-full-nowait\", \"[mpmc_blocking_q]\")\n+{\n+    spdlog::details::mpmc_blocking_queue<int> q(1);\n+    q.enqueue(42);\n+\n+    int item = 0;\n+    q.dequeue_for(item, milliseconds::zero());\n+    REQUIRE(item == 42);\n+}\n+\n+TEST_CASE(\"dequeue-full-wait\", \"[mpmc_blocking_q]\")\n+{\n+    spdlog::details::mpmc_blocking_queue<int> q(1);\n+    q.enqueue(42);\n+\n+    int item = 0;\n+    q.dequeue(item);\n+    REQUIRE(item == 42);\n+}\n+\n TEST_CASE(\"enqueue_nowait\", \"[mpmc_blocking_q]\")\n {\n \n@@ -95,12 +115,12 @@ TEST_CASE(\"full_queue\", \"[mpmc_blocking_q]\")\n     for (int i = 1; i < static_cast<int>(q_size); i++)\n     {\n         int item = -1;\n-        q.dequeue_for(item, milliseconds(0));\n+        q.dequeue(item);\n         REQUIRE(item == i);\n     }\n \n     // last item pushed has overridden the oldest.\n     int item = -1;\n-    q.dequeue_for(item, milliseconds(0));\n+    q.dequeue(item);\n     REQUIRE(item == 123456);\n }\n", "problem_statement": "tsan false warnings for mpmc_blocking_queue::dequeue_for\ngcc 11.3.0 on Ubuntu 22.04 reports \"data race\" and \"double lock of a mutex\" for `mpmc_blocking_queue::dequeue_for`\r\n\r\nThis is most probably due to this gcc bug - https://gcc.gnu.org/bugzilla//show_bug.cgi?id=101978\r\n\r\nReplacing timed [wait_for](https://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/mpmc_blocking_q.h#L58) with `std::condition_variable::wait` avoids the tsan warnings.\r\n\r\nThis of course should be fixed in gcc, but I am curious what is the reason for wait_for in the first place? Do you see any issues with replacing `wait_for` with `wait`?\n", "hints_text": "This is because `mpmc_blocking_queue` is designed as a queue for the Producer-Consumer pattern (as described at the top of the header file).\r\n\r\nhttps://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/mpmc_blocking_q.h#L6-L11\r\n\r\nMany developers may want to allow the Consumer thread to perform other tasks while there are no messages in the queue.\r\nIt is a commonplace idea to implement a dequeue (pop) API with a timeout on the queue for this purpose.\nThe `mpmc_blocking_queue` is only used in `thread_pool` though, where the consumer thread does not perform any idle task. It unnecessarily wakes up the thread every 10s only to go back to waiting for the next message - https://github.com/gabime/spdlog/blob/edc51df1bdad8667b628999394a1e7c4dc6f3658/include/spdlog/details/thread_pool-inl.h#L114\r\n\r\nIf there is a desire for `mpmc_blocking_queue` to be a generic producer-consumer queue, may be we could add another blocking non-timed `dequeue` and use that in `thread_pool`? Unless I am missing some other reason for the timeout?\nI did not develop `thread_pool` so I don't know why it uses `dequeue_for()`.\r\n\r\nIf you think wakeup every 10 seconds is useless, you can create a PR, but I personally don't see the need to change the current implementation for the purpose of avoiding the compiler sanitizer bug.", "created_at": "2022-12-29T22:59:33Z", "version": "1.11"}
{"repo": "gabime/spdlog", "pull_number": 892, "instance_id": "gabime__spdlog-892", "issue_numbers": ["712"], "base_commit": "1aace95c8d14944358c0374bbda3ce44d759bef7", "patch": "diff --git a/include/spdlog/async.h b/include/spdlog/async.h\n--- a/include/spdlog/async.h\n+++ b/include/spdlog/async.h\n@@ -52,7 +52,7 @@ struct async_factory_impl\n \n         auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n         auto new_logger = std::make_shared<async_logger>(std::move(logger_name), std::move(sink), std::move(tp), OverflowPolicy);\n-        registry_inst.register_and_init(new_logger);\n+        registry_inst.initialize_logger(new_logger);\n         return new_logger;\n     }\n };\ndiff --git a/include/spdlog/details/registry.h b/include/spdlog/details/registry.h\n--- a/include/spdlog/details/registry.h\n+++ b/include/spdlog/details/registry.h\n@@ -47,13 +47,9 @@ class registry\n         loggers_[logger_name] = std::move(new_logger);\n     }\n \n-    void register_and_init(std::shared_ptr<logger> new_logger)\n+    void initialize_logger(std::shared_ptr<logger> new_logger)\n     {\n         std::lock_guard<std::mutex> lock(logger_map_mutex_);\n-        auto logger_name = new_logger->name();\n-        throw_if_exists_(logger_name);\n-\n-        // set the global formatter pattern\n         new_logger->set_formatter(formatter_->clone());\n \n         if (err_handler_)\n@@ -64,8 +60,11 @@ class registry\n         new_logger->set_level(level_);\n         new_logger->flush_on(flush_level_);\n \n-        // add to registry\n-        loggers_[logger_name] = std::move(new_logger);\n+        if (automatic_registration_)\n+        {\n+            throw_if_exists_(new_logger->name());\n+            loggers_[new_logger->name()] = std::move(new_logger);\n+        }\n     }\n \n     std::shared_ptr<logger> get(const std::string &logger_name)\n@@ -223,6 +222,12 @@ class registry\n         return tp_mutex_;\n     }\n \n+    void set_automatic_registration(bool automatic_regsistration)\n+    {\n+        std::lock_guard<std::mutex> lock(logger_map_mutex_);\n+        automatic_registration_ = automatic_regsistration;\n+    }\n+\n     static registry &instance()\n     {\n         static registry s_instance;\n@@ -269,6 +274,7 @@ class registry\n     std::shared_ptr<thread_pool> tp_;\n     std::unique_ptr<periodic_worker> periodic_flusher_;\n     std::shared_ptr<logger> default_logger_;\n+    bool automatic_registration_ = true;\n };\n \n } // namespace details\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -29,7 +29,7 @@ struct synchronous_factory\n     {\n         auto sink = std::make_shared<Sink>(std::forward<SinkArgs>(args)...);\n         auto new_logger = std::make_shared<logger>(std::move(logger_name), std::move(sink));\n-        details::registry::instance().register_and_init(new_logger);\n+        details::registry::instance().initialize_logger(new_logger);\n         return new_logger;\n     }\n };\n@@ -125,6 +125,12 @@ inline void shutdown()\n     details::registry::instance().shutdown();\n }\n \n+// Automatic registration of loggers when using spdlog::create() or spdlog::create_async\n+inline void set_automatic_registration(bool automatic_registation)\n+{\n+    details::registry::instance().set_automatic_registration(automatic_registation);\n+}\n+\n // API for using default logger (stdout_color_mt),\n // e.g: spdlog::info(\"Message {}\", 1);\n //\n", "test_patch": "diff --git a/tests/test_registry.cpp b/tests/test_registry.cpp\n--- a/tests/test_registry.cpp\n+++ b/tests/test_registry.cpp\n@@ -93,3 +93,20 @@ TEST_CASE(\"set_default_logger(nullptr)\", \"[registry]\")\n     spdlog::set_default_logger(nullptr);\n     REQUIRE_FALSE(spdlog::default_logger());\n }\n+\n+TEST_CASE(\"disable automatic registration\", \"[registry]\")\n+{\n+    // set some global parameters\n+    spdlog::level::level_enum log_level = spdlog::level::level_enum::warn;\n+    spdlog::set_level(log_level);\n+    // but disable automatic registration\n+    spdlog::set_automatic_registration(false);\n+    auto logger1 = spdlog::create<spdlog::sinks::daily_file_sink_st>(tested_logger_name, \"filename\", 11, 59);\n+    auto logger2 = spdlog::create_async<spdlog::sinks::stdout_color_sink_mt>(tested_logger_name2);\n+    // loggers should not be part of the registry\n+    REQUIRE_FALSE(spdlog::get(tested_logger_name));\n+    REQUIRE_FALSE(spdlog::get(tested_logger_name2));\n+    // but make sure they are still initialized according to global defaults\n+    REQUIRE(logger1->level() == log_level);\n+    REQUIRE(logger2->level() == log_level);\n+}\n", "problem_statement": "Create logger without automatic registration\nIt is treacherous that if one wants to create loggers on the spot or have loggers with the same name, they have to do manually everything that `create` does (choose async or not, set level, flush policy, etc). Same things for many other functions whose documentation starts with \"Create and register\"...\r\n\r\nPersonally I do not foresee a case when I will need to register my loggers, so automatic registration is just an impediment. \r\n\r\nSome proposition for backward compatible changes:\r\n- a global flag (`set_automatic_registration`) to disable registration in convenience functions\r\n- an optional argument added to `create` (and maybe every other function automatically registering)\r\n- extra functions which would not register, naming is tricky, `create_local` ? `create_noregister`?\r\n- have the constructor of `logger`lookup the different global variables like `create` does (most intuitive, but casting for `async_logger` would be an issue)\r\n... ?\r\n\n", "hints_text": "I think the first option would be the easiest. \nthat would be fine yes", "created_at": "2018-11-04T19:31:48Z", "version": "1.2"}
{"repo": "gabime/spdlog", "pull_number": 1422, "instance_id": "gabime__spdlog-1422", "issue_numbers": ["1247"], "base_commit": "4e643fa42c4c502993e79010eff72c5ed3c1319f", "patch": "diff --git a/example/CMakeLists.txt b/example/CMakeLists.txt\n--- a/example/CMakeLists.txt\n+++ b/example/CMakeLists.txt\n@@ -4,6 +4,8 @@\n cmake_minimum_required(VERSION 3.1)\n project(spdlog_examples CXX)\n \n+include(../cmake/utils.cmake)\n+\n if(NOT TARGET spdlog)\n     # Stand-alone build\n     find_package(spdlog REQUIRED)\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -1,5 +1,12 @@\n+cmake_minimum_required(VERSION 3.2)\n+\n project(spdlog_utests CXX)\n \n+if(NOT TARGET spdlog)\n+    # Stand-alone build\n+    find_package(spdlog REQUIRED)\n+endif()\n+\n include(../cmake/utils.cmake)\n \n find_package(PkgConfig)\n", "problem_statement": "Request: post installation runnable tests\nHello,\r\n\r\nI'm updating the spdlog package for Debian and I'm no longer easily able to run the tests against the installed headers due to the removal of the standalone `tests/Makefile`.\r\n\r\nHere is the current setup\r\n```\r\n# this is after copying the contents of the tests directory from the libspdlog-dev package to the # temporary working directory\r\ncmake -DSPDLOG_BUILD_TESTS=ON -DSPDLOG_BUILD_TESTS_HO=ON .\r\nmake CFLAGS=-DSPDLOG_FMT_EXTERNAL\r\nmake test\r\n```\r\n\r\nAnd the current result\r\n\r\n```\r\n-- The CXX compiler identification is GNU 9.2.1\r\n-- Check for working CXX compiler: /usr/bin/c++\r\n-- Check for working CXX compiler: /usr/bin/c++ -- works\r\n-- Detecting CXX compiler ABI info\r\n-- Detecting CXX compiler ABI info - done\r\n-- Detecting CXX compile features\r\n-- Detecting CXX compile features - done\r\n-- Found PkgConfig: /usr/bin/pkg-config (found version \"0.29\") \r\n-- Checking for module 'libsystemd'\r\n--   Found libsystemd, version 242\r\nCMake Warning (dev) in CMakeLists.txt:\r\n  No cmake_minimum_required command is present.  A line of code such as\r\n\r\n    cmake_minimum_required(VERSION 3.13)\r\n\r\n  should be added at the top of the file.  The version specified may be lower\r\n  if you wish to support older CMake versions for this project.  For more\r\n  information run \"cmake --help-policy CMP0000\".\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Configuring done\r\nCMake Warning (dev) at CMakeLists.txt:58 (add_executable):\r\n  Policy CMP0028 is not set: Double colon in target name means ALIAS or\r\n  IMPORTED target.  Run \"cmake --help-policy CMP0028\" for policy details.\r\n  Use the cmake_policy command to set the policy and suppress this warning.\r\n\r\n  Target \"spdlog-utests-ho\" links to target \"spdlog::spdlog_header_only\" but\r\n  the target was not found.  Perhaps a find_package() call is missing for an\r\n  IMPORTED target, or an ALIAS target is missing?\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Generating done\r\n-- Build files have been written to: /tmp/autopkgtest.u6TQBq/autopkgtest_tmp/tests\r\nScanning dependencies of target spdlog-utests\r\n[  2%] Building CXX object CMakeFiles/spdlog-utests.dir/test_file_helper.o\r\nIn file included from /usr/include/spdlog/common.h:38,\r\n                 from /usr/include/spdlog/spdlog.h:12,\r\n                 from /tmp/autopkgtest.u6TQBq/autopkgtest_tmp/tests/includes.h:17,\r\n                 from /tmp/autopkgtest.u6TQBq/autopkgtest_tmp/tests/test_file_helper.cpp:4:\r\n/usr/include/spdlog/fmt/fmt.h:22:10: fatal error: bundled/core.h: No such file or directory\r\n   22 | #include \"bundled/core.h\"\r\n      |          ^~~~~~~~~~~~~~~~\r\ncompilation terminated.\r\n```\r\n\r\n```\r\n\n", "hints_text": "Not sure I understand whats going on here,  but you probably need to pass the \u201c-DSPDLOG_FMT_EXTERNAL\u201d to the CMake command as well.\n`SPDLOG_FMT_EXTERNAL` is not an option for `tests/CMakeLists.txt`\r\n\r\n```\r\n$ cmake -DSPDLOG_BUILD_TESTS=ON -DSPDLOG_BUILD_TESTS_HO=ON -DSPDLOG_FMT_EXTERNAL=ON .\r\n-- The CXX compiler identification is GNU 9.2.1\r\n-- Check for working CXX compiler: /usr/bin/c++\r\n-- Check for working CXX compiler: /usr/bin/c++ -- works\r\n-- Detecting CXX compiler ABI info\r\n-- Detecting CXX compiler ABI info - done\r\n-- Detecting CXX compile features\r\n-- Detecting CXX compile features - done\r\n-- Found PkgConfig: /usr/bin/pkg-config (found version \"0.29\") \r\n-- Checking for module 'libsystemd'\r\n--   Found libsystemd, version 242\r\nCMake Warning (dev) in CMakeLists.txt:\r\n  No cmake_minimum_required command is present.  A line of code such as\r\n\r\n    cmake_minimum_required(VERSION 3.13)\r\n\r\n  should be added at the top of the file.  The version specified may be lower\r\n  if you wish to support older CMake versions for this project.  For more\r\n  information run \"cmake --help-policy CMP0000\".\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Configuring done\r\nCMake Warning (dev) at CMakeLists.txt:58 (add_executable):\r\n  Policy CMP0028 is not set: Double colon in target name means ALIAS or\r\n  IMPORTED target.  Run \"cmake --help-policy CMP0028\" for policy details.\r\n  Use the cmake_policy command to set the policy and suppress this warning.\r\n\r\n  Target \"spdlog-utests-ho\" links to target \"spdlog::spdlog_header_only\" but\r\n  the target was not found.  Perhaps a find_package() call is missing for an\r\n  IMPORTED target, or an ALIAS target is missing?\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n\r\n-- Generating done\r\nCMake Warning:\r\n  Manually-specified variables were not used by the project:\r\n\r\n    SPDLOG_FMT_EXTERNAL\r\n\r\n\r\n-- Build files have been written to: /tmp/autopkgtest.uxh3Fa/autopkgtest_tmp/tests\r\n$ make CFLAGS=-DSPDLOG_FMT_EXTERNAL spdlog-utests-ho spdlog-utests\r\nScanning dependencies of target spdlog-utests-ho\r\n[  5%] Building CXX object CMakeFiles/spdlog-utests-ho.dir/test_file_helper.o\r\nIn file included from /usr/include/spdlog/common.h:38,\r\n                 from /usr/include/spdlog/spdlog.h:12,\r\n                 from /tmp/autopkgtest.uxh3Fa/autopkgtest_tmp/tests/includes.h:17,\r\n                 from /tmp/autopkgtest.uxh3Fa/autopkgtest_tmp/tests/test_file_helper.cpp:4:\r\n/usr/include/spdlog/fmt/fmt.h:22:10: fatal error: bundled/core.h: No such file or directory\r\n   22 | #include \"bundled/core.h\"\r\n      |          ^~~~~~~~~~~~~~~~\r\ncompilation terminated.\r\n\r\n```\n> Target \"spdlog-utests-ho\" links to target \"spdlog::spdlog_header_only\" but\r\n  the target was not found.\r\n\r\nPerhaps the has something to do with this? To not setting right define(SPDLOG_FMT_EXTERNAL).\n> Perhaps the has something to do with this? To not setting right define(SPDLOG_FMT_EXTERNAL).\r\n\r\nI'm not clear as to what you are suggesting here\r\n\r\nAlso, can this issue be re-opened?\n@mr-c Where can I download and try the package for Debian ? Seems very old \n@gabime https://packages.debian.org/search?keywords=spdlog has the released packages The latest package is for 1.3.1, the January release\r\n\r\nThe current packaging source is at https://salsa.debian.org/med-team/spdlog", "created_at": "2020-02-07T14:41:08Z", "version": "1.5"}
{"repo": "gabime/spdlog", "pull_number": 789, "instance_id": "gabime__spdlog-789", "issue_numbers": ["783"], "base_commit": "f8f2d7b9505a68e15dd1a4bc0c3b8b6f5d36380c", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -14,15 +14,19 @@ include(GNUInstallDirs)\n #---------------------------------------------------------------------------------------\n set(CMAKE_CXX_STANDARD 11)\n set(CMAKE_CXX_STANDARD_REQUIRED ON)\n+set(CMAKE_CXX_EXTENSIONS OFF)\n \n if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\" OR \"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"Clang\")\n     set(CMAKE_CXX_FLAGS \"-Wall -O3 ${CMAKE_CXX_FLAGS}\")\n endif()\n \n+include(cmake/sanitizers.cmake)\n+\n #---------------------------------------------------------------------------------------\n # spdlog target\n #---------------------------------------------------------------------------------------\n add_library(spdlog INTERFACE)\n+add_library(spdlog::spdlog ALIAS spdlog)\n \n option(SPDLOG_BUILD_EXAMPLES \"Build examples\" OFF)\n cmake_dependent_option(SPDLOG_BUILD_TESTING\ndiff --git a/example/CMakeLists.txt b/example/CMakeLists.txt\n--- a/example/CMakeLists.txt\n+++ b/example/CMakeLists.txt\n@@ -24,10 +24,7 @@\n cmake_minimum_required(VERSION 3.1)\n project(SpdlogExamples CXX)\n \n-if(TARGET spdlog)\n-  # Part of the main project\n-  add_library(spdlog::spdlog ALIAS spdlog)\n-else()\n+if(NOT TARGET spdlog)\n   # Stand-alone build\n   find_package(spdlog CONFIG REQUIRED)\n endif()\n@@ -37,13 +34,10 @@ find_package(Threads REQUIRED)\n add_executable(example example.cpp)\n target_link_libraries(example spdlog::spdlog Threads::Threads)\n \n-add_executable(benchmark bench.cpp)\n-target_link_libraries(benchmark spdlog::spdlog Threads::Threads)\n-\n add_executable(multisink multisink.cpp)\n target_link_libraries(multisink spdlog::spdlog Threads::Threads)\n \n enable_testing()\n file(MAKE_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}/logs\")\n-add_test(NAME RunExample COMMAND example)\n-add_test(NAME RunBenchmark COMMAND benchmark)\n+add_test(NAME example COMMAND example)\n+add_test(NAME multisink COMMAND multisink)\ndiff --git a/example/multisink.cpp b/example/multisink.cpp\n--- a/example/multisink.cpp\n+++ b/example/multisink.cpp\n@@ -1,4 +1,4 @@\n-#include \"spdlog/sinks/file_sinks.h\"\n+#include \"spdlog/sinks/basic_file_sink.h\"\n #include \"spdlog/sinks/stdout_sinks.h\"\n #include \"spdlog/spdlog.h\"\n #include <iostream>\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -18,7 +18,7 @@ set(SPDLOG_UTESTS_SOURCES\n \n add_executable(${PROJECT_NAME} ${SPDLOG_UTESTS_SOURCES})\n target_link_libraries(${PROJECT_NAME} PRIVATE Threads::Threads)\n-target_link_libraries(${PROJECT_NAME} PRIVATE spdlog)\n+target_link_libraries(${PROJECT_NAME} PRIVATE spdlog::spdlog)\n \n add_test(NAME ${PROJECT_NAME} COMMAND ${PROJECT_NAME})\n file(MAKE_DIRECTORY \"${CMAKE_CURRENT_BINARY_DIR}/logs\")\n", "problem_statement": "Cannot find source file: bench.cpp\nin examples CMakeLists.txt was mentioned bench.cpp , but it is not in the folder.\n", "hints_text": "", "created_at": "2018-08-11T00:30:41Z", "version": "1.0"}
{"repo": "gabime/spdlog", "pull_number": 1771, "instance_id": "gabime__spdlog-1771", "issue_numbers": ["1770"], "base_commit": "adcfb7fb558cb2d3435f5d20edec2a61a5340361", "patch": "diff --git a/include/spdlog/sinks/wincolor_sink-inl.h b/include/spdlog/sinks/wincolor_sink-inl.h\n--- a/include/spdlog/sinks/wincolor_sink-inl.h\n+++ b/include/spdlog/sinks/wincolor_sink-inl.h\n@@ -7,22 +7,30 @@\n #include <spdlog/sinks/wincolor_sink.h>\n #endif\n \n+#include <spdlog/details/windows_include.h>\n+#include <wincon.h>\n+\n #include <spdlog/common.h>\n #include <spdlog/pattern_formatter.h>\n \n namespace spdlog {\n namespace sinks {\n-\n template<typename ConsoleMutex>\n-SPDLOG_INLINE wincolor_sink<ConsoleMutex>::wincolor_sink(HANDLE out_handle, color_mode mode)\n-    : out_handle_(out_handle)\n+SPDLOG_INLINE wincolor_sink<ConsoleMutex>::wincolor_sink(void *out_handle, color_mode mode)\n+    : BOLD(FOREGROUND_INTENSITY)\n+    , RED(FOREGROUND_RED)\n+    , GREEN(FOREGROUND_GREEN)\n+    , CYAN(FOREGROUND_GREEN | FOREGROUND_BLUE)\n+    , WHITE(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)\n+    , YELLOW(FOREGROUND_RED | FOREGROUND_GREEN)\n+    , out_handle_(out_handle)\n     , mutex_(ConsoleMutex::mutex())\n     , formatter_(details::make_unique<spdlog::pattern_formatter>())\n {\n     // check if out_handle is points to the actual console.\n     // ::GetConsoleMode() should return 0 if it is redirected or not valid console handle.\n     DWORD console_mode;\n-    in_console_ = ::GetConsoleMode(out_handle, &console_mode) != 0;\n+    in_console_ = ::GetConsoleMode(static_cast<HANDLE>(out_handle_), &console_mode) != 0;\n \n     set_color_mode(mode);\n     colors_[level::trace] = WHITE;\n@@ -42,7 +50,7 @@ SPDLOG_INLINE wincolor_sink<ConsoleMutex>::~wincolor_sink()\n \n // change the color for the given level\n template<typename ConsoleMutex>\n-void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color(level::level_enum level, WORD color)\n+void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color(level::level_enum level, std::uint16_t color)\n {\n     std::lock_guard<mutex_t> lock(mutex_);\n     colors_[level] = color;\n@@ -67,10 +75,10 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::log(const details::log_msg &msg)\n         print_range_(formatted, 0, msg.color_range_start);\n \n         // in color range\n-        auto orig_attribs = set_foreground_color_(colors_[msg.level]);\n+        auto orig_attribs = static_cast<WORD>(set_foreground_color_(colors_[msg.level]));\n         print_range_(formatted, msg.color_range_start, msg.color_range_end);\n         // reset to orig colors\n-        ::SetConsoleTextAttribute(out_handle_, orig_attribs);\n+        ::SetConsoleTextAttribute(static_cast<HANDLE>(out_handle_), orig_attribs);\n         print_range_(formatted, msg.color_range_end, formatted.size());\n     }\n     else // print without colors if color range is invalid (or color is disabled)\n@@ -118,16 +126,16 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_color_mode(color_mode mode)\n \n // set foreground color and return the orig console attributes (for resetting later)\n template<typename ConsoleMutex>\n-WORD SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_foreground_color_(WORD attribs)\n+std::uint16_t SPDLOG_INLINE wincolor_sink<ConsoleMutex>::set_foreground_color_(std::uint16_t attribs)\n {\n     CONSOLE_SCREEN_BUFFER_INFO orig_buffer_info;\n-    ::GetConsoleScreenBufferInfo(out_handle_, &orig_buffer_info);\n+    ::GetConsoleScreenBufferInfo(static_cast<HANDLE>(out_handle_), &orig_buffer_info);\n     WORD back_color = orig_buffer_info.wAttributes;\n     // retrieve the current background color\n     back_color &= static_cast<WORD>(~(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY));\n     // keep the background color unchanged\n-    ::SetConsoleTextAttribute(out_handle_, attribs | back_color);\n-    return orig_buffer_info.wAttributes; // return orig attribs\n+    ::SetConsoleTextAttribute(static_cast<HANDLE>(out_handle_), static_cast<WORD>(attribs) | back_color);\n+    return static_cast<std::uint16_t>(orig_buffer_info.wAttributes); // return orig attribs\n }\n \n // print a range of formatted message to console\n@@ -135,7 +143,7 @@ template<typename ConsoleMutex>\n void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::print_range_(const memory_buf_t &formatted, size_t start, size_t end)\n {\n     auto size = static_cast<DWORD>(end - start);\n-    ::WriteConsoleA(out_handle_, formatted.data() + start, size, nullptr, nullptr);\n+    ::WriteConsoleA(static_cast<HANDLE>(out_handle_), formatted.data() + start, size, nullptr, nullptr);\n }\n \n template<typename ConsoleMutex>\n@@ -147,7 +155,7 @@ void SPDLOG_INLINE wincolor_sink<ConsoleMutex>::write_to_file_(const memory_buf_\n     }\n     auto size = static_cast<DWORD>(formatted.size());\n     DWORD bytes_written = 0;\n-    bool ok = ::WriteFile(out_handle_, formatted.data(), size, &bytes_written, nullptr) != 0;\n+    bool ok = ::WriteFile(static_cast<HANDLE>(out_handle_), formatted.data(), size, &bytes_written, nullptr) != 0;\n     if (!ok)\n     {\n         throw_spdlog_ex(\"wincolor_sink: ::WriteFile() failed. GetLastError(): \" + std::to_string(::GetLastError()));\n@@ -165,6 +173,5 @@ template<typename ConsoleMutex>\n SPDLOG_INLINE wincolor_stderr_sink<ConsoleMutex>::wincolor_stderr_sink(color_mode mode)\n     : wincolor_sink<ConsoleMutex>(::GetStdHandle(STD_ERROR_HANDLE), mode)\n {}\n-\n } // namespace sinks\n } // namespace spdlog\ndiff --git a/include/spdlog/sinks/wincolor_sink.h b/include/spdlog/sinks/wincolor_sink.h\n--- a/include/spdlog/sinks/wincolor_sink.h\n+++ b/include/spdlog/sinks/wincolor_sink.h\n@@ -12,9 +12,7 @@\n #include <mutex>\n #include <string>\n #include <array>\n-\n-#include <spdlog/details/windows_include.h>\n-#include <wincon.h>\n+#include <cstdint>\n \n namespace spdlog {\n namespace sinks {\n@@ -26,21 +24,21 @@ template<typename ConsoleMutex>\n class wincolor_sink : public sink\n {\n public:\n-    const WORD BOLD = FOREGROUND_INTENSITY;\n-    const WORD RED = FOREGROUND_RED;\n-    const WORD GREEN = FOREGROUND_GREEN;\n-    const WORD CYAN = FOREGROUND_GREEN | FOREGROUND_BLUE;\n-    const WORD WHITE = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;\n-    const WORD YELLOW = FOREGROUND_RED | FOREGROUND_GREEN;\n-\n-    wincolor_sink(HANDLE out_handle, color_mode mode);\n+    const std::uint16_t BOLD;\n+    const std::uint16_t RED;\n+    const std::uint16_t GREEN;\n+    const std::uint16_t CYAN;\n+    const std::uint16_t WHITE;\n+    const std::uint16_t YELLOW;\n+\n+    wincolor_sink(void *out_handle, color_mode mode);\n     ~wincolor_sink() override;\n \n     wincolor_sink(const wincolor_sink &other) = delete;\n     wincolor_sink &operator=(const wincolor_sink &other) = delete;\n \n     // change the color for the given level\n-    void set_color(level::level_enum level, WORD color);\n+    void set_color(level::level_enum level, std::uint16_t color);\n     void log(const details::log_msg &msg) final override;\n     void flush() final override;\n     void set_pattern(const std::string &pattern) override final;\n@@ -49,15 +47,15 @@ class wincolor_sink : public sink\n \n protected:\n     using mutex_t = typename ConsoleMutex::mutex_t;\n-    HANDLE out_handle_;\n+    void *out_handle_;\n     mutex_t &mutex_;\n     bool in_console_;\n     bool should_do_colors_;\n     std::unique_ptr<spdlog::formatter> formatter_;\n-    std::array<WORD, level::n_levels> colors_;\n+    std::array<std::uint16_t, level::n_levels> colors_;\n \n     // set foreground color and return the orig console attributes (for resetting later)\n-    WORD set_foreground_color_(WORD attribs);\n+    std::uint16_t set_foreground_color_(std::uint16_t attribs);\n \n     // print a range of formatted message to console\n     void print_range_(const memory_buf_t &formatted, size_t start, size_t end);\n@@ -85,7 +83,6 @@ using wincolor_stdout_sink_st = wincolor_stdout_sink<details::console_nullmutex>\n \n using wincolor_stderr_sink_mt = wincolor_stderr_sink<details::console_mutex>;\n using wincolor_stderr_sink_st = wincolor_stderr_sink<details::console_nullmutex>;\n-\n } // namespace sinks\n } // namespace spdlog\n \n", "test_patch": "diff --git a/tests/utils.cpp b/tests/utils.cpp\n--- a/tests/utils.cpp\n+++ b/tests/utils.cpp\n@@ -1,6 +1,8 @@\n #include \"includes.h\"\n \n-#ifndef _WIN32\n+#ifdef _WIN32\n+#include <Windows.h>\n+#else\n #include <sys/types.h>\n #include <dirent.h>\n #endif\n", "problem_statement": "wincolor_sink pulls in windows.h even with SPDLOG_COMPILED_LIB defined\nI don't think it would be too hard to split the dependencies into the inline file. I could make a pr for it if you're okay with that.\n", "hints_text": "Sure, pr would be welcome.", "created_at": "2020-12-26T11:48:09Z", "version": "1.8"}
{"repo": "gabime/spdlog", "pull_number": 375, "instance_id": "gabime__spdlog-375", "issue_numbers": ["333"], "base_commit": "d7a8db8f6357856c7ac1eb3bde1f3a90a9ab9e0c", "patch": "diff --git a/example/example.cpp b/example/example.cpp\n--- a/example/example.cpp\n+++ b/example/example.cpp\n@@ -39,7 +39,7 @@ int main(int, char*[])\n \n \n         // Create basic file logger (not rotated)\n-        auto my_logger = spd::basic_logger_mt(\"basic_logger\", \"logs/basic.txt\");\n+        auto my_logger = spd::basic_logger_mt(\"basic_logger\", \"logs/basic\");\n         my_logger->info(\"Some log message\");\n \n         // Create a file rotating logger with 5mb size max and 3 rotated files\n@@ -106,7 +106,7 @@ void async_example()\n {\n     size_t q_size = 4096; //queue size must be power of 2\n     spdlog::set_async_mode(q_size);\n-    auto async_file = spd::daily_logger_st(\"async_file_logger\", \"logs/async_log.txt\");\n+    auto async_file = spd::daily_logger_st(\"async_file_logger\", \"logs/async_log\");\n \n     for (int i = 0; i < 100; ++i)\n         async_file->info(\"Async message #{}\", i);\ndiff --git a/include/spdlog/details/spdlog_impl.h b/include/spdlog/details/spdlog_impl.h\n--- a/include/spdlog/details/spdlog_impl.h\n+++ b/include/spdlog/details/spdlog_impl.h\n@@ -61,23 +61,23 @@ inline std::shared_ptr<spdlog::logger> spdlog::basic_logger_st(const std::string\n // Create multi/single threaded rotating file logger\n inline std::shared_ptr<spdlog::logger> spdlog::rotating_logger_mt(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files)\n {\n-    return create<spdlog::sinks::rotating_file_sink_mt>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), max_file_size, max_files);\n+    return create<spdlog::sinks::rotating_file_sink_mt>(logger_name, filename, max_file_size, max_files);\n }\n \n inline std::shared_ptr<spdlog::logger> spdlog::rotating_logger_st(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files)\n {\n-    return create<spdlog::sinks::rotating_file_sink_st>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), max_file_size, max_files);\n+    return create<spdlog::sinks::rotating_file_sink_st>(logger_name, filename, max_file_size, max_files);\n }\n \n // Create file logger which creates new file at midnight):\n inline std::shared_ptr<spdlog::logger> spdlog::daily_logger_mt(const std::string& logger_name, const filename_t& filename, int hour, int minute)\n {\n-    return create<spdlog::sinks::daily_file_sink_mt>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), hour, minute);\n+    return create<spdlog::sinks::daily_file_sink_mt>(logger_name, filename, hour, minute);\n }\n \n inline std::shared_ptr<spdlog::logger> spdlog::daily_logger_st(const std::string& logger_name, const filename_t& filename, int hour, int minute)\n {\n-    return create<spdlog::sinks::daily_file_sink_st>(logger_name, filename, SPDLOG_FILENAME_T(\"txt\"), hour, minute);\n+    return create<spdlog::sinks::daily_file_sink_st>(logger_name, filename, hour, minute);\n }\n \n \ndiff --git a/include/spdlog/sinks/file_sinks.h b/include/spdlog/sinks/file_sinks.h\n--- a/include/spdlog/sinks/file_sinks.h\n+++ b/include/spdlog/sinks/file_sinks.h\n@@ -64,16 +64,15 @@ template<class Mutex>\n class rotating_file_sink : public base_sink < Mutex >\n {\n public:\n-    rotating_file_sink(const filename_t &base_filename, const filename_t &extension,\n-                       std::size_t max_size, std::size_t max_files                       ) :\n+    rotating_file_sink(const filename_t &base_filename,\n+                       std::size_t max_size, std::size_t max_files) :\n         _base_filename(base_filename),\n-        _extension(extension),\n         _max_size(max_size),\n         _max_files(max_files),\n         _current_size(0),\n         _file_helper()\n     {\n-        _file_helper.open(calc_filename(_base_filename, 0, _extension));\n+        _file_helper.open(calc_filename(_base_filename, 0));\n         _current_size = _file_helper.size(); //expensive. called only once\n     }\n \n@@ -95,21 +94,21 @@ class rotating_file_sink : public base_sink < Mutex >\n     }\n \n private:\n-    static filename_t calc_filename(const filename_t& filename, std::size_t index, const filename_t& extension)\n+    static filename_t calc_filename(const filename_t& filename, std::size_t index)\n     {\n         std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;\n         if (index)\n-            w.write(SPDLOG_FILENAME_T(\"{}.{}.{}\"), filename, index, extension);\n+            w.write(SPDLOG_FILENAME_T(\"{}.{}\"), filename, index);\n         else\n-            w.write(SPDLOG_FILENAME_T(\"{}.{}\"), filename, extension);\n+            w.write(SPDLOG_FILENAME_T(\"{}\"), filename);\n         return w.str();\n     }\n \n     // Rotate files:\n-    // log.txt -> log.1.txt\n-    // log.1.txt -> log2.txt\n-    // log.2.txt -> log3.txt\n-    // log.3.txt -> delete\n+    // log.txt -> log.txt.1\n+    // log.txt.1 -> log.txt.2\n+    // log.txt.2 -> log.txt.3\n+    // lo3.txt.3 -> delete\n \n     void _rotate()\n     {\n@@ -117,8 +116,8 @@ class rotating_file_sink : public base_sink < Mutex >\n         _file_helper.close();\n         for (auto i = _max_files; i > 0; --i)\n         {\n-            filename_t src = calc_filename(_base_filename, i - 1, _extension);\n-            filename_t target = calc_filename(_base_filename, i, _extension);\n+            filename_t src = calc_filename(_base_filename, i - 1);\n+            filename_t target = calc_filename(_base_filename, i);\n \n             if (details::file_helper::file_exists(target))\n             {\n@@ -135,7 +134,6 @@ class rotating_file_sink : public base_sink < Mutex >\n         _file_helper.reopen(true);\n     }\n     filename_t _base_filename;\n-    filename_t _extension;\n     std::size_t _max_size;\n     std::size_t _max_files;\n     std::size_t _current_size;\n@@ -150,27 +148,27 @@ typedef rotating_file_sink<details::null_mutex>rotating_file_sink_st;\n  */\n struct default_daily_file_name_calculator\n {\n-    // Create filename for the form basename.YYYY-MM-DD_hh-mm.extension\n-    static filename_t calc_filename(const filename_t& basename, const filename_t& extension)\n+    // Create filename for the form basename.YYYY-MM-DD_hh-mm\n+    static filename_t calc_filename(const filename_t& basename)\n     {\n         std::tm tm = spdlog::details::os::localtime();\n         std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;\n-        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}.{}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, extension);\n+        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n         return w.str();\n     }\n };\n \n /*\n- * Generator of daily log file names in format basename.YYYY-MM-DD.extension\n+ * Generator of daily log file names in format basename.YYYY-MM-DD\n  */\n struct dateonly_daily_file_name_calculator\n {\n-    // Create filename for the form basename.YYYY-MM-DD.extension\n-    static filename_t calc_filename(const filename_t& basename, const filename_t& extension)\n+    // Create filename for the form basename.YYYY-MM-DD\n+    static filename_t calc_filename(const filename_t& basename)\n     {\n         std::tm tm = spdlog::details::os::localtime();\n         std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;\n-        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}.{}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, extension);\n+        w.write(SPDLOG_FILENAME_T(\"{}_{:04d}-{:02d}-{:02d}\"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n         return w.str();\n     }\n };\n@@ -185,17 +183,15 @@ class daily_file_sink :public base_sink < Mutex >\n     //create daily file sink which rotates on given time\n     daily_file_sink(\n         const filename_t& base_filename,\n-        const filename_t& extension,\n         int rotation_hour,\n         int rotation_minute) : _base_filename(base_filename),\n-        _extension(extension),\n         _rotation_h(rotation_hour),\n         _rotation_m(rotation_minute)\n     {\n         if (rotation_hour < 0 || rotation_hour > 23 || rotation_minute < 0 || rotation_minute > 59)\n             throw spdlog_ex(\"daily_file_sink: Invalid rotation time in ctor\");\n         _rotation_tp = _next_rotation_tp();\n-        _file_helper.open(FileNameCalc::calc_filename(_base_filename, _extension));\n+        _file_helper.open(FileNameCalc::calc_filename(_base_filename));\n     }\n \n     void flush() override\n@@ -208,7 +204,7 @@ class daily_file_sink :public base_sink < Mutex >\n     {\n         if (std::chrono::system_clock::now() >= _rotation_tp)\n         {\n-            _file_helper.open(FileNameCalc::calc_filename(_base_filename, _extension));\n+            _file_helper.open(FileNameCalc::calc_filename(_base_filename));\n             _rotation_tp = _next_rotation_tp();\n         }\n         _file_helper.write(msg);\n@@ -231,7 +227,6 @@ class daily_file_sink :public base_sink < Mutex >\n     }\n \n     filename_t _base_filename;\n-    filename_t _extension;\n     int _rotation_h;\n     int _rotation_m;\n     std::chrono::system_clock::time_point _rotation_tp;\ndiff --git a/include/spdlog/spdlog.h b/include/spdlog/spdlog.h\n--- a/include/spdlog/spdlog.h\n+++ b/include/spdlog/spdlog.h\n@@ -124,7 +124,7 @@ std::shared_ptr<logger> create(const std::string& logger_name, const It& sinks_b\n \n // Create and register a logger with templated sink type\n // Example:\n-// spdlog::create<daily_file_sink_st>(\"mylog\", \"dailylog_filename\", \"txt\");\n+// spdlog::create<daily_file_sink_st>(\"mylog\", \"dailylog_filename\");\n template <typename Sink, typename... Args>\n std::shared_ptr<spdlog::logger> create(const std::string& logger_name, Args...);\n \n", "test_patch": "diff --git a/tests/file_log.cpp b/tests/file_log.cpp\n--- a/tests/file_log.cpp\n+++ b/tests/file_log.cpp\n@@ -7,7 +7,7 @@\n TEST_CASE(\"simple_file_logger\", \"[simple_logger]]\")\n {\n     prepare_logdir();\n-    std::string filename = \"logs/simple_log.txt\";\n+    std::string filename = \"logs/simple_log\";\n \n     auto logger = spdlog::create<spdlog::sinks::simple_file_sink_mt>(\"logger\", filename);\n     logger->set_pattern(\"%v\");\n@@ -24,7 +24,7 @@ TEST_CASE(\"simple_file_logger\", \"[simple_logger]]\")\n TEST_CASE(\"flush_on\", \"[flush_on]]\")\n {\n     prepare_logdir();\n-    std::string filename = \"logs/simple_log.txt\";\n+    std::string filename = \"logs/simple_log\";\n \n     auto logger = spdlog::create<spdlog::sinks::simple_file_sink_mt>(\"logger\", filename);\n     logger->set_pattern(\"%v\");\n@@ -50,7 +50,7 @@ TEST_CASE(\"rotating_file_logger1\", \"[rotating_logger]]\")\n         logger->info(\"Test message {}\", i);\n \n     logger->flush();\n-    auto filename = basename + \".txt\";\n+    auto filename = basename;\n     REQUIRE(count_lines(filename) == 10);\n }\n \n@@ -64,14 +64,14 @@ TEST_CASE(\"rotating_file_logger2\", \"[rotating_logger]]\")\n         logger->info(\"Test message {}\", i);\n \n     logger->flush();\n-    auto filename = basename + \".txt\";\n+    auto filename = basename;\n     REQUIRE(count_lines(filename) == 10);\n     for (int i = 0; i < 1000; i++)\n         logger->info(\"Test message {}\", i);\n \n     logger->flush();\n     REQUIRE(get_filesize(filename) <= 1024);\n-    auto filename1 = basename + \".1.txt\";\n+    auto filename1 = basename + \".1\";\n     REQUIRE(get_filesize(filename1) <= 1024);\n }\n \n@@ -83,7 +83,7 @@ TEST_CASE(\"daily_logger\", \"[daily_logger]]\")\n     std::string basename = \"logs/daily_log\";\n     std::tm tm = spdlog::details::os::localtime();\n     fmt::MemoryWriter w;\n-    w.write(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}.txt\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n+    w.write(\"{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n \n     auto logger = spdlog::daily_logger_mt(\"logger\", basename, 0, 0);\n     logger->flush_on(spdlog::level::info);\n@@ -106,9 +106,9 @@ TEST_CASE(\"daily_logger with dateonly calculator\", \"[daily_logger_dateonly]]\")\n     std::string basename = \"logs/daily_dateonly\";\n     std::tm tm = spdlog::details::os::localtime();\n     fmt::MemoryWriter w;\n-    w.write(\"{}_{:04d}-{:02d}-{:02d}.txt\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n+    w.write(\"{}_{:04d}-{:02d}-{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n \n-    auto logger = spdlog::create<sink_type>(\"logger\", basename, \"txt\", 0, 0);\n+    auto logger = spdlog::create<sink_type>(\"logger\", basename, 0, 0);\n     for (int i = 0; i < 10; ++i)\n         logger->info(\"Test message {}\", i);\n     logger->flush();\n@@ -118,11 +118,11 @@ TEST_CASE(\"daily_logger with dateonly calculator\", \"[daily_logger_dateonly]]\")\n \n struct custom_daily_file_name_calculator\n {\n-    static spdlog::filename_t calc_filename(const spdlog::filename_t& basename, const spdlog::filename_t& extension)\n+    static spdlog::filename_t calc_filename(const spdlog::filename_t& basename)\n     {\n         std::tm tm = spdlog::details::os::localtime();\n         fmt::MemoryWriter w;\n-        w.write(\"{}{:04d}{:02d}{:02d}.{}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, extension);\n+        w.write(\"{}{:04d}{:02d}{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n         return w.str();\n     }\n };\n@@ -138,9 +138,9 @@ TEST_CASE(\"daily_logger with custom calculator\", \"[daily_logger_custom]]\")\n     std::string basename = \"logs/daily_dateonly\";\n     std::tm tm = spdlog::details::os::localtime();\n     fmt::MemoryWriter w;\n-    w.write(\"{}{:04d}{:02d}{:02d}.txt\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n+    w.write(\"{}{:04d}{:02d}{:02d}\", basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);\n \n-    auto logger = spdlog::create<sink_type>(\"logger\", basename, \"txt\", 0, 0);\n+    auto logger = spdlog::create<sink_type>(\"logger\", basename, 0, 0);\n     for (int i = 0; i < 10; ++i)\n         logger->info(\"Test message {}\", i);\n \n", "problem_statement": "Unexpected appending of \"txt\" at the end of a log filename\nI was confused by the usage of the filename parameter for `rotating_logger_mt`. It's called `filename`, so I interpreted that as being the absolute path to the file. Instead, it seems like `.txt` is appended onto the end of whatever is provided, so I ended up getting something like `mylog.txt.txt`. Is there a reason that the extension is hardcoded to `.txt`? Why not allow the entire filename to be specified by the caller?\r\n\r\nAs a result of this behaviour, I have to implement two functions in my code: one to output the desired log filename *without* an extension (to provide to `spdlog`), and one to output the log filename *with* an extension (when I want to operate on the log file myself).\n", "hints_text": "+1\nThe intention was to try to keep the extension for the rotated files. Maybe this it is not really needed (i.e. rotated log files would be just named log.txt.1, log.txt.2) and maybe there is a better way to achieve this. I will happy to consider alternative ways.\r\n\r\nA possible fix would be to ignore the extension if it is empty string\r\n\r\n\nhi @gabime , looking shortly into my /var/log - most logs just add number on the end of file i.e.\r\n<pre>\r\nfilename.ext\r\nfilename.ext.0\r\nfilename.ext.1\r\nfilename.ext.2\r\n</pre>\r\neventuelly, extra suffix is for rotated/compressed file i.e.:\r\n<pre>\r\nfilename.ext\r\nfilename.ext.0.xz\r\nfilename.ext.1.xz\r\nfilename.ext.2.xz\r\n</pre>\r\n\r\nI vote for rotating file and let user use plain filename or filename with extension.\nYes, I think you are right. It would also simplify things a little which is always good..\nI can try create a PR  (?)\nSure. Please do", "created_at": "2017-02-28T00:01:12Z", "version": "0.12"}
