{"repo": "catchorg/Catch2", "pull_number": 1448, "instance_id": "catchorg__Catch2-1448", "issue_numbers": ["1436"], "base_commit": "62460fafe6b54c3173bc5cbc46d05a5f071017ff", "patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -11,6 +11,7 @@\n #include \"catch_uncaught_exceptions.h\"\n \n #include <cassert>\n+#include <stack>\n \n namespace Catch {\n \n@@ -60,19 +61,48 @@ namespace Catch {\n \n \n     Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {\n-        auto start = std::string::npos;\n-        for( size_t pos = 0; pos <= names.size(); ++pos ) {\n+        auto trimmed = [&] (size_t start, size_t end) {\n+            while (names[start] == ',' || isspace(names[start])) {\n+                ++start;\n+            }\n+            while (names[end] == ',' || isspace(names[end])) {\n+                --end;\n+            }\n+            return names.substr(start, end - start + 1);\n+        };\n+\n+        size_t start = 0;\n+        std::stack<char> openings;\n+        for (size_t pos = 0; pos < names.size(); ++pos) {\n             char c = names[pos];\n-            if( pos == names.size() || c == ' ' || c == '\\t' || c == ',' || c == ']' ) {\n-                if( start != std::string::npos ) {\n-                    m_messages.push_back( MessageInfo( macroName, lineInfo, resultType ) );\n-                    m_messages.back().message = names.substr( start, pos-start) + \" := \";\n-                    start = std::string::npos;\n+            switch (c) {\n+            case '[':\n+            case '{':\n+            case '(':\n+            // It is basically impossible to disambiguate between\n+            // comparison and start of template args in this context\n+//            case '<':\n+                openings.push(c);\n+                break;\n+            case ']':\n+            case '}':\n+            case ')':\n+//           case '>':\n+                openings.pop();\n+                break;\n+            case ',':\n+                if (start != pos && openings.size() == 0) {\n+                    m_messages.emplace_back(macroName, lineInfo, resultType);\n+                    m_messages.back().message = trimmed(start, pos);\n+                    m_messages.back().message += \" := \";\n+                    start = pos;\n                 }\n             }\n-            else if( c != '[' && c != ']' && start == std::string::npos )\n-                start = pos;\n         }\n+        assert(openings.size() == 0 && \"Mismatched openings\");\n+        m_messages.emplace_back(macroName, lineInfo, resultType);\n+        m_messages.back().message = trimmed(start, names.size() - 1);\n+        m_messages.back().message += \" := \";\n     }\n     Capturer::~Capturer() {\n         if ( !uncaught_exceptions() ){\n@@ -82,7 +112,7 @@ namespace Catch {\n         }\n     }\n \n-    void Capturer::captureValue( size_t index, StringRef value ) {\n+    void Capturer::captureValue( size_t index, std::string const& value ) {\n         assert( index < m_messages.size() );\n         m_messages[index].message += value;\n         m_resultCapture.pushScopedMessage( m_messages[index] );\ndiff --git a/include/internal/catch_message.h b/include/internal/catch_message.h\n--- a/include/internal/catch_message.h\n+++ b/include/internal/catch_message.h\n@@ -77,16 +77,16 @@ namespace Catch {\n         Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );\n         ~Capturer();\n \n-        void captureValue( size_t index, StringRef value );\n+        void captureValue( size_t index, std::string const& value );\n \n         template<typename T>\n-        void captureValues( size_t index, T&& value ) {\n+        void captureValues( size_t index, T const& value ) {\n             captureValue( index, Catch::Detail::stringify( value ) );\n         }\n \n         template<typename T, typename... Ts>\n-        void captureValues( size_t index, T&& value, Ts&&... values ) {\n-            captureValues( index, value );\n+        void captureValues( size_t index, T const& value, Ts const&... values ) {\n+            captureValue( index, Catch::Detail::stringify(value) );\n             captureValues( index+1, values... );\n         }\n     };\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -9,10 +9,6 @@\n #include \"catch.hpp\"\n #include <iostream>\n \n-#ifdef __clang__\n-#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n-#endif\n-\n TEST_CASE( \"INFO and WARN do not abort tests\", \"[messages][.]\" ) {\n     INFO( \"this is a \" << \"message\" );    // This should output the message if a failure occurs\n     WARN( \"this is a \" << \"warning\" );    // This should always output the message but then continue\n@@ -135,3 +131,60 @@ TEST_CASE( \"Pointers can be converted to strings\", \"[messages][.][approvals]\" )\n     WARN( \"actual address of p: \" << &p );\n     WARN( \"toString(p): \" << ::Catch::Detail::stringify( &p ) );\n }\n+\n+TEST_CASE( \"CAPTURE can deal with complex expressions\", \"[messages][capture]\" ) {\n+    int a = 1;\n+    int b = 2;\n+    int c = 3;\n+    CAPTURE( a, b, c, a + b, a+b, c > b, a == 1 );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wunused-value\" // In (1, 2), the \"1\" is unused ...\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-value\" // All the comma operators are side-effect free\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(push)\n+#pragma warning(disable:4709) // comma in indexing operator\n+#endif\n+\n+template <typename T1, typename T2>\n+struct helper_1436 {\n+    helper_1436(T1 t1, T2 t2):\n+        t1{ t1 },\n+        t2{ t2 }\n+    {}\n+    T1 t1;\n+    T2 t2;\n+};\n+\n+template <typename T1, typename T2>\n+std::ostream& operator<<(std::ostream& out, helper_1436<T1, T2> const& helper) {\n+    out << \"{ \" << helper.t1 << \", \" << helper.t2 << \" }\";\n+    return out;\n+}\n+\n+TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messages][capture]\") {\n+    CAPTURE(std::vector<int>{1, 2, 3}[0, 1, 2],\n+            std::vector<int>{1, 2, 3}[(0, 1)],\n+            std::vector<int>{1, 2, 3}[0]);\n+    CAPTURE((helper_1436<int, int>{12, -12}),\n+            (helper_1436<int, int>(-12, 12)));\n+    CAPTURE( (1, 2), (2, 3) );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic pop\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(pop)\n+#endif\n", "problem_statement": "Capturer destructor asserts due to bad expression parsing\nThe following asserts:\r\n\r\n```\r\nTEST_CASE(\"Explodes\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a + b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe following does not:\r\n```\r\nTEST_CASE(\"Works\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a+b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe assertion that fires:\r\nhttps://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L79\r\n\r\nThe issue appears to have been caused here: https://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L66\r\n\r\n\n", "hints_text": "Looks like you'd want to only count `,` instead of all whitespace as an argument delimiter, and also only when `,` appears at the top level (not nested within `[]`, `{}`, or `()`). You can count the nesting depth of each bracket type in one variable since mismatching brackets would cause the compilation to fail anyway.", "created_at": "2018-11-19T22:15:46Z", "version": "2.4"}