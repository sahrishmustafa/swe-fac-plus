{"repo": "catchorg/Catch2", "pull_number": 2986, "instance_id": "catchorg__Catch2-2986", "issue_numbers": ["2755"], "base_commit": "1de7d0ed7be47080f0f436bc88cac73d0af53006", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -79,8 +79,8 @@ add_subdirectory(src)\n \n # Build tests only if requested\n if(BUILD_TESTING AND CATCH_BUILD_TESTING AND NOT_SUBPROJECT)\n-  find_package(PythonInterp 3 REQUIRED)\n-  if(NOT PYTHONINTERP_FOUND)\n+  find_package(Python3 REQUIRED COMPONENTS Interpreter)\n+  if(NOT TARGET Python3::Interpreter)\n     message(FATAL_ERROR \"Python not found, but required for tests\")\n   endif()\n   set(CMAKE_FOLDER \"tests\")\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -342,10 +342,9 @@ set_tests_properties(FilteredSection::GeneratorsDontCauseInfiniteLoop-2\n     PASS_REGULAR_EXPRESSION \"All tests passed \\\\(4 assertions in 1 test case\\\\)\"\n )\n \n-# AppVeyor has a Python 2.7 in path, but doesn't have .py files as autorunnable\n add_test(NAME ApprovalTests\n   COMMAND\n-    ${PYTHON_EXECUTABLE}\n+    Python3::Interpreter\n     ${CATCH_DIR}/tools/scripts/approvalTests.py\n     $<TARGET_FILE:SelfTest>\n     \"${CMAKE_CURRENT_BINARY_DIR}\"\n@@ -408,7 +407,7 @@ set_tests_properties(TagAlias PROPERTIES\n   FAIL_REGULAR_EXPRESSION \"0 matching test cases\"\n )\n \n-add_test(NAME RandomTestOrdering COMMAND ${PYTHON_EXECUTABLE}\n+add_test(NAME RandomTestOrdering COMMAND Python3::Interpreter\n   ${CATCH_DIR}/tests/TestScripts/testRandomOrder.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(RandomTestOrdering\n   PROPERTIES\n@@ -417,7 +416,7 @@ set_tests_properties(RandomTestOrdering\n \n add_test(NAME CheckConvenienceHeaders\n   COMMAND\n-    ${PYTHON_EXECUTABLE} ${CATCH_DIR}/tools/scripts/checkConvenienceHeaders.py\n+    Python3::Interpreter ${CATCH_DIR}/tools/scripts/checkConvenienceHeaders.py\n )\n set_tests_properties(CheckConvenienceHeaders\n   PROPERTIES\n@@ -602,7 +601,7 @@ if(CATCH_ENABLE_CONFIGURE_TESTS)\n                     \"ExperimentalRedirect\")\n     add_test(NAME \"CMakeConfig::${testName}\"\n       COMMAND\n-        \"${PYTHON_EXECUTABLE}\" \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/testConfigure${testName}.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n+        Python3::Interpreter \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/testConfigure${testName}.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n     )\n     set_tests_properties(\"CMakeConfig::${testName}\"\n       PROPERTIES\n@@ -615,7 +614,7 @@ endif()\n if(CATCH_ENABLE_CMAKE_HELPER_TESTS)\n   add_test(NAME \"CMakeHelper::DiscoverTests\"\n     COMMAND\n-      \"${PYTHON_EXECUTABLE}\" \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/DiscoverTests/VerifyRegistration.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n+      Python3::Interpreter \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/DiscoverTests/VerifyRegistration.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n   )\n   set_tests_properties(\"CMakeHelper::DiscoverTests\"\n     PROPERTIES\ndiff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -5,7 +5,7 @@ message(STATUS \"Extra tests included\")\n \n add_test(\n   NAME TestShardingIntegration\n-  COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/tests/TestScripts/testSharding.py $<TARGET_FILE:SelfTest>\n+  COMMAND Python3::Interpreter ${CATCH_DIR}/tests/TestScripts/testSharding.py $<TARGET_FILE:SelfTest>\n )\n set_tests_properties(TestShardingIntegration\n   PROPERTIES\n@@ -114,7 +114,7 @@ target_compile_definitions(BazelReporter PRIVATE CATCH_CONFIG_BAZEL_SUPPORT)\n target_link_libraries(BazelReporter Catch2_buildall_interface)\n add_test(NAME CATCH_CONFIG_BAZEL_REPORTER-1\n   COMMAND\n-  \"${PYTHON_EXECUTABLE}\" \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporter> \"${CMAKE_CURRENT_BINARY_DIR}\"\n+  Python3::Interpreter \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporter> \"${CMAKE_CURRENT_BINARY_DIR}\"\n )\n set_tests_properties(CATCH_CONFIG_BAZEL_REPORTER-1\n   PROPERTIES\n@@ -126,7 +126,7 @@ add_executable(BazelReporterNoCatchConfig ${TESTS_DIR}/X30-BazelReporter.cpp)\n target_link_libraries(BazelReporterNoCatchConfig Catch2WithMain)\n add_test(NAME NO_CATCH_CONFIG_BAZEL_REPORTER-1\n   COMMAND\n-  \"${PYTHON_EXECUTABLE}\" \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporterNoCatchConfig> \"${CMAKE_CURRENT_BINARY_DIR}\"\n+  Python3::Interpreter \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporterNoCatchConfig> \"${CMAKE_CURRENT_BINARY_DIR}\"\n )\n set_tests_properties(NO_CATCH_CONFIG_BAZEL_REPORTER-1\n   PROPERTIES\n@@ -146,7 +146,7 @@ set_tests_properties(BazelEnv::TESTBRIDGE_TEST_ONLY\n \n add_test(NAME BazelEnv::Sharding\n   COMMAND\n-    \"${PYTHON_EXECUTABLE}\" \"${CATCH_DIR}/tests/TestScripts/testBazelSharding.py\"\n+    Python3::Interpreter \"${CATCH_DIR}/tests/TestScripts/testBazelSharding.py\"\n       $<TARGET_FILE:BazelReporterNoCatchConfig>\n       \"${CMAKE_CURRENT_BINARY_DIR}\"\n )\n@@ -222,7 +222,7 @@ add_executable(PartialTestCaseEvents ${TESTS_DIR}/X21-PartialTestCaseEvents.cpp)\n target_link_libraries(PartialTestCaseEvents PRIVATE Catch2WithMain)\n add_test(\n   NAME PartialTestCaseEvents\n-  COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/tests/TestScripts/testPartialTestCaseEvent.py $<TARGET_FILE:PartialTestCaseEvents>\n+  COMMAND Python3::Interpreter ${CATCH_DIR}/tests/TestScripts/testPartialTestCaseEvent.py $<TARGET_FILE:PartialTestCaseEvents>\n )\n set_tests_properties(PartialTestCaseEvents\n   PROPERTIES\n", "problem_statement": "Stop using deprecated FindPythonInterp module\n**Describe the bug**\r\nCMake 3.27 warns about the FindPythonInterp being deprecated and removed in newer releases. \r\n\r\n```\r\nCMake Warning (dev) at CMakeLists.txt:86 (find_package):\r\n  Policy CMP0148 is not set: The FindPythonInterp and FindPythonLibs modules\r\n  are removed.  Run \"cmake --help-policy CMP0148\" for policy details.  Use\r\n  the cmake_policy command to set the policy and suppress this warning.\r\n\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n```\r\n\r\nhttps://github.com/catchorg/Catch2/actions/runs/6679314592/job/18151308282#step:3:26\r\n\r\nCI shows this warning as well.\r\n\r\n**Expected behavior**\r\nFor there to be no `(dev)` warnings when configuring.\r\n\r\n**Additional context**\r\nI believe the fix is to use the `FindPython` module which has a particular component for the Python interpreter. This was added in CMake 3.12 yet the trunk branch currently only requires CMake 3.10. Raising the minimum CMake version would be reasonable and is unlikely to affect any users other than those still on Ubuntu 18 which by default ships 3.10.\r\n\n", "hints_text": "I don't want to push up the minimum cmake version just yet, instead there should be a version check to pick the right module.", "created_at": "2025-06-09T01:06:18Z"}
{"repo": "catchorg/Catch2", "pull_number": 2976, "instance_id": "catchorg__Catch2-2976", "issue_numbers": ["2955"], "base_commit": "4ff57aba42938478f8b626c0862409f6eb7548f0", "patch": "diff --git a/src/catch2/catch_session.cpp b/src/catch2/catch_session.cpp\n--- a/src/catch2/catch_session.cpp\n+++ b/src/catch2/catch_session.cpp\n@@ -33,14 +33,6 @@\n namespace Catch {\n \n     namespace {\n-        static constexpr int TestFailureExitCode = 42;\n-        static constexpr int UnspecifiedErrorExitCode = 1;\n-        static constexpr int AllTestsSkippedExitCode = 4;\n-        static constexpr int NoTestsRunExitCode = 2;\n-        static constexpr int UnmatchedTestSpecExitCode = 3;\n-        static constexpr int InvalidTestSpecExitCode = 5;\n-\n-\n         IEventListenerPtr createReporter(std::string const& reporterName, ReporterConfig&& config) {\n             auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, CATCH_MOVE(config));\n             CATCH_ENFORCE(reporter, \"No reporter registered with name: '\" << reporterName << '\\'');\ndiff --git a/src/catch2/catch_session.hpp b/src/catch2/catch_session.hpp\n--- a/src/catch2/catch_session.hpp\n+++ b/src/catch2/catch_session.hpp\n@@ -16,6 +16,14 @@\n \n namespace Catch {\n \n+    // TODO: Use C++17 `inline` variables\n+    constexpr int UnspecifiedErrorExitCode = 1;\n+    constexpr int NoTestsRunExitCode = 2;\n+    constexpr int UnmatchedTestSpecExitCode = 3;\n+    constexpr int AllTestsSkippedExitCode = 4;\n+    constexpr int InvalidTestSpecExitCode = 5;\n+    constexpr int TestFailureExitCode = 42;\n+\n     class Session : Detail::NonCopyable {\n     public:\n \n", "test_patch": "", "problem_statement": "Make exit codes available to users\n**Description**\nCurrently (catch2 v3.8.0) the exit codes are defined in an anonymous namespace inside `catch_session.cpp`. [permalink to github code](https://github.com/catchorg/Catch2/blob/914aeecfe23b1e16af6ea675a4fb5dbd5a5b8d0a/src/catch2/catch_session.cpp#L37)\n\n```cpp\nnamespace Catch {\n\n    namespace {\n        static constexpr int TestFailureExitCode = 42;\n        static constexpr int UnspecifiedErrorExitCode = 1;\n        static constexpr int AllTestsSkippedExitCode = 4;\n        static constexpr int NoTestsRunExitCode = 2;\n        static constexpr int UnmatchedTestSpecExitCode = 3;\n        static constexpr int InvalidTestSpecExitCode = 5;\n// more code\n    }\n}\n```\n\nWhen writing a user-defined main function that calls `auto const result = Catch::Session().run(argc, argv)`, it would be helpful to be able compare the returned `result` to the defined values.\nCurrently this is not possible as they are only inside the anonymous namespace, leading to internal linkage. Redefining the exit values in user code is not optimal.\n\nMy suggestion would be to define the exit codes in the `catch_session.hpp` header, so they are available to end-users.\n\n\n", "hints_text": "", "created_at": "2025-04-27T17:14:17Z"}
{"repo": "catchorg/Catch2", "pull_number": 2919, "instance_id": "catchorg__Catch2-2919", "issue_numbers": ["2915"], "base_commit": "fa43b77429ba76c462b1898d6cd2f2d7a9416b14", "patch": "diff --git a/src/catch2/matchers/catch_matchers_range_equals.hpp b/src/catch2/matchers/catch_matchers_range_equals.hpp\n--- a/src/catch2/matchers/catch_matchers_range_equals.hpp\n+++ b/src/catch2/matchers/catch_matchers_range_equals.hpp\n@@ -96,55 +96,64 @@ namespace Catch {\n          * Creates a matcher that checks if all elements in a range are equal\n          * to all elements in another range.\n          *\n-         * Uses `std::equal_to` to do the comparison\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike>\n+        template <typename RangeLike,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        std::enable_if_t<!Detail::is_matcher<RangeLike>::value,\n-                         RangeEqualsMatcher<RangeLike, std::equal_to<>>>\n-        RangeEquals( RangeLike&& range ) {\n-            return { CATCH_FORWARD( range ), std::equal_to<>{} };\n+        RangeEqualsMatcher<RangeLike, Equality>\n+        RangeEquals( RangeLike&& range,\n+                     Equality&& predicate = std::equal_to<>{} ) {\n+            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range.\n+         * to all elements in an initializer list.\n          *\n-         * Uses to provided predicate `predicate` to do the comparisons\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike, typename Equality>\n+        template <typename T,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        RangeEqualsMatcher<RangeLike, Equality>\n-        RangeEquals( RangeLike&& range, Equality&& predicate ) {\n-            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n+        RangeEqualsMatcher<std::initializer_list<T>, Equality>\n+        RangeEquals( std::initializer_list<T> range,\n+                     Equality&& predicate = std::equal_to<>{} ) {\n+            return { range, CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range, in some permutation\n+         * to all elements in another range, in some permutation.\n          *\n-         * Uses `std::equal_to` to do the comparison\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike>\n+        template <typename RangeLike,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        std::enable_if_t<\n-            !Detail::is_matcher<RangeLike>::value,\n-            UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>\n-        UnorderedRangeEquals( RangeLike&& range ) {\n-            return { CATCH_FORWARD( range ), std::equal_to<>{} };\n+        UnorderedRangeEqualsMatcher<RangeLike, Equality>\n+        UnorderedRangeEquals( RangeLike&& range,\n+                              Equality&& predicate = std::equal_to<>{} ) {\n+            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range, in some permutation.\n+         * to all elements in an initializer list, in some permutation.\n          *\n-         * Uses to provided predicate `predicate` to do the comparisons\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike, typename Equality>\n+        template <typename T,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        UnorderedRangeEqualsMatcher<RangeLike, Equality>\n-        UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) {\n-            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n+        UnorderedRangeEqualsMatcher<std::initializer_list<T>, Equality>\n+        UnorderedRangeEquals( std::initializer_list<T> range,\n+                              Equality&& predicate = std::equal_to<>{} ) {\n+            return { range, CATCH_FORWARD( predicate ) };\n         }\n     } // namespace Matchers\n } // namespace Catch\n", "test_patch": "diff --git a/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp b/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n--- a/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n+++ b/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n@@ -727,6 +727,15 @@ TEST_CASE( \"Usage of RangeEquals range matcher\", \"[matchers][templated][quantifi\n                       } ) );\n     }\n \n+    SECTION( \"Compare against std::initializer_list\" ) {\n+        const std::array<int, 3> array_a{ { 1, 2, 3 } };\n+\n+        REQUIRE_THAT( array_a, RangeEquals( { 1, 2, 3 } ) );\n+        REQUIRE_THAT( array_a, RangeEquals( { 2, 4, 6 }, []( int l, int r ) {\n+                          return l * 2 == r;\n+                      } ) );\n+    }\n+\n     SECTION(\"Check short-circuiting behaviour\") {\n         with_mocked_iterator_access<int> const mocked1{ 1, 2, 3, 4 };\n \n@@ -820,6 +829,16 @@ TEST_CASE( \"Usage of UnorderedRangeEquals range matcher\",\n \n         REQUIRE_THAT( needs_adl1, UnorderedRangeEquals( needs_adl2 ) );\n     }\n+\n+    SECTION( \"Compare against std::initializer_list\" ) {\n+        const std::array<int, 3> array_a{ { 1, 10, 20 } };\n+\n+        REQUIRE_THAT( array_a, UnorderedRangeEquals( { 10, 20, 1 } ) );\n+        REQUIRE_THAT( array_a,\n+                      UnorderedRangeEquals( { 11, 21, 2 }, []( int l, int r ) {\n+                          return std::abs( l - r ) <= 1;\n+                      } ) );\n+    }\n }\n \n /**\n", "problem_statement": "RangeEquals doesn't support literal std::initializer_list\nIt would often be useful to write something like this:\r\n```c++\r\n  const auto v = calculateSomeVectorOfInts();\r\n  CHECK_THAT(v, RangeEquals({1, 2, 3}));\r\n```\r\nThis doesn't compile. It can be made to compile by adding an overload to RangeEquals that takes a std::initializer_list. Would a PR adding such an overload have a chance of being accepted?\r\n\r\nIt's not a huge issue since there are workarounds, including any of these:\r\n```c++\r\n  const auto expected = {1, 2, 3};\r\n  CHECK_THAT(v, RangeEquals(expected));\r\n\r\n  CHECK_THAT(v, RangeEquals(std::vector{1, 2, 3}));\r\n\r\n  CHECK_THAT(v, RangeEquals(std::initializer_list<int>{1, 2, 3}));\r\n```\r\nStill, the convenience of writing the initializer_list inline without extra qualification would be nice.\n", "hints_text": "Sure, why not.", "created_at": "2024-10-12T15:21:56Z"}
{"repo": "catchorg/Catch2", "pull_number": 2855, "instance_id": "catchorg__Catch2-2855", "issue_numbers": ["1210"], "base_commit": "2bce3e276b5f859ac45c43f011ffed98d0325115", "patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -450,6 +450,13 @@ namespace Catch {\n         assertionEnded(CATCH_MOVE(result) );\n         resetAssertionInfo();\n \n+        // Best effort cleanup for sections that have not been destructed yet\n+        // Since this is a fatal error, we have not had and won't have the opportunity to destruct them properly\n+        while (!m_activeSections.empty()) {\n+            auto nl = m_activeSections.back()->nameAndLocation();\n+            SectionEndInfo endInfo{ SectionInfo(CATCH_MOVE(nl.location), CATCH_MOVE(nl.name)), {}, 0.0 };\n+            sectionEndedEarly(CATCH_MOVE(endInfo));\n+        }\n         handleUnfinishedSections();\n \n         // Recreate section for test case (as we will lose the one that was in scope)\n", "test_patch": "diff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -467,6 +467,18 @@ set_tests_properties(\n     PASS_REGULAR_EXPRESSION \"Errors occurred during startup!\"\n )\n \n+add_executable(ReportingCrashWithJunitReporter ${TESTS_DIR}/X36-ReportingCrashWithJunitReporter.cpp)\n+target_link_libraries(ReportingCrashWithJunitReporter PRIVATE Catch2::Catch2WithMain)\n+add_test(\n+  NAME Reporters::CrashInJunitReporter\n+  COMMAND ${CMAKE_COMMAND} -E env $<TARGET_FILE:ReportingCrashWithJunitReporter> --reporter JUnit\n+)\n+set_tests_properties(\n+    Reporters::CrashInJunitReporter\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"</testsuites>\"\n+    LABELS \"uses-signals\"\n+)\n \n add_executable(AssertionStartingEventGoesBeforeAssertionIsEvaluated\n   X20-AssertionStartingEventGoesBeforeAssertionIsEvaluated.cpp\ndiff --git a/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp b/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp\n@@ -0,0 +1,32 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+/**\\file\n+ * Checks that signals/SEH within open section does not hard crash JUnit\n+ * (or similar reporter) while we are trying to report fatal error.\n+ */\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+#include <csignal>\n+\n+// On Windows we need to send SEH and not signal to test the\n+// RunContext::handleFatalErrorCondition code path\n+#if defined( _MSC_VER )\n+#    include <windows.h>\n+#endif\n+\n+TEST_CASE( \"raises signal\" ) {\n+    SECTION( \"section\" ) {\n+#if defined( _MSC_VER )\n+        RaiseException( 0xC0000005, 0, 0, NULL );\n+#else\n+        std::raise( SIGILL );\n+#endif\n+    }\n+}\ndiff --git a/tools/misc/appveyorTestRunScript.bat b/tools/misc/appveyorTestRunScript.bat\n--- a/tools/misc/appveyorTestRunScript.bat\n+++ b/tools/misc/appveyorTestRunScript.bat\n@@ -5,7 +5,7 @@ reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug\\AutoExclusion\n cd Build\n if \"%CONFIGURATION%\"==\"Debug\" (\n   if \"%coverage%\"==\"1\" (\n-    ctest -j 2 -C %CONFIGURATION% -D ExperimentalMemCheck || exit /b !ERRORLEVEL!\n+    ctest -j 2 -C %CONFIGURATION% -D ExperimentalMemCheck -LE uses-signals || exit /b !ERRORLEVEL!\n     python ..\\tools\\misc\\appveyorMergeCoverageScript.py || exit /b !ERRORLEVEL!\n     codecov --root .. --no-color --disable gcov -f cobertura.xml -t %CODECOV_TOKEN% || exit /b !ERRORLEVEL!\n   ) else (\n", "problem_statement": "virtual void Catch::CumulativeReporterBase::testCaseEnded(const Catch::TestCaseStats&):  Assertion `m_sectionStack.size() == 0' failed\n## Description\r\nI am getting this error sometimes in CI.\r\n```\r\ntestd: /build/agent-2/FAL-BS-JOB1/third-party/catch-1.9.3/catch.hpp:9611: \r\nvirtual void Catch::CumulativeReporterBase::testCaseEnded(const Catch::TestCaseStats&): \r\nAssertion `m_sectionStack.size() == 0' failed.\r\n```\r\nRerunning the job fixes the problem.  \r\n\r\nThis was mentioned in a comment to #663.\r\n\r\n### Extra information\r\n* Catch command line options: **-r junit -o testresults.xml**\r\n* Catch version: **v1.9.3**\r\n* Operating System: **RHEL 4.9**\r\n* Compiler+version: **g++ 5.3**\r\n\n", "hints_text": "This is happening almost all the time now\nDo you have a reliable repro, or is it still an intermittent thing? The JUnit reporter is ran multiple times on each commit and it doesn't reproduce with our tests, so it's hard to tell what is going on.\nI will work on a repro\nI'm using `-fno-exceptions` and see the same problem; this reproduces the problem for me:\r\na.cpp:\r\n```C++\r\n#define CATCH_CONFIG_MAIN\r\n#include \"catch2/catch.hpp\"\r\n\r\nTEST_CASE(\"doomed\", \"[tag]\") {\r\n\r\n  SECTION(\"only section\") {\r\n    REQUIRE(false);\r\n  }\r\n}\r\n```\r\n    > g++ --version\r\n    g++ (GCC) 7.3.0\r\n    Copyright (C) 2017 Free Software Foundation, Inc.\r\n    This is free software; see the source for copying conditions.  There is NO\r\n    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n    > g++ -fno-exceptions -I../Catch2/single_include a.cpp\r\n    > ./a.out -r junit\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    terminate called without an active exception\r\n    <testsuitesa.out: ../Catch2/single_include/catch2/catch.hpp:4463: void Catch::CumulativeReporterBase<DerivedT>::testCaseEnded(const Catch::TestCaseStats&) [with DerivedT = Catch::JunitReporter]: Assertion `m_sectionStack.size() == 0' failed.\r\n    Aborted (core dumped)\r\n\n@sd-x That's actually quite useful, thanks.\nSeeing this also in my CI sometimes.\r\n\nI'm seeing this pretty regularly, but not 100% consistently, on our windows builds. We don't have exceptions disabled or anything. Is the recommended workaround to stop using SECTIONs?\r\n\r\nfor reference, also using junit. seems to be a common factor in these reports.\nOur GitLab CI just ran into the same or a very similar issue, the exact assertion error in our case is\r\n```\r\nAssertion failed: m_sectionStack.size() == 0, file catch.hpp, line 5859\r\n```\r\n\r\nWe are also running on Windows and using the JUnit reporter. Catch version v2.11.1, MSVC 16.5. The issue disappeared after rerunning.\nProbably I found one possible scenario, why it could happen #1967 \r\n\nMy problem was that I was dividing by zero which crashed on my Linux CI but did not crash on my macOS dev machine. A working stacktrace from Catch would have saved me 30 minutes of printf debugging!\nI am not too familiar with catch internals but here is what I assume is happening\r\n\r\nIn `RunContext::handleFatalErrorCondition`, `handleUnfinishedSections()`  is called:\r\nhttps://github.com/catchorg/Catch2/blob/029fe3b4609dd84cd939b73357f37bbb75bcf82f/src/catch2/internal/catch_run_context.cpp#L453\r\n\r\nIf I understand it correctly, running Sections are in `m_activeSections`, and when a Section's destructor is called with an active exception, that Section is moved to `m_unfinishedSections`. `handleUnfinishedSections()` then handles those Sections in `m_unfinishedSections`. However, if a signal is being handled, we have not and will not call the destructors for the Sections, which means, all those Sections are in `m_activeSections` and not `m_unfinishedSections`.\r\n\r\nMy (potentially very dirty) fix is the following before the call to `handleUnfinishedSections()`:\r\n```c++\r\nwhile (!m_activeSections.empty()) {\r\n    auto nl = m_activeSections.back()->nameAndLocation();\r\n    SectionEndInfo endInfo{ SectionInfo(nl.location, nl.name), {}, 0.0 };\r\n    sectionEndedEarly(CATCH_MOVE(endInfo));\r\n}\r\nhandleUnfinishedSections();\r\n```\r\n\r\nI move the Sections from `m_activeSections` to `m_unfinishedSections` in a best effort way as to not trigger the assertion later.\r\n\r\nBtw, here is a test case that reproduces the issue for me (with `--reporter JUnit`):\r\n```c++\r\nTEST_CASE(\"broken\") {\r\n   SECTION(\"section\") {\r\n      /// Use illegal cpu instruction\r\n      __asm__ __volatile__(\"ud2\" : : : \"memory\");\r\n   }\r\n}\r\n```\r\n\r\n", "created_at": "2024-04-15T11:26:37Z"}
{"repo": "catchorg/Catch2", "pull_number": 2849, "instance_id": "catchorg__Catch2-2849", "issue_numbers": ["2833"], "base_commit": "7ce35799767de7b9c6ba836c72e479c5f70219a3", "patch": "diff --git a/src/catch2/internal/catch_textflow.cpp b/src/catch2/internal/catch_textflow.cpp\n--- a/src/catch2/internal/catch_textflow.cpp\n+++ b/src/catch2/internal/catch_textflow.cpp\n@@ -26,117 +26,228 @@ namespace {\n         return std::memchr( chars, c, sizeof( chars ) - 1 ) != nullptr;\n     }\n \n-    bool isBoundary( std::string const& line, size_t at ) {\n-        assert( at > 0 );\n-        assert( at <= line.size() );\n-\n-        return at == line.size() ||\n-               ( isWhitespace( line[at] ) && !isWhitespace( line[at - 1] ) ) ||\n-               isBreakableBefore( line[at] ) ||\n-               isBreakableAfter( line[at - 1] );\n-    }\n-\n } // namespace\n \n namespace Catch {\n     namespace TextFlow {\n+        void AnsiSkippingString::preprocessString() {\n+            for ( auto it = m_string.begin(); it != m_string.end(); ) {\n+                // try to read through an ansi sequence\n+                while ( it != m_string.end() && *it == '\\033' &&\n+                        it + 1 != m_string.end() && *( it + 1 ) == '[' ) {\n+                    auto cursor = it + 2;\n+                    while ( cursor != m_string.end() &&\n+                            ( isdigit( *cursor ) || *cursor == ';' ) ) {\n+                        ++cursor;\n+                    }\n+                    if ( cursor == m_string.end() || *cursor != 'm' ) {\n+                        break;\n+                    }\n+                    // 'm' -> 0xff\n+                    *cursor = AnsiSkippingString::sentinel;\n+                    // if we've read an ansi sequence, set the iterator and\n+                    // return to the top of the loop\n+                    it = cursor + 1;\n+                }\n+                if ( it != m_string.end() ) {\n+                    ++m_size;\n+                    ++it;\n+                }\n+            }\n+        }\n+\n+        AnsiSkippingString::AnsiSkippingString( std::string const& text ):\n+            m_string( text ) {\n+            preprocessString();\n+        }\n+\n+        AnsiSkippingString::AnsiSkippingString( std::string&& text ):\n+            m_string( CATCH_MOVE( text ) ) {\n+            preprocessString();\n+        }\n+\n+        AnsiSkippingString::const_iterator AnsiSkippingString::begin() const {\n+            return const_iterator( m_string );\n+        }\n+\n+        AnsiSkippingString::const_iterator AnsiSkippingString::end() const {\n+            return const_iterator( m_string, const_iterator::EndTag{} );\n+        }\n+\n+        std::string AnsiSkippingString::substring( const_iterator begin,\n+                                                   const_iterator end ) const {\n+            // There's one caveat here to an otherwise simple substring: when\n+            // making a begin iterator we might have skipped ansi sequences at\n+            // the start. If `begin` here is a begin iterator, skipped over\n+            // initial ansi sequences, we'll use the true beginning of the\n+            // string. Lastly: We need to transform any chars we replaced with\n+            // 0xff back to 'm'\n+            auto str = std::string( begin == this->begin() ? m_string.begin()\n+                                                           : begin.m_it,\n+                                    end.m_it );\n+            std::transform( str.begin(), str.end(), str.begin(), []( char c ) {\n+                return c == AnsiSkippingString::sentinel ? 'm' : c;\n+            } );\n+            return str;\n+        }\n+\n+        void AnsiSkippingString::const_iterator::tryParseAnsiEscapes() {\n+            // check if we've landed on an ansi sequence, and if so read through\n+            // it\n+            while ( m_it != m_string->end() && *m_it == '\\033' &&\n+                    m_it + 1 != m_string->end() &&  *( m_it + 1 ) == '[' ) {\n+                auto cursor = m_it + 2;\n+                while ( cursor != m_string->end() &&\n+                        ( isdigit( *cursor ) || *cursor == ';' ) ) {\n+                    ++cursor;\n+                }\n+                if ( cursor == m_string->end() ||\n+                     *cursor != AnsiSkippingString::sentinel ) {\n+                    break;\n+                }\n+                // if we've read an ansi sequence, set the iterator and\n+                // return to the top of the loop\n+                m_it = cursor + 1;\n+            }\n+        }\n+\n+        void AnsiSkippingString::const_iterator::advance() {\n+            assert( m_it != m_string->end() );\n+            m_it++;\n+            tryParseAnsiEscapes();\n+        }\n+\n+        void AnsiSkippingString::const_iterator::unadvance() {\n+            assert( m_it != m_string->begin() );\n+            m_it--;\n+            // if *m_it is 0xff, scan back to the \\033 and then m_it-- once more\n+            // (and repeat check)\n+            while ( *m_it == AnsiSkippingString::sentinel ) {\n+                while ( *m_it != '\\033' ) {\n+                    assert( m_it != m_string->begin() );\n+                    m_it--;\n+                }\n+                // if this happens, we must have been a begin iterator that had\n+                // skipped over ansi sequences at the start of a string\n+                assert( m_it != m_string->begin() );\n+                assert( *m_it == '\\033' );\n+                m_it--;\n+            }\n+        }\n+\n+        static bool isBoundary( AnsiSkippingString const& line,\n+                                AnsiSkippingString::const_iterator it ) {\n+            return it == line.end() ||\n+                   ( isWhitespace( *it ) &&\n+                     !isWhitespace( *it.oneBefore() ) ) ||\n+                   isBreakableBefore( *it ) ||\n+                   isBreakableAfter( *it.oneBefore() );\n+        }\n \n         void Column::const_iterator::calcLength() {\n             m_addHyphen = false;\n             m_parsedTo = m_lineStart;\n+            AnsiSkippingString const& current_line = m_column.m_string;\n \n-            std::string const& current_line = m_column.m_string;\n-            if ( current_line[m_lineStart] == '\\n' ) {\n-                ++m_parsedTo;\n+            if ( m_parsedTo == current_line.end() ) {\n+                m_lineEnd = m_parsedTo;\n+                return;\n             }\n \n+            assert( m_lineStart != current_line.end() );\n+            if ( *m_lineStart == '\\n' ) { ++m_parsedTo; }\n+\n             const auto maxLineLength = m_column.m_width - indentSize();\n-            const auto maxParseTo = std::min(current_line.size(), m_lineStart + maxLineLength);\n-            while ( m_parsedTo < maxParseTo &&\n-                    current_line[m_parsedTo] != '\\n' ) {\n+            std::size_t lineLength = 0;\n+            while ( m_parsedTo != current_line.end() &&\n+                    lineLength < maxLineLength && *m_parsedTo != '\\n' ) {\n                 ++m_parsedTo;\n+                ++lineLength;\n             }\n \n             // If we encountered a newline before the column is filled,\n             // then we linebreak at the newline and consider this line\n             // finished.\n-            if ( m_parsedTo < m_lineStart + maxLineLength ) {\n-                m_lineLength = m_parsedTo - m_lineStart;\n+            if ( lineLength < maxLineLength ) {\n+                m_lineEnd = m_parsedTo;\n             } else {\n                 // Look for a natural linebreak boundary in the column\n                 // (We look from the end, so that the first found boundary is\n                 // the right one)\n-                size_t newLineLength = maxLineLength;\n-                while ( newLineLength > 0 && !isBoundary( current_line, m_lineStart + newLineLength ) ) {\n-                    --newLineLength;\n+                m_lineEnd = m_parsedTo;\n+                while ( lineLength > 0 &&\n+                        !isBoundary( current_line, m_lineEnd ) ) {\n+                    --lineLength;\n+                    --m_lineEnd;\n                 }\n-                while ( newLineLength > 0 &&\n-                        isWhitespace( current_line[m_lineStart + newLineLength - 1] ) ) {\n-                    --newLineLength;\n+                while ( lineLength > 0 &&\n+                        isWhitespace( *m_lineEnd.oneBefore() ) ) {\n+                    --lineLength;\n+                    --m_lineEnd;\n                 }\n \n-                // If we found one, then that is where we linebreak\n-                if ( newLineLength > 0 ) {\n-                    m_lineLength = newLineLength;\n-                } else {\n-                    // Otherwise we have to split text with a hyphen\n+                // If we found one, then that is where we linebreak, otherwise\n+                // we have to split text with a hyphen\n+                if ( lineLength == 0 ) {\n                     m_addHyphen = true;\n-                    m_lineLength = maxLineLength - 1;\n+                    m_lineEnd = m_parsedTo.oneBefore();\n                 }\n             }\n         }\n \n         size_t Column::const_iterator::indentSize() const {\n-            auto initial =\n-                m_lineStart == 0 ? m_column.m_initialIndent : std::string::npos;\n+            auto initial = m_lineStart == m_column.m_string.begin()\n+                               ? m_column.m_initialIndent\n+                               : std::string::npos;\n             return initial == std::string::npos ? m_column.m_indent : initial;\n         }\n \n-        std::string\n-        Column::const_iterator::addIndentAndSuffix( size_t position,\n-                                              size_t length ) const {\n+        std::string Column::const_iterator::addIndentAndSuffix(\n+            AnsiSkippingString::const_iterator start,\n+            AnsiSkippingString::const_iterator end ) const {\n             std::string ret;\n             const auto desired_indent = indentSize();\n-            ret.reserve( desired_indent + length + m_addHyphen );\n+            // ret.reserve( desired_indent + (end - start) + m_addHyphen );\n             ret.append( desired_indent, ' ' );\n-            ret.append( m_column.m_string, position, length );\n-            if ( m_addHyphen ) {\n-                ret.push_back( '-' );\n-            }\n+            // ret.append( start, end );\n+            ret += m_column.m_string.substring( start, end );\n+            if ( m_addHyphen ) { ret.push_back( '-' ); }\n \n             return ret;\n         }\n \n-        Column::const_iterator::const_iterator( Column const& column ): m_column( column ) {\n+        Column::const_iterator::const_iterator( Column const& column ):\n+            m_column( column ),\n+            m_lineStart( column.m_string.begin() ),\n+            m_lineEnd( column.m_string.begin() ),\n+            m_parsedTo( column.m_string.begin() ) {\n             assert( m_column.m_width > m_column.m_indent );\n             assert( m_column.m_initialIndent == std::string::npos ||\n                     m_column.m_width > m_column.m_initialIndent );\n             calcLength();\n-            if ( m_lineLength == 0 ) {\n-                m_lineStart = m_column.m_string.size();\n+            if ( m_lineStart == m_lineEnd ) {\n+                m_lineStart = m_column.m_string.end();\n             }\n         }\n \n         std::string Column::const_iterator::operator*() const {\n             assert( m_lineStart <= m_parsedTo );\n-            return addIndentAndSuffix( m_lineStart, m_lineLength );\n+            return addIndentAndSuffix( m_lineStart, m_lineEnd );\n         }\n \n         Column::const_iterator& Column::const_iterator::operator++() {\n-            m_lineStart += m_lineLength;\n-            std::string const& current_line = m_column.m_string;\n-            if ( m_lineStart < current_line.size() && current_line[m_lineStart] == '\\n' ) {\n-                m_lineStart += 1;\n+            m_lineStart = m_lineEnd;\n+            AnsiSkippingString const& current_line = m_column.m_string;\n+            if ( m_lineStart != current_line.end() && *m_lineStart == '\\n' ) {\n+                m_lineStart++;\n             } else {\n-                while ( m_lineStart < current_line.size() &&\n-                        isWhitespace( current_line[m_lineStart] ) ) {\n+                while ( m_lineStart != current_line.end() &&\n+                        isWhitespace( *m_lineStart ) ) {\n                     ++m_lineStart;\n                 }\n             }\n \n-            if ( m_lineStart != current_line.size() ) {\n-                calcLength();\n-            }\n+            if ( m_lineStart != current_line.end() ) { calcLength(); }\n             return *this;\n         }\n \n@@ -233,25 +344,25 @@ namespace Catch {\n             return os;\n         }\n \n-        Columns operator+(Column const& lhs, Column const& rhs) {\n+        Columns operator+( Column const& lhs, Column const& rhs ) {\n             Columns cols;\n             cols += lhs;\n             cols += rhs;\n             return cols;\n         }\n-        Columns operator+(Column&& lhs, Column&& rhs) {\n+        Columns operator+( Column&& lhs, Column&& rhs ) {\n             Columns cols;\n             cols += CATCH_MOVE( lhs );\n             cols += CATCH_MOVE( rhs );\n             return cols;\n         }\n \n-        Columns& operator+=(Columns& lhs, Column const& rhs) {\n+        Columns& operator+=( Columns& lhs, Column const& rhs ) {\n             lhs.m_columns.push_back( rhs );\n             return lhs;\n         }\n-        Columns& operator+=(Columns& lhs, Column&& rhs) {\n-            lhs.m_columns.push_back( CATCH_MOVE(rhs) );\n+        Columns& operator+=( Columns& lhs, Column&& rhs ) {\n+            lhs.m_columns.push_back( CATCH_MOVE( rhs ) );\n             return lhs;\n         }\n         Columns operator+( Columns const& lhs, Column const& rhs ) {\ndiff --git a/src/catch2/internal/catch_textflow.hpp b/src/catch2/internal/catch_textflow.hpp\n--- a/src/catch2/internal/catch_textflow.hpp\n+++ b/src/catch2/internal/catch_textflow.hpp\n@@ -20,6 +20,107 @@ namespace Catch {\n \n         class Columns;\n \n+        /**\n+         * Abstraction for a string with ansi escape sequences that\n+         * automatically skips over escapes when iterating. Only graphical\n+         * escape sequences are considered.\n+         *\n+         * Internal representation:\n+         * An escape sequence looks like \\033[39;49m\n+         * We need bidirectional iteration and the unbound length of escape\n+         * sequences poses a problem for operator-- To make this work we'll\n+         * replace the last `m` with a 0xff (this is a codepoint that won't have\n+         * any utf-8 meaning).\n+         */\n+        class AnsiSkippingString {\n+            std::string m_string;\n+            std::size_t m_size = 0;\n+\n+            // perform 0xff replacement and calculate m_size\n+            void preprocessString();\n+\n+        public:\n+            class const_iterator;\n+            using iterator = const_iterator;\n+            // note: must be u-suffixed or this will cause a \"truncation of\n+            // constant value\" warning on MSVC\n+            static constexpr char sentinel = static_cast<char>( 0xffu );\n+\n+            explicit AnsiSkippingString( std::string const& text );\n+            explicit AnsiSkippingString( std::string&& text );\n+\n+            const_iterator begin() const;\n+            const_iterator end() const;\n+\n+            size_t size() const { return m_size; }\n+\n+            std::string substring( const_iterator begin,\n+                                   const_iterator end ) const;\n+        };\n+\n+        class AnsiSkippingString::const_iterator {\n+            friend AnsiSkippingString;\n+            struct EndTag {};\n+\n+            const std::string* m_string;\n+            std::string::const_iterator m_it;\n+\n+            explicit const_iterator( const std::string& string, EndTag ):\n+                m_string( &string ), m_it( string.end() ) {}\n+\n+            void tryParseAnsiEscapes();\n+            void advance();\n+            void unadvance();\n+\n+        public:\n+            using difference_type = std::ptrdiff_t;\n+            using value_type = char;\n+            using pointer = value_type*;\n+            using reference = value_type&;\n+            using iterator_category = std::bidirectional_iterator_tag;\n+\n+            explicit const_iterator( const std::string& string ):\n+                m_string( &string ), m_it( string.begin() ) {\n+                tryParseAnsiEscapes();\n+            }\n+\n+            char operator*() const { return *m_it; }\n+\n+            const_iterator& operator++() {\n+                advance();\n+                return *this;\n+            }\n+            const_iterator operator++( int ) {\n+                iterator prev( *this );\n+                operator++();\n+                return prev;\n+            }\n+            const_iterator& operator--() {\n+                unadvance();\n+                return *this;\n+            }\n+            const_iterator operator--( int ) {\n+                iterator prev( *this );\n+                operator--();\n+                return prev;\n+            }\n+\n+            bool operator==( const_iterator const& other ) const {\n+                return m_it == other.m_it;\n+            }\n+            bool operator!=( const_iterator const& other ) const {\n+                return !operator==( other );\n+            }\n+            bool operator<=( const_iterator const& other ) const {\n+                return m_it <= other.m_it;\n+            }\n+\n+            const_iterator oneBefore() const {\n+                auto it = *this;\n+                return --it;\n+            }\n+        };\n+\n         /**\n          * Represents a column of text with specific width and indentation\n          *\n@@ -29,10 +130,11 @@ namespace Catch {\n          */\n         class Column {\n             // String to be written out\n-            std::string m_string;\n+            AnsiSkippingString m_string;\n             // Width of the column for linebreaking\n             size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;\n-            // Indentation of other lines (including first if initial indent is unset)\n+            // Indentation of other lines (including first if initial indent is\n+            // unset)\n             size_t m_indent = 0;\n             // Indentation of the first line\n             size_t m_initialIndent = std::string::npos;\n@@ -47,16 +149,19 @@ namespace Catch {\n \n                 Column const& m_column;\n                 // Where does the current line start?\n-                size_t m_lineStart = 0;\n+                AnsiSkippingString::const_iterator m_lineStart;\n                 // How long should the current line be?\n-                size_t m_lineLength = 0;\n+                AnsiSkippingString::const_iterator m_lineEnd;\n                 // How far have we checked the string to iterate?\n-                size_t m_parsedTo = 0;\n+                AnsiSkippingString::const_iterator m_parsedTo;\n                 // Should a '-' be appended to the line?\n                 bool m_addHyphen = false;\n \n                 const_iterator( Column const& column, EndTag ):\n-                    m_column( column ), m_lineStart( m_column.m_string.size() ) {}\n+                    m_column( column ),\n+                    m_lineStart( m_column.m_string.end() ),\n+                    m_lineEnd( column.m_string.end() ),\n+                    m_parsedTo( column.m_string.end() ) {}\n \n                 // Calculates the length of the current line\n                 void calcLength();\n@@ -66,8 +171,9 @@ namespace Catch {\n \n                 // Creates an indented and (optionally) suffixed string from\n                 // current iterator position, indentation and length.\n-                std::string addIndentAndSuffix( size_t position,\n-                                                size_t length ) const;\n+                std::string addIndentAndSuffix(\n+                    AnsiSkippingString::const_iterator start,\n+                    AnsiSkippingString::const_iterator end ) const;\n \n             public:\n                 using difference_type = std::ptrdiff_t;\n@@ -84,7 +190,8 @@ namespace Catch {\n                 const_iterator operator++( int );\n \n                 bool operator==( const_iterator const& other ) const {\n-                    return m_lineStart == other.m_lineStart && &m_column == &other.m_column;\n+                    return m_lineStart == other.m_lineStart &&\n+                           &m_column == &other.m_column;\n                 }\n                 bool operator!=( const_iterator const& other ) const {\n                     return !operator==( other );\n@@ -94,7 +201,7 @@ namespace Catch {\n \n             explicit Column( std::string const& text ): m_string( text ) {}\n             explicit Column( std::string&& text ):\n-                m_string( CATCH_MOVE(text)) {}\n+                m_string( CATCH_MOVE( text ) ) {}\n \n             Column& width( size_t newWidth ) & {\n                 assert( newWidth > 0 );\n@@ -125,7 +232,9 @@ namespace Catch {\n \n             size_t width() const { return m_width; }\n             const_iterator begin() const { return const_iterator( *this ); }\n-            const_iterator end() const { return { *this, const_iterator::EndTag{} }; }\n+            const_iterator end() const {\n+                return { *this, const_iterator::EndTag{} };\n+            }\n \n             friend std::ostream& operator<<( std::ostream& os,\n                                              Column const& col );\n", "test_patch": "diff --git a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n@@ -12,6 +12,7 @@\n #include <sstream>\n \n using Catch::TextFlow::Column;\n+using Catch::TextFlow::AnsiSkippingString;\n \n namespace {\n     static std::string as_written(Column const& c) {\n@@ -198,3 +199,202 @@ TEST_CASE( \"#1400 - TextFlow::Column wrapping would sometimes duplicate words\",\n             \"  in \\n\"\n             \"  convallis posuere, libero nisi ultricies orci, nec lobortis.\");\n }\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString skips ansi sequences\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+\n+    SECTION(\"basic string\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+\n+        SECTION( \"iterates forward\" ) {\n+            auto it = str.begin();\n+            CHECK(*it == 'a');\n+            ++it;\n+            CHECK(*it == 'b');\n+            ++it;\n+            CHECK(*it == 'c');\n+            ++it;\n+            CHECK(*it == 'd');\n+            ++it;\n+            CHECK(*it == 'e');\n+            ++it;\n+            CHECK(it == str.end());\n+        }\n+        SECTION( \"iterates backwards\" ) {\n+            auto it = str.end();\n+            --it;\n+            CHECK(*it == 'e');\n+            --it;\n+            CHECK(*it == 'd');\n+            --it;\n+            CHECK(*it == 'c');\n+            --it;\n+            CHECK(*it == 'b');\n+            --it;\n+            CHECK(*it == 'a');\n+            CHECK(it == str.begin());\n+        }\n+    }\n+\n+    SECTION( \"ansi escape sequences at the start\" ) {\n+        std::string text = \"\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"ansi escape sequences at the end\" ) {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\\033[38;2;98;174;239m\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"skips consecutive escapes\" ) {\n+        std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"handles incomplete ansi sequences\" ) {\n+        std::string text = \"a\\033[b\\033[30c\\033[30;d\\033[30;2e\";\n+        AnsiSkippingString str(text);\n+        CHECK(std::string(str.begin(), str.end()) == text);\n+    }\n+}\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString computes the size properly\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+    std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+    AnsiSkippingString str(text);\n+    CHECK(str.size() == 5);\n+}\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString substrings properly\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+    SECTION(\"basic test\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"a\\033[38;2;98;174;239mb\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38mc\\033[0md\\033[me\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+    SECTION(\"escapes at the start\") {\n+        std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38m\\033[38m\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+    SECTION(\"escapes at the end\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\\033[38m\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"a\\033[38;2;98;174;239mb\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38mc\\033[0md\\033[me\\033[38m\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+}\n+\n+TEST_CASE( \"TextFlow::Column skips ansi escape sequences\",\n+           \"[TextFlow][column][approvals]\" ) {\n+    std::string text = \"\\033[38;2;98;174;239m\\033[38;2;198;120;221mThe quick brown \\033[38;2;198;120;221mfox jumped over the lazy dog\\033[0m\";\n+    Column col(text);\n+\n+    SECTION( \"width=20\" ) {\n+        col.width( 20 );\n+        REQUIRE( as_written( col ) == \"\\033[38;2;98;174;239m\\033[38;2;198;120;221mThe quick brown \\033[38;2;198;120;221mfox\\n\"\n+                                      \"jumped over the lazy\\n\"\n+                                      \"dog\\033[0m\" );\n+    }\n+\n+    SECTION( \"width=80\" ) {\n+        col.width( 80 );\n+        REQUIRE( as_written( col ) == text );\n+    }\n+}\n", "problem_statement": "Handle ANSI escape sequences during text wrapping\n**Description**\r\n\r\nI'd like to provide diagnostic messages from a `Catch::Matchers::MatcherBase::describe` function that are colored with ANSI sequences, however Catch2's line wrapping interferes with this.\r\n\r\nWould a PR to update the line wrapping logic be welcomed?\r\n\r\n**Additional context**\r\n\r\nI have an assertion library that I'd like to provide a catch2 integration for. Without color codes, with my current attempt to make it work in Catch2, it looks like this:\r\n\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/4f410b0c-a0c4-472d-935a-37e0068770ba)\r\n\r\nHowever with color codes the lines are messed up and escape sequences are split in the middle:\r\n\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/a600caf7-f047-4c66-90cf-dd41f9eef258)\n", "hints_text": "", "created_at": "2024-03-29T20:16:51Z"}
{"repo": "catchorg/Catch2", "pull_number": 2839, "instance_id": "catchorg__Catch2-2839", "issue_numbers": ["2837"], "base_commit": "459ac8562b4f4b23280003beabeca910e823627a", "patch": "diff --git a/src/catch2/internal/catch_platform.hpp b/src/catch2/internal/catch_platform.hpp\n--- a/src/catch2/internal/catch_platform.hpp\n+++ b/src/catch2/internal/catch_platform.hpp\n@@ -11,6 +11,9 @@\n // See e.g.:\n // https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-18.1/TargetConditionals.h.auto.html\n #ifdef __APPLE__\n+#  ifndef __has_extension\n+#    define __has_extension(x) 0\n+#  endif\n #  include <TargetConditionals.h>\n #  if (defined(TARGET_OS_OSX) && TARGET_OS_OSX == 1) || \\\n       (defined(TARGET_OS_MAC) && TARGET_OS_MAC == 1)\n", "test_patch": "", "problem_statement": "Latest macOS system header causes compilation failures on GCC\n**Description**\r\nAfter recent developer tools update on macOS Sonoma (i.e. \"Command Line Tools for Xcode 15.3\"), some Catch2 headers fail to compile on GCC.\r\n\r\n**Test case**\r\n```\r\n// v2's `single_include/catch2/catch.hpp` includes `TargetConditionals.h`\r\n#include <catch2/catch.hpp>\r\n```\r\nand\r\n```\r\n// v3's `catch2/internal/catch_platform.hpp`, which is included by `catch2/catch_all.hpp`, includes `TargetConditionals.h`\r\n#include <catch2/catch_all.hpp>\r\n```\r\nfail to compile on GCC 13 or earlier, after updating to \"Command Line Tools for Xcode 15.3\". \r\n\r\n**Background**\r\n\"Command Line Tools for Xcode 15.3\" introduces a problematic code at Line 140 of `usr/include/TargetConditionals.h` (i.e. `MacOSX14.4.sdk/usr/include/TargetConditionals.h`):\r\n```\r\n#if !defined(__has_extension) || # !__has_extension(define_target_os_macros)\r\n```\r\nThis is problematic, since compilers without `__has_extension` support cause compilation failure with it. Notably, GCC does not support `__has_extension` until the next release (GCC 14).\r\n\r\n(I think this should be fixed upstream by Apple, but ...) it may make some sense to add guard for `__has_extension`:\r\n```\r\n#ifdef __APPLE__\r\n#  ifndef __has_extension\r\n#  define __has_extension(x) 0\r\n#  endif\r\n#  include <TargetConditionals.h>\r\n```\r\n\n", "hints_text": "Why does the compilation fail there? Is this a hard error?\nYes, that's hard errors. For example, on mac with the latest developer tools, this\r\n```\r\necho '#include <catch2/catch_all.hpp>' | g++-13 -xc++ -\r\n```\r\nproduces the following error messages\r\n```\r\nIn file included from catch2/internal/catch_platform.hpp:14,\r\n                 from catch2/internal/catch_compiler_capabilities.hpp:27,\r\n                 from catch2/benchmark/catch_benchmark.hpp:14,\r\n                 from catch2/benchmark/catch_benchmark_all.hpp:24,\r\n                 from catch2/catch_all.hpp:25,\r\n                 from <stdin>:1:\r\n/usr/include/TargetConditionals.h:140:50: error: missing binary operator before token \"(\"\r\n  140 | #if !defined(__has_extension) || !__has_extension(define_target_os_macros)\r\n```\r\nThe code `!__has_extension(define_target_os_macros)` causes compilation failure, because `__has_extension` is not supported/defined on GCC (until the next release of GCC).\nHmmm, yeah there was a reason why we are checking headers like this\r\n\r\n```cpp\r\n#if defined(__has_include)\r\n  #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)\r\n```\r\n\r\n\r\nI'll accept a PR that adds the workaround.\nThanks. I'll submit PR later.", "created_at": "2024-03-12T17:58:02Z"}
{"repo": "catchorg/Catch2", "pull_number": 2822, "instance_id": "catchorg__Catch2-2822", "issue_numbers": ["2792"], "base_commit": "f476bcb633b24870b7c0414b0caeb9e192f485e4", "patch": "diff --git a/src/catch2/internal/catch_random_integer_helpers.hpp b/src/catch2/internal/catch_random_integer_helpers.hpp\n--- a/src/catch2/internal/catch_random_integer_helpers.hpp\n+++ b/src/catch2/internal/catch_random_integer_helpers.hpp\n@@ -41,9 +41,8 @@ namespace Catch {\n         struct ExtendedMultResult {\n             T upper;\n             T lower;\n-            friend bool operator==( ExtendedMultResult const& lhs,\n-                                    ExtendedMultResult const& rhs ) {\n-                return lhs.upper == rhs.upper && lhs.lower == rhs.lower;\n+            bool operator==( ExtendedMultResult const& rhs ) const {\n+                return upper == rhs.upper && lower == rhs.lower;\n             }\n         };\n \n", "test_patch": "", "problem_statement": "Compiler problem with operator and include catch_all.hpp\n**Description**\r\nThere is a compiler error, when `#include <catch2/catch_all.hpp>` is included. \r\n\r\nError msg is: ` C2039: \"value\": is not an element of \"Catch::Detail::is_eq_comparable<LhsT,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,void>\"`\r\n\r\nSimple example when the error occurs:\r\n```cpp\r\n#include <catch2/catch_all.hpp>\r\n\r\nTEST_CASE(\"first\") {\r\n  REQUIRE(true);\r\n}\r\n````\r\nUsing the include `catch2/catch_test_macros.hpp`  instead of `catch2/catch_all.hpp` all is fine\r\n\r\n\r\n**Reproduction steps**\r\nIncluding `catch2/catch_all.hpp` in one of the catch internal tests (e.g. String.tests.cpp) reproduce this error too.\r\n\r\n**Platform information:**\r\n - OS: **Windows 10**\r\n - Compiler+version: **Visual Studio 2017 15.9.16**\r\n - SDK-Version: *10.0.17763.0*\r\n - Catch version: **v3.5.0** and **v3.5.1**\r\n\r\nUsing **v3.4.0** all is fine. \r\n\n", "hints_text": "The error can be reproduced, \r\n````cpp\r\n\r\n#include <catch2/catch_test_macros.hpp>\r\n\r\n\r\n\r\n#include <catch2/benchmark/catch_benchmark_all.hpp>\r\n#include <catch2/catch_approx.hpp>\r\n#include <catch2/catch_assertion_info.hpp>\r\n#include <catch2/catch_assertion_result.hpp>\r\n#include <catch2/catch_config.hpp>\r\n#include <catch2/catch_get_random_seed.hpp>\r\n#include <catch2/catch_message.hpp>\r\n#include <catch2/catch_section_info.hpp>\r\n#include <catch2/catch_session.hpp>\r\n#include <catch2/catch_tag_alias.hpp>\r\n#include <catch2/catch_tag_alias_autoregistrar.hpp>\r\n#include <catch2/catch_template_test_macros.hpp>\r\n#include <catch2/catch_test_case_info.hpp>\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <catch2/catch_test_spec.hpp>\r\n#include <catch2/catch_timer.hpp>\r\n#include <catch2/catch_tostring.hpp>\r\n#include <catch2/catch_totals.hpp>\r\n#include <catch2/catch_translate_exception.hpp>\r\n#include <catch2/catch_version.hpp>\r\n#include <catch2/catch_version_macros.hpp>\r\n\r\n\r\n// #include <catch2/generators/catch_generators_all.hpp>\r\n#include <catch2/generators/catch_generator_exception.hpp>\r\n#include <catch2/generators/catch_generators.hpp>\r\n#include <catch2/generators/catch_generators_adapters.hpp>\r\n// adding this include creates this error\r\n#include <catch2/generators/catch_generators_random.hpp>\r\n#include <catch2/generators/catch_generators_range.hpp>\r\n\r\n\r\nTEST_CASE(\"first\") {\r\n\tREQUIRE(true);\r\n\t//REQUIRE(5 <= 5);\r\n}\r\n````\r\nIn the combination of the above includes (as they are from _catch_all_) the error can be \"tuned on / off\" by include _catch_generators_random.hpp_\r\n\r\nCatch version: *v3.5.0*\nCan you reproduce this with a newer version of Visual Studio or does it only appear with VS 2017?\nI'v just tried VS 2017 till now. \r\n\r\nBut with the new Catch version: v3.5.2 I've get the Error C2039 also in the SelfTest of \r\n`RandomNumberGeneration.tests.cpp` \r\n````cpp\r\nTEST_CASE(\"Comparison ops\", \"[rng]\") {\r\n    using Catch::SimplePcg32;\r\n    REQUIRE(SimplePcg32{} == SimplePcg32{}); // C2039:  \"value\": is not an element of \"Catch::Detail::is_eq_comparable<LhsT,Catch::SimplePcg32,void>\"\tSelfTest\t...\\14.16.27023\\include\\type_traits\t74\t\r\n````\r\n\r\nWhen I reduce the header include to the following in `RandomNumberGeneration.tests.cpp`  and remove the rest of code, the Code compiles. Including `catch_random_integer_helpers.hpp` will create the error  C2039:\r\n````cpp\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <catch2/catch_template_test_macros.hpp>\r\n#include <catch2/internal/catch_floating_point_helpers.hpp>\r\n// #include <catch2/internal/catch_random_integer_helpers.hpp>\r\n#include <catch2/internal/catch_random_number_generator.hpp>\r\n// #include <catch2/internal/catch_random_seed_generation.hpp>\r\n// #include <catch2/internal/catch_uniform_floating_point_distribution.hpp>\r\n// #include <catch2/internal/catch_uniform_integer_distribution.hpp>\r\n#include <catch2/generators/catch_generators.hpp>\r\n#include <catch2/matchers/catch_matchers_range_equals.hpp>\r\n\r\nTEST_CASE(\"Comparison ops\", \"[rng]\") {\r\n    using Catch::SimplePcg32;\r\n    REQUIRE(SimplePcg32{} == SimplePcg32{});\r\n    REQUIRE(SimplePcg32{ 0 } != SimplePcg32{});\r\n    REQUIRE_FALSE(SimplePcg32{ 1 } == SimplePcg32{ 2 });\r\n    REQUIRE_FALSE(SimplePcg32{ 1 } != SimplePcg32{ 1 });\r\n}\r\n````\r\n\r\nCatch version: _v3.5.2_\n> Can you reproduce this with a newer version of Visual Studio or does it only appear with VS 2017?\r\n\r\nVerified with the SelfTest of Catch v3.5.2 - Checked with the other compiler Visual Studio locally:\r\nVisual Studio 2019 (v142)  SDK Version used 10.0.10240.0 - SUCCESS\r\nVisual Studio 2022 (v143)  SDK Version used 10.0.10240.0 - SUCCESS\r\nVisual Studio 2017 (v141)  SDK Version used 10.0.10240.0 - FAILED\r\n\r\nThe results for Visual Studio 2019 & Visual Studio 2022 where expected, since they are part of the *Windows builds* `windows-simple-builds.yml`.\r\n\r\n**Question** is, why is Visual Studio 2017 v141 not part of this test-builds. Is Visual Studio 2017not official supported any more?\r\n\r\n\r\nCatch version: _v3.5.2_ \n2017 is currently not supported. The support policy is C++14 + maybe reasonable workarounds. Since I haven't used 2017 since, ..., well, ever, I am not interested in figuring out a workaround for VS2017 to accept the new RNG code.\r\n\r\nIf you are interested in figuring it out, I can point you to `catch_random_integer_helpers.hpp`, which trigger the bug.\nHi horenmar,\r\nthanks for your replay. I can understand that not all compilers with their peculiarities can be supported.\r\nMay be it would be helpfull to define the supported compiler on the main project page.  \nIn the meantime I was able to narrow down the problem further. The compiler stumbles with the == operator of a template structure.\r\n````cpp\r\n#include <catch2/catch_test_macros.hpp>\r\n\r\nnamespace Catch {\r\n    namespace Detail {\r\n        template <typename T>\r\n        struct MyTemplate {\r\n            friend bool operator==( MyTemplate const& lhs,MyTemplate const& rhs ) { return false; }\r\n        };\r\n    } // namespace Detail\r\n} // namespace Catch\r\n\r\nnamespace Catch {\r\n    struct MyClass {\r\n        friend bool operator==( MyClass const& lhs, MyClass const& rhs ) { return false; }\r\n    };\r\n} // namespace Catch\r\n\r\nTEST_CASE( \"first\", \"[x]\" ) {\r\n    Catch::Detail::MyTemplate<std::uint64_t> aa; // comment this line to get rid of the error\r\n    CHECK_FALSE( std::string( \"Hallo\" ) == std::string( \"huhu\" ) );\r\n    Catch::MyClass a, b;\r\n    CHECK_FALSE( a == b ); // will generate compile error, when aa is defined\r\n}\r\n````\r\nThen comes CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( eq, == )\r\nin stumble.\r\nI couldn't solve the problem straight away. I'm not sure how to point the compiler in the right direction.\r\n\r\nA simple but unpleasant solution is to put the template struct/class in its own namespace, such as Catch::Detail::Internal. \r\n\r\nPuting all the code of the `catch_random_integer_helpers.hpp` in an inner namespace solved the problem and the code compiled and was usable. But I think that is not the desired strategy.\r\n\r\nHow about making the new RNG code deactivable using the CMAKE option? That would also mean Catch2 is usable with Visual Studio 2017.\nActually it looks like making the operator not-friend is sufficient: https://godbolt.org/z/783xW6jT5\n(I would be willing to merge that PR)", "created_at": "2024-02-23T00:06:23Z"}
{"repo": "catchorg/Catch2", "pull_number": 2821, "instance_id": "catchorg__Catch2-2821", "issue_numbers": ["2820"], "base_commit": "024cfb354211b40e368a66c40054d8881e26b8a8", "patch": "diff --git a/src/catch2/catch_approx.cpp b/src/catch2/catch_approx.cpp\n--- a/src/catch2/catch_approx.cpp\n+++ b/src/catch2/catch_approx.cpp\n@@ -25,7 +25,7 @@ bool marginComparison(double lhs, double rhs, double margin) {\n namespace Catch {\n \n     Approx::Approx ( double value )\n-    :   m_epsilon( std::numeric_limits<float>::epsilon()*100. ),\n+    :   m_epsilon( static_cast<double>(std::numeric_limits<float>::epsilon())*100. ),\n         m_margin( 0.0 ),\n         m_scale( 0.0 ),\n         m_value( value )\n", "test_patch": "", "problem_statement": "unnecessary double promotion generate warning. \n**Describe the bug**\r\nSmall MPUs have limited floating point units, for this reason we avoid double promotion.\r\nIf we try to compile Catch2 in our build pipeline with -Werror and -Wdouble-promotion, the build will fail.\r\n\r\n**Expected behavior**\r\n\r\nCatch2 should compile without warnings, helpful in the embedded world. \r\n\r\n**Reproduction steps**\r\n\r\nCompile Catch with GCC 12.3.0:\r\n\r\n```text\r\n/home/sven/work/Universal-LED-Driver/build-presets/EmulationDev/_deps/catch2-src/src/catch2/catch_approx.cpp: In constructor \u2018Catch::Approx::Approx(double)\u2019:\r\n/home/sven/work/Universal-LED-Driver/build-presets/EmulationDev/_deps/catch2-src/src/catch2/catch_approx.cpp:28:57: warning: implicit conversion from \u2018float\u2019 to \u2018double\u2019 to match other operand of binary expression [-Wdouble-promotion]\r\n   28 |     :   m_epsilon( std::numeric_limits<float>::epsilon()*100. ),\r\n```\r\n\r\n**Platform information:**\r\n\r\n - OS: **Linux**\r\n - Compiler+version: **GCC v12.3.0**\r\n - Catch version: **v3.4.0**\r\n\n", "hints_text": "", "created_at": "2024-02-21T10:45:29Z"}
{"repo": "catchorg/Catch2", "pull_number": 2817, "instance_id": "catchorg__Catch2-2817", "issue_numbers": ["2816"], "base_commit": "c3fd4eb17e28ace4d3d9df1fb0656f3975879709", "patch": "diff --git a/examples/210-Evt-EventListeners.cpp b/examples/210-Evt-EventListeners.cpp\n--- a/examples/210-Evt-EventListeners.cpp\n+++ b/examples/210-Evt-EventListeners.cpp\n@@ -385,8 +385,7 @@ struct MyListener : Catch::EventListenerBase {\n CATCH_REGISTER_LISTENER( MyListener )\n \n // Get rid of Wweak-tables\n-MyListener::~MyListener() {}\n-\n+MyListener::~MyListener() = default;\n \n // -----------------------------------------------------------------------\n // 3. Test cases:\ndiff --git a/examples/231-Cfg-OutputStreams.cpp b/examples/231-Cfg-OutputStreams.cpp\n--- a/examples/231-Cfg-OutputStreams.cpp\n+++ b/examples/231-Cfg-OutputStreams.cpp\n@@ -22,7 +22,7 @@ class out_buff : public std::stringbuf {\n     std::FILE* m_stream;\n public:\n     out_buff(std::FILE* stream):m_stream(stream) {}\n-    ~out_buff();\n+    ~out_buff() override;\n     int sync() override {\n         int ret = 0;\n         for (unsigned char c : str()) {\ndiff --git a/examples/232-Cfg-CustomMain.cpp b/examples/232-Cfg-CustomMain.cpp\n--- a/examples/232-Cfg-CustomMain.cpp\n+++ b/examples/232-Cfg-CustomMain.cpp\n@@ -35,7 +35,7 @@ int main(int argc, char** argv) {\n       return returnCode;\n \n   // if set on the command line then 'height' is now set at this point\n-  std::cout << \"height: \" << height << std::endl;\n+  std::cout << \"height: \" << height << '\\n';\n \n   return session.run();\n }\ndiff --git a/examples/300-Gen-OwnGenerator.cpp b/examples/300-Gen-OwnGenerator.cpp\n--- a/examples/300-Gen-OwnGenerator.cpp\n+++ b/examples/300-Gen-OwnGenerator.cpp\n@@ -21,7 +21,7 @@\n namespace {\n \n // This class shows how to implement a simple generator for Catch tests\n-class RandomIntGenerator : public Catch::Generators::IGenerator<int> {\n+class RandomIntGenerator final : public Catch::Generators::IGenerator<int> {\n     std::minstd_rand m_rand;\n     std::uniform_int_distribution<> m_dist;\n     int current_number;\ndiff --git a/examples/301-Gen-MapTypeConversion.cpp b/examples/301-Gen-MapTypeConversion.cpp\n--- a/examples/301-Gen-MapTypeConversion.cpp\n+++ b/examples/301-Gen-MapTypeConversion.cpp\n@@ -24,12 +24,12 @@ namespace {\n // Returns a line from a stream. You could have it e.g. read lines from\n // a file, but to avoid problems with paths in examples, we will use\n // a fixed stringstream.\n-class LineGenerator : public Catch::Generators::IGenerator<std::string> {\n+class LineGenerator final : public Catch::Generators::IGenerator<std::string> {\n     std::string m_line;\n     std::stringstream m_stream;\n public:\n-    LineGenerator() {\n-        m_stream.str(\"1\\n2\\n3\\n4\\n\");\n+    explicit LineGenerator( std::string const& lines ) {\n+        m_stream.str( lines );\n         if (!next()) {\n             Catch::Generators::Detail::throw_generator_exception(\"Couldn't read a single line\");\n         }\n@@ -49,18 +49,19 @@ std::string const& LineGenerator::get() const {\n // This helper function provides a nicer UX when instantiating the generator\n // Notice that it returns an instance of GeneratorWrapper<std::string>, which\n // is a value-wrapper around std::unique_ptr<IGenerator<std::string>>.\n-Catch::Generators::GeneratorWrapper<std::string> lines(std::string /* ignored for example */) {\n+Catch::Generators::GeneratorWrapper<std::string>\n+lines( std::string const& lines ) {\n     return Catch::Generators::GeneratorWrapper<std::string>(\n-        new LineGenerator()\n-    );\n+        new LineGenerator( lines ) );\n }\n \n } // end anonymous namespace\n \n \n TEST_CASE(\"filter can convert types inside the generator expression\", \"[example][generator]\") {\n-    auto num = GENERATE(map<int>([](std::string const& line) { return std::stoi(line); },\n-                                 lines(\"fake-file\")));\n+    auto num = GENERATE(\n+        map<int>( []( std::string const& line ) { return std::stoi( line ); },\n+                  lines( \"1\\n2\\n3\\n4\\n\" ) ) );\n \n     REQUIRE(num > 0);\n }\ndiff --git a/src/catch2/catch_message.cpp b/src/catch2/catch_message.cpp\n--- a/src/catch2/catch_message.cpp\n+++ b/src/catch2/catch_message.cpp\n@@ -91,6 +91,7 @@ namespace Catch {\n                     m_messages.back().message += \" := \";\n                     start = pos;\n                 }\n+            default:; // noop\n             }\n         }\n         assert(openings.empty() && \"Mismatched openings\");\ndiff --git a/src/catch2/catch_registry_hub.cpp b/src/catch2/catch_registry_hub.cpp\n--- a/src/catch2/catch_registry_hub.cpp\n+++ b/src/catch2/catch_registry_hub.cpp\n@@ -20,7 +20,6 @@\n #include <catch2/internal/catch_noncopyable.hpp>\n #include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n #include <catch2/internal/catch_move_and_forward.hpp>\n-#include <catch2/internal/catch_reporter_registry.hpp>\n \n #include <exception>\n \ndiff --git a/src/catch2/catch_tostring.cpp b/src/catch2/catch_tostring.cpp\n--- a/src/catch2/catch_tostring.cpp\n+++ b/src/catch2/catch_tostring.cpp\n@@ -54,13 +54,13 @@ namespace Detail {\n         }\n     } // end unnamed namespace\n \n-    std::string convertIntoString(StringRef string, bool escape_invisibles) {\n+    std::string convertIntoString(StringRef string, bool escapeInvisibles) {\n         std::string ret;\n         // This is enough for the \"don't escape invisibles\" case, and a good\n         // lower bound on the \"escape invisibles\" case.\n         ret.reserve(string.size() + 2);\n \n-        if (!escape_invisibles) {\n+        if (!escapeInvisibles) {\n             ret += '\"';\n             ret += string;\n             ret += '\"';\n@@ -138,7 +138,7 @@ std::string StringMaker<char const*>::convert(char const* str) {\n         return{ \"{null string}\" };\n     }\n }\n-std::string StringMaker<char*>::convert(char* str) {\n+std::string StringMaker<char*>::convert(char* str) { // NOLINT(readability-non-const-parameter)\n     if (str) {\n         return Detail::convertIntoString( str );\n     } else {\n@@ -235,8 +235,8 @@ std::string StringMaker<signed char>::convert(signed char value) {\n std::string StringMaker<char>::convert(char c) {\n     return ::Catch::Detail::stringify(static_cast<signed char>(c));\n }\n-std::string StringMaker<unsigned char>::convert(unsigned char c) {\n-    return ::Catch::Detail::stringify(static_cast<char>(c));\n+std::string StringMaker<unsigned char>::convert(unsigned char value) {\n+    return ::Catch::Detail::stringify(static_cast<char>(value));\n }\n \n int StringMaker<float>::precision = 5;\ndiff --git a/src/catch2/catch_tostring.hpp b/src/catch2/catch_tostring.hpp\n--- a/src/catch2/catch_tostring.hpp\n+++ b/src/catch2/catch_tostring.hpp\n@@ -279,11 +279,11 @@ namespace Catch {\n     };\n     template<>\n     struct StringMaker<signed char> {\n-        static std::string convert(signed char c);\n+        static std::string convert(signed char value);\n     };\n     template<>\n     struct StringMaker<unsigned char> {\n-        static std::string convert(unsigned char c);\n+        static std::string convert(unsigned char value);\n     };\n \n     template<>\ndiff --git a/src/catch2/internal/catch_commandline.cpp b/src/catch2/internal/catch_commandline.cpp\n--- a/src/catch2/internal/catch_commandline.cpp\n+++ b/src/catch2/internal/catch_commandline.cpp\n@@ -47,7 +47,7 @@ namespace Catch {\n                     line = trim(line);\n                     if( !line.empty() && !startsWith( line, '#' ) ) {\n                         if( !startsWith( line, '\"' ) )\n-                            line = '\"' + line + '\"';\n+                            line = '\"' + CATCH_MOVE(line) + '\"';\n                         config.testsOrTags.push_back( line );\n                         config.testsOrTags.emplace_back( \",\" );\n                     }\ndiff --git a/src/catch2/internal/catch_console_colour.cpp b/src/catch2/internal/catch_console_colour.cpp\n--- a/src/catch2/internal/catch_console_colour.cpp\n+++ b/src/catch2/internal/catch_console_colour.cpp\n@@ -230,21 +230,21 @@ namespace {\n \n namespace Catch {\n \n-    Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode implSelection,\n+    Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,\n                                                    IStream* stream ) {\n #if defined( CATCH_CONFIG_COLOUR_WIN32 )\n-        if ( implSelection == ColourMode::Win32 ) {\n+        if ( colourSelection == ColourMode::Win32 ) {\n             return Detail::make_unique<Win32ColourImpl>( stream );\n         }\n #endif\n-        if ( implSelection == ColourMode::ANSI ) {\n+        if ( colourSelection == ColourMode::ANSI ) {\n             return Detail::make_unique<ANSIColourImpl>( stream );\n         }\n-        if ( implSelection == ColourMode::None ) {\n+        if ( colourSelection == ColourMode::None ) {\n             return Detail::make_unique<NoColourImpl>( stream );\n         }\n \n-        if ( implSelection == ColourMode::PlatformDefault) {\n+        if ( colourSelection == ColourMode::PlatformDefault) {\n #if defined( CATCH_CONFIG_COLOUR_WIN32 )\n             if ( Win32ColourImpl::useImplementationForStream( *stream ) ) {\n                 return Detail::make_unique<Win32ColourImpl>( stream );\n@@ -256,7 +256,7 @@ namespace Catch {\n             return Detail::make_unique<NoColourImpl>( stream );\n         }\n \n-        CATCH_ERROR( \"Could not create colour impl for selection \" << static_cast<int>(implSelection) );\n+        CATCH_ERROR( \"Could not create colour impl for selection \" << static_cast<int>(colourSelection) );\n     }\n \n     bool isColourImplAvailable( ColourMode colourSelection ) {\ndiff --git a/src/catch2/internal/catch_enum_values_registry.hpp b/src/catch2/internal/catch_enum_values_registry.hpp\n--- a/src/catch2/internal/catch_enum_values_registry.hpp\n+++ b/src/catch2/internal/catch_enum_values_registry.hpp\n@@ -24,7 +24,7 @@ namespace Catch {\n \n             std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;\n \n-            EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values) override;\n+            EnumInfo const& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values) override;\n         };\n \n         std::vector<StringRef> parseEnums( StringRef enums );\ndiff --git a/src/catch2/internal/catch_jsonwriter.cpp b/src/catch2/internal/catch_jsonwriter.cpp\n--- a/src/catch2/internal/catch_jsonwriter.cpp\n+++ b/src/catch2/internal/catch_jsonwriter.cpp\n@@ -31,7 +31,7 @@ namespace Catch {\n         m_os{ os }, m_indent_level{ indent_level } {\n         m_os << '{';\n     }\n-    JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ):\n+    JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ) noexcept:\n         m_os{ source.m_os },\n         m_indent_level{ source.m_indent_level },\n         m_should_comma{ source.m_should_comma },\n@@ -62,7 +62,7 @@ namespace Catch {\n         m_os{ os }, m_indent_level{ indent_level } {\n         m_os << '[';\n     }\n-    JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ):\n+    JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ) noexcept:\n         m_os{ source.m_os },\n         m_indent_level{ source.m_indent_level },\n         m_should_comma{ source.m_should_comma },\ndiff --git a/src/catch2/internal/catch_jsonwriter.hpp b/src/catch2/internal/catch_jsonwriter.hpp\n--- a/src/catch2/internal/catch_jsonwriter.hpp\n+++ b/src/catch2/internal/catch_jsonwriter.hpp\n@@ -65,7 +65,7 @@ namespace Catch {\n         JsonObjectWriter( std::ostream& os );\n         JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );\n \n-        JsonObjectWriter( JsonObjectWriter&& source );\n+        JsonObjectWriter( JsonObjectWriter&& source ) noexcept;\n         JsonObjectWriter& operator=( JsonObjectWriter&& source ) = delete;\n \n         ~JsonObjectWriter();\n@@ -84,7 +84,7 @@ namespace Catch {\n         JsonArrayWriter( std::ostream& os );\n         JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );\n \n-        JsonArrayWriter( JsonArrayWriter&& source );\n+        JsonArrayWriter( JsonArrayWriter&& source ) noexcept;\n         JsonArrayWriter& operator=( JsonArrayWriter&& source ) = delete;\n \n         ~JsonArrayWriter();\ndiff --git a/src/catch2/internal/catch_reporter_spec_parser.cpp b/src/catch2/internal/catch_reporter_spec_parser.cpp\n--- a/src/catch2/internal/catch_reporter_spec_parser.cpp\n+++ b/src/catch2/internal/catch_reporter_spec_parser.cpp\n@@ -117,7 +117,7 @@ namespace Catch {\n             auto kv = splitKVPair( parts[i] );\n             auto key = kv.key, value = kv.value;\n \n-            if ( key.empty() || value.empty() ) {\n+            if ( key.empty() || value.empty() ) { // NOLINT(bugprone-branch-clone)\n                 return {};\n             } else if ( key[0] == 'X' ) {\n                 // This is a reporter-specific option, we don't check these\ndiff --git a/src/catch2/internal/catch_section.hpp b/src/catch2/internal/catch_section.hpp\n--- a/src/catch2/internal/catch_section.hpp\n+++ b/src/catch2/internal/catch_section.hpp\n@@ -69,7 +69,9 @@ namespace Catch {\n     namespace Detail {\n         // Intentionally without linkage, as it should only be used as a dummy\n         // symbol for static analysis.\n-        int GetNewSectionHint();\n+        // The arguments are used as a dummy for checking warnings in the passed\n+        // expressions.\n+        int GetNewSectionHint( StringRef, const char* const = nullptr );\n     } // namespace Detail\n } // namespace Catch\n \n@@ -80,7 +82,8 @@ namespace Catch {\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\\n         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\\n                  catchInternalSectionHint,                                  \\\n-             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(); \\\n+             catchInternalSectionHint =                                     \\\n+                 Catch::Detail::GetNewSectionHint(__VA_ARGS__);             \\\n              catchInternalPreviousSectionHint == __LINE__ )                 \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \n@@ -90,7 +93,8 @@ namespace Catch {\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\\n         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\\n                  catchInternalSectionHint,                                  \\\n-             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(); \\\n+             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(   \\\n+                ( Catch::ReusableStringStream() << __VA_ARGS__ ).str());    \\\n              catchInternalPreviousSectionHint == __LINE__ )                 \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \ndiff --git a/src/catch2/internal/catch_string_manip.cpp b/src/catch2/internal/catch_string_manip.cpp\n--- a/src/catch2/internal/catch_string_manip.cpp\n+++ b/src/catch2/internal/catch_string_manip.cpp\n@@ -5,6 +5,7 @@\n //        https://www.boost.org/LICENSE_1_0.txt)\n \n // SPDX-License-Identifier: BSL-1.0\n+#include <catch2/internal/catch_move_and_forward.hpp>\n #include <catch2/internal/catch_string_manip.hpp>\n #include <catch2/internal/catch_stringref.hpp>\n \n@@ -65,17 +66,29 @@ namespace Catch {\n     }\n \n     bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {\n-        bool replaced = false;\n         std::size_t i = str.find( replaceThis );\n-        while( i != std::string::npos ) {\n-            replaced = true;\n-            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\n-            if( i < str.size()-withThis.size() )\n-                i = str.find( replaceThis, i+withThis.size() );\n+        if (i == std::string::npos) {\n+            return false;\n+        }\n+        std::size_t copyBegin = 0;\n+        std::string origStr = CATCH_MOVE(str);\n+        str.clear();\n+        // There is at least one replacement, so reserve with the best guess\n+        // we can make without actually counting the number of occurences.\n+        str.reserve(origStr.size() - replaceThis.size() + withThis.size());\n+        do {\n+            str.append(origStr, copyBegin, i-copyBegin );\n+            str += withThis;\n+            copyBegin = i + replaceThis.size();\n+            if( copyBegin < origStr.size() )\n+                i = origStr.find( replaceThis, copyBegin );\n             else\n                 i = std::string::npos;\n+        } while( i != std::string::npos );\n+        if ( copyBegin < origStr.size() ) {\n+            str.append(origStr, copyBegin, origStr.size() );\n         }\n-        return replaced;\n+        return true;\n     }\n \n     std::vector<StringRef> splitStringRef( StringRef str, char delimiter ) {\ndiff --git a/src/catch2/internal/catch_stringref.hpp b/src/catch2/internal/catch_stringref.hpp\n--- a/src/catch2/internal/catch_stringref.hpp\n+++ b/src/catch2/internal/catch_stringref.hpp\n@@ -97,8 +97,8 @@ namespace Catch {\n         constexpr const_iterator end() const { return m_start + m_size; }\n \n \n-        friend std::string& operator += (std::string& lhs, StringRef sr);\n-        friend std::ostream& operator << (std::ostream& os, StringRef sr);\n+        friend std::string& operator += (std::string& lhs, StringRef rhs);\n+        friend std::ostream& operator << (std::ostream& os, StringRef str);\n         friend std::string operator+(StringRef lhs, StringRef rhs);\n \n         /**\ndiff --git a/src/catch2/reporters/catch_reporter_console.cpp b/src/catch2/reporters/catch_reporter_console.cpp\n--- a/src/catch2/reporters/catch_reporter_console.cpp\n+++ b/src/catch2/reporters/catch_reporter_console.cpp\n@@ -520,8 +520,8 @@ void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {\n     m_stream << '\\n' << std::flush;\n     StreamingReporterBase::testRunEnded(_testRunStats);\n }\n-void ConsoleReporter::testRunStarting(TestRunInfo const& _testInfo) {\n-    StreamingReporterBase::testRunStarting(_testInfo);\n+void ConsoleReporter::testRunStarting(TestRunInfo const& _testRunInfo) {\n+    StreamingReporterBase::testRunStarting(_testRunInfo);\n     if ( m_config->testSpec().hasFilters() ) {\n         m_stream << m_colour->guardColour( Colour::BrightYellow ) << \"Filters: \"\n                  << m_config->testSpec() << '\\n';\ndiff --git a/src/catch2/reporters/catch_reporter_cumulative_base.cpp b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n--- a/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n+++ b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n@@ -16,8 +16,7 @@ namespace Catch {\n     namespace {\n         struct BySectionInfo {\n             BySectionInfo( SectionInfo const& other ): m_other( other ) {}\n-            BySectionInfo( BySectionInfo const& other ):\n-                m_other( other.m_other ) {}\n+            BySectionInfo( BySectionInfo const& other ) = default;\n             bool operator()(\n                 Detail::unique_ptr<CumulativeReporterBase::SectionNode> const&\n                     node ) const {\ndiff --git a/src/catch2/reporters/catch_reporter_json.cpp b/src/catch2/reporters/catch_reporter_json.cpp\n--- a/src/catch2/reporters/catch_reporter_json.cpp\n+++ b/src/catch2/reporters/catch_reporter_json.cpp\n@@ -133,8 +133,8 @@ namespace Catch {\n         return \"Outputs listings as JSON. Test listing is Work-in-Progress!\";\n     }\n \n-    void JsonReporter::testRunStarting( TestRunInfo const& testInfo ) {\n-        StreamingReporterBase::testRunStarting( testInfo );\n+    void JsonReporter::testRunStarting( TestRunInfo const& runInfo ) {\n+        StreamingReporterBase::testRunStarting( runInfo );\n         endListing();\n \n         assert( isInside( Writer::Object ) );\ndiff --git a/src/catch2/reporters/catch_reporter_junit.cpp b/src/catch2/reporters/catch_reporter_junit.cpp\n--- a/src/catch2/reporters/catch_reporter_junit.cpp\n+++ b/src/catch2/reporters/catch_reporter_junit.cpp\n@@ -74,7 +74,7 @@ namespace Catch {\n \n         static void normalizeNamespaceMarkers(std::string& str) {\n             std::size_t pos = str.find( \"::\" );\n-            while ( pos != str.npos ) {\n+            while ( pos != std::string::npos ) {\n                 str.replace( pos, 2, \".\" );\n                 pos += 1;\n                 pos = str.find( \"::\", pos );\ndiff --git a/src/catch2/reporters/catch_reporter_multi.hpp b/src/catch2/reporters/catch_reporter_multi.hpp\n--- a/src/catch2/reporters/catch_reporter_multi.hpp\n+++ b/src/catch2/reporters/catch_reporter_multi.hpp\n@@ -53,7 +53,7 @@ namespace Catch {\n \n         void assertionEnded( AssertionStats const& assertionStats ) override;\n         void sectionEnded( SectionStats const& sectionStats ) override;\n-        void testCasePartialEnded(TestCaseStats const& testInfo, uint64_t partNumber) override;\n+        void testCasePartialEnded(TestCaseStats const& testStats, uint64_t partNumber) override;\n         void testCaseEnded( TestCaseStats const& testCaseStats ) override;\n         void testRunEnded( TestRunStats const& testRunStats ) override;\n \ndiff --git a/src/catch2/reporters/catch_reporter_sonarqube.hpp b/src/catch2/reporters/catch_reporter_sonarqube.hpp\n--- a/src/catch2/reporters/catch_reporter_sonarqube.hpp\n+++ b/src/catch2/reporters/catch_reporter_sonarqube.hpp\n@@ -37,7 +37,7 @@ namespace Catch {\n             xml.endElement();\n         }\n \n-        void writeRun( TestRunNode const& groupNode );\n+        void writeRun( TestRunNode const& runNode );\n \n         void writeTestFile(StringRef filename, std::vector<TestCaseNode const*> const& testCaseNodes);\n \ndiff --git a/src/catch2/reporters/catch_reporter_teamcity.hpp b/src/catch2/reporters/catch_reporter_teamcity.hpp\n--- a/src/catch2/reporters/catch_reporter_teamcity.hpp\n+++ b/src/catch2/reporters/catch_reporter_teamcity.hpp\n@@ -35,8 +35,8 @@ namespace Catch {\n             return \"Reports test results as TeamCity service messages\"s;\n         }\n \n-        void testRunStarting( TestRunInfo const& groupInfo ) override;\n-        void testRunEnded( TestRunStats const& testGroupStats ) override;\n+        void testRunStarting( TestRunInfo const& runInfo ) override;\n+        void testRunEnded( TestRunStats const& runStats ) override;\n \n \n         void assertionEnded(AssertionStats const& assertionStats) override;\n", "test_patch": "diff --git a/src/catch2/catch_test_case_info.hpp b/src/catch2/catch_test_case_info.hpp\n--- a/src/catch2/catch_test_case_info.hpp\n+++ b/src/catch2/catch_test_case_info.hpp\n@@ -68,7 +68,7 @@ namespace Catch {\n     struct TestCaseInfo : Detail::NonCopyable {\n \n         TestCaseInfo(StringRef _className,\n-                     NameAndTags const& _tags,\n+                     NameAndTags const& _nameAndTags,\n                      SourceLineInfo const& _lineInfo);\n \n         bool isHidden() const;\ndiff --git a/src/catch2/internal/catch_test_registry.hpp b/src/catch2/internal/catch_test_registry.hpp\n--- a/src/catch2/internal/catch_test_registry.hpp\n+++ b/src/catch2/internal/catch_test_registry.hpp\n@@ -95,7 +95,7 @@ struct AutoReg : Detail::NonCopyable {\n namespace Catch {\n     namespace Detail {\n         struct DummyUse {\n-            DummyUse( void ( * )( int ) );\n+            DummyUse( void ( * )( int ), Catch::NameAndTags const& );\n         };\n     } // namespace Detail\n } // namespace Catch\n@@ -107,18 +107,18 @@ namespace Catch {\n // tests can compile. The redefined `TEST_CASE` shadows this with param.\n static int catchInternalSectionHint = 0;\n \n-#    define INTERNAL_CATCH_TESTCASE2( fname )                              \\\n+#    define INTERNAL_CATCH_TESTCASE2( fname, ... )                         \\\n         static void fname( int );                                          \\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \\\n         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                   \\\n         static const Catch::Detail::DummyUse INTERNAL_CATCH_UNIQUE_NAME(   \\\n-            dummyUser )( &(fname) );                                       \\\n+            dummyUser )( &(fname), Catch::NameAndTags{ __VA_ARGS__ } );    \\\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                            \\\n         static void fname( [[maybe_unused]] int catchInternalSectionHint ) \\\n             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n #    define INTERNAL_CATCH_TESTCASE( ... ) \\\n-        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ) )\n+        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ), __VA_ARGS__ )\n \n \n #endif // CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT\ndiff --git a/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp b/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n--- a/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n+++ b/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n@@ -34,7 +34,7 @@ class CumulativeBenchmarkReporter final : public Catch::CumulativeReporterBase {\n         return \"Custom reporter for testing cumulative reporter base\";\n     }\n \n-    virtual void testRunEndedCumulative() override;\n+    void testRunEndedCumulative() override;\n };\n \n CATCH_REGISTER_REPORTER(\"testReporter\", CumulativeBenchmarkReporter)\ndiff --git a/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp b/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n--- a/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n+++ b/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n@@ -36,6 +36,7 @@ class TestReporter : public Catch::StreamingReporterBase {\n \n     void testRunStarting( Catch::TestRunInfo const& ) override {\n         std::vector<std::pair<std::string, std::string>> options;\n+        options.reserve( m_customOptions.size() );\n         for ( auto const& kv : m_customOptions ) {\n             options.push_back( kv );\n         }\ndiff --git a/tests/ExtraTests/X91-AmalgamatedCatch.cpp b/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n--- a/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n+++ b/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n@@ -16,10 +16,10 @@\n TEST_CASE(\"Just a dummy test\") {\n     auto i = GENERATE(1, 2, 3);\n     SECTION(\"a\") {\n-        REQUIRE(1 != 4);\n+        REQUIRE(i != 4);\n     }\n     SECTION(\"b\") {\n-        CHECK(1 != 5);\n+        CHECK(i != 5);\n     }\n     REQUIRE_THAT(1,\n                  Catch::Matchers::Predicate<int>([](int i) {\ndiff --git a/tests/SelfTest/IntrospectiveTests/Details.tests.cpp b/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n@@ -120,13 +120,13 @@ TEST_CASE( \"Optional supports move ops\", \"[optional][approvals]\" ) {\n     }\n     SECTION( \"Move construction from optional\" ) {\n         Optional<MoveChecker> opt_B( CATCH_MOVE( opt_A ) );\n-        REQUIRE( opt_A->has_moved );\n+        REQUIRE( opt_A->has_moved ); // NOLINT(clang-analyzer-cplusplus.Move)\n     }\n     SECTION( \"Move assignment from optional\" ) {\n         Optional<MoveChecker> opt_B( opt_A );\n         REQUIRE_FALSE( opt_A->has_moved );\n         opt_B = CATCH_MOVE( opt_A );\n-        REQUIRE( opt_A->has_moved );\n+        REQUIRE( opt_A->has_moved ); // NOLINT(clang-analyzer-cplusplus.Move)\n     }\n }\n \ndiff --git a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -18,7 +18,6 @@\n #include <catch2/generators/catch_generators_adapters.hpp>\n #include <catch2/generators/catch_generators_random.hpp>\n #include <catch2/generators/catch_generators_range.hpp>\n-#include <catch2/generators/catch_generator_exception.hpp>\n \n // Tests of generator implementation details\n TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\ndiff --git a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n@@ -107,7 +107,7 @@ TEST_CASE( \"Reporter's write listings to provided stream\", \"[reporters]\" ) {\n     for (auto const& factory : factories) {\n         INFO(\"Tested reporter: \" << factory.first);\n         auto sstream = Catch::Detail::make_unique<StringIStream>();\n-        auto& sstreamRef = *sstream.get();\n+        auto& sstreamRef = *sstream;\n \n         Catch::ConfigData cfg_data;\n         cfg_data.rngSeed = 1234;\ndiff --git a/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp b/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n@@ -57,6 +57,17 @@ TEST_CASE(\"replaceInPlace\", \"[string-manip]\") {\n         CHECK_FALSE(Catch::replaceInPlace(letters, \"x\", \"z\"));\n         CHECK(letters == letters);\n     }\n+    SECTION(\"no replace in already-replaced string\") {\n+        SECTION(\"lengthening\") {\n+            CHECK(Catch::replaceInPlace(letters, \"c\", \"cc\"));\n+            CHECK(letters == \"abccdefccg\");\n+        }\n+        SECTION(\"shortening\") {\n+            std::string s = \"----\";\n+            CHECK(Catch::replaceInPlace(s, \"--\", \"-\"));\n+            CHECK(s == \"--\");\n+        }\n+    }\n     SECTION(\"escape '\") {\n         std::string s = \"didn't\";\n         CHECK(Catch::replaceInPlace(s, \"'\", \"|'\"));\ndiff --git a/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp b/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n@@ -236,7 +236,7 @@ TEST_CASE( \"Parse test names and tags\", \"[command-line][test-spec][approvals]\" )\n         CHECK( spec.matches( *tcD ) == false );\n     }\n     SECTION( \"two wildcarded names\" ) {\n-        TestSpec spec = parseTestSpec( \"\\\"longer*\\\"\\\"*spaces\\\"\" );\n+        TestSpec spec = parseTestSpec( R\"(\"longer*\"\"*spaces\")\" );\n         CHECK( spec.hasFilters() == true );\n         CHECK( spec.matches( *tcA ) == false );\n         CHECK( spec.matches( *tcB ) == false );\ndiff --git a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n@@ -152,7 +152,7 @@ TEST_CASE( \"TextFlow::Column respects indentation for empty lines\",\n \n     std::string written = as_written(col);\n \n-    REQUIRE(as_written(col) == \"  \\n  \\n  third line\");\n+    REQUIRE(written == \"  \\n  \\n  third line\");\n }\n \n TEST_CASE( \"TextFlow::Column leading/trailing whitespace\",\ndiff --git a/tests/SelfTest/UsageTests/Benchmark.tests.cpp b/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n--- a/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n@@ -90,14 +90,14 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n         };\n         REQUIRE(v.size() == size);\n \n-        int array[size];\n+        int array[size] {};\n         BENCHMARK(\"A fixed size array that should require no allocations\") {\n             for (int i = 0; i < size; ++i)\n                 array[i] = i;\n         };\n         int sum = 0;\n-        for (int i = 0; i < size; ++i)\n-            sum += array[i];\n+        for (int val : array)\n+            sum += val;\n         REQUIRE(sum > size);\n \n         SECTION(\"XYZ\") {\n@@ -121,8 +121,8 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n                 runs = benchmarkIndex;\n             };\n \n-            for (size_t i = 0; i < v.size(); ++i) {\n-                REQUIRE(v[i] == runs);\n+            for (int val : v) {\n+                REQUIRE(val == runs);\n             }\n         }\n     }\n@@ -135,8 +135,8 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n             for (int i = 0; i < size; ++i)\n                 v[i] = generated;\n         };\n-        for (size_t i = 0; i < v.size(); ++i) {\n-            REQUIRE(v[i] == generated);\n+        for (int val : v) {\n+            REQUIRE(val == generated);\n         }\n     }\n \ndiff --git a/tests/SelfTest/UsageTests/Class.tests.cpp b/tests/SelfTest/UsageTests/Class.tests.cpp\n--- a/tests/SelfTest/UsageTests/Class.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Class.tests.cpp\n@@ -39,7 +39,7 @@ namespace {\n     };\n \n     template <typename T> struct Template_Fixture_2 {\n-        Template_Fixture_2() {}\n+        Template_Fixture_2() = default;\n \n         T m_a;\n     };\ndiff --git a/tests/SelfTest/UsageTests/Exception.tests.cpp b/tests/SelfTest/UsageTests/Exception.tests.cpp\n--- a/tests/SelfTest/UsageTests/Exception.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Exception.tests.cpp\n@@ -119,7 +119,7 @@ TEST_CASE( \"When unchecked exceptions are thrown, but caught, they do not affect\n     try {\n         throw std::domain_error( \"unexpected exception\" );\n     }\n-    catch(...) {}\n+    catch(...) {} // NOLINT(bugprone-empty-catch)\n }\n \n \n@@ -152,7 +152,7 @@ TEST_CASE( \"Custom exceptions can be translated when testing for throwing as som\n }\n \n TEST_CASE( \"Unexpected exceptions can be translated\", \"[.][failing][!throws]\"  ) {\n-    throw double( 3.14 );\n+    throw double( 3.14 ); // NOLINT(readability-redundant-casting): the type is important here, so we want to be explicit\n }\n \n TEST_CASE(\"Thrown string literals are translated\", \"[.][failing][!throws]\") {\ndiff --git a/tests/SelfTest/UsageTests/Matchers.tests.cpp b/tests/SelfTest/UsageTests/Matchers.tests.cpp\n--- a/tests/SelfTest/UsageTests/Matchers.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Matchers.tests.cpp\n@@ -1027,7 +1027,6 @@ TEST_CASE( \"Combining MatchNotOfGeneric does not nest\",\n }\n \n struct EvilAddressOfOperatorUsed : std::exception {\n-    EvilAddressOfOperatorUsed() {}\n     const char* what() const noexcept override {\n         return \"overloaded address-of operator of matcher was used instead of \"\n                \"std::addressof\";\n@@ -1035,7 +1034,6 @@ struct EvilAddressOfOperatorUsed : std::exception {\n };\n \n struct EvilCommaOperatorUsed : std::exception {\n-    EvilCommaOperatorUsed() {}\n     const char* what() const noexcept override {\n         return \"overloaded comma operator of matcher was used\";\n     }\n@@ -1073,7 +1071,6 @@ struct ImmovableMatcher : Catch::Matchers::MatcherGenericBase {\n };\n \n struct MatcherWasMovedOrCopied : std::exception {\n-    MatcherWasMovedOrCopied() {}\n     const char* what() const noexcept override {\n         return \"attempted to copy or move a matcher\";\n     }\n@@ -1081,17 +1078,20 @@ struct MatcherWasMovedOrCopied : std::exception {\n \n struct ThrowOnCopyOrMoveMatcher : Catch::Matchers::MatcherGenericBase {\n     ThrowOnCopyOrMoveMatcher() = default;\n-    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher const& ):\n-        Catch::Matchers::MatcherGenericBase() {\n+\n+    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher const& other ):\n+        Catch::Matchers::MatcherGenericBase( other ) {\n         throw MatcherWasMovedOrCopied();\n     }\n-    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher&& ):\n-        Catch::Matchers::MatcherGenericBase() {\n+    // NOLINTNEXTLINE(performance-noexcept-move-constructor)\n+    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher&& other ):\n+        Catch::Matchers::MatcherGenericBase( CATCH_MOVE(other) ) {\n         throw MatcherWasMovedOrCopied();\n     }\n     ThrowOnCopyOrMoveMatcher& operator=( ThrowOnCopyOrMoveMatcher const& ) {\n         throw MatcherWasMovedOrCopied();\n     }\n+    // NOLINTNEXTLINE(performance-noexcept-move-constructor)\n     ThrowOnCopyOrMoveMatcher& operator=( ThrowOnCopyOrMoveMatcher&& ) {\n         throw MatcherWasMovedOrCopied();\n     }\ndiff --git a/tests/SelfTest/UsageTests/Message.tests.cpp b/tests/SelfTest/UsageTests/Message.tests.cpp\n--- a/tests/SelfTest/UsageTests/Message.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Message.tests.cpp\n@@ -80,20 +80,20 @@ TEST_CASE( \"Output from all sections is reported\", \"[failing][messages][.]\" ) {\n \n TEST_CASE( \"Standard output from all sections is reported\", \"[messages][.]\" ) {\n     SECTION( \"one\" ) {\n-        std::cout << \"Message from section one\" << std::endl;\n+        std::cout << \"Message from section one\\n\";\n     }\n \n     SECTION( \"two\" ) {\n-        std::cout << \"Message from section two\" << std::endl;\n+        std::cout << \"Message from section two\\n\";\n     }\n }\n \n TEST_CASE( \"Standard error is reported and redirected\", \"[messages][.][approvals]\" ) {\n     SECTION( \"std::cerr\" ) {\n-        std::cerr << \"Write to std::cerr\" << std::endl;\n+        std::cerr << \"Write to std::cerr\\n\";\n     }\n     SECTION( \"std::clog\" ) {\n-        std::clog << \"Write to std::clog\" << std::endl;\n+        std::clog << \"Write to std::clog\\n\";\n     }\n     SECTION( \"Interleaved writes to cerr and clog\" ) {\n         std::cerr << \"Inter\";\n@@ -101,7 +101,7 @@ TEST_CASE( \"Standard error is reported and redirected\", \"[messages][.][approvals\n         std::cerr << ' ';\n         std::clog << \"writes\";\n         std::cerr << \" to error\";\n-        std::clog << \" streams\" << std::endl;\n+        std::clog << \" streams\\n\" << std::flush;\n     }\n }\n \ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -158,9 +158,9 @@ TEST_CASE( \"looped tests\", \"[.][failing]\" ) {\n }\n \n TEST_CASE( \"Sends stuff to stdout and stderr\", \"[.]\" ) {\n-    std::cout << \"A string sent directly to stdout\" << std::endl;\n-    std::cerr << \"A string sent directly to stderr\" << std::endl;\n-    std::clog << \"A string sent to stderr via clog\" << std::endl;\n+    std::cout << \"A string sent directly to stdout\\n\" << std::flush;\n+    std::cerr << \"A string sent directly to stderr\\n\" << std::flush;\n+    std::clog << \"A string sent to stderr via clog\\n\" << std::flush;\n }\n \n TEST_CASE( \"null strings\" ) {\n@@ -396,7 +396,7 @@ TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product\n using MyTypes = std::tuple<int, char, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_arithmetic<TestType>::value);\n }\n \n struct NonDefaultConstructibleType {\n@@ -406,7 +406,7 @@ struct NonDefaultConstructibleType {\n using MyNonDefaultConstructibleTypes = std::tuple<NonDefaultConstructibleType, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside non-default-constructible std::tuple\", \"[template][list]\", MyNonDefaultConstructibleTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_trivially_copyable<TestType>::value);\n }\n \n struct NonCopyableAndNonMovableType {\n@@ -421,7 +421,7 @@ struct NonCopyableAndNonMovableType {\n using NonCopyableAndNonMovableTypes = std::tuple<NonCopyableAndNonMovableType, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside non-copyable and non-movable std::tuple\", \"[template][list]\", NonCopyableAndNonMovableTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_default_constructible<TestType>::value);\n }\n \n // https://github.com/philsquared/Catch/issues/166\ndiff --git a/tests/SelfTest/UsageTests/Tricky.tests.cpp b/tests/SelfTest/UsageTests/Tricky.tests.cpp\n--- a/tests/SelfTest/UsageTests/Tricky.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Tricky.tests.cpp\n@@ -261,7 +261,7 @@ TEST_CASE( \"non streamable - with conv. op\", \"[Tricky]\" )\n \n inline void foo() {}\n \n-typedef void (*fooptr_t)();\n+using fooptr_t = void (*)();\n \n TEST_CASE( \"Comparing function pointers\", \"[Tricky][function pointer]\" )\n {\n@@ -281,7 +281,7 @@ struct S\n \n TEST_CASE( \"Comparing member function pointers\", \"[Tricky][member function pointer][approvals]\" )\n {\n-    typedef void (S::*MF)();\n+    using MF = void (S::*)();\n     MF m = &S::f;\n \n     CHECK( m == &S::f );\n", "problem_statement": "Wunused-variable in (DYNAMIC_)SECTION when CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT is enabled\n**Describe the bug**\r\n\r\nIn static analysis mode, the argument of `SECTION`/`DYNAMIC_SECTION` is not evaluated. If it contains\r\na variable that is used only there, it'll lead to `Wunused-variable` warning.\r\n\r\n\r\n**Expected behavior**\r\nNo warning\r\n\r\n**Reproduction steps**\r\n\r\nhttps://compiler-explorer.com/z/K9fxKGaz4\r\n\r\n**Platform information:**\r\n - Compiler+version: clang (clang-tidy)\r\n - Catch version: devel\r\n\n", "hints_text": "", "created_at": "2024-02-19T17:20:35Z"}
{"repo": "catchorg/Catch2", "pull_number": 2766, "instance_id": "catchorg__Catch2-2766", "issue_numbers": ["2551"], "base_commit": "733b901dd26110039466c04a74633a5709a1229e", "patch": "diff --git a/src/catch2/benchmark/catch_optimizer.hpp b/src/catch2/benchmark/catch_optimizer.hpp\n--- a/src/catch2/benchmark/catch_optimizer.hpp\n+++ b/src/catch2/benchmark/catch_optimizer.hpp\n@@ -70,7 +70,7 @@ namespace Catch {\n \n         template <typename Fn, typename... Args>\n         inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> std::enable_if_t<std::is_same<void, decltype(fn(args...))>::value> {\n-            CATCH_FORWARD(fn) (CATCH_FORWARD(args)...);\n+            CATCH_FORWARD((fn)) (CATCH_FORWARD(args)...);\n         }\n     } // namespace Benchmark\n } // namespace Catch\n", "test_patch": "", "problem_statement": "Unable to compile Catch2 version 3.x.x using Intel 2019 compiler\n**Describe the bug**\r\n\r\nCompiling Catch devel, 3.1.0, and 3.1.0 using the intel 2019 compiler:\r\n\r\n```\r\n$ icpc --version\r\nicpc (ICC) 19.0.5.281 20190815\r\nCopyright (C) 1985-2019 Intel Corporation.  All rights reserved.\r\n```\r\nyields the following error:\r\n```\r\n/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/catch_optimizer.hpp(66): error: expression preceding parentheses of apparent call must have (pointer-to-) function type\r\n              CATCH_FORWARD(fn) (CATCH_FORWARD(args)...);\r\n              ^\r\n          detected during:\r\n            instantiation of \"void Catch::Benchmark::Chronometer::measure(Fun &&, std::true_type) [with Fun=lambda [](int)->void]\" at line 57 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/catch_chronometer.hpp\"\r\n            instantiation of \"void Catch::Benchmark::Chronometer::measure(Fun &&, std::false_type) [with Fun=const Catch::Benchmark::Detail::BenchmarkFunction::do_nothing &]\" at line 46 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/catch_chronometer.hpp\"\r\n            instantiation of \"void Catch::Benchmark::Chronometer::measure(Fun &&) [with Fun=const Catch::Benchmark::Detail::BenchmarkFunction::do_nothing &]\" at line 62 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/detail/catch_benchmark_function.hpp\"\r\n            instantiation of \"void Catch::Benchmark::Detail::BenchmarkFunction::model<Fun>::call(Catch::Benchmark::Chronometer, std::false_type) const [with Fun=Catch::Benchmark::Detail::BenchmarkFunction::do_nothing]\" at line 56 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/detail/catch_benchmark_function.hpp\"\r\n            instantiation of \"void Catch::Benchmark::Detail::BenchmarkFunction::model<Fun>::call(Catch::Benchmark::Chronometer) const [with Fun=Catch::Benchmark::Detail::BenchmarkFunction::do_nothing]\" at line 48 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/detail/catch_benchmark_function.hpp\"\r\n            implicit generation of \"Catch::Benchmark::Detail::BenchmarkFunction::model<Fun>::~model() [with Fun=Catch::Benchmark::Detail::BenchmarkFunction::do_nothing]\" at line 48 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/detail/catch_benchmark_function.hpp\"\r\n            instantiation of class \"Catch::Benchmark::Detail::BenchmarkFunction::model<Fun> [with Fun=Catch::Benchmark::Detail::BenchmarkFunction::do_nothing]\" at line 48 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/detail/catch_benchmark_function.hpp\"\r\n            instantiation of \"Catch::Benchmark::Detail::BenchmarkFunction::model<Fun>::model(Fun &&) [with Fun=Catch::Benchmark::Detail::BenchmarkFunction::do_nothing]\" at line 75 of \"/hpnobackup2/kbthomp1/Catch2/src/catch2/../catch2/benchmark/detail/catch_benchmark_function.hpp\"\r\n\r\ncompilation aborted for /hpnobackup2/kbthomp1/Catch2/src/catch2/benchmark/detail/catch_benchmark_function.cpp (code 2)\r\n```\r\n\r\n**Expected behavior**\r\nUsing the default cmake configuration, the Catch2 library can be built using LLVM 14.0, gcc 6.2.0/8.3.0, and intel oneAPI version 2021.3.0 20210609, but fails to compile with the intel 19.0.5.281 20190815 compiler listed above.\r\n\r\n**Reproduction steps**\r\nConfigured without extra arguments to cmake, i.e.:\r\n\r\n```\r\ncd Catch2\r\nmkdir build\r\ncmake ..\r\nmake\r\n```\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: Centos 7\r\n - Compiler+version: **Intel compiler version 19.0.5.281 20190815**\r\n - Catch version: **v3.1.1**\r\n\r\n\r\n\n", "hints_text": "I am willing to merge a PR with reasonable workaround, but otherwise my advice is to use a better compiler. \nSame problem on Intel 19.1.0.20200306\r\n\r\nAnd \"use a better compiler\" is easier said then done if you're on a 10 thousand node supercomputer where you support dozens of packages: upgrading a compiler is a multi-week undertaking that is not undertaken lightly. Intel 19.1.1 was until very recently the most stable Intel compiler. I understand that it's not part of your CI workflow?", "created_at": "2023-11-15T15:16:06Z"}
{"repo": "catchorg/Catch2", "pull_number": 2723, "instance_id": "catchorg__Catch2-2723", "issue_numbers": ["2719"], "base_commit": "4acc51828f7f93f3b2058a63f54d112af4034503", "patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -20,6 +20,7 @@\n #include <catch2/internal/catch_output_redirect.hpp>\n #include <catch2/internal/catch_assertion_handler.hpp>\n #include <catch2/internal/catch_test_failure_exception.hpp>\n+#include <catch2/internal/catch_result_type.hpp>\n \n #include <cassert>\n #include <algorithm>\n@@ -293,13 +294,14 @@ namespace Catch {\n             m_messageScopes.clear();\n         }\n \n-        // Reset working state\n-        resetAssertionInfo();\n+        // Reset working state. assertion info will be reset after\n+        // populateReaction is run if it is needed\n         m_lastResult = CATCH_MOVE( result );\n     }\n     void RunContext::resetAssertionInfo() {\n         m_lastAssertionInfo.macroName = StringRef();\n         m_lastAssertionInfo.capturedExpression = \"{Unknown expression after the reported line}\"_sr;\n+        m_lastAssertionInfo.resultDisposition = ResultDisposition::Normal;\n     }\n \n     void RunContext::notifyAssertionStarted( AssertionInfo const& info ) {\n@@ -447,6 +449,7 @@ namespace Catch {\n         AssertionResult result(m_lastAssertionInfo, CATCH_MOVE(tempResult));\n \n         assertionEnded(CATCH_MOVE(result) );\n+        resetAssertionInfo();\n \n         handleUnfinishedSections();\n \n@@ -583,6 +586,7 @@ namespace Catch {\n             reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\n             populateReaction( reaction );\n         }\n+        resetAssertionInfo();\n     }\n     void RunContext::reportExpr(\n             AssertionInfo const &info,\n@@ -621,6 +625,7 @@ namespace Catch {\n             // considered \"OK\"\n             reaction.shouldSkip = true;\n         }\n+        resetAssertionInfo();\n     }\n     void RunContext::handleUnexpectedExceptionNotThrown(\n             AssertionInfo const& info,\n@@ -641,6 +646,7 @@ namespace Catch {\n         AssertionResult assertionResult{ info, CATCH_MOVE(data) };\n         assertionEnded( CATCH_MOVE(assertionResult) );\n         populateReaction( reaction );\n+        resetAssertionInfo();\n     }\n \n     void RunContext::populateReaction( AssertionReaction& reaction ) {\n@@ -658,6 +664,7 @@ namespace Catch {\n         data.message = \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\"s;\n         AssertionResult assertionResult{ info, CATCH_MOVE( data ) };\n         assertionEnded( CATCH_MOVE(assertionResult) );\n+        resetAssertionInfo();\n     }\n     void RunContext::handleNonExpr(\n             AssertionInfo const &info,\n@@ -672,6 +679,7 @@ namespace Catch {\n         const auto isOk = assertionResult.isOk();\n         assertionEnded( CATCH_MOVE(assertionResult) );\n         if ( !isOk ) { populateReaction( reaction ); }\n+        resetAssertionInfo();\n     }\n \n \n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -78,6 +78,7 @@ endif(MSVC) #Temporary workaround\n set(TEST_SOURCES\n         ${SELF_TEST_DIR}/TestRegistrations.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Algorithms.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/AssertionHandler.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Clara.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLine.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLineHelpers.tests.cpp\ndiff --git a/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp b/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp\n@@ -0,0 +1,17 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+TEST_CASE( \"Incomplete AssertionHandler\", \"[assertion-handler][!shouldfail]\" ) {\n+    Catch::AssertionHandler catchAssertionHandler(\n+        \"REQUIRE\"_catch_sr,\n+        CATCH_INTERNAL_LINEINFO,\n+        \"Dummy\",\n+        Catch::ResultDisposition::Normal );\n+}\ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -217,6 +217,18 @@ TEST_CASE(\"Testing checked-if 3\", \"[checked-if][!shouldfail]\") {\n     SUCCEED();\n }\n \n+[[noreturn]]\n+TEST_CASE(\"Testing checked-if 4\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(true) {}\n+    throw std::runtime_error(\"Uncaught exception should fail!\");\n+}\n+\n+[[noreturn]]\n+TEST_CASE(\"Testing checked-if 5\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(false) {}\n+    throw std::runtime_error(\"Uncaught exception should fail!\");\n+}\n+\n TEST_CASE( \"xmlentitycheck\" ) {\n     SECTION( \"embedded xml: <test>it should be possible to embed xml characters, such as <, \\\" or &, or even whole <xml>documents</xml> within an attribute</test>\" ) {\n         SUCCEED(); // We need this here to stop it failing due to no tests\n", "problem_statement": "Exception is treated as passing when used CHECKED_ELSE before in xml reporter\n**Describe the bug**\r\nAfter CHECKED_ELSE(true) {} is being run, any exception being thrown in the tests are suppressed and treated as passing when using xml reporter. Using console reporter reports failure.\r\n\r\nAfter CHECKED_ELSE(false) {} is being run, any exception being thrown are suppressed in both console and xml reporter.\r\n\r\n**Expected behavior**\r\nBoth the console reporter and xml reporter should behave exactly the same, that the exception is reported and test counted as failure in both cases.\r\n\r\n**Reproduction steps**\r\nSteps to reproduce the bug.\r\n<!-- Usually this means a small and self-contained piece of code that uses Catch and specifying compiler flags if relevant. -->\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <exception>\r\n\r\nTEST_CASE(\"Testing\") {\r\n    CHECKED_ELSE(true) {}\r\n    throw std::runtime_error(\"it is an error\");\r\n}\r\n```\r\nRunning it with \r\n./test -r xml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Catch2TestRun name=\"test\" rng-seed=\"3025144594\" xml-format-version=\"2\" catch\r\n  <TestCase name=\"Testing\" filename=\"/home/ross/workspace/catch2-xml/test.cpp\r\n    <OverallResult success=\"true\" skips=\"0\"/>\r\n  </TestCase>\r\n  <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n  <OverallResultsCases successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\r\n</Catch2TestRun>\r\n```\r\nAnd running it directly with\r\n./test\r\n```\r\n...\r\n/home/ross/workspace/catch2-xml/test.cpp:4: FAILED:\r\n  {Unknown expression after the reported line}\r\ndue to unexpected exception with message:\r\n  it is an error\r\n\r\n===============================================================================\r\ntest cases: 1 | 1 failed\r\nassertions: 2 | 1 passed | 1 failed\r\n```\r\nAnd if the argument inside CHECKED_ELSE is false, exception is suppressed for both console and xml reporter. It also looks like a bug.\r\n\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <exception>\r\n\r\nTEST_CASE(\"Testing\") {\r\n    CHECKED_ELSE(false) {}\r\n    throw std::runtime_error(\"it is an error\");\r\n}\r\n```\r\nRunning\r\n./test -r xml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Catch2TestRun name=\"test\" rng-seed=\"3270933764\" xml-format-version=\"2\" catch2-version=\"3.3.2\">\r\n  <TestCase name=\"Testing\" filename=\"/home/ross/workspace/catch2-xml/test.cpp\" line=\"4\">\r\n    <OverallResult success=\"true\" skips=\"0\"/>\r\n  </TestCase>\r\n  <OverallResults successes=\"0\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n  <OverallResultsCases successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n</Catch2TestRun>\r\n```\r\nRunning \r\n./test \r\n```\r\nRandomness seeded to: 1751265161\r\n===============================================================================\r\ntest cases: 1 | 1 passed\r\nassertions: - none -\r\n```\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Ubuntu jammy**\r\n - Compiler+version: **clang++-15**\r\n - Catch version: **v3.3.2**\r\n\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n\n", "hints_text": "", "created_at": "2023-07-21T17:31:25Z"}
{"repo": "catchorg/Catch2", "pull_number": 2626, "instance_id": "catchorg__Catch2-2626", "issue_numbers": ["2603"], "base_commit": "b5be6420427331c2bf1160fa7eedf0f5f1145b6b", "patch": "diff --git a/src/catch2/internal/catch_compiler_capabilities.hpp b/src/catch2/internal/catch_compiler_capabilities.hpp\n--- a/src/catch2/internal/catch_compiler_capabilities.hpp\n+++ b/src/catch2/internal/catch_compiler_capabilities.hpp\n@@ -61,9 +61,14 @@\n #endif\n \n #if defined(__CUDACC__) && !defined(__clang__)\n+#  ifdef __NVCC_DIAG_PRAGMA_SUPPORT__\n+// New pragmas introduced in CUDA 11.5+\n #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( \"nv_diagnostic push\" )\n #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( \"nv_diagnostic pop\" )\n #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( \"nv_diag_suppress 177\" )\n+#  else\n+#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( \"diag_suppress 177\" )\n+#  endif\n #endif\n \n // clang-cl defines _MSC_VER as well as __clang__, which could cause the\n@@ -181,8 +186,14 @@\n // Visual C++\n #if defined(_MSC_VER)\n \n-#  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )\n-#  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )\n+// We want to defer to nvcc-specific warning suppression if we are compiled\n+// with nvcc masquerading for MSVC.\n+#    if !defined( __CUDACC__ )\n+#        define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+            __pragma( warning( push ) )\n+#        define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n+            __pragma( warning( pop ) )\n+#    endif\n \n // Universal Windows platform does not support SEH\n // Or console colours (or console at all...)\n", "test_patch": "", "problem_statement": "Macro redefinition on windows with CUDA\n**Describe the bug**\r\n\r\nBuilding my project on MSVC + CUDA, I have some CUDA tests (e.g. `test_foo.cu`) that are compiled with nvcc.\r\nCompilation of these files fail with this error:\r\n\r\n```\r\n[build] catch2/internal/catch_compiler_capabilities.hpp(184): error C2220: the following warning is treated as an error\r\n[build] catch2/internal/catch_compiler_capabilities.hpp(184): warning C4005: 'CATCH_INTERNAL_START_WARNINGS_SUPPRESSION': macro redefinition\r\n[build] catch2/internal/catch_compiler_capabilities.hpp(64): note: see previous definition of 'CATCH_INTERNAL_START_WARNINGS_SUPPRESSION'\r\n[build] catch2/internal/catch_compiler_capabilities.hpp(185): warning C4005: 'CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION': macro redefinition\r\n[build] catch2/internal/catch_compiler_capabilities.hpp(65): note: see previous definition of 'CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION'\r\n```\r\n\r\nThe problem is indeed that both `_MSC_VER` and `__CUDACC__` are defined for these files.\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Windows 10**\r\n - Compiler+version: **Visual Studio 2019 + CUDA 11.3**\r\n - Catch version: **v3.2.1**\r\n\r\nRelates to: https://github.com/catchorg/Catch2/issues/2307\n", "hints_text": "Same here with CUDA 12 and Visual Studio 2022.", "created_at": "2023-01-17T07:06:55Z"}
{"repo": "catchorg/Catch2", "pull_number": 2554, "instance_id": "catchorg__Catch2-2554", "issue_numbers": ["878"], "base_commit": "8ce92d2c7288b6b3261caf1c016f8a779b6a8efc", "patch": "diff --git a/src/catch2/reporters/catch_reporter_compact.cpp b/src/catch2/reporters/catch_reporter_compact.cpp\n--- a/src/catch2/reporters/catch_reporter_compact.cpp\n+++ b/src/catch2/reporters/catch_reporter_compact.cpp\n@@ -18,22 +18,6 @@\n \n #include <ostream>\n \n-namespace {\n-\n-    constexpr Catch::StringRef bothOrAll( std::uint64_t count ) {\n-        switch (count) {\n-        case 1:\n-            return Catch::StringRef{};\n-        case 2:\n-            return \"both \"_catch_sr;\n-        default:\n-            return \"all \"_catch_sr;\n-        }\n-    }\n-\n-} // anon namespace\n-\n-\n namespace Catch {\n namespace {\n \n@@ -48,42 +32,6 @@ namespace {\n     static constexpr Catch::StringRef compactPassedString = \"passed\"_sr;\n #endif\n \n-// Colour, message variants:\n-// - white: No tests ran.\n-// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.\n-// - white: Passed [both/all] N test cases (no assertions).\n-// -   red: Failed N tests cases, failed M assertions.\n-// - green: Passed [both/all] N tests cases with M assertions.\n-void printTotals(std::ostream& out, const Totals& totals, ColourImpl* colourImpl) {\n-    if (totals.testCases.total() == 0) {\n-        out << \"No tests ran.\";\n-    } else if (totals.testCases.failed == totals.testCases.total()) {\n-        auto guard = colourImpl->guardColour( Colour::ResultError ).engage( out );\n-        const StringRef qualify_assertions_failed =\n-            totals.assertions.failed == totals.assertions.total() ?\n-            bothOrAll(totals.assertions.failed) : StringRef{};\n-        out <<\n-            \"Failed \" << bothOrAll(totals.testCases.failed)\n-            << pluralise(totals.testCases.failed, \"test case\"_sr) << \", \"\n-            \"failed \" << qualify_assertions_failed <<\n-            pluralise(totals.assertions.failed, \"assertion\"_sr) << '.';\n-    } else if (totals.assertions.total() == 0) {\n-        out <<\n-            \"Passed \" << bothOrAll(totals.testCases.total())\n-            << pluralise(totals.testCases.total(), \"test case\"_sr)\n-            << \" (no assertions).\";\n-    } else if (totals.assertions.failed) {\n-        out << colourImpl->guardColour( Colour::ResultError ) <<\n-            \"Failed \" << pluralise(totals.testCases.failed, \"test case\"_sr) << \", \"\n-            \"failed \" << pluralise(totals.assertions.failed, \"assertion\"_sr) << '.';\n-    } else {\n-        out << colourImpl->guardColour( Colour::ResultSuccess ) <<\n-            \"Passed \" << bothOrAll(totals.testCases.passed)\n-            << pluralise(totals.testCases.passed, \"test case\"_sr) <<\n-            \" with \" << pluralise(totals.assertions.passed, \"assertion\"_sr) << '.';\n-    }\n-}\n-\n // Implementation of CompactReporter formatting\n class AssertionPrinter {\n public:\n@@ -291,7 +239,7 @@ class AssertionPrinter {\n         }\n \n         void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {\n-            printTotals( m_stream, _testRunStats.totals, m_colour.get() );\n+            printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\n             m_stream << \"\\n\\n\" << std::flush;\n             StreamingReporterBase::testRunEnded( _testRunStats );\n         }\ndiff --git a/src/catch2/reporters/catch_reporter_console.cpp b/src/catch2/reporters/catch_reporter_console.cpp\n--- a/src/catch2/reporters/catch_reporter_console.cpp\n+++ b/src/catch2/reporters/catch_reporter_console.cpp\n@@ -491,7 +491,7 @@ void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n }\n void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {\n     printTotalsDivider(_testRunStats.totals);\n-    printTotals(_testRunStats.totals);\n+    printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\n     m_stream << '\\n' << std::flush;\n     StreamingReporterBase::testRunEnded(_testRunStats);\n }\n@@ -598,82 +598,6 @@ void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t\n            << '\\n';\n }\n \n-struct SummaryColumn {\n-\n-    SummaryColumn( std::string _label, Colour::Code _colour )\n-    :   label( CATCH_MOVE( _label ) ),\n-        colour( _colour ) {}\n-    SummaryColumn addRow( std::uint64_t count ) {\n-        ReusableStringStream rss;\n-        rss << count;\n-        std::string row = rss.str();\n-        for (auto& oldRow : rows) {\n-            while (oldRow.size() < row.size())\n-                oldRow = ' ' + oldRow;\n-            while (oldRow.size() > row.size())\n-                row = ' ' + row;\n-        }\n-        rows.push_back(row);\n-        return *this;\n-    }\n-\n-    std::string label;\n-    Colour::Code colour;\n-    std::vector<std::string> rows;\n-\n-};\n-\n-void ConsoleReporter::printTotals( Totals const& totals ) {\n-    if (totals.testCases.total() == 0) {\n-        m_stream << m_colour->guardColour( Colour::Warning )\n-                 << \"No tests ran\\n\";\n-    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {\n-        m_stream << m_colour->guardColour( Colour::ResultSuccess )\n-                 << \"All tests passed\";\n-        m_stream << \" (\"\n-            << pluralise(totals.assertions.passed, \"assertion\"_sr) << \" in \"\n-            << pluralise(totals.testCases.passed, \"test case\"_sr) << ')'\n-            << '\\n';\n-    } else {\n-\n-        std::vector<SummaryColumn> columns;\n-        columns.push_back(SummaryColumn(\"\", Colour::None)\n-                          .addRow(totals.testCases.total())\n-                          .addRow(totals.assertions.total()));\n-        columns.push_back(SummaryColumn(\"passed\", Colour::Success)\n-                          .addRow(totals.testCases.passed)\n-                          .addRow(totals.assertions.passed));\n-        columns.push_back(SummaryColumn(\"failed\", Colour::ResultError)\n-                          .addRow(totals.testCases.failed)\n-                          .addRow(totals.assertions.failed));\n-        columns.push_back(SummaryColumn(\"failed as expected\", Colour::ResultExpectedFailure)\n-                          .addRow(totals.testCases.failedButOk)\n-                          .addRow(totals.assertions.failedButOk));\n-\n-        printSummaryRow(\"test cases\"_sr, columns, 0);\n-        printSummaryRow(\"assertions\"_sr, columns, 1);\n-    }\n-}\n-void ConsoleReporter::printSummaryRow(StringRef label, std::vector<SummaryColumn> const& cols, std::size_t row) {\n-    for (auto col : cols) {\n-        std::string const& value = col.rows[row];\n-        if (col.label.empty()) {\n-            m_stream << label << \": \";\n-            if ( value != \"0\" ) {\n-                m_stream << value;\n-            } else {\n-                m_stream << m_colour->guardColour( Colour::Warning )\n-                         << \"- none -\";\n-            }\n-        } else if (value != \"0\") {\n-            m_stream << m_colour->guardColour( Colour::LightGrey ) << \" | \"\n-                     << m_colour->guardColour( col.colour ) << value << ' '\n-                     << col.label;\n-        }\n-    }\n-    m_stream << '\\n';\n-}\n-\n void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n     if (totals.testCases.total() > 0) {\n         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\n@@ -701,9 +625,6 @@ void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n     }\n     m_stream << '\\n';\n }\n-void ConsoleReporter::printSummaryDivider() {\n-    m_stream << lineOfChars('-') << '\\n';\n-}\n \n } // end namespace Catch\n \ndiff --git a/src/catch2/reporters/catch_reporter_console.hpp b/src/catch2/reporters/catch_reporter_console.hpp\n--- a/src/catch2/reporters/catch_reporter_console.hpp\n+++ b/src/catch2/reporters/catch_reporter_console.hpp\n@@ -13,7 +13,6 @@\n \n namespace Catch {\n     // Fwd decls\n-    struct SummaryColumn;\n     class TablePrinter;\n \n     class ConsoleReporter final : public StreamingReporterBase {\n@@ -57,12 +56,7 @@ namespace Catch {\n         // subsequent lines\n         void printHeaderString(std::string const& _string, std::size_t indent = 0);\n \n-\n-        void printTotals(Totals const& totals);\n-        void printSummaryRow(StringRef label, std::vector<SummaryColumn> const& cols, std::size_t row);\n-\n         void printTotalsDivider(Totals const& totals);\n-        void printSummaryDivider();\n \n         bool m_headerPrinted = false;\n         bool m_testRunInfoPrinted = false;\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.cpp b/src/catch2/reporters/catch_reporter_helpers.cpp\n--- a/src/catch2/reporters/catch_reporter_helpers.cpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.cpp\n@@ -235,4 +235,102 @@ namespace Catch {\n         out << \"\\n\\n\" << std::flush;\n     }\n \n+    namespace {\n+        class SummaryColumn {\n+        public:\n+            SummaryColumn( std::string suffix, Colour::Code colour ):\n+                m_suffix( CATCH_MOVE( suffix ) ), m_colour( colour ) {}\n+\n+            SummaryColumn&& addRow( std::uint64_t count ) && {\n+                std::string row = std::to_string(count);\n+                auto const new_width = std::max( m_width, row.size() );\n+                if ( new_width > m_width ) {\n+                    for ( auto& oldRow : m_rows ) {\n+                        oldRow.insert( 0, new_width - m_width, ' ' );\n+                    }\n+                } else {\n+                    row.insert( 0, m_width - row.size(), ' ' );\n+                }\n+                m_width = new_width;\n+                m_rows.push_back( row );\n+                return std::move( *this );\n+            }\n+\n+            std::string const& getSuffix() const { return m_suffix; }\n+            Colour::Code getColour() const { return m_colour; }\n+            std::string const& getRow( std::size_t index ) const {\n+                return m_rows[index];\n+            }\n+\n+        private:\n+            std::string m_suffix;\n+            Colour::Code m_colour;\n+            std::size_t m_width = 0;\n+            std::vector<std::string> m_rows;\n+        };\n+\n+        void printSummaryRow( std::ostream& stream,\n+                              ColourImpl& colour,\n+                              StringRef label,\n+                              std::vector<SummaryColumn> const& cols,\n+                              std::size_t row ) {\n+            for ( auto const& col : cols ) {\n+                auto const& value = col.getRow( row );\n+                auto const& suffix = col.getSuffix();\n+                if ( suffix.empty() ) {\n+                    stream << label << \": \";\n+                    if ( value != \"0\" ) {\n+                        stream << value;\n+                    } else {\n+                        stream << colour.guardColour( Colour::Warning )\n+                               << \"- none -\";\n+                    }\n+                } else if ( value != \"0\" ) {\n+                    stream << colour.guardColour( Colour::LightGrey ) << \" | \"\n+                           << colour.guardColour( col.getColour() ) << value\n+                           << ' ' << suffix;\n+                }\n+            }\n+            stream << '\\n';\n+        }\n+    } // namespace\n+\n+    void printTestRunTotals( std::ostream& stream,\n+                             ColourImpl& streamColour,\n+                             Totals const& totals ) {\n+        if ( totals.testCases.total() == 0 ) {\n+            stream << streamColour.guardColour( Colour::Warning )\n+                   << \"No tests ran\\n\";\n+            return;\n+        }\n+\n+        if ( totals.assertions.total() > 0 && totals.testCases.allPassed() ) {\n+            stream << streamColour.guardColour( Colour::ResultSuccess )\n+                   << \"All tests passed\";\n+            stream << \" (\"\n+                   << pluralise( totals.assertions.passed, \"assertion\"_sr )\n+                   << \" in \"\n+                   << pluralise( totals.testCases.passed, \"test case\"_sr )\n+                   << ')' << '\\n';\n+            return;\n+        }\n+\n+        std::vector<SummaryColumn> columns;\n+        columns.push_back( SummaryColumn( \"\", Colour::None )\n+                               .addRow( totals.testCases.total() )\n+                               .addRow( totals.assertions.total() ) );\n+        columns.push_back( SummaryColumn( \"passed\", Colour::Success )\n+                               .addRow( totals.testCases.passed )\n+                               .addRow( totals.assertions.passed ) );\n+        columns.push_back( SummaryColumn( \"failed\", Colour::ResultError )\n+                               .addRow( totals.testCases.failed )\n+                               .addRow( totals.assertions.failed ) );\n+        columns.push_back(\n+            SummaryColumn( \"failed as expected\", Colour::ResultExpectedFailure )\n+                .addRow( totals.testCases.failedButOk )\n+                .addRow( totals.assertions.failedButOk ) );\n+        printSummaryRow( stream, streamColour, \"test cases\"_sr, columns, 0 );\n+        printSummaryRow( stream, streamColour, \"assertions\"_sr, columns, 1 );\n+    }\n+\n } // namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.hpp b/src/catch2/reporters/catch_reporter_helpers.hpp\n--- a/src/catch2/reporters/catch_reporter_helpers.hpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.hpp\n@@ -14,6 +14,7 @@\n \n #include <catch2/internal/catch_list.hpp>\n #include <catch2/interfaces/catch_interfaces_config.hpp>\n+#include <catch2/catch_totals.hpp>\n \n namespace Catch {\n \n@@ -80,6 +81,15 @@ namespace Catch {\n                            bool isFiltered,\n                            Verbosity verbosity );\n \n+    /**\n+     * Prints test run totals to the provided stream in user-friendly format\n+     *\n+     * Used by the console and compact reporters.\n+     */\n+    void printTestRunTotals( std::ostream& stream,\n+                      ColourImpl& streamColour,\n+                      Totals const& totals );\n+\n } // end namespace Catch\n \n #endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -336,7 +336,7 @@ set_tests_properties(ApprovalTests\n )\n \n add_test(NAME RegressionCheck-1670 COMMAND $<TARGET_FILE:SelfTest> \"#1670 regression check\" -c A -r compact)\n-set_tests_properties(RegressionCheck-1670 PROPERTIES PASS_REGULAR_EXPRESSION \"Passed 1 test case with 2 assertions.\")\n+set_tests_properties(RegressionCheck-1670 PROPERTIES PASS_REGULAR_EXPRESSION \"All tests passed \\\\(2 assertions in 1 test case\\\\)\")\n \n add_test(NAME VersionCheck COMMAND $<TARGET_FILE:SelfTest> -h)\n set_tests_properties(VersionCheck PROPERTIES PASS_REGULAR_EXPRESSION \"Catch2 v${PROJECT_VERSION}\")\ndiff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -210,7 +210,7 @@ add_test(NAME DeferredStaticChecks COMMAND DeferredStaticChecks -r compact)\n set_tests_properties(\n     DeferredStaticChecks\n   PROPERTIES\n-    PASS_REGULAR_EXPRESSION \"Failed 1 test case, failed all 3 assertions.\"\n+    PASS_REGULAR_EXPRESSION \"test cases: 1 \\\\| 1 failed\\nassertions: 3 \\\\| 3 failed\"\n )\n \n \n", "problem_statement": "Compact reporter does not handle [!shouldfail] properly\n## Description\r\nCompact reporter does not handle the `[!shouldfail]` tag properly. Given this code (from #876):\r\n```cpp\r\nbool thisThrows() {\r\n    throw std::runtime_error(\"Boom\");\r\n}\r\n\r\nTEST_CASE(\"#748 - captures with unexpected exceptions\", \"[!shouldfail]\") {\r\n    int answer = 42;\r\n    CAPTURE(answer);\r\n    // the message should be printed on the first two sections but not on the third\r\n    SECTION(\"outside assertions\") {\r\n        thisThrows();\r\n    }\r\n    SECTION(\"inside REQUIRE_NOTHROW\") {\r\n        REQUIRE_NOTHROW(thisThrows());\r\n    }\r\n    SECTION(\"inside REQUIRE_THROWS\") {\r\n        REQUIRE_THROWS(thisThrows());\r\n    }\r\n}\r\n```\r\ncompact reporter's output is\r\n```\r\n<snip>\r\nPassed all 0 test cases with 1 assertion.\r\n```\r\nwhich, while kind-of correct, is surprising. Standard console reporter's output looks like this:\r\n```\r\n<snip>\r\ntest cases: 1 | 1 failed as expected\r\nassertions: 3 | 1 passed | 2 failed as expected\r\n```\r\nwhich is much clearer about what happened and should be in some way replicated by the compact reporter.\r\n\r\n\r\n### Extra information\r\n* Catch version: **v1.8.2**\r\n\n", "hints_text": "I thought a bit about how this might look like but any attempts to have all the information on a single line ended up being quite messy (and it will only get worse with #2360). How about we just copy the output format from the console reporter exactly, save for the \"totals divider\"?\nYeah, that seems fine.\nOkay, stylistically, would you prefer (1) a common base class for console and compact reporter, (2) free functions used by both or (3) code duplication?\n2) or 3), depending on how annoying the signature would be. I don't think the console and compact reporters should have a shared base class.", "created_at": "2022-10-24T12:27:56Z"}
{"repo": "catchorg/Catch2", "pull_number": 2546, "instance_id": "catchorg__Catch2-2546", "issue_numbers": ["2545"], "base_commit": "728de353be6a6d3658932bfc8e1ea5c7742a61c6", "patch": "diff --git a/src/catch2/catch_tostring.hpp b/src/catch2/catch_tostring.hpp\n--- a/src/catch2/catch_tostring.hpp\n+++ b/src/catch2/catch_tostring.hpp\n@@ -43,7 +43,7 @@ namespace Catch {\n         inline std::size_t catch_strnlen(const char *str, std::size_t n) {\n             auto ret = std::char_traits<char>::find(str, n, '\\0');\n             if (ret != nullptr) {\n-                return ret - str;\n+                return static_cast<std::size_t>(ret - str);\n             }\n             return n;\n         }\n", "test_patch": "", "problem_statement": "sign-conversion warning in catch_tostring.hpp\n**Describe the bug**\r\n\r\nHello, the latest devel of Catch2 raises a warning on g++ 12.\r\n\r\n`conversion to \u2018std::size_t\u2019 {aka \u2018long unsigned int\u2019} from \u2018long int\u2019 may change the sign of the result`\r\n\r\nThis warning was introduced a few days ago by PR #2540 \r\n\r\nFile `catch_tostring.hpp` line 46:\r\n\r\n```cpp\r\ninline std::size_t catch_strnlen(const char *str, std::size_t n) {\r\n    auto ret = std::char_traits<char>::find(str, n, '\\0');\r\n    if (ret != nullptr) {\r\n        return ret - str;  // <-- Here !\r\n    }\r\n    return n;\r\n}\r\n```\r\n\r\n**Expected behavior**\r\n\r\nCatch2 builds without warnings.\r\n\r\n**Reproduction steps**\r\n\r\nBuild Catch2 with g++ .\r\n\r\n**Platform information:**\r\ng++ version 12.1.0 (Ubuntu 12.1.0-2ubuntu1~22.04) \r\n\r\n**Possible fixes**\r\n\r\n- Change the return type of `catch_strnlen` to `std::ptrdiff_t`. This would prevent to return `n` without a cast to `std::ptrdiff_t`. \r\n- Explicitly cast the result to `std::size_t`.\r\n```cpp\r\nreturn static_cast<std::size_t>(ret - str);\r\n```\r\nThis should be relatively safe as `str` should never be greater than `ret`. In my opinion this is the way to go.\r\n\r\n@rkaminsk what do you think ?\n", "hints_text": "The code safe. We could add a static cast to silence the warning.\nstatic cast is the correct option, ptrdiff return type would just force the cast in callers.", "created_at": "2022-10-08T21:18:10Z"}
{"repo": "catchorg/Catch2", "pull_number": 2540, "instance_id": "catchorg__Catch2-2540", "issue_numbers": ["2511"], "base_commit": "6a9bf2e0afe7eeece351777ae2f9b8e714ecd274", "patch": "diff --git a/src/catch2/catch_tostring.hpp b/src/catch2/catch_tostring.hpp\n--- a/src/catch2/catch_tostring.hpp\n+++ b/src/catch2/catch_tostring.hpp\n@@ -13,7 +13,6 @@\n #include <cstddef>\n #include <type_traits>\n #include <string>\n-#include <string.h>\n \n #include <catch2/internal/catch_compiler_capabilities.hpp>\n #include <catch2/internal/catch_config_wchar.hpp>\n@@ -41,6 +40,13 @@ namespace Catch {\n \n     namespace Detail {\n \n+        inline std::size_t catch_strnlen(const char *str, std::size_t n) {\n+            auto ret = std::char_traits<char>::find(str, n, '\\0');\n+            if (ret != nullptr) {\n+                return ret - str;\n+            }\n+            return n;\n+        }\n \n         constexpr StringRef unprintableString = \"{?}\"_sr;\n \n@@ -208,28 +214,24 @@ namespace Catch {\n     template<size_t SZ>\n     struct StringMaker<char[SZ]> {\n         static std::string convert(char const* str) {\n-            // Note that `strnlen` is not actually part of standard C++,\n-            // but both POSIX and Windows cstdlib provide it.\n             return Detail::convertIntoString(\n-                StringRef( str, strnlen( str, SZ ) ) );\n+                StringRef( str, Detail::catch_strnlen( str, SZ ) ) );\n         }\n     };\n     template<size_t SZ>\n     struct StringMaker<signed char[SZ]> {\n         static std::string convert(signed char const* str) {\n-            // See the plain `char const*` overload\n             auto reinterpreted = reinterpret_cast<char const*>(str);\n             return Detail::convertIntoString(\n-                StringRef(reinterpreted, strnlen(reinterpreted, SZ)));\n+                StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\n         }\n     };\n     template<size_t SZ>\n     struct StringMaker<unsigned char[SZ]> {\n         static std::string convert(unsigned char const* str) {\n-            // See the plain `char const*` overload\n             auto reinterpreted = reinterpret_cast<char const*>(str);\n             return Detail::convertIntoString(\n-                StringRef(reinterpreted, strnlen(reinterpreted, SZ)));\n+                StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\n         }\n     };\n \n", "test_patch": "", "problem_statement": "strnlen and Cygwin compatability - catch_tostring.hpp\nI was trying to make autodiff (https://autodiff.github.io/installation/) using cmake and the most recent version of Catch2 on Cygwin, but would always run into an error at the cmake --build . --target install. I finally narrowed down my issue thanks to this error message : \r\n\r\n/usr/local/include/catch2/catch_tostring.hpp: In static member function \u2018static std::string Catch::StringMaker<char [SZ]>::convert(const char)\u2019:\r\n/usr/local/include/catch2/catch_tostring.hpp:214:33: error: there are no arguments to \u2018strnlen\u2019 that depend on a template parameter, so a declaration of \u2018strnlen\u2019 must be available [-fpermissive]\r\n\r\nI think the issue is that in the file catch_tostring.hpp there is a call to 'strnlen' that is unfortunately not supported in Cygwin (https://github.com/microsoft/GSL/issues/331). \r\n\r\nI have tried to debug my issue by editing this file and changing the strnlen calls. \r\n\r\nI understand there are several limitations to using cygwin and I am posting this here in case anyone else has this issue. Please let me know if this is not a bug and there was an issue in my implementation. \r\n\n", "hints_text": "", "created_at": "2022-10-03T17:44:45Z"}
{"repo": "catchorg/Catch2", "pull_number": 2527, "instance_id": "catchorg__Catch2-2527", "issue_numbers": ["2482"], "base_commit": "98d37da03ee21e8a87cd3e0e6542c794c667e78b", "patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -409,6 +409,10 @@ if (CATCH_BUILD_EXAMPLES OR CATCH_BUILD_EXTRA_TESTS)\n         $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/generated-includes>\n         $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>\n     )\n+    target_compile_definitions(Catch2_buildall_interface\n+      INTERFACE\n+        CATCH_CONFIG_STATIC\n+    )\n     target_compile_features(Catch2_buildall_interface\n       INTERFACE\n         cxx_alignas\ndiff --git a/src/catch2/catch_tostring.hpp b/src/catch2/catch_tostring.hpp\n--- a/src/catch2/catch_tostring.hpp\n+++ b/src/catch2/catch_tostring.hpp\n@@ -296,13 +296,13 @@ namespace Catch {\n     template<>\n     struct StringMaker<float> {\n         static std::string convert(float value);\n-        static int precision;\n+        CATCH_EXPORT static int precision;\n     };\n \n     template<>\n     struct StringMaker<double> {\n         static std::string convert(double value);\n-        static int precision;\n+        CATCH_EXPORT static int precision;\n     };\n \n     template <typename T>\ndiff --git a/src/catch2/internal/catch_compiler_capabilities.hpp b/src/catch2/internal/catch_compiler_capabilities.hpp\n--- a/src/catch2/internal/catch_compiler_capabilities.hpp\n+++ b/src/catch2/internal/catch_compiler_capabilities.hpp\n@@ -376,5 +376,15 @@\n #    define CATCH_CONFIG_COLOUR_WIN32\n #endif\n \n+#if defined( CATCH_CONFIG_SHARED_LIBRARY ) && defined( _MSC_VER ) && \\\n+    !defined( CATCH_CONFIG_STATIC )\n+#    ifdef Catch2_EXPORTS\n+#        define CATCH_EXPORT //__declspec( dllexport ) // not needed\n+#    else\n+#        define CATCH_EXPORT __declspec( dllimport )\n+#    endif\n+#else\n+#    define CATCH_EXPORT\n+#endif\n \n #endif // CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED\ndiff --git a/src/catch2/internal/catch_context.hpp b/src/catch2/internal/catch_context.hpp\n--- a/src/catch2/internal/catch_context.hpp\n+++ b/src/catch2/internal/catch_context.hpp\n@@ -8,6 +8,8 @@\n #ifndef CATCH_CONTEXT_HPP_INCLUDED\n #define CATCH_CONTEXT_HPP_INCLUDED\n \n+#include <catch2/internal/catch_compiler_capabilities.hpp>\n+\n namespace Catch {\n \n     class IResultCapture;\n@@ -28,7 +30,7 @@ namespace Catch {\n         virtual void setConfig( IConfig const* config ) = 0;\n \n     private:\n-        static IMutableContext *currentContext;\n+        CATCH_EXPORT static IMutableContext* currentContext;\n         friend IMutableContext& getCurrentMutableContext();\n         friend void cleanUpContext();\n         static void createContext();\n", "test_patch": "", "problem_statement": "Tests fail to link with v3.1.0 on windows when built as shared library\n**Describe the bug**\r\nVersion `v3.1.0` enables building `catch2` as a shared lib but does not export/import `static` symbols in header files.\r\nWithout proper annotations, `link.exe` on windows will not automatically import `static` variables even when they are exported by `CMake`. Currently `Selftest` cannot be built against a shared version of `catch2`.\r\nThe following linker error is produced:\r\n```\r\nInternalBenchmark.tests.cpp.obj : error LNK2001: unresolved external symbol \"private: static class Catch::IMutableContext * Catch::IMutableContext::currentContext\" (?currentContext@IMutableContext@Catch@@0PEAV12@EA)\r\nBenchmark.tests.cpp.obj : error LNK2001: unresolved external symbol \"private: static class Catch::IMutableContext * Catch::IMutableContext::currentContext\" (?currentContext@IMutableContext@Catch@@0PEAV12@EA)\r\nToStringGeneral.tests.cpp.obj : error LNK2001: unresolved external symbol \"public: static int Catch::StringMaker<float,void>::precision\" (?precision@?$StringMaker@MX@Catch@@2HA)\r\nToStringGeneral.tests.cpp.obj : error LNK2001: unresolved external symbol \"public: static int Catch::StringMaker<double,void>::precision\" (?precision@?$StringMaker@NX@Catch@@2HA)\r\ntests\\SelfTest.exe : fatal error LNK1120: 3 unresolved externals\r\nninja: build stopped: subcommand failed.\r\n```\r\n\r\n**Expected behavior**\r\nNo linker errors when linking against a shared library build of `catch2`.\r\n\r\n**Reproduction steps**\r\nCompile and build the project as a shared library:\r\n```\r\nmkdir build && cd build\r\ncmake .. -DBUILD_SHARED_LIBS=ON -DCATCH_DEVELOPMENT_BUILD=ON -GNinja\r\ncmake --build .\r\n````\r\n\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Windows NT**\r\n - Compiler+version: **MSVC 19.30**\r\n - Catch version: **v3.1.0**\r\n\r\n\r\n**Additional context**\r\nCMake's `WINDOWS_EXPORT_ALL_SYMBOLS` exports all symbols but `link.exe` only auto links functions without the necessary `__declspec(dllimport)` annotation. `Selftest` relies on the above mentioned `static` variables that are not automatically linked even though exported.\r\n\r\nThe cleanest solution at the moment is to:\r\n- Create a new header file\r\n```\r\n----- catch2/export.hpp ------\r\n#pragma once\r\n\r\n#if defined(CATCH_STATIC)         // Using static.\r\n#  define CATCH_SYMEXPORT\r\n#elif defined(CATCH_STATIC_BUILD) // Building static.\r\n#  define CATCH_SYMEXPORT\r\n#elif defined(CATCH_SHARED)       // Using shared.\r\n#  ifdef _WIN32\r\n#    define CATCH_SYMEXPORT __declspec(dllimport)\r\n#  else\r\n#    define CATCH_SYMEXPORT\r\n#  endif\r\n#elif defined(CATCH_SHARED_BUILD) // Building shared.\r\n#  ifdef _WIN32\r\n#    define CATCH_SYMEXPORT __declspec(dllexport)\r\n#  else\r\n#    define CATCH_SYMEXPORT\r\n#  endif\r\n#else\r\n#  define CATCH_SYMEXPORT         // Using static or shared.\r\n//#  error define CATCH_STATIC or CATCH_SHARED preprocessor macro to signal test library type being linked\r\n#endif\r\n```\r\n- Include `catch2/export.hpp` in necessary header files (Minimum `catch2/internal/catch_context.hpp` and `catch2/catch_tostring.hpp`) as well as to `src/CMakeLists.txt`\r\n- Annotate `catch2/internal/catch_context.hpp:31` with `CATCH_SYMEXPORT`\r\n- Annotate `catch2/catch_tostring.hpp:299 and 305` with `CATCH_SYMEXPORT`\r\n- Add necessary compile definitions to CMake\r\n```\r\ntarget_compile_definitions(Catch2 PRIVATE CATCH_SHARED_BUILD INTERFACE CATCH_SHARED)\r\n```\n", "hints_text": "This header can be generated by cmake of https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html\r\nThe good thing about the generated header is that if you build static library all definitions are empty so downstream users don't need to manually define CATCH_STATIC.", "created_at": "2022-09-17T19:30:08Z"}
{"repo": "catchorg/Catch2", "pull_number": 2526, "instance_id": "catchorg__Catch2-2526", "issue_numbers": ["2432"], "base_commit": "98d37da03ee21e8a87cd3e0e6542c794c667e78b", "patch": "diff --git a/src/catch2/catch_all.hpp b/src/catch2/catch_all.hpp\n--- a/src/catch2/catch_all.hpp\n+++ b/src/catch2/catch_all.hpp\n@@ -114,7 +114,6 @@\n #include <catch2/internal/catch_unique_ptr.hpp>\n #include <catch2/internal/catch_void_type.hpp>\n #include <catch2/internal/catch_wildcard_pattern.hpp>\n-#include <catch2/internal/catch_windows_h_proxy.hpp>\n #include <catch2/internal/catch_xmlwriter.hpp>\n #include <catch2/matchers/catch_matchers_all.hpp>\n #include <catch2/reporters/catch_reporters_all.hpp>\ndiff --git a/src/catch2/internal/catch_windows_h_proxy.hpp b/src/catch2/internal/catch_windows_h_proxy.hpp\n--- a/src/catch2/internal/catch_windows_h_proxy.hpp\n+++ b/src/catch2/internal/catch_windows_h_proxy.hpp\n@@ -21,11 +21,7 @@\n #  define WIN32_LEAN_AND_MEAN\n #endif\n \n-#ifdef __AFXDLL\n-#include <AfxWin.h>\n-#else\n #include <windows.h>\n-#endif\n \n #endif // defined(CATCH_PLATFORM_WINDOWS)\n \n", "test_patch": "", "problem_statement": "Windows_h_proxy is included in catch_all.hpp and does name-polution\n**Describe the bug**\r\nIf I include `catch2/catch_all.hpp` on Windows it transitively includes `windows.h` which defines a lot of preprocessor definitions whose names will be in conflict with my code.\r\n\r\n**Expected behavior**\r\nWindows.h should be included only in the implementation files of catch2, not in the public headers.\r\n\r\n**Reproduction steps**\r\nSee description above.\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Windows NT**\r\n - Compiler+version: **GCC 11 (Mingw64)**\r\n - Catch version: **v3.0.1**\r\n\n", "hints_text": "Do you know how to fix this? I expected this to be an easy fix, remove just a line from `catch_all.hpp`, but this came up https://github.com/catchorg/Catch2/blob/devel/tools/scripts/checkConvenienceHeaders.py and makes the test-suite fail.\r\n\r\nMaybe a better fix is to include `windows.h` directly where needed and completely delete this file `catch_windows_h_proxy.hpp`. An even better solution is to have public and private headers, install only the public headers and any scripts like the above one should test only for those. I'd go with the former solution right now.", "created_at": "2022-09-17T00:04:35Z"}
{"repo": "catchorg/Catch2", "pull_number": 2524, "instance_id": "catchorg__Catch2-2524", "issue_numbers": ["2489"], "base_commit": "359542d53ec142514da8a606ada8d9efd13b9678", "patch": "diff --git a/src/catch2/benchmark/catch_constructor.hpp b/src/catch2/benchmark/catch_constructor.hpp\n--- a/src/catch2/benchmark/catch_constructor.hpp\n+++ b/src/catch2/benchmark/catch_constructor.hpp\n@@ -54,14 +54,18 @@ namespace Catch {\n                 template <typename U>\n                 void destruct_on_exit(std::enable_if_t<!Destruct, U>* = nullptr) { }\n \n-                T& stored_object() {\n-                    return *static_cast<T*>(static_cast<void*>(data));\n-                }\n+#if defined( __GNUC__ ) && __GNUC__ <= 6\n+#    pragma GCC diagnostic push\n+#    pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n+#endif\n+                T& stored_object() { return *reinterpret_cast<T*>( data ); }\n \n                 T const& stored_object() const {\n-                    return *static_cast<T const*>(static_cast<void const*>(data));\n+                    return *reinterpret_cast<T const*>( data );\n                 }\n-\n+#if defined( __GNUC__ ) && __GNUC__ <= 6\n+#    pragma GCC diagnostic pop\n+#endif\n \n                 alignas( T ) unsigned char data[sizeof( T )]{};\n             };\n", "test_patch": "", "problem_statement": "Include GCC v5 and GCC v6 in the CI\n**Description**\r\nGitHub actions provides two Linux images, one is Ubuntu 18.04 which provides GCC 5-8 and 20.04 which has GCC 7-10. One can tweak the scripts to use the older Ubuntu for the older GCC versions. Or we can always use the older Ubuntu and get the newer GCC versions [via PPA](https://launchpad.net/~ubuntu-toolchain-r/+archive/ubuntu/test).\r\n\n", "hints_text": "", "created_at": "2022-09-14T21:02:33Z"}
{"repo": "catchorg/Catch2", "pull_number": 2521, "instance_id": "catchorg__Catch2-2521", "issue_numbers": ["2520", "2520"], "base_commit": "359542d53ec142514da8a606ada8d9efd13b9678", "patch": "diff --git a/src/catch2/internal/catch_compiler_capabilities.hpp b/src/catch2/internal/catch_compiler_capabilities.hpp\n--- a/src/catch2/internal/catch_compiler_capabilities.hpp\n+++ b/src/catch2/internal/catch_compiler_capabilities.hpp\n@@ -53,6 +53,9 @@\n #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n          _Pragma( \"GCC diagnostic ignored \\\"-Wunused-variable\\\"\" )\n \n+#    define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n+         _Pragma( \"GCC diagnostic ignored \\\"-Wuseless-cast\\\"\" )\n+\n #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)\n \n #endif\n@@ -335,6 +338,9 @@\n #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS)\n #   define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS\n #endif\n+#if !defined(CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS)\n+#   define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS\n+#endif\n #if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)\n #   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS\n #endif\n", "test_patch": "diff --git a/src/catch2/internal/catch_test_macro_impl.hpp b/src/catch2/internal/catch_test_macro_impl.hpp\n--- a/src/catch2/internal/catch_test_macro_impl.hpp\n+++ b/src/catch2/internal/catch_test_macro_impl.hpp\n@@ -76,7 +76,10 @@\n     do { \\\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\n         try { \\\n+            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+            CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n             static_cast<void>(__VA_ARGS__); \\\n+            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n             catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\\n         } \\\n         catch( ... ) { \\\n@@ -91,7 +94,10 @@\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\\n         if( catchAssertionHandler.allowThrows() ) \\\n             try { \\\n+                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n                 static_cast<void>(__VA_ARGS__); \\\n+                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n             } \\\n             catch( ... ) { \\\n@@ -108,7 +114,10 @@\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) \", \" CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\\n         if( catchAssertionHandler.allowThrows() ) \\\n             try { \\\n+                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n                 static_cast<void>(expr); \\\n+                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n             } \\\n             catch( exceptionType const& ) { \\\n@@ -131,7 +140,10 @@\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) \", \" CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\n         if( catchAssertionHandler.allowThrows() ) \\\n             try { \\\n+                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n                 static_cast<void>(__VA_ARGS__); \\\n+                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n             } \\\n             catch( ... ) { \\\n", "problem_statement": "useless-cast warning from THROW macro family\n**Describe the bug**\r\nWe get the following error message (with -Werror) when using `REQUIRE_NOTHROW` on a void function.\r\n```\r\n.../Catch2/src/catch2/internal/catch_test_macro_impl.hpp:79:13: error: useless cast to type 'void' [-Werror=useless-cast]\r\n   79 |             static_cast<void>(__VA_ARGS__); \\\r\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n.../Catch2/src/catch2/catch_test_macros.hpp:128:34: note: in expansion of macro 'INTERNAL_CATCH_NO_THROW'\r\n  128 |   #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\r\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~\r\nmycode.cpp:47:41: note: in expansion of macro 'REQUIRE_NOTHROW'\r\n```\r\n\r\n**Expected behavior**\r\nNo Warning.\r\n\r\n**Reproduction steps**\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n\r\nvoid op();\r\n\r\nTEST_CASE(\"\") {\r\n    REQUIRE_NOTHROW(op());\r\n}\r\n```\r\nAlthough I was not able to reproduce it on godbolt.\r\n\r\n\r\n**Platform information:**\r\n - OS: **Windows 10**\r\n - Compiler+version: **g++.exe (Rev1, Built by MSYS2 project) 12.2.0**\r\n - We have `-Wuseless-cast` in our warning list\r\n - Catch version: **v3.1.0**\r\n\r\n\r\n**Additional context**\r\nWe just migrated from Catch 2.13.8 with the single include. Before the Code produced no warning.\r\n\r\nI'm also willing to fix this with\r\n```\r\n                if constexpr ( std::is_same_v<decltype( __VA_ARGS__ ),      \\\r\n                                              void> ) {                     \\\r\n                    __VA_ARGS__;                                            \\\r\n                } else {                                                    \\\r\n                    static_cast<void>( __VA_ARGS__ );                       \\\r\n                }                                                           \\\r\n```\nuseless-cast warning from THROW macro family\n**Describe the bug**\r\nWe get the following error message (with -Werror) when using `REQUIRE_NOTHROW` on a void function.\r\n```\r\n.../Catch2/src/catch2/internal/catch_test_macro_impl.hpp:79:13: error: useless cast to type 'void' [-Werror=useless-cast]\r\n   79 |             static_cast<void>(__VA_ARGS__); \\\r\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n.../Catch2/src/catch2/catch_test_macros.hpp:128:34: note: in expansion of macro 'INTERNAL_CATCH_NO_THROW'\r\n  128 |   #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\r\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~\r\nmycode.cpp:47:41: note: in expansion of macro 'REQUIRE_NOTHROW'\r\n```\r\n\r\n**Expected behavior**\r\nNo Warning.\r\n\r\n**Reproduction steps**\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n\r\nvoid op();\r\n\r\nTEST_CASE(\"\") {\r\n    REQUIRE_NOTHROW(op());\r\n}\r\n```\r\nAlthough I was not able to reproduce it on godbolt.\r\n\r\n\r\n**Platform information:**\r\n - OS: **Windows 10**\r\n - Compiler+version: **g++.exe (Rev1, Built by MSYS2 project) 12.2.0**\r\n - We have `-Wuseless-cast` in our warning list\r\n - Catch version: **v3.1.0**\r\n\r\n\r\n**Additional context**\r\nWe just migrated from Catch 2.13.8 with the single include. Before the Code produced no warning.\r\n\r\nI'm also willing to fix this with\r\n```\r\n                if constexpr ( std::is_same_v<decltype( __VA_ARGS__ ),      \\\r\n                                              void> ) {                     \\\r\n                    __VA_ARGS__;                                            \\\r\n                } else {                                                    \\\r\n                    static_cast<void>( __VA_ARGS__ );                       \\\r\n                }                                                           \\\r\n```\n", "hints_text": "Okay that doesn't solve the warning. So one would need to suppress it?\nOkay that doesn't solve the warning. So one would need to suppress it?", "created_at": "2022-09-14T08:37:37Z"}
{"repo": "catchorg/Catch2", "pull_number": 2503, "instance_id": "catchorg__Catch2-2503", "issue_numbers": ["2401"], "base_commit": "14bc25be00881a0f85229d62dfeb32ce1e9cbe03", "patch": "diff --git a/include/internal/catch_session.cpp b/include/internal/catch_session.cpp\n--- a/include/internal/catch_session.cpp\n+++ b/include/internal/catch_session.cpp\n@@ -293,7 +293,7 @@ namespace Catch {\n \n             // Handle list request\n             if( Option<std::size_t> listed = list( m_config ) )\n-                return static_cast<int>( *listed );\n+                return (std::min) (MaxExitCode, static_cast<int>(*listed));\n \n             TestGroup tests { m_config };\n             auto const totals = tests.execute();\n", "test_patch": "", "problem_statement": "With exactly 256 tests I get a warning saying there are no tests (using CMake)\n```\r\nCMake Warning at <hidden>/Catch2/v2.13.7/Catch2_Release/lib/cmake/Catch2/CatchAddTests.cmake:46 (message):\r\n  Test executable\r\n  '<hidden>'\r\n  contains no tests!\r\n```\r\n\r\nAdding another test makes the error go away. :smile: \n", "hints_text": "Ooooh, that's a repeat of #797 due to the v2 versions using the number of listed tests (things in general) as the return code.\r\n\r\nShould be easy enough to fix.", "created_at": "2022-08-21T16:00:10Z"}
{"repo": "catchorg/Catch2", "pull_number": 2487, "instance_id": "catchorg__Catch2-2487", "issue_numbers": ["2486"], "base_commit": "20d413b8b6803c6d456874935d7014fe684e9426", "patch": "diff --git a/include/internal/catch_default_main.hpp b/include/internal/catch_default_main.hpp\n--- a/include/internal/catch_default_main.hpp\n+++ b/include/internal/catch_default_main.hpp\n@@ -13,12 +13,20 @@\n \n #ifndef __OBJC__\n \n+#ifndef CATCH_INTERNAL_CDECL\n+#ifdef _MSC_VER\n+#define CATCH_INTERNAL_CDECL __cdecl\n+#else\n+#define CATCH_INTERNAL_CDECL\n+#endif\n+#endif\n+\n #if defined(CATCH_CONFIG_WCHAR) && defined(CATCH_PLATFORM_WINDOWS) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)\n // Standard C/C++ Win32 Unicode wmain entry point\n-extern \"C\" int wmain (int argc, wchar_t * argv[], wchar_t * []) {\n+extern \"C\" int CATCH_INTERNAL_CDECL wmain (int argc, wchar_t * argv[], wchar_t * []) {\n #else\n // Standard C/C++ main entry point\n-int main (int argc, char * argv[]) {\n+int CATCH_INTERNAL_CDECL main (int argc, char * argv[]) {\n #endif\n \n     return Catch::Session().run( argc, argv );\n", "test_patch": "", "problem_statement": "CATCH_CONFIG_MAIN isn't __cdecl, causing x86 build failures\n**Describe the bug**\r\nSee title\r\n\r\n**Expected behavior**\r\n#define CATCH_CONFIG_MAIN works on x86.\r\n\r\n**Reproduction steps**\r\nBuilding on x86:\r\n```c++\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch2/catch.hpp>\r\n\r\nTEST_CASE(\"passes\")\r\n{\r\n    constexpr int x{ 1 };\r\n    constexpr int y{ 1 };\r\n    REQUIRE(x == 1);\r\n}\r\n\r\nCurrent workaround:\r\n```c++\r\n#define CATCH_CONFIG_RUNNER\r\n#include <catch2/catch.hpp>\r\n\r\n// Using #define CATCH_CONFIG_MAIN would be nicer, but it fails to specify __cdecl, causing a build failure on x86.\r\nextern \"C\" int __cdecl wmain(int argc, wchar_t* argv[])\r\n{\r\n    return Catch::Session{}.run(argc, argv);\r\n}\r\n\r\nTEST_CASE(\"passes\")\r\n{\r\n    constexpr int x{ 1 };\r\n    constexpr int y{ 1 };\r\n    REQUIRE(x == 1);\r\n}\r\n```\r\n\r\n**Platform information:**\r\n - OS: **Windows NT**\r\n - Compiler+version: **MSVC v19.30.30795.3**\r\n - Catch version: **v2.13.8**\r\n\n", "hints_text": "", "created_at": "2022-07-25T20:44:21Z"}
{"repo": "catchorg/Catch2", "pull_number": 2477, "instance_id": "catchorg__Catch2-2477", "issue_numbers": ["2476"], "base_commit": "5a1ef7e4a6caf3d5f696eb82302e3d87ff5c2303", "patch": "diff --git a/src/catch2/benchmark/catch_constructor.hpp b/src/catch2/benchmark/catch_constructor.hpp\n--- a/src/catch2/benchmark/catch_constructor.hpp\n+++ b/src/catch2/benchmark/catch_constructor.hpp\n@@ -59,7 +59,7 @@ namespace Catch {\n                 }\n \n                 T const& stored_object() const {\n-                    return *static_cast<T*>(static_cast<void*>(data));\n+                    return *static_cast<T const*>(static_cast<void const*>(data));\n                 }\n \n \n", "test_patch": "", "problem_statement": "nvcc compile error\n**Describe the bug**\r\nThe `const` version of `Catch::Benchmark::Detail::ObjectStorage::stored_object` does not compile with nvcc (invalid type cast). The problem is solved by first casting to `const void*` and then to `void*` using `const_cast`.\r\n\r\nI will make a PR ASAP.\r\n\n", "hints_text": "", "created_at": "2022-07-04T10:34:24Z"}
{"repo": "catchorg/Catch2", "pull_number": 2427, "instance_id": "catchorg__Catch2-2427", "issue_numbers": ["2306"], "base_commit": "231c58a048039fc09d399bdccdfb7c65a1a6ed4a", "patch": "diff --git a/src/catch2/internal/catch_compiler_capabilities.hpp b/src/catch2/internal/catch_compiler_capabilities.hpp\n--- a/src/catch2/internal/catch_compiler_capabilities.hpp\n+++ b/src/catch2/internal/catch_compiler_capabilities.hpp\n@@ -57,6 +57,12 @@\n \n #endif\n \n+#if defined(__CUDACC__) && !defined(__clang__)\n+#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( \"nv_diagnostic push\" )\n+#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( \"nv_diagnostic pop\" )\n+#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( \"nv_diag_suppress 177\" )\n+#endif\n+\n #if defined(__clang__) && !defined(_MSC_VER)\n \n #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( \"clang diagnostic push\" )\n", "test_patch": "diff --git a/src/catch2/internal/catch_test_registry.hpp b/src/catch2/internal/catch_test_registry.hpp\n--- a/src/catch2/internal/catch_test_registry.hpp\n+++ b/src/catch2/internal/catch_test_registry.hpp\n@@ -77,6 +77,7 @@ struct AutoReg : Detail::NonCopyable {\n         static void TestName(); \\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n         static void TestName()\n@@ -87,6 +88,7 @@ struct AutoReg : Detail::NonCopyable {\n     #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, \"&\" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \n@@ -94,6 +96,7 @@ struct AutoReg : Detail::NonCopyable {\n     #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n         namespace{ \\\n             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \\\n                 void test(); \\\n@@ -110,6 +113,7 @@ struct AutoReg : Detail::NonCopyable {\n         do { \\\n             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n             CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+            CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n             Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \\\n             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n         } while(false)\n", "problem_statement": "Unused variable warnings when compiling with nvcc + gcc\nWhen compiling CUDA files with nvcc (CUDA 11.3 and GCC 9.4), when including catch2 and declaring a simple test case, I'm getting warnings such as `variable \"[...]autoRegistrar1\" was declared but never referenced`.\r\nIs there a way to get rid of these warnings?\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Linux x86_64**\r\n - Compiler+version: **NVCC 11.3 / GCC 9.4.0**\r\n - Catch version: **v2.13.0** [included as part of CMake build, with cmake 3.17.0]\r\n\n", "hints_text": "Other issues similar to this have been opened (#2132,  #1552) but I believe they're not using a fairly recent GCC.", "created_at": "2022-05-18T13:48:47Z"}
{"repo": "catchorg/Catch2", "pull_number": 2420, "instance_id": "catchorg__Catch2-2420", "issue_numbers": ["2419"], "base_commit": "d71b4617e9935f8589870af211f5b7552d743654", "patch": "diff --git a/include/internal/benchmark/catch_constructor.hpp b/include/internal/benchmark/catch_constructor.hpp\n--- a/include/internal/benchmark/catch_constructor.hpp\n+++ b/include/internal/benchmark/catch_constructor.hpp\n@@ -19,8 +19,6 @@ namespace Catch {\n             template <typename T, bool Destruct>\n             struct ObjectStorage\n             {\n-                using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;\n-\n                 ObjectStorage() : data() {}\n \n                 ObjectStorage(const ObjectStorage& other)\n@@ -64,7 +62,7 @@ namespace Catch {\n                 }\n \n \n-                TStorage data;\n+                struct { alignas(T) unsigned char data[sizeof(T)]; }  data;\n             };\n         }\n \n", "test_patch": "", "problem_statement": "std::aligned_storage is deprecated in C++23\n`ObjectStorage` is using `std::aligned_storage`, but C++23 deprecates it, causing warnings in projects that already use `-std=c++2b`.\n", "hints_text": "", "created_at": "2022-05-07T09:49:57Z"}
{"repo": "catchorg/Catch2", "pull_number": 2394, "instance_id": "catchorg__Catch2-2394", "issue_numbers": ["2304"], "base_commit": "1a8a793178d50b74b0f9a0adb3eec937b61039a9", "patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -157,6 +157,7 @@ set(INTERNAL_HEADERS\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.hpp\n     ${SOURCES_DIR}/internal/catch_windows_h_proxy.hpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.hpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.hpp\n )\n set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_approx.cpp\n@@ -213,6 +214,7 @@ set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_version.cpp\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.cpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.cpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.cpp\n )\n set(INTERNAL_FILES ${IMPL_SOURCES} ${INTERNAL_HEADERS})\n \ndiff --git a/src/catch2/catch_all.hpp b/src/catch2/catch_all.hpp\n--- a/src/catch2/catch_all.hpp\n+++ b/src/catch2/catch_all.hpp\n@@ -95,6 +95,7 @@\n #include <catch2/internal/catch_stringref.hpp>\n #include <catch2/internal/catch_tag_alias_registry.hpp>\n #include <catch2/internal/catch_template_test_registry.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n #include <catch2/internal/catch_test_case_registry_impl.hpp>\n #include <catch2/internal/catch_test_case_tracker.hpp>\n #include <catch2/internal/catch_test_failure_exception.hpp>\n", "test_patch": "diff --git a/src/catch2/internal/catch_test_case_info_hasher.cpp b/src/catch2/internal/catch_test_case_info_hasher.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.cpp\n@@ -0,0 +1,31 @@\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+namespace Catch {\n+    TestCaseInfoHasher::TestCaseInfoHasher( hash_t seed ): m_seed( seed ) {}\n+\n+    uint32_t TestCaseInfoHasher::operator()( TestCaseInfo const& t ) const {\n+        // FNV-1a hash algorithm that is designed for uniqueness:\n+        const hash_t prime = 1099511628211u;\n+        hash_t hash = 14695981039346656037u;\n+        for ( const char c : t.name ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const char c : t.className ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const Tag& tag : t.tags ) {\n+            for ( const char c : tag.original ) {\n+                hash ^= c;\n+                hash *= prime;\n+            }\n+        }\n+        hash ^= m_seed;\n+        hash *= prime;\n+        const uint32_t low{ static_cast<uint32_t>( hash ) };\n+        const uint32_t high{ static_cast<uint32_t>( hash >> 32 ) };\n+        return low * high;\n+    }\n+} // namespace Catch\ndiff --git a/src/catch2/internal/catch_test_case_info_hasher.hpp b/src/catch2/internal/catch_test_case_info_hasher.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.hpp\n@@ -0,0 +1,22 @@\n+#ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+\n+#include <cstdint>\n+\n+namespace Catch {\n+\n+    struct TestCaseInfo;\n+\n+    class TestCaseInfoHasher {\n+    public:\n+        using hash_t = std::uint64_t;\n+        TestCaseInfoHasher( hash_t seed );\n+        uint32_t operator()( TestCaseInfo const& t ) const;\n+\n+    private:\n+        hash_t m_seed;\n+    };\n+\n+} // namespace Catch\n+\n+#endif /* CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED */\ndiff --git a/src/catch2/internal/catch_test_case_registry_impl.cpp b/src/catch2/internal/catch_test_case_registry_impl.cpp\n--- a/src/catch2/internal/catch_test_case_registry_impl.cpp\n+++ b/src/catch2/internal/catch_test_case_registry_impl.cpp\n@@ -16,38 +16,13 @@\n #include <catch2/catch_test_case_info.hpp>\n #include <catch2/catch_test_spec.hpp>\n #include <catch2/internal/catch_move_and_forward.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n \n #include <algorithm>\n #include <set>\n \n namespace Catch {\n \n-namespace {\n-    struct TestHasher {\n-        using hash_t = uint64_t;\n-\n-        explicit TestHasher( hash_t hashSuffix ):\n-            m_hashSuffix( hashSuffix ) {}\n-\n-        uint64_t m_hashSuffix;\n-\n-        uint32_t operator()( TestCaseInfo const& t ) const {\n-            // FNV-1a hash with multiplication fold.\n-            const hash_t prime = 1099511628211u;\n-            hash_t hash = 14695981039346656037u;\n-            for (const char c : t.name) {\n-                hash ^= c;\n-                hash *= prime;\n-            }\n-            hash ^= m_hashSuffix;\n-            hash *= prime;\n-            const uint32_t low{ static_cast<uint32_t>(hash) };\n-            const uint32_t high{ static_cast<uint32_t>(hash >> 32) };\n-            return low * high;\n-        }\n-    };\n-} // end anonymous namespace\n-\n     std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases ) {\n         switch (config.runOrder()) {\n         case TestRunOrder::Declared:\n@@ -66,9 +41,9 @@ namespace {\n         }\n         case TestRunOrder::Randomized: {\n             seedRng(config);\n-            using TestWithHash = std::pair<TestHasher::hash_t, TestCaseHandle>;\n+            using TestWithHash = std::pair<TestCaseInfoHasher::hash_t, TestCaseHandle>;\n \n-            TestHasher h{ config.rngSeed() };\n+            TestCaseInfoHasher h{ config.rngSeed() };\n             std::vector<TestWithHash> indexed_tests;\n             indexed_tests.reserve(unsortedTestCases.size());\n \ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -88,6 +88,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/IntrospectiveTests/RandomNumberGeneration.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Reporters.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TestSpecParser.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TextFlow.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Sharding.tests.cpp\ndiff --git a/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n@@ -0,0 +1,51 @@\n+#include <catch2/catch_test_macros.hpp>\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+static constexpr Catch::SourceLineInfo dummySourceLineInfo = CATCH_INTERNAL_LINEINFO;\n+\n+TEST_CASE( \"TestCaseInfoHasher produces equal hashes.\" ) {\n+    SECTION( \"class names and names and tags are equal.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2));\n+    }\n+}\n+\n+TEST_CASE( \"TestCaseInfoHasher produces different hashes.\" ) {\n+    SECTION( \"class names are equal, names are equal but tags are different.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag2]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names are equal, tags are equal but names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name1\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name2\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"names are equal, tags are equal but class names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"class1\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"class2\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names and names and tags are equal but hashers are seeded differently.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher h1(14695981039346656037u);\n+        Catch::TestCaseInfoHasher h2(14695981039346656038u);\n+\n+        CHECK(h1(testCase1) != h2(testCase2));\n+    }\n+}\n", "problem_statement": "Test case name hashing should consider tags and class name too\n**Describe the bug**\r\nRecently I changed the \"unique test case\" criteria to allow test cases with same name, but different tags, or same names and tags but different class name (when a test case hangs off a type).\r\n\r\nHowever, we also hash test cases when ordering them randomly (to get subset-stable ordering), and the hashing currently only considers test case name, which means that hash collisions are now much more realistic (in fact the collision is guaranteed if two test cases have same name, which is a desired property by some users).\r\n\r\n_Note that this doesn't break the subset invariant, because we use the ordering of test case infos to break ties, which handles tags and class name properly_\r\n\r\n**Expected behavior**\r\nTo fix this, the hasher should also consider tags and class name.\r\n\r\n**Additional context**\r\nThis change also makes the hasher complex enough that it should be promoted to a header and receive direct unit tests.\n", "hints_text": "I am happy to work on this.\n@MohamedAlaa201 Sure, go for it.", "created_at": "2022-03-18T19:32:21Z"}
{"repo": "catchorg/Catch2", "pull_number": 2393, "instance_id": "catchorg__Catch2-2393", "issue_numbers": ["2328"], "base_commit": "ff151d2833d48aa630564859cd1401a93a2bb333", "patch": "diff --git a/include/internal/catch_session.cpp b/include/internal/catch_session.cpp\n--- a/include/internal/catch_session.cpp\n+++ b/include/internal/catch_session.cpp\n@@ -127,6 +127,10 @@ namespace Catch {\n                     filename.erase(0, lastSlash);\n                     filename[0] = '#';\n                 }\n+                else\n+                {\n+                    filename.insert(0, \"#\");\n+                }\n \n                 auto lastDot = filename.find_last_of('.');\n                 if (lastDot != std::string::npos) {\n", "test_patch": "", "problem_statement": "Missing # in the filename tag when __FILE__ is a filename\n**Describe the bug**\r\nWhen compiler flags are such that \\_\\_FILE\\_\\_ macro is replaced with a relative file path (on MSVC no /Z7, /Zi or /ZI and no /FC) then it might be replaced with just a filename with no path separators. In this case tags for tests with --filenames-as-tags do not contain '#' symbol.\r\n\r\nThe bug is present in the 2.x branch, but not in the main branch where the relevant code has been redesigned.\r\nThe culprit is the following code in catch_session.cpp:\r\n\r\n```\r\nvoid applyFilenamesAsTags(Catch::IConfig const& config) {\r\n    auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\r\n    for (auto& testCase : tests) {\r\n        auto tags = testCase.tags;\r\n\r\n        std::string filename = testCase.lineInfo.file;\r\n        auto lastSlash = filename.find_last_of(\"\\\\/\");\r\n        if (lastSlash != std::string::npos) {\r\n            filename.erase(0, lastSlash);\r\n            filename[0] = '#';\r\n        }\r\n\r\n        auto lastDot = filename.find_last_of('.');\r\n        if (lastDot != std::string::npos) {\r\n            filename.erase(lastDot);\r\n        }\r\n\r\n        tags.push_back(std::move(filename));\r\n        setTags(testCase, tags);\r\n    }\r\n}\r\n```\r\n\r\nAdding the following nonintrusive but uninspired adjustment resolves the issue:\r\n\r\n```\r\nvoid applyFilenamesAsTags(Catch::IConfig const& config) {\r\n    auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\r\n    for (auto& testCase : tests) {\r\n        auto tags = testCase.tags;\r\n\r\n        std::string filename = testCase.lineInfo.file;\r\n        auto lastSlash = filename.find_last_of(\"\\\\/\");\r\n        if (lastSlash != std::string::npos) {\r\n            filename.erase(0, lastSlash);\r\n            filename[0] = '#';\r\n        }\r\n        else\r\n        {\r\n            filename.insert(0, \"#\");\r\n        }\r\n\r\n        auto lastDot = filename.find_last_of('.');\r\n        if (lastDot != std::string::npos) {\r\n            filename.erase(lastDot);\r\n        }\r\n\r\n        tags.push_back(std::move(filename));\r\n        setTags(testCase, tags);\r\n    }\r\n}\r\n```\r\n\r\n**Expected behavior**\r\nSymbol # always prefixes filename tags.\r\n\r\n**Reproduction steps**\r\nCompiler flags (MSVC): no /Z7, /Zi, /ZI, /FC\r\nCatch flags: [#test_file] --filenames-as-tags\r\nPlace test_file.cpp with any test cases in the root project directory and try to run them.\r\nIn the current 2.x branch no tests would be found.\n", "hints_text": "", "created_at": "2022-03-17T20:03:55Z"}
{"repo": "catchorg/Catch2", "pull_number": 2360, "instance_id": "catchorg__Catch2-2360", "issue_numbers": ["395"], "base_commit": "52066dbc2a53f4c3ab2a418d03f93200a8245451", "patch": "diff --git a/src/catch2/catch_session.cpp b/src/catch2/catch_session.cpp\n--- a/src/catch2/catch_session.cpp\n+++ b/src/catch2/catch_session.cpp\n@@ -341,6 +341,12 @@ namespace Catch {\n                 return 2;\n             }\n \n+            if ( totals.testCases.total() > 0 &&\n+                 totals.testCases.total() == totals.testCases.skipped\n+                && !m_config->zeroTestsCountAsSuccess() ) {\n+                return 4;\n+            }\n+\n             // Note that on unices only the lower 8 bits are usually used, clamping\n             // the return value to 255 prevents false negative when some multiple\n             // of 256 tests has failed\ndiff --git a/src/catch2/catch_totals.cpp b/src/catch2/catch_totals.cpp\n--- a/src/catch2/catch_totals.cpp\n+++ b/src/catch2/catch_totals.cpp\n@@ -14,6 +14,7 @@ namespace Catch {\n         diff.passed = passed - other.passed;\n         diff.failed = failed - other.failed;\n         diff.failedButOk = failedButOk - other.failedButOk;\n+        diff.skipped = skipped - other.skipped;\n         return diff;\n     }\n \n@@ -21,14 +22,15 @@ namespace Catch {\n         passed += other.passed;\n         failed += other.failed;\n         failedButOk += other.failedButOk;\n+        skipped += other.skipped;\n         return *this;\n     }\n \n     std::uint64_t Counts::total() const {\n-        return passed + failed + failedButOk;\n+        return passed + failed + failedButOk + skipped;\n     }\n     bool Counts::allPassed() const {\n-        return failed == 0 && failedButOk == 0;\n+        return failed == 0 && failedButOk == 0 && skipped == 0;\n     }\n     bool Counts::allOk() const {\n         return failed == 0;\n@@ -53,6 +55,8 @@ namespace Catch {\n             ++diff.testCases.failed;\n         else if( diff.assertions.failedButOk > 0 )\n             ++diff.testCases.failedButOk;\n+        else if ( diff.assertions.skipped > 0 )\n+            ++ diff.testCases.skipped;\n         else\n             ++diff.testCases.passed;\n         return diff;\ndiff --git a/src/catch2/catch_totals.hpp b/src/catch2/catch_totals.hpp\n--- a/src/catch2/catch_totals.hpp\n+++ b/src/catch2/catch_totals.hpp\n@@ -23,6 +23,7 @@ namespace Catch {\n         std::uint64_t passed = 0;\n         std::uint64_t failed = 0;\n         std::uint64_t failedButOk = 0;\n+        std::uint64_t skipped = 0;\n     };\n \n     struct Totals {\ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter.hpp b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter.hpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n@@ -242,7 +242,12 @@ namespace Catch {\n          */\n         virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;\n \n-        //! Called with test cases that are skipped due to the test run aborting\n+        /**\n+         * Called with test cases that are skipped due to the test run aborting.\n+         * NOT called for test cases that are explicitly skipped using the `SKIP` macro.\n+         *\n+         * Deprecated - will be removed in the next major release.\n+         */\n         virtual void skipTest( TestCaseInfo const& testInfo ) = 0;\n \n         //! Called if a fatal error (signal/structured exception) occured\ndiff --git a/src/catch2/internal/catch_assertion_handler.cpp b/src/catch2/internal/catch_assertion_handler.cpp\n--- a/src/catch2/internal/catch_assertion_handler.cpp\n+++ b/src/catch2/internal/catch_assertion_handler.cpp\n@@ -50,6 +50,13 @@ namespace Catch {\n         if (m_reaction.shouldThrow) {\n             throw_test_failure_exception();\n         }\n+        if ( m_reaction.shouldSkip ) {\n+#if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )\n+            throw Catch::TestSkipException();\n+#else\n+            CATCH_ERROR( \"Explicitly skipping tests during runtime requires exceptions\" );\n+#endif\n+        }\n     }\n     void AssertionHandler::setCompleted() {\n         m_completed = true;\ndiff --git a/src/catch2/internal/catch_assertion_handler.hpp b/src/catch2/internal/catch_assertion_handler.hpp\n--- a/src/catch2/internal/catch_assertion_handler.hpp\n+++ b/src/catch2/internal/catch_assertion_handler.hpp\n@@ -22,6 +22,7 @@ namespace Catch {\n     struct AssertionReaction {\n         bool shouldDebugBreak = false;\n         bool shouldThrow = false;\n+        bool shouldSkip = false;\n     };\n \n     class AssertionHandler {\ndiff --git a/src/catch2/internal/catch_console_colour.hpp b/src/catch2/internal/catch_console_colour.hpp\n--- a/src/catch2/internal/catch_console_colour.hpp\n+++ b/src/catch2/internal/catch_console_colour.hpp\n@@ -47,6 +47,7 @@ namespace Catch {\n \n             Error = BrightRed,\n             Success = Green,\n+            Skip = LightGrey,\n \n             OriginalExpression = Cyan,\n             ReconstructedExpression = BrightYellow,\ndiff --git a/src/catch2/internal/catch_exception_translator_registry.cpp b/src/catch2/internal/catch_exception_translator_registry.cpp\n--- a/src/catch2/internal/catch_exception_translator_registry.cpp\n+++ b/src/catch2/internal/catch_exception_translator_registry.cpp\n@@ -44,6 +44,9 @@ namespace Catch {\n         catch( TestFailureException& ) {\n             std::rethrow_exception(std::current_exception());\n         }\n+        catch( TestSkipException& ) {\n+            std::rethrow_exception(std::current_exception());\n+        }\n         catch( std::exception const& ex ) {\n             return ex.what();\n         }\ndiff --git a/src/catch2/internal/catch_result_type.hpp b/src/catch2/internal/catch_result_type.hpp\n--- a/src/catch2/internal/catch_result_type.hpp\n+++ b/src/catch2/internal/catch_result_type.hpp\n@@ -16,6 +16,8 @@ namespace Catch {\n         Ok = 0,\n         Info = 1,\n         Warning = 2,\n+        // TODO: Should explicit skip be considered \"not OK\" (cf. isOk)? I.e., should it have the failure bit?\n+        ExplicitSkip = 4,\n \n         FailureBit = 0x10,\n \ndiff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -270,6 +270,9 @@ namespace Catch {\n         if (result.getResultType() == ResultWas::Ok) {\n             m_totals.assertions.passed++;\n             m_lastAssertionPassed = true;\n+        } else if (result.getResultType() == ResultWas::ExplicitSkip) {\n+            m_totals.assertions.skipped++;\n+            m_lastAssertionPassed = true;\n         } else if (!result.succeeded()) {\n             m_lastAssertionPassed = false;\n             if (result.isOk()) {\n@@ -475,6 +478,8 @@ namespace Catch {\n             duration = timer.getElapsedSeconds();\n         } CATCH_CATCH_ANON (TestFailureException&) {\n             // This just means the test was aborted due to failure\n+        } CATCH_CATCH_ANON (TestSkipException&) {\n+            // This just means the test was explicitly skipped\n         } CATCH_CATCH_ALL {\n             // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions\n             // are reported without translation at the point of origin.\n@@ -571,8 +576,13 @@ namespace Catch {\n         data.message = static_cast<std::string>(message);\n         AssertionResult assertionResult{ m_lastAssertionInfo, data };\n         assertionEnded( assertionResult );\n-        if( !assertionResult.isOk() )\n+        if ( !assertionResult.isOk() ) {\n             populateReaction( reaction );\n+        } else if ( resultType == ResultWas::ExplicitSkip ) {\n+            // TODO: Need to handle this explicitly, as ExplicitSkip is\n+            // considered \"OK\"\n+            reaction.shouldSkip = true;\n+        }\n     }\n     void RunContext::handleUnexpectedExceptionNotThrown(\n             AssertionInfo const& info,\ndiff --git a/src/catch2/reporters/catch_reporter_automake.cpp b/src/catch2/reporters/catch_reporter_automake.cpp\n--- a/src/catch2/reporters/catch_reporter_automake.cpp\n+++ b/src/catch2/reporters/catch_reporter_automake.cpp\n@@ -17,7 +17,9 @@ namespace Catch {\n     void AutomakeReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n         // Possible values to emit are PASS, XFAIL, SKIP, FAIL, XPASS and ERROR.\n         m_stream << \":test-result: \";\n-        if (_testCaseStats.totals.assertions.allPassed()) {\n+        if ( _testCaseStats.totals.testCases.skipped > 0 ) {\n+            m_stream << \"SKIP\";\n+        } else if (_testCaseStats.totals.assertions.allPassed()) {\n             m_stream << \"PASS\";\n         } else if (_testCaseStats.totals.assertions.allOk()) {\n             m_stream << \"XFAIL\";\ndiff --git a/src/catch2/reporters/catch_reporter_compact.cpp b/src/catch2/reporters/catch_reporter_compact.cpp\n--- a/src/catch2/reporters/catch_reporter_compact.cpp\n+++ b/src/catch2/reporters/catch_reporter_compact.cpp\n@@ -105,6 +105,11 @@ class AssertionPrinter {\n             printIssue(\"explicitly\");\n             printRemainingMessages(Colour::None);\n             break;\n+        case ResultWas::ExplicitSkip:\n+            printResultType(Colour::Skip, \"skipped\"_sr);\n+            printMessage();\n+            printRemainingMessages();\n+            break;\n             // These cases are here to prevent compiler warnings\n         case ResultWas::Unknown:\n         case ResultWas::FailureBit:\n@@ -220,7 +225,7 @@ class AssertionPrinter {\n \n             // Drop out if result was successful and we're not printing those\n             if( !m_config->includeSuccessfulResults() && result.isOk() ) {\n-                if( result.getResultType() != ResultWas::Warning )\n+                if( result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip )\n                     return;\n                 printInfoMessages = false;\n             }\ndiff --git a/src/catch2/reporters/catch_reporter_console.cpp b/src/catch2/reporters/catch_reporter_console.cpp\n--- a/src/catch2/reporters/catch_reporter_console.cpp\n+++ b/src/catch2/reporters/catch_reporter_console.cpp\n@@ -111,6 +111,14 @@ class ConsoleAssertionPrinter {\n             if (_stats.infoMessages.size() > 1)\n                 messageLabel = \"explicitly with messages\";\n             break;\n+        case ResultWas::ExplicitSkip:\n+            colour = Colour::Skip;\n+            passOrFail = \"SKIPPED\"_sr;\n+            if (_stats.infoMessages.size() == 1)\n+                messageLabel = \"explicitly with message\";\n+            if (_stats.infoMessages.size() > 1)\n+                messageLabel = \"explicitly with messages\";\n+            break;\n             // These cases are here to prevent compiler warnings\n         case ResultWas::Unknown:\n         case ResultWas::FailureBit:\n@@ -185,13 +193,16 @@ std::size_t makeRatio( std::uint64_t number, std::uint64_t total ) {\n     return (ratio == 0 && number > 0) ? 1 : static_cast<std::size_t>(ratio);\n }\n \n-std::size_t& findMax( std::size_t& i, std::size_t& j, std::size_t& k ) {\n-    if (i > j && i > k)\n+std::size_t&\n+findMax( std::size_t& i, std::size_t& j, std::size_t& k, std::size_t& l ) {\n+    if (i > j && i > k && i > l)\n         return i;\n-    else if (j > k)\n+    else if (j > k && j > l)\n         return j;\n-    else\n+    else if (k > l)\n         return k;\n+    else\n+        return l;\n }\n \n enum class Justification { Left, Right };\n@@ -400,7 +411,8 @@ void ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n     bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n \n     // Drop out if result was successful but we're not printing them.\n-    if (!includeResults && result.getResultType() != ResultWas::Warning)\n+    // TODO: Make configurable whether skips should be printed\n+    if (!includeResults && result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip)\n         return;\n \n     lazyPrint();\n@@ -603,10 +615,11 @@ void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\n         std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());\n         std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());\n-        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\n-            findMax(failedRatio, failedButOkRatio, passedRatio)++;\n+        std::size_t skippedRatio = makeRatio(totals.testCases.skipped, totals.testCases.total());\n+        while (failedRatio + failedButOkRatio + passedRatio + skippedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\n+            findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)++;\n         while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)\n-            findMax(failedRatio, failedButOkRatio, passedRatio)--;\n+            findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)--;\n \n         m_stream << m_colour->guardColour( Colour::Error )\n                  << std::string( failedRatio, '=' )\n@@ -619,6 +632,8 @@ void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n             m_stream << m_colour->guardColour( Colour::Success )\n                      << std::string( passedRatio, '=' );\n         }\n+        m_stream << m_colour->guardColour( Colour::Skip )\n+                 << std::string( skippedRatio, '=' );\n     } else {\n         m_stream << m_colour->guardColour( Colour::Warning )\n                  << std::string( CATCH_CONFIG_CONSOLE_WIDTH - 1, '=' );\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.cpp b/src/catch2/reporters/catch_reporter_helpers.cpp\n--- a/src/catch2/reporters/catch_reporter_helpers.cpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.cpp\n@@ -316,15 +316,22 @@ namespace Catch {\n         }\n \n         std::vector<SummaryColumn> columns;\n+        // Don't include \"skipped assertions\" in total count\n+        const auto totalAssertionCount =\n+            totals.assertions.total() - totals.assertions.skipped;\n         columns.push_back( SummaryColumn( \"\", Colour::None )\n                                .addRow( totals.testCases.total() )\n-                               .addRow( totals.assertions.total() ) );\n+                               .addRow( totalAssertionCount ) );\n         columns.push_back( SummaryColumn( \"passed\", Colour::Success )\n                                .addRow( totals.testCases.passed )\n                                .addRow( totals.assertions.passed ) );\n         columns.push_back( SummaryColumn( \"failed\", Colour::ResultError )\n                                .addRow( totals.testCases.failed )\n                                .addRow( totals.assertions.failed ) );\n+        columns.push_back( SummaryColumn( \"skipped\", Colour::Skip )\n+                               .addRow( totals.testCases.skipped )\n+                               // Don't print \"skipped assertions\"\n+                               .addRow( 0 ) );\n         columns.push_back(\n             SummaryColumn( \"failed as expected\", Colour::ResultExpectedFailure )\n                 .addRow( totals.testCases.failedButOk )\ndiff --git a/src/catch2/reporters/catch_reporter_junit.cpp b/src/catch2/reporters/catch_reporter_junit.cpp\n--- a/src/catch2/reporters/catch_reporter_junit.cpp\n+++ b/src/catch2/reporters/catch_reporter_junit.cpp\n@@ -132,6 +132,7 @@ namespace Catch {\n         xml.writeAttribute( \"name\"_sr, stats.runInfo.name );\n         xml.writeAttribute( \"errors\"_sr, unexpectedExceptions );\n         xml.writeAttribute( \"failures\"_sr, stats.totals.assertions.failed-unexpectedExceptions );\n+        xml.writeAttribute( \"skipped\"_sr, stats.totals.assertions.skipped );\n         xml.writeAttribute( \"tests\"_sr, stats.totals.assertions.total() );\n         xml.writeAttribute( \"hostname\"_sr, \"tbd\"_sr ); // !TBD\n         if( m_config->showDurations() == ShowDurations::Never )\n@@ -244,7 +245,8 @@ namespace Catch {\n \n     void JunitReporter::writeAssertion( AssertionStats const& stats ) {\n         AssertionResult const& result = stats.assertionResult;\n-        if( !result.isOk() ) {\n+        if ( !result.isOk() ||\n+             result.getResultType() == ResultWas::ExplicitSkip ) {\n             std::string elementName;\n             switch( result.getResultType() ) {\n                 case ResultWas::ThrewException:\n@@ -256,7 +258,9 @@ namespace Catch {\n                 case ResultWas::DidntThrowException:\n                     elementName = \"failure\";\n                     break;\n-\n+                case ResultWas::ExplicitSkip:\n+                    elementName = \"skipped\";\n+                    break;\n                 // We should never see these here:\n                 case ResultWas::Info:\n                 case ResultWas::Warning:\n@@ -274,7 +278,9 @@ namespace Catch {\n             xml.writeAttribute( \"type\"_sr, result.getTestMacroName() );\n \n             ReusableStringStream rss;\n-            if (stats.totals.assertions.total() > 0) {\n+            if ( result.getResultType() == ResultWas::ExplicitSkip ) {\n+                rss << \"SKIPPED\\n\";\n+            } else {\n                 rss << \"FAILED\" << \":\\n\";\n                 if (result.hasExpression()) {\n                     rss << \"  \";\n@@ -285,8 +291,6 @@ namespace Catch {\n                     rss << \"with expansion:\\n\";\n                     rss << TextFlow::Column(result.getExpandedExpression()).indent(2) << '\\n';\n                 }\n-            } else {\n-                rss << '\\n';\n             }\n \n             if( !result.getMessage().empty() )\ndiff --git a/src/catch2/reporters/catch_reporter_sonarqube.cpp b/src/catch2/reporters/catch_reporter_sonarqube.cpp\n--- a/src/catch2/reporters/catch_reporter_sonarqube.cpp\n+++ b/src/catch2/reporters/catch_reporter_sonarqube.cpp\n@@ -97,7 +97,8 @@ namespace Catch {\n \n     void SonarQubeReporter::writeAssertion(AssertionStats const& stats, bool okToFail) {\n         AssertionResult const& result = stats.assertionResult;\n-        if (!result.isOk()) {\n+        if ( !result.isOk() ||\n+             result.getResultType() == ResultWas::ExplicitSkip ) {\n             std::string elementName;\n             if (okToFail) {\n                 elementName = \"skipped\";\n@@ -108,15 +109,13 @@ namespace Catch {\n                     elementName = \"error\";\n                     break;\n                 case ResultWas::ExplicitFailure:\n-                    elementName = \"failure\";\n-                    break;\n                 case ResultWas::ExpressionFailed:\n-                    elementName = \"failure\";\n-                    break;\n                 case ResultWas::DidntThrowException:\n                     elementName = \"failure\";\n                     break;\n-\n+                case ResultWas::ExplicitSkip:\n+                    elementName = \"skipped\";\n+                    break;\n                     // We should never see these here:\n                 case ResultWas::Info:\n                 case ResultWas::Warning:\n@@ -136,7 +135,9 @@ namespace Catch {\n             xml.writeAttribute(\"message\"_sr, messageRss.str());\n \n             ReusableStringStream textRss;\n-            if (stats.totals.assertions.total() > 0) {\n+            if ( result.getResultType() == ResultWas::ExplicitSkip ) {\n+                textRss << \"SKIPPED\\n\";\n+            } else {\n                 textRss << \"FAILED:\\n\";\n                 if (result.hasExpression()) {\n                     textRss << '\\t' << result.getExpressionInMacro() << '\\n';\ndiff --git a/src/catch2/reporters/catch_reporter_tap.cpp b/src/catch2/reporters/catch_reporter_tap.cpp\n--- a/src/catch2/reporters/catch_reporter_tap.cpp\n+++ b/src/catch2/reporters/catch_reporter_tap.cpp\n@@ -100,6 +100,12 @@ namespace Catch {\n                     printIssue(\"explicitly\"_sr);\n                     printRemainingMessages(Colour::None);\n                     break;\n+                case ResultWas::ExplicitSkip:\n+                    printResultType(tapPassedString);\n+                    printIssue(\" # SKIP\"_sr);\n+                    printMessage();\n+                    printRemainingMessages();\n+                    break;\n                     // These cases are here to prevent compiler warnings\n                 case ResultWas::Unknown:\n                 case ResultWas::FailureBit:\ndiff --git a/src/catch2/reporters/catch_reporter_teamcity.cpp b/src/catch2/reporters/catch_reporter_teamcity.cpp\n--- a/src/catch2/reporters/catch_reporter_teamcity.cpp\n+++ b/src/catch2/reporters/catch_reporter_teamcity.cpp\n@@ -59,7 +59,8 @@ namespace Catch {\n \n     void TeamCityReporter::assertionEnded(AssertionStats const& assertionStats) {\n         AssertionResult const& result = assertionStats.assertionResult;\n-        if (!result.isOk()) {\n+        if ( !result.isOk() ||\n+             result.getResultType() == ResultWas::ExplicitSkip ) {\n \n             ReusableStringStream msg;\n             if (!m_headerPrintedForThisSection)\n@@ -84,6 +85,9 @@ namespace Catch {\n             case ResultWas::ExplicitFailure:\n                 msg << \"explicit failure\";\n                 break;\n+            case ResultWas::ExplicitSkip:\n+                msg << \"explicit skip\";\n+                break;\n \n                 // We shouldn't get here because of the isOk() test\n             case ResultWas::Ok:\n@@ -111,18 +115,16 @@ namespace Catch {\n                     \"  \" << result.getExpandedExpression() << '\\n';\n             }\n \n-            if (currentTestCaseInfo->okToFail()) {\n+            if ( result.getResultType() == ResultWas::ExplicitSkip ) {\n+                m_stream << \"##teamcity[testIgnored\";\n+            } else if ( currentTestCaseInfo->okToFail() ) {\n                 msg << \"- failure ignore as test marked as 'ok to fail'\\n\";\n-                m_stream << \"##teamcity[testIgnored\"\n-                    << \" name='\" << escape(currentTestCaseInfo->name) << '\\''\n-                    << \" message='\" << escape(msg.str()) << '\\''\n-                    << \"]\\n\";\n+                m_stream << \"##teamcity[testIgnored\";\n             } else {\n-                m_stream << \"##teamcity[testFailed\"\n-                    << \" name='\" << escape(currentTestCaseInfo->name) << '\\''\n-                    << \" message='\" << escape(msg.str()) << '\\''\n-                    << \"]\\n\";\n+                m_stream << \"##teamcity[testFailed\";\n             }\n+            m_stream << \" name='\" << escape( currentTestCaseInfo->name ) << '\\''\n+                     << \" message='\" << escape( msg.str() ) << '\\'' << \"]\\n\";\n         }\n         m_stream.flush();\n     }\ndiff --git a/src/catch2/reporters/catch_reporter_xml.cpp b/src/catch2/reporters/catch_reporter_xml.cpp\n--- a/src/catch2/reporters/catch_reporter_xml.cpp\n+++ b/src/catch2/reporters/catch_reporter_xml.cpp\n@@ -108,9 +108,10 @@ namespace Catch {\n         }\n \n         // Drop out if result was successful but we're not printing them.\n-        if( !includeResults && result.getResultType() != ResultWas::Warning )\n+        if ( !includeResults && result.getResultType() != ResultWas::Warning &&\n+             result.getResultType() != ResultWas::ExplicitSkip ) {\n             return;\n-\n+        }\n \n         // Print the expression if there is one.\n         if( result.hasExpression() ) {\n@@ -153,6 +154,12 @@ namespace Catch {\n                 m_xml.writeText( result.getMessage() );\n                 m_xml.endElement();\n                 break;\n+            case ResultWas::ExplicitSkip:\n+                m_xml.startElement( \"Skip\" );\n+                writeSourceInfo( result.getSourceInfo() );\n+                m_xml.writeText( result.getMessage() );\n+                m_xml.endElement();\n+                break;\n             default:\n                 break;\n         }\n@@ -163,15 +170,18 @@ namespace Catch {\n \n     void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {\n         StreamingReporterBase::sectionEnded( sectionStats );\n-        if( --m_sectionDepth > 0 ) {\n-            XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResults\" );\n-            e.writeAttribute( \"successes\"_sr, sectionStats.assertions.passed );\n-            e.writeAttribute( \"failures\"_sr, sectionStats.assertions.failed );\n-            e.writeAttribute( \"expectedFailures\"_sr, sectionStats.assertions.failedButOk );\n-\n-            if ( m_config->showDurations() == ShowDurations::Always )\n-                e.writeAttribute( \"durationInSeconds\"_sr, sectionStats.durationInSeconds );\n-\n+        if ( --m_sectionDepth > 0 ) {\n+            {\n+                XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResults\" );\n+                e.writeAttribute( \"successes\"_sr, sectionStats.assertions.passed );\n+                e.writeAttribute( \"failures\"_sr, sectionStats.assertions.failed );\n+                e.writeAttribute( \"expectedFailures\"_sr, sectionStats.assertions.failedButOk );\n+                e.writeAttribute( \"skipped\"_sr, sectionStats.assertions.skipped > 0 );\n+\n+                if ( m_config->showDurations() == ShowDurations::Always )\n+                    e.writeAttribute( \"durationInSeconds\"_sr, sectionStats.durationInSeconds );\n+            }\n+            // Ends assertion tag\n             m_xml.endElement();\n         }\n     }\n@@ -180,6 +190,7 @@ namespace Catch {\n         StreamingReporterBase::testCaseEnded( testCaseStats );\n         XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResult\" );\n         e.writeAttribute( \"success\"_sr, testCaseStats.totals.assertions.allOk() );\n+        e.writeAttribute( \"skips\"_sr, testCaseStats.totals.assertions.skipped );\n \n         if ( m_config->showDurations() == ShowDurations::Always )\n             e.writeAttribute( \"durationInSeconds\"_sr, m_testCaseTimer.getElapsedSeconds() );\n@@ -197,11 +208,13 @@ namespace Catch {\n         m_xml.scopedElement( \"OverallResults\" )\n             .writeAttribute( \"successes\"_sr, testRunStats.totals.assertions.passed )\n             .writeAttribute( \"failures\"_sr, testRunStats.totals.assertions.failed )\n-            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.assertions.failedButOk );\n+            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.assertions.failedButOk )\n+            .writeAttribute( \"skips\"_sr, testRunStats.totals.assertions.skipped );\n         m_xml.scopedElement( \"OverallResultsCases\")\n             .writeAttribute( \"successes\"_sr, testRunStats.totals.testCases.passed )\n             .writeAttribute( \"failures\"_sr, testRunStats.totals.testCases.failed )\n-            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.testCases.failedButOk );\n+            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.testCases.failedButOk )\n+            .writeAttribute( \"skips\"_sr, testRunStats.totals.testCases.skipped );\n         m_xml.endElement();\n     }\n \n", "test_patch": "diff --git a/src/catch2/catch_test_macros.hpp b/src/catch2/catch_test_macros.hpp\n--- a/src/catch2/catch_test_macros.hpp\n+++ b/src/catch2/catch_test_macros.hpp\n@@ -49,6 +49,7 @@\n   #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n   #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( \"CATCH_SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CATCH_SKIP( ... ) INTERNAL_CATCH_MSG( \"SKIP\", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n \n \n   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)\n@@ -102,6 +103,7 @@\n   #define CATCH_FAIL( ... ) (void)(0)\n   #define CATCH_FAIL_CHECK( ... ) (void)(0)\n   #define CATCH_SUCCEED( ... ) (void)(0)\n+  #define CATCH_SKIP( ... ) (void)(0)\n \n   #define CATCH_STATIC_REQUIRE( ... )       (void)(0)\n   #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)\n@@ -146,6 +148,7 @@\n   #define FAIL( ... ) INTERNAL_CATCH_MSG( \"FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n   #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define SUCCEED( ... ) INTERNAL_CATCH_MSG( \"SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define SKIP( ... ) INTERNAL_CATCH_MSG( \"SKIP\", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n \n \n   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)\n@@ -198,6 +201,7 @@\n   #define FAIL( ... ) (void)(0)\n   #define FAIL_CHECK( ... ) (void)(0)\n   #define SUCCEED( ... ) (void)(0)\n+  #define SKIP( ... ) (void)(0)\n \n   #define STATIC_REQUIRE( ... )       (void)(0)\n   #define STATIC_REQUIRE_FALSE( ... ) (void)(0)\ndiff --git a/src/catch2/internal/catch_test_failure_exception.hpp b/src/catch2/internal/catch_test_failure_exception.hpp\n--- a/src/catch2/internal/catch_test_failure_exception.hpp\n+++ b/src/catch2/internal/catch_test_failure_exception.hpp\n@@ -20,6 +20,9 @@ namespace Catch {\n      */\n     [[noreturn]] void throw_test_failure_exception();\n \n+    //! Used to signal that the remainder of a test should be skipped\n+    struct TestSkipException{};\n+\n } // namespace Catch\n \n #endif // CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED\ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -116,6 +116,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/UsageTests/Generators.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/Message.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/Misc.tests.cpp\n+        ${SELF_TEST_DIR}/UsageTests/Skip.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/ToStringByte.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/ToStringChrono.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/ToStringGeneral.tests.cpp\n@@ -272,6 +273,10 @@ add_test(NAME TestSpecs::OverrideFailureWithNoMatchedTests\n   COMMAND $<TARGET_FILE:SelfTest> \"___nonexistent_test___\" --allow-running-no-tests\n )\n \n+add_test(NAME TestSpecs::OverrideAllSkipFailure\n+  COMMAND $<TARGET_FILE:SelfTest> \"tests can be skipped dynamically at runtime\" --allow-running-no-tests\n+)\n+\n add_test(NAME TestSpecs::NonMatchingTestSpecIsRoundTrippable\n     COMMAND $<TARGET_FILE:SelfTest> Tracker, \"this test does not exist\" \"[nor does this tag]\"\n )\ndiff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -488,15 +488,32 @@ set_tests_properties(TestSpecs::EmptySpecWithNoTestsFails\n   PROPERTIES\n     WILL_FAIL ON\n )\n+\n add_test(\n   NAME TestSpecs::OverrideFailureWithEmptySpec\n   COMMAND $<TARGET_FILE:NoTests> --allow-running-no-tests\n )\n+\n add_test(\n   NAME List::Listeners::WorksWithoutRegisteredListeners\n   COMMAND $<TARGET_FILE:NoTests> --list-listeners\n )\n+\n+\n+add_executable(AllSkipped ${TESTS_DIR}/X93-AllSkipped.cpp)\n+target_link_libraries(AllSkipped PRIVATE Catch2::Catch2WithMain)\n+\n+add_test(\n+  NAME TestSpecs::SkippingAllTestsFails\n+  COMMAND $<TARGET_FILE:AllSkipped>\n+)\n+set_tests_properties(TestSpecs::SkippingAllTestsFails\n+  PROPERTIES\n+    WILL_FAIL ON\n+)\n+\n set( EXTRA_TEST_BINARIES\n+    AllSkipped\n     PrefixedMacros\n     DisabledMacros\n     DisabledExceptions-DefaultHandler\ndiff --git a/tests/ExtraTests/X93-AllSkipped.cpp b/tests/ExtraTests/X93-AllSkipped.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ExtraTests/X93-AllSkipped.cpp\n@@ -0,0 +1,16 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+TEST_CASE( \"this test case is being skipped\" ) { SKIP(); }\n+\n+TEST_CASE( \"all sections in this test case are being skipped\" ) {\n+    SECTION( \"A\" ) { SKIP(); }\n+    SECTION( \"B\" ) { SKIP(); }\n+}\ndiff --git a/tests/SelfTest/UsageTests/Skip.tests.cpp b/tests/SelfTest/UsageTests/Skip.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/UsageTests/Skip.tests.cpp\n@@ -0,0 +1,73 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+#include <catch2/generators/catch_generators_range.hpp>\n+\n+#include <iostream>\n+\n+TEST_CASE( \"tests can be skipped dynamically at runtime\", \"[skipping]\" ) {\n+    SKIP();\n+    FAIL( \"this is not reached\" );\n+}\n+\n+TEST_CASE( \"skipped tests can optionally provide a reason\", \"[skipping]\" ) {\n+    const int answer = 43;\n+    SKIP( \"skipping because answer = \" << answer );\n+    FAIL( \"this is not reached\" );\n+}\n+\n+TEST_CASE( \"sections can be skipped dynamically at runtime\", \"[skipping]\" ) {\n+    SECTION( \"not skipped\" ) { SUCCEED(); }\n+    SECTION( \"skipped\" ) { SKIP(); }\n+    SECTION( \"also not skipped\" ) { SUCCEED(); }\n+}\n+\n+TEST_CASE( \"nested sections can be skipped dynamically at runtime\",\n+           \"[skipping]\" ) {\n+    SECTION( \"A\" ) { std::cout << \"a\"; }\n+    SECTION( \"B\" ) {\n+        SECTION( \"B1\" ) { std::cout << \"b1\"; }\n+        SECTION( \"B2\" ) { SKIP(); }\n+    }\n+    std::cout << \"!\\n\";\n+}\n+\n+TEST_CASE( \"dynamic skipping works with generators\", \"[skipping]\" ) {\n+    const int answer = GENERATE( 41, 42, 43 );\n+    if ( answer != 42 ) { SKIP( \"skipping because answer = \" << answer ); }\n+    SUCCEED();\n+}\n+\n+TEST_CASE( \"failed assertions before SKIP cause test case to fail\",\n+           \"[skipping][!shouldfail]\" ) {\n+    CHECK( 3 == 4 );\n+    SKIP();\n+}\n+\n+TEST_CASE( \"a succeeding test can still be skipped\",\n+           \"[skipping][!shouldfail]\" ) {\n+    SUCCEED();\n+    SKIP();\n+}\n+\n+TEST_CASE( \"failing in some unskipped sections causes entire test case to fail\",\n+           \"[skipping][!shouldfail]\" ) {\n+    SECTION( \"skipped\" ) { SKIP(); }\n+    SECTION( \"not skipped\" ) { FAIL(); }\n+}\n+\n+TEST_CASE( \"failing for some generator values causes entire test case to fail\",\n+           \"[skipping][!shouldfail]\" ) {\n+    int i = GENERATE( 1, 2, 3, 4 );\n+    if ( i % 2 == 0 ) {\n+        SKIP();\n+    } else {\n+        FAIL();\n+    }\n+}\n", "problem_statement": "Allow skipping tests at run-time.\nThis is another request for a way to skip tests, but it's not quite the same as #355 because in my case the condition determining if the test can be run or should be skipped is dynamic and determined by the program itself (basically it connects to the database specified on the command line and does different things depending on the exact kind of RDBMS).\n\nCurrently I just test the condition and use `WARN(\"Skipped because...\")`, but this is not ideal because the test still counts as passing when, in fact, it wasn't run at all.\n\n", "hints_text": "The next level would be to have a declarative way of describing dependencies between tests. And when one is skipped or failed skip the dependent ones.\n\nIt would be really great to have this facility for a bunch of tests I have, as their viability is determined only at runtime.", "created_at": "2022-01-31T16:16:06Z"}
{"repo": "catchorg/Catch2", "pull_number": 2334, "instance_id": "catchorg__Catch2-2334", "issue_numbers": ["898"], "base_commit": "d3199c42c2af0f69e43686c2b47189c8bad04026", "patch": "diff --git a/src/catch2/internal/catch_fatal_condition_handler.cpp b/src/catch2/internal/catch_fatal_condition_handler.cpp\n--- a/src/catch2/internal/catch_fatal_condition_handler.cpp\n+++ b/src/catch2/internal/catch_fatal_condition_handler.cpp\n@@ -84,7 +84,7 @@ namespace Catch {\n         { static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), \"Divide by zero error\" },\n     };\n \n-    static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {\n+    static LONG CALLBACK topLevelExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo) {\n         for (auto const& def : signalDefs) {\n             if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {\n                 reportFatal(def.name);\n@@ -98,7 +98,7 @@ namespace Catch {\n     // Since we do not support multiple instantiations, we put these\n     // into global variables and rely on cleaning them up in outlined\n     // constructors/destructors\n-    static PVOID exceptionHandlerHandle = nullptr;\n+    static LPTOP_LEVEL_EXCEPTION_FILTER previousTopLevelExceptionFilter = nullptr;\n \n \n     // For MSVC, we reserve part of the stack memory for handling\n@@ -120,18 +120,15 @@ namespace Catch {\n \n \n     void FatalConditionHandler::engage_platform() {\n-        // Register as first handler in current chain\n-        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\n-        if (!exceptionHandlerHandle) {\n-            CATCH_RUNTIME_ERROR(\"Could not register vectored exception handler\");\n-        }\n+        // Register as a the top level exception filter.\n+        previousTopLevelExceptionFilter = SetUnhandledExceptionFilter(topLevelExceptionFilter);\n     }\n \n     void FatalConditionHandler::disengage_platform() {\n-        if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {\n-            CATCH_RUNTIME_ERROR(\"Could not unregister vectored exception handler\");\n+        if (SetUnhandledExceptionFilter(reinterpret_cast<LPTOP_LEVEL_EXCEPTION_FILTER>(previousTopLevelExceptionFilter)) != topLevelExceptionFilter) {\n+            CATCH_RUNTIME_ERROR(\"Could not restore previous top level exception filter\");\n         }\n-        exceptionHandlerHandle = nullptr;\n+        previousTopLevelExceptionFilter = nullptr;\n     }\n \n } // end namespace Catch\n", "test_patch": "diff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -6,6 +6,7 @@\n #include <catch2/catch_test_macros.hpp>\n #include <catch2/catch_template_test_macros.hpp>\n #include <catch2/internal/catch_config_wchar.hpp>\n+#include <catch2/internal/catch_windows_h_proxy.hpp>\n \n #ifdef __clang__\n #   pragma clang diagnostic ignored \"-Wc++98-compat\"\n@@ -498,3 +499,34 @@ TEMPLATE_TEST_CASE_SIG(\"#1954 - 7 arg template test case sig compiles\", \"[regres\n \n TEST_CASE(\"Same test name but with different tags is fine\", \"[.approvals][some-tag]\") {}\n TEST_CASE(\"Same test name but with different tags is fine\", \"[.approvals][other-tag]\") {}\n+\n+#if defined(CATCH_PLATFORM_WINDOWS)\n+void throw_and_catch()\n+{\n+    __try {\n+        RaiseException(0xC0000005, 0, 0, NULL);\n+    }\n+    __except (1)\n+    {\n+\n+    }\n+}\n+\n+\n+TEST_CASE(\"Validate SEH behavior - handled\", \"[approvals][FatalConditionHandler][CATCH_PLATFORM_WINDOWS]\")\n+{\n+    // Validate that Catch2 framework correctly handles tests raising and handling SEH exceptions.\n+    throw_and_catch();\n+}\n+\n+void throw_no_catch()\n+{\n+    RaiseException(0xC0000005, 0, 0, NULL);\n+}\n+\n+TEST_CASE(\"Validate SEH behavior - unhandled\", \"[.approvals][FatalConditionHandler][CATCH_PLATFORM_WINDOWS]\")\n+{\n+    // Validate that Catch2 framework correctly handles tests raising and not handling SEH exceptions.\n+    throw_no_catch();\n+}\n+#endif\n", "problem_statement": "[clang] [windows] [address-sanitizer] stack overflow when test is failing\n## Description\r\nCatch enters infinite recursion trying to print error message when compiled with clang -faddress-sanitize under Windows\r\n\r\n### Steps to reproduce\r\n0. Install VS 2015 and [clang](http://llvm.org/pre-releases/win-snapshots/LLVM-5.0.0-r300231-win64.exe)\r\n1. Put `catch.hpp` and `test.bat` from [test.zip](https://github.com/philsquared/Catch/files/964783/test.zip) in one directory, start `test.bat`\r\n2. Resulting executable, instead of reporting an error, will output:\r\n<pre>\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n</pre>\r\nand then it will crash.\r\n\n", "hints_text": "FWIW this works normally under Linux.\r\n\r\nWhat if you use normal Clang:\r\n\r\n```\r\nclang++ -fsanitize=address -o test.exe test.cpp\r\n```\r\n\r\nAlso, you seem to be building a normal, shared executable. What if you change the library name to `clang_rt.asan_dynamic-x86_64.lib`? (The one you're using is for applications using the static CRT.)\nCompiling with \r\n\r\n    clang++ -fsanitize=address -o test.exe test.cpp\r\n\r\ngives me \r\n\r\n<pre>\r\n==748==AddressSanitizer CHECK failed: D:\\src\\llvm_package_300231\\llvm\\projects\\compiler-rt\\lib\\asan\\asan_rtl.cc:505 \"((!asan_init_is_running && \"ASan init calls itself!\")) != (0)\" (0x0, 0x0)\r\n==748==AddressSanitizer CHECK failed: D:\\src\\llvm_package_300231\\llvm\\projects\\compiler-rt\\lib\\asan\\asan_poisoning.cc:37 \"((AddrIsInMem(addr))) != (0)\" (0x0, 0x0)\r\n</pre>\r\n \r\neven if 'test.cpp' is just an empty `main`. This is why I've added `/DEBUG` when linking. This has nothing to do with Catch, must be clang bug.\r\n\r\nWith `clang_rt.asan_dynamic-x86_64.lib` linking fails:\r\n<pre>\r\ntest.obj : error LNK2019: unresolved external symbol __asan_shadow_memory_dynamic_address referenced in function \"struct Catch::IResultCapture & __cdecl Catch::getResultCapture(void)\" (?getResultCapture@Catch@@YAAEAUIResultCapture@1@XZ)\r\ntest.obj : error LNK2019: unresolved external symbol __asan_option_detect_stack_use_after_return referenced in function \"struct Catch::IResultCapture & __cdecl Catch::getResultCapture(void)\" (?getResultCapture@Catch@@YAAEAUIResultCapture@1@XZ)\r\ntest.exe : fatal error LNK1120: 2 unresolved externals\r\n</pre>\r\n\nIs ASan supported under Windows? Last time I checked, it was \"this will very likely work for C, C++ is very much beta\".\nHello. Now that Address Sanitizer is [Generally Available](https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/) for MSVC, I've noticed that I'm unable to run my tests due to this issue--they get stuck and won't complete.\r\n\r\nAfter some digging, I found a relevant open issue on Microsoft's tracker with a [potential workaround](https://developercommunity.visualstudio.com/t/Asan-problems-when-manual-exception-hand/1242524#T-N1295191) that would consist of the following (naive) change to Catch here https://github.com/catchorg/Catch2/blob/b025a007b924cc16da84c07a5d35118695cb9bcc/include/internal/catch_fatal_condition.cpp#L64 and here for the single include header: https://github.com/catchorg/Catch2/blob/b025a007b924cc16da84c07a5d35118695cb9bcc/single_include/catch2/catch.hpp#L10787\r\n\r\n```diff\r\n- exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\r\n+ exceptionHandlerHandle = AddVectoredExceptionHandler(0, handleVectoredException);\r\n```\r\n\r\n\r\nI've tested this change locally with a modified (read: updated) version of the batch script in the OP with a fully updated Visual Studio (v16.9.1) on latest Catch (v2.13.4), and it seems to run to completion! \r\n```bat\r\necho #define CATCH_CONFIG_MAIN > test.cpp\r\necho #include \"catch.hpp\" >> test.cpp\r\necho TEST_CASE( \"t\", \"[t]\" ) { REQUIRE( 2 == 1 ); } >> test.cpp\r\n\r\ncall \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" amd64\r\necho Please wait...\r\ncl /EHsc test.cpp -fsanitize=address -c\r\nlink /DEBUG test.obj\r\n\r\nstart test.exe\r\n```\r\n\r\nHowever, I don't understand the consequences of this change and how it could affect the rest of Catch's logic and exception handling, so hopefully this helps one of the maintainers or someone else more familiar with the code base and C++ in general \ud83d\ude42 \nThis is related to the way asan is implemented on x64 msvc. See here [doc](https://devblogs.microsoft.com/cppblog/asan-for-windows-x64-and-debug-build-support/).\r\nCatch2 is catching tons of 0xc0000005 (FCE - first chance exceptions) and gets confused.\r\nYour fix works but gives up on FCEs.\r\n\r\ncatch2+asan+msvc is working on x86 unmodified (but nobody builds for x86 anymore)\r\n\r\nMaybe catch2 could offer an option to give up on first chance exception or do it automatically on x64 with\r\n```#  if __SANITIZE_ADDRESS__\r\n... ```\r\n\r\nEdit: with catch2 moving as a library, this way to fix depending on asan would not work. \nas a workaround, setting `CATCH_CONFIG_NO_WINDOWS_SEH` fixed this issue for me (tested with 2.13.6).", "created_at": "2021-12-15T17:06:20Z"}
{"repo": "catchorg/Catch2", "pull_number": 2288, "instance_id": "catchorg__Catch2-2288", "issue_numbers": ["2273"], "base_commit": "85c9544fa4c9625b9656d9bd765e54f8e639287f", "patch": "diff --git a/include/internal/catch_approx.h b/include/internal/catch_approx.h\n--- a/include/internal/catch_approx.h\n+++ b/include/internal/catch_approx.h\n@@ -33,7 +33,7 @@ namespace Detail {\n         Approx operator-() const;\n \n         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n-        Approx operator()( T const& value ) {\n+        Approx operator()( T const& value ) const {\n             Approx approx( static_cast<double>(value) );\n             approx.m_epsilon = m_epsilon;\n             approx.m_margin = m_margin;\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Approx.tests.cpp b/projects/SelfTest/UsageTests/Approx.tests.cpp\n--- a/projects/SelfTest/UsageTests/Approx.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Approx.tests.cpp\n@@ -212,4 +212,11 @@ TEST_CASE( \"Comparison with explicitly convertible types\", \"[Approx]\" )\n \n }\n \n+TEST_CASE(\"Approx::operator() is const correct\", \"[Approx][.approvals]\") {\n+  const Approx ap = Approx(0.0).margin(0.01);\n+\n+  // As long as this compiles, the test should be considered passing\n+  REQUIRE(1.0 == ap(1.0));\n+}\n+\n }} // namespace ApproxTests\n", "problem_statement": "Approx::operator() not const-correct\n**Describe the bug**\r\n\r\nThe `Approx` type has an overload of `template <typename T, ...SFINAE...> Approx operator()(T const&)` which (correct me if I'm wrong) is meant to be a factory function for instances that have the same epsilon, margin, and scale, but that use the passed value. \r\n\r\nAFAICT this should be const on the instance, but it's not.\r\n\r\nMinimum failing example:\r\n```C++\r\n#include <catch2/catch.hpp>\r\n\r\nTEST_CASE(\"Approx factory is const-correct\") {\r\n  // Set up a template Approx with problem-specific margin, etc.\r\n  Approx const apprx = Approx(0.0).margin(1e-6);\r\n  double value = 1.0;\r\n  // Use template in assertions\r\n  REQUIRE(value == apprx(1.0));\r\n}\r\n```\r\n\r\n**Expected behavior**\r\nAbove test compiles, runs and passes.\r\n\r\n**Reproduction steps**\r\nSee above.\r\n\r\n**Platform information:**\r\n - OS: RHEL 8\r\n - Compiler+version: GCC 8.2.0\r\n - Catch version: 2.13.6\r\n\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n\n", "hints_text": "Sorry forgot to add error message:\r\n```\r\n$ g++ -I$Catch2_DIR/include const-approx.cpp \r\nIn file included from const-approx.cpp:1:\r\nconst-approx.cpp: In function \u2018void ____C_A_T_C_H____T_E_S_T____0()\u2019:\r\nconst-approx.cpp:6:29: error: no match for call to \u2018(const Catch::Detail::Approx) (double)\u2019\r\n   REQUIRE(value == apprx(1.0));\r\n                             ^\r\nIn file included from const-approx.cpp:1:\r\n$Catch2_DIR/include/catch2/catch.hpp:3094:16: note: candidate: \u2018Catch::Detail::Approx Catch::Detail::Approx::operator()(const T&) [with T = double; <template-parameter-1-2> = void]\u2019 <near match>\r\n         Approx operator()( T const& value ) {\r\n                ^~~~~~~~\r\n$Catch2_DIR/include/catch2/catch.hpp:3094:16: note:   passing \u2018const Catch::Detail::Approx*\u2019 as \u2018this\u2019 argument discards qualifiers\r\n```\nMakes sense to have it const-qualified.\r\n\r\nIf you want the fix to be in v2, PRs are welcome \ud83d\ude03 ", "created_at": "2021-09-17T10:05:47Z"}
{"repo": "catchorg/Catch2", "pull_number": 2213, "instance_id": "catchorg__Catch2-2213", "issue_numbers": ["2212"], "base_commit": "42e368dd0aedc122798008d8c4f583fea3296a97", "patch": "diff --git a/include/internal/catch_fatal_condition.cpp b/include/internal/catch_fatal_condition.cpp\n--- a/include/internal/catch_fatal_condition.cpp\n+++ b/include/internal/catch_fatal_condition.cpp\n@@ -40,8 +40,8 @@ namespace Catch {\n \n     // If neither SEH nor signal handling is required, the handler impls\n     // do not have to do anything, and can be empty.\n-    FatalConditionHandler::engage_platform() {}\n-    FatalConditionHandler::disengage_platform() {}\n+    void FatalConditionHandler::engage_platform() {}\n+    void FatalConditionHandler::disengage_platform() {}\n     FatalConditionHandler::FatalConditionHandler() = default;\n     FatalConditionHandler::~FatalConditionHandler() = default;\n \n", "test_patch": "", "problem_statement": "[dis]engage_platform declarations mismatch with mingw crosscompiler\n**Describe the bug**\r\nUsing `catch.hpp` with mingw crosscompiler leads to compilation errors:\r\n\r\n```\r\nIn file included from main.cpp:4:\r\nsingle_include/catch2/catch.hpp:10755:5: error: no declaration matches \u2018int Catch::FatalConditionHandler::engage_platform()\u2019\r\n10755 |     FatalConditionHandler::engage_platform() {}\r\n      |     ^~~~~~~~~~~~~~~~~~~~~\r\nIn file included from main.cpp:4:\r\nsingle_include/catch2/catch.hpp:8007:14: note: candidate is: \u2018void Catch::FatalConditionHandler::engage_platform()\u2019\r\n 8007 |         void engage_platform();\r\n      |              ^~~~~~~~~~~~~~~\r\nsingle_include/catch2/catch.hpp:8001:11: note: \u2018class Catch::FatalConditionHandler\u2019 defined here\r\n 8001 |     class FatalConditionHandler {\r\n      |           ^~~~~~~~~~~~~~~~~~~~~\r\nIn file included from main.cpp:4:\r\nsingle_include/catch2/catch.hpp:10756:5: error: no declaration matches \u2018int Catch::FatalConditionHandler::disengage_platform()\u2019\r\n10756 |     FatalConditionHandler::disengage_platform() {}\r\n      |     ^~~~~~~~~~~~~~~~~~~~~\r\nIn file included from main.cpp:4:\r\nsingle_include/catch2/catch.hpp:8008:14: note: candidate is: \u2018void Catch::FatalConditionHandler::disengage_platform()\u2019\r\n 8008 |         void disengage_platform();\r\n      |              ^~~~~~~~~~~~~~~~~~\r\nsingle_include/catch2/catch.hpp:8001:11: note: \u2018class Catch::FatalConditionHandler\u2019 defined here\r\n 8001 |     class FatalConditionHandler {\r\n      |           ^~~~~~~~~~~~~~~~~~~~~\r\nmain.cpp:6:5: error: redefinition of \u2018int main(int, char**)\u2019\r\n    6 | int main(int argc, char* argv[]) {\r\n      |     ^~~~\r\nIn file included from main.cpp:4:\r\nsingle_include/catch2/catch.hpp:17502:5: note: \u2018int main(int, char**)\u2019 previously defined here\r\n17502 | int main (int argc, char * argv[]) {\r\n      |     ^~~~\r\n```\r\n\r\n**Expected behavior**\r\nThe program compiles without errors.\r\n\r\n**Reproduction steps**\r\nBasically it happens when neither windows exceptions nor posix signals are handled. Program to reproduce the bug even with standard g++:\r\n\r\n```cpp\r\n#define CATCH_CONFIG_MAIN\r\n#define CATCH_CONFIG_NO_WINDOWS_SEH\r\n#define CATCH_CONFIG_NO_POSIX_SIGNALS\r\n#include <catch2/catch.hpp>\r\n\r\nint main(int argc, char* argv[]) {\r\n    return 0;\r\n}\r\n```\r\n**Platform information:**\r\n - OS: **Arch Linux**\r\n - Compiler+version: **x86_64-w64-mingw32-g++ (GCC) 10.1.0**\r\n - Catch version: **v2.13.5**\r\n\r\n\r\n**Additional context**\r\nA PR will follow in few minutes.\r\n\n", "hints_text": "", "created_at": "2021-04-13T09:36:44Z"}
{"repo": "catchorg/Catch2", "pull_number": 2205, "instance_id": "catchorg__Catch2-2205", "issue_numbers": ["2203"], "base_commit": "a5abec9cb5d7a26b94d3da24fd239c28ac2dbf91", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -4,6 +4,8 @@ cmake_minimum_required(VERSION 3.5)\n # disable testsuite in that case\n if(NOT DEFINED PROJECT_NAME)\n   set(NOT_SUBPROJECT ON)\n+else()\n+  set(NOT_SUBPROJECT OFF)\n endif()\n \n option(CATCH_INSTALL_DOCS \"Install documentation alongside library\" ON)\n", "test_patch": "", "problem_statement": "global settings are changed when configuring devel branch as a subproject\nThis text is taken straight from the PR #1986\r\n\r\nWhen adding Catch2 as a subdirectory, a couple of choices in the main CMakeLists.txt file end up having a global effect:\r\n\r\n* The `USE_FOLDERS` property is global; setting it affects the entire workspace.\r\n* Including the `CTest` module will cause the generation of several new targets.\r\n\r\nI intend to port the #1986 changes over to the `devel` branch.\r\n\r\n\r\n\n", "hints_text": "", "created_at": "2021-04-05T14:03:30Z"}
{"repo": "catchorg/Catch2", "pull_number": 2187, "instance_id": "catchorg__Catch2-2187", "issue_numbers": ["1390"], "base_commit": "2cb5210caf35bf8fc29ade2e5570cc0f37537951", "patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -230,9 +230,11 @@ namespace Catch {\n         if (result.getResultType() == ResultWas::Ok) {\n             m_totals.assertions.passed++;\n             m_lastAssertionPassed = true;\n-        } else if (!result.isOk()) {\n+        } else if (!result.succeeded()) {\n             m_lastAssertionPassed = false;\n-            if( m_activeTestCase->getTestCaseInfo().okToFail() )\n+            if (result.isOk()) {\n+            }\n+            else if( m_activeTestCase->getTestCaseInfo().okToFail() )\n                 m_totals.assertions.failedButOk++;\n             else\n                 m_totals.assertions.failed++;\n", "test_patch": "diff --git a/src/catch2/catch_test_macros.hpp b/src/catch2/catch_test_macros.hpp\n--- a/src/catch2/catch_test_macros.hpp\n+++ b/src/catch2/catch_test_macros.hpp\n@@ -32,8 +32,8 @@\n \n   #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n-  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n-  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n+  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n   #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n \n   #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CATCH_CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n@@ -123,8 +123,8 @@\n \n   #define CHECK( ... ) INTERNAL_CATCH_TEST( \"CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n-  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n-  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n+  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n   #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n \n   #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -182,6 +182,39 @@ TEST_CASE( \"checkedElse, failing\", \"[failing][.]\" ) {\n     REQUIRE( testCheckedElse( false ) );\n }\n \n+TEST_CASE(\"Testing checked-if\", \"[checked-if]\") {\n+    CHECKED_IF(true) {\n+        SUCCEED();\n+    }\n+    CHECKED_IF(false) {\n+        FAIL();\n+    }\n+    CHECKED_ELSE(true) {\n+        FAIL();\n+    }\n+    CHECKED_ELSE(false) {\n+        SUCCEED();\n+    }\n+}\n+\n+TEST_CASE(\"Testing checked-if 2\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_IF(true) {\n+        FAIL();\n+    }\n+    // If the checked if is not entered, this passes and the test\n+    // fails, because of the [!shouldfail] tag.\n+    SUCCEED();\n+}\n+\n+TEST_CASE(\"Testing checked-if 3\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(false) {\n+        FAIL();\n+    }\n+    // If the checked false is not entered, this passes and the test\n+    // fails, because of the [!shouldfail] tag.\n+    SUCCEED();\n+}\n+\n TEST_CASE( \"xmlentitycheck\" ) {\n     SECTION( \"embedded xml: <test>it should be possible to embed xml characters, such as <, \\\" or &, or even whole <xml>documents</xml> within an attribute</test>\" ) {\n         SUCCEED(); // We need this here to stop it failing due to no tests\n", "problem_statement": "Make CHECKED_IF and CHECKED_ELSE \"ok to fail\"\n## Description\r\nBoth `CHECKED_IF` and `CHECKED_ELSE` are currently fairly obscure macros that simplify using `if`/`else` in tests.\r\n\r\nHowever, entering the `else` branch fails the test in which it occurs, because they are not marked as being ok to fail (tagged with `Catch::ResultDisposition::SuppressFail` to be exact). This behaviour makes them less than useful, but with a change they should be actually usable.\r\n\r\nMilestone 3.0, because it is a theoretically breaking change.\r\n\n", "hints_text": "First of all, awesome work with Catch2, THE best testing framework out there. This thread is particularly useful as currently I'm testing with MPI communication whose number of processors is known only at runtime. By adding CHECKED_IF( num_of_procs > 4 ) I can prevent MPI failure on small core machines without having to comment out these tests. Really looking forward to this tweak.", "created_at": "2021-03-12T19:19:22Z"}
{"repo": "catchorg/Catch2", "pull_number": 2177, "instance_id": "catchorg__Catch2-2177", "issue_numbers": ["2166"], "base_commit": "c12170ff69ddc9a0a25ec2025783b815354c6d26", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -17,6 +17,8 @@ cmake_dependent_option(CATCH_BUILD_EXTRA_TESTS \"Build extra tests\" OFF \"CATCH_DE\n cmake_dependent_option(CATCH_BUILD_FUZZERS \"Build fuzzers\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n cmake_dependent_option(CATCH_ENABLE_COVERAGE \"Generate coverage for codecov.io\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n cmake_dependent_option(CATCH_ENABLE_WERROR \"Enables Werror during build\" ON \"CATCH_DEVELOPMENT_BUILD\" OFF)\n+cmake_dependent_option(CATCH_BUILD_SURROGATES \"Enable generating and building surrogate TUs for the main headers\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n+\n \n # Catch2's build breaks if done in-tree. You probably should not build\n # things in tree anyway, but we can allow projects that include Catch2\ndiff --git a/src/catch2/benchmark/catch_constructor.hpp b/src/catch2/benchmark/catch_constructor.hpp\n--- a/src/catch2/benchmark/catch_constructor.hpp\n+++ b/src/catch2/benchmark/catch_constructor.hpp\n@@ -11,6 +11,7 @@\n #define CATCH_CONSTRUCTOR_HPP_INCLUDED\n \n #include <type_traits>\n+#include <utility>\n \n namespace Catch {\n     namespace Benchmark {\ndiff --git a/src/catch2/benchmark/detail/catch_analyse.hpp b/src/catch2/benchmark/detail/catch_analyse.hpp\n--- a/src/catch2/benchmark/detail/catch_analyse.hpp\n+++ b/src/catch2/benchmark/detail/catch_analyse.hpp\n@@ -11,8 +11,10 @@\n #define CATCH_ANALYSE_HPP_INCLUDED\n \n #include <catch2/benchmark/catch_clock.hpp>\n+#include <catch2/benchmark/catch_environment.hpp>\n #include <catch2/benchmark/catch_sample_analysis.hpp>\n #include <catch2/benchmark/detail/catch_stats.hpp>\n+#include <catch2/interfaces/catch_interfaces_config.hpp>\n \n #include <algorithm>\n #include <iterator>\ndiff --git a/src/catch2/catch_reporter_registrars.hpp b/src/catch2/catch_reporter_registrars.hpp\n--- a/src/catch2/catch_reporter_registrars.hpp\n+++ b/src/catch2/catch_reporter_registrars.hpp\n@@ -9,11 +9,15 @@\n #define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED\n \n #include <catch2/interfaces/catch_interfaces_registry_hub.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter.hpp>\n #include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n #include <catch2/internal/catch_unique_ptr.hpp>\n \n namespace Catch {\n \n+    struct IStreamingReporter;\n+    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\n+\n     template <typename T>\n     class ReporterFactory : public IReporterFactory {\n \ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp b/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n@@ -8,9 +8,16 @@\n #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED\n #define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED\n \n+#include <catch2/internal/catch_unique_ptr.hpp>\n+\n+#include <string>\n+\n namespace Catch {\n \n     struct ReporterConfig;\n+    struct IStreamingReporter;\n+    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\n+\n \n     struct IReporterFactory {\n         virtual ~IReporterFactory(); // = default\ndiff --git a/src/catch2/internal/catch_container_nonmembers.hpp b/src/catch2/internal/catch_container_nonmembers.hpp\n--- a/src/catch2/internal/catch_container_nonmembers.hpp\n+++ b/src/catch2/internal/catch_container_nonmembers.hpp\n@@ -10,6 +10,8 @@\n \n #include <catch2/internal/catch_compiler_capabilities.hpp>\n \n+#include <cstddef>\n+#include <initializer_list>\n \n // We want a simple polyfill over `std::empty`, `std::size` and so on\n // for C++14 or C++ libraries with incomplete support.\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -1,5 +1,66 @@\n include(MiscFunctions)\n \n+if (CATCH_BUILD_SURROGATES)\n+  message(STATUS \"Configuring targets for surrogate TUs\")\n+\n+  # If the folder does not exist before we ask for output redirect to\n+  # a file, it won't work.\n+  file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/surrogates)\n+\n+  # Creates target to generate the surrogate TU for provided header.\n+  # Returns the path to the generated file.\n+  function(createSurrogateFileTarget sourceHeader pathToFile)\n+    set(pathPrefix ${PROJECT_SOURCE_DIR}/src)\n+\n+    file(RELATIVE_PATH includePath ${pathPrefix} ${sourceHeader})\n+\n+    get_filename_component(basicFileName \"${sourceHeader}\" NAME_WE)\n+\n+    set(surrogateFilePath ${CMAKE_CURRENT_BINARY_DIR}/surrogates/surrogate_${basicFileName}.cpp)\n+\n+    add_custom_command(\n+      OUTPUT ${surrogateFilePath}\n+      COMMAND cmake -E echo \"\\#include <${includePath}>\" > \"${surrogateFilePath}\"\n+      VERBATIM\n+    )\n+\n+    set(${pathToFile} ${surrogateFilePath} PARENT_SCOPE)\n+  endfunction()\n+\n+  # Extracts all non-helper (e.g. catch_all.hpp) headers from the\n+  # Catch2 target, and returns them through the argument.\n+  function(ExtractCatch2Headers OutArg)\n+    get_target_property(targetSources Catch2 SOURCES)\n+    foreach(Source ${targetSources})\n+      string(REGEX MATCH \"^.*\\\\.hpp$\" isHeader ${Source})\n+      string(REGEX MATCH \"_all.hpp\" isAllHeader ${Source})\n+      if(isHeader AND NOT isAllHeader)\n+        list(APPEND AllHeaders ${Source})\n+      endif()\n+    endforeach()\n+    set(${OutArg} ${AllHeaders} PARENT_SCOPE)\n+  endfunction()\n+\n+\n+  ExtractCatch2Headers(mainHeaders)\n+\n+  if (NOT mainHeaders)\n+    message(FATAL_ERROR \"No headers in the main target were detected. Something is broken.\")\n+  endif()\n+\n+  foreach(header ${mainHeaders})\n+    createSurrogateFileTarget(${header} pathToGeneratedFile)\n+    list(APPEND surrogateFiles ${pathToGeneratedFile})\n+  endforeach()\n+\n+\n+  add_executable(Catch2SurrogateTarget\n+    ${surrogateFiles}\n+  )\n+  target_link_libraries(Catch2SurrogateTarget PRIVATE Catch2WithMain)\n+\n+endif(CATCH_BUILD_SURROGATES)\n+\n ####\n # Temporary workaround for VS toolset changes in 2017\n # We need to disable <UseFullPaths> property, but CMake doesn't support it\n", "problem_statement": "Add surrogate TUs for header files\n## Description\r\n\r\nThis PR adds surrogate TUs to test that each header file in the project can be included without depending on other files.\r\n\r\nIn order for the PR to be complete I have to clean the commit history.\r\nAlso 5 files are commented in the CMakeLists.txt of SurrogateCpps since they need to be fixed.\r\n\r\n## GitHub Issues\r\n\r\nCloses #2106\r\n\n", "hints_text": "# [Codecov](https://codecov.io/gh/catchorg/Catch2/pull/2166?src=pr&el=h1) Report\n> Merging [#2166](https://codecov.io/gh/catchorg/Catch2/pull/2166?src=pr&el=desc) (4fad45c) into [devel](https://codecov.io/gh/catchorg/Catch2/commit/ba8150516800dd5e18f818346a2a12c45b6ec542?el=desc) (ba81505) will **increase** coverage by `0.04%`.\n> The diff coverage is `n/a`.\n\n```diff\n@@            Coverage Diff             @@\n##            devel    #2166      +/-   ##\n==========================================\n+ Coverage   90.03%   90.07%   +0.04%     \n==========================================\n  Files         146      146              \n  Lines        7089     7110      +21     \n==========================================\n+ Hits         6382     6404      +22     \n+ Misses        707      706       -1     \n```\n\nCleared commit history.\nActually don't do a thing now, this might be an entirely wrong approach \ud83d\ude03 \r\n\r\nI realized that this approach where the surrogate cpp files actually exist on disk add a lot of mechanical overhead to creating new headers, and that we could replace it with generating the surrogate cpp files on-demand. This would move the mechanical work from the developer to a machine, which is much better.\nAt some point, I got bored copy-pasting headers, and I wrote a script to autogenerate the surrogate files. Should I make it generic to autogenerate them based on what exists in the src directory of catch2?", "created_at": "2021-02-16T15:26:54Z"}
{"repo": "catchorg/Catch2", "pull_number": 2165, "instance_id": "catchorg__Catch2-2165", "issue_numbers": ["2008"], "base_commit": "b435e391c45c7cdb23c35cd2afb3435b0b7e53c7", "patch": "diff --git a/src/catch2/reporters/catch_reporter_junit.cpp b/src/catch2/reporters/catch_reporter_junit.cpp\n--- a/src/catch2/reporters/catch_reporter_junit.cpp\n+++ b/src/catch2/reporters/catch_reporter_junit.cpp\n@@ -22,28 +22,22 @@ namespace Catch {\n \n     namespace {\n         std::string getCurrentTimestamp() {\n-            // Beware, this is not reentrant because of backward compatibility issues\n-            // Also, UTC only, again because of backward compatibility (%z is C++11)\n             time_t rawtime;\n             std::time(&rawtime);\n-            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n \n-#ifdef _MSC_VER\n             std::tm timeInfo = {};\n+#ifdef _MSC_VER\n             gmtime_s(&timeInfo, &rawtime);\n #else\n-            std::tm* timeInfo;\n-            timeInfo = std::gmtime(&rawtime);\n+            gmtime_r(&rawtime, &timeInfo);\n #endif\n \n+            auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n             char timeStamp[timeStampSize];\n             const char * const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n \n-#ifdef _MSC_VER\n             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n-#else\n-            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\n-#endif\n+\n             return std::string(timeStamp);\n         }\n \n", "test_patch": "", "problem_statement": "new github CodeQL reports that catch makes use of a standard library function that is not thread-safe\n**Description**\r\nMy software on Github uses Catch 2.  I have just added the beta CodeQL action to my repository and a code scanning alert is listed against catch.\r\n\r\nCodeQL rule: cpp/potentially-dangerous-function\r\n\r\nMITRE CWE-676, reliability, security\r\n\r\n\"Call to gmtime is potentially dangerous\"\r\n\r\n**Additional context**\r\nI expect my own code and all the code that I use to be free of warnings.\r\n\n", "hints_text": "", "created_at": "2021-01-27T12:31:23Z"}
{"repo": "catchorg/Catch2", "pull_number": 2163, "instance_id": "catchorg__Catch2-2163", "issue_numbers": ["2061"], "base_commit": "ba8150516800dd5e18f818346a2a12c45b6ec542", "patch": "diff --git a/src/catch2/catch_session.cpp b/src/catch2/catch_session.cpp\n--- a/src/catch2/catch_session.cpp\n+++ b/src/catch2/catch_session.cpp\n@@ -48,7 +48,7 @@ namespace Catch {\n             // doesn't compile without a std::move call. However, this causes\n             // a warning on newer platforms. Thus, we have to work around\n             // it a bit and downcast the pointer manually.\n-            auto ret = Detail::unique_ptr<IStreamingReporter>(new ListeningReporter);\n+            auto ret = Detail::unique_ptr<IStreamingReporter>(new ListeningReporter(config));\n             auto& multi = static_cast<ListeningReporter&>(*ret);\n             auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\n             for (auto const& listener : listeners) {\ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter.cpp b/src/catch2/interfaces/catch_interfaces_reporter.cpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter.cpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter.cpp\n@@ -11,34 +11,15 @@\n #include <catch2/internal/catch_console_width.hpp>\n #include <catch2/catch_message.hpp>\n #include <catch2/internal/catch_list.hpp>\n-#include <catch2/internal/catch_textflow.hpp>\n #include <catch2/internal/catch_string_manip.hpp>\n #include <catch2/catch_test_case_info.hpp>\n-#include <catch2/internal/catch_textflow.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n \n #include <algorithm>\n #include <iomanip>\n \n namespace Catch {\n \n-    namespace {\n-        void listTestNamesOnly( std::vector<TestCaseHandle> const& tests ) {\n-            for ( auto const& test : tests ) {\n-                auto const& testCaseInfo = test.getTestCaseInfo();\n-\n-                if ( startsWith( testCaseInfo.name, '#' ) ) {\n-                    Catch::cout() << '\"' << testCaseInfo.name << '\"';\n-                } else {\n-                    Catch::cout() << testCaseInfo.name;\n-                }\n-\n-                Catch::cout() << '\\n';\n-            }\n-            Catch::cout() << std::flush;\n-        }\n-    } // end unnamed namespace\n-\n-\n     ReporterConfig::ReporterConfig( IConfig const* _fullConfig )\n     :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}\n \n@@ -127,89 +108,4 @@ namespace Catch {\n \n     void IStreamingReporter::fatalErrorEncountered( StringRef ) {}\n \n-    void IStreamingReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) {\n-        Catch::cout() << \"Available reporters:\\n\";\n-        const auto maxNameLen = std::max_element(descriptions.begin(), descriptions.end(),\n-            [](ReporterDescription const& lhs, ReporterDescription const& rhs) { return lhs.name.size() < rhs.name.size(); })\n-            ->name.size();\n-\n-        for (auto const& desc : descriptions) {\n-            if (config.verbosity() == Verbosity::Quiet) {\n-                Catch::cout()\n-                    << TextFlow::Column(desc.name)\n-                    .indent(2)\n-                    .width(5 + maxNameLen) << '\\n';\n-            } else {\n-                Catch::cout()\n-                    << TextFlow::Column(desc.name + \":\")\n-                    .indent(2)\n-                    .width(5 + maxNameLen)\n-                    + TextFlow::Column(desc.description)\n-                    .initialIndent(0)\n-                    .indent(2)\n-                    .width(CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8)\n-                    << '\\n';\n-            }\n-        }\n-        Catch::cout() << std::endl;\n-    }\n-\n-    void IStreamingReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) {\n-        // We special case this to provide the equivalent of old\n-        // `--list-test-names-only`, which could then be used by the\n-        // `--input-file` option.\n-        if (config.verbosity() == Verbosity::Quiet) {\n-            listTestNamesOnly(tests);\n-            return;\n-        }\n-\n-        if (config.hasTestFilters()) {\n-            Catch::cout() << \"Matching test cases:\\n\";\n-        } else {\n-            Catch::cout() << \"All available test cases:\\n\";\n-        }\n-\n-        for (auto const& test : tests) {\n-            auto const& testCaseInfo = test.getTestCaseInfo();\n-            Colour::Code colour = testCaseInfo.isHidden()\n-                ? Colour::SecondaryText\n-                : Colour::None;\n-            Colour colourGuard(colour);\n-\n-            Catch::cout() << TextFlow::Column(testCaseInfo.name).initialIndent(2).indent(4) << '\\n';\n-            if (config.verbosity() >= Verbosity::High) {\n-                Catch::cout() << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << std::endl;\n-            }\n-            if (!testCaseInfo.tags.empty() && config.verbosity() > Verbosity::Quiet) {\n-                Catch::cout() << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << '\\n';\n-            }\n-        }\n-\n-        if (!config.hasTestFilters()) {\n-            Catch::cout() << pluralise(tests.size(), \"test case\") << '\\n' << std::endl;\n-        } else {\n-            Catch::cout() << pluralise(tests.size(), \"matching test case\") << '\\n' << std::endl;\n-        }\n-    }\n-\n-    void IStreamingReporter::listTags(std::vector<TagInfo> const& tags, IConfig const& config) {\n-        if (config.hasTestFilters()) {\n-            Catch::cout() << \"Tags for matching test cases:\\n\";\n-        } else {\n-            Catch::cout() << \"All available tags:\\n\";\n-        }\n-\n-        for (auto const& tagCount : tags) {\n-            ReusableStringStream rss;\n-            rss << \"  \" << std::setw(2) << tagCount.count << \"  \";\n-            auto str = rss.str();\n-            auto wrapper = TextFlow::Column(tagCount.all())\n-                .initialIndent(0)\n-                .indent(str.size())\n-                .width(CATCH_CONFIG_CONSOLE_WIDTH - 10);\n-            Catch::cout() << str << wrapper << '\\n';\n-        }\n-        Catch::cout() << pluralise(tags.size(), \"tag\") << '\\n' << std::endl;\n-    }\n-\n } // end namespace Catch\ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter.hpp b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter.hpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n@@ -176,7 +176,12 @@ namespace Catch {\n     protected:\n         //! Derived classes can set up their preferences here\n         ReporterPreferences m_preferences;\n+        //! The test run's config as filled in from CLI and defaults\n+        IConfig const* m_config;\n+\n     public:\n+        IStreamingReporter( IConfig const* config ): m_config( config ) {}\n+\n         virtual ~IStreamingReporter() = default;\n \n         // Implementing class must also provide the following static methods:\n@@ -217,11 +222,11 @@ namespace Catch {\n         virtual void fatalErrorEncountered( StringRef name );\n \n         //! Writes out information about provided reporters using reporter-specific format\n-        virtual void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config);\n+        virtual void listReporters(std::vector<ReporterDescription> const& descriptions) = 0;\n         //! Writes out information about provided tests using reporter-specific format\n-        virtual void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config);\n+        virtual void listTests(std::vector<TestCaseHandle> const& tests) = 0;\n         //! Writes out information about the provided tags using reporter-specific format\n-        virtual void listTags(std::vector<TagInfo> const& tags, IConfig const& config);\n+        virtual void listTags(std::vector<TagInfo> const& tags) = 0;\n \n     };\n     using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\ndiff --git a/src/catch2/internal/catch_list.cpp b/src/catch2/internal/catch_list.cpp\n--- a/src/catch2/internal/catch_list.cpp\n+++ b/src/catch2/internal/catch_list.cpp\n@@ -24,7 +24,7 @@ namespace Catch {\n         void listTests(IStreamingReporter& reporter, IConfig const& config) {\n             auto const& testSpec = config.testSpec();\n             auto matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);\n-            reporter.listTests(matchedTestCases, config);\n+            reporter.listTests(matchedTestCases);\n         }\n \n         void listTags(IStreamingReporter& reporter, IConfig const& config) {\n@@ -46,10 +46,10 @@ namespace Catch {\n                 infos.push_back(std::move(tagc.second));\n             }\n \n-            reporter.listTags(infos, config);\n+            reporter.listTags(infos);\n         }\n \n-        void listReporters(IStreamingReporter& reporter, IConfig const& config) {\n+        void listReporters(IStreamingReporter& reporter) {\n             std::vector<ReporterDescription> descriptions;\n \n             IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n@@ -58,7 +58,7 @@ namespace Catch {\n                 descriptions.push_back({ fac.first, fac.second->getDescription() });\n             }\n \n-            reporter.listReporters(descriptions, config);\n+            reporter.listReporters(descriptions);\n         }\n \n     } // end anonymous namespace\n@@ -96,7 +96,7 @@ namespace Catch {\n         }\n         if (config.listReporters()) {\n             listed = true;\n-            listReporters(reporter, config);\n+            listReporters(reporter);\n         }\n         return listed;\n     }\ndiff --git a/src/catch2/reporters/catch_reporter_combined_tu.cpp b/src/catch2/reporters/catch_reporter_combined_tu.cpp\n--- a/src/catch2/reporters/catch_reporter_combined_tu.cpp\n+++ b/src/catch2/reporters/catch_reporter_combined_tu.cpp\n@@ -21,13 +21,40 @@\n #include <catch2/interfaces/catch_interfaces_config.hpp>\n #include <catch2/internal/catch_console_width.hpp>\n #include <catch2/internal/catch_errno_guard.hpp>\n-\n+#include <catch2/internal/catch_textflow.hpp>\n+#include <catch2/internal/catch_stream.hpp>\n+#include <catch2/internal/catch_string_manip.hpp>\n+#include <catch2/internal/catch_console_colour.hpp>\n+#include <catch2/catch_tostring.hpp>\n+#include <catch2/catch_test_case_info.hpp>\n+\n+#include <algorithm>\n #include <cfloat>\n #include <cstdio>\n #include <ostream>\n+#include <iomanip>\n \n namespace Catch {\n \n+    namespace {\n+        void listTestNamesOnly(std::ostream& out,\n+                               std::vector<TestCaseHandle> const& tests) {\n+            for (auto const& test : tests) {\n+                auto const& testCaseInfo = test.getTestCaseInfo();\n+\n+                if (startsWith(testCaseInfo.name, '#')) {\n+                    out << '\"' << testCaseInfo.name << '\"';\n+                } else {\n+                    out << testCaseInfo.name;\n+                }\n+\n+                out << '\\n';\n+            }\n+            out << std::flush;\n+        }\n+    } // end unnamed namespace\n+\n+\n     // Because formatting using c++ streams is stateful, drop down to C is\n     // required Alternatively we could use stringstream, but its performance\n     // is... not good.\n@@ -89,6 +116,101 @@ namespace Catch {\n         return out;\n     }\n \n+    void\n+    defaultListReporters( std::ostream& out,\n+                          std::vector<ReporterDescription> const& descriptions,\n+                          Verbosity verbosity ) {\n+        out << \"Available reporters:\\n\";\n+        const auto maxNameLen =\n+            std::max_element( descriptions.begin(),\n+                              descriptions.end(),\n+                              []( ReporterDescription const& lhs,\n+                                  ReporterDescription const& rhs ) {\n+                                  return lhs.name.size() < rhs.name.size();\n+                              } )\n+                ->name.size();\n+\n+        for ( auto const& desc : descriptions ) {\n+            if ( verbosity == Verbosity::Quiet ) {\n+                out << TextFlow::Column( desc.name )\n+                           .indent( 2 )\n+                           .width( 5 + maxNameLen )\n+                    << '\\n';\n+            } else {\n+                out << TextFlow::Column( desc.name + \":\" )\n+                               .indent( 2 )\n+                               .width( 5 + maxNameLen ) +\n+                           TextFlow::Column( desc.description )\n+                               .initialIndent( 0 )\n+                               .indent( 2 )\n+                               .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\n+                    << '\\n';\n+            }\n+        }\n+        out << '\\n' << std::flush;\n+    }\n+\n+    void defaultListTags( std::ostream& out,\n+                          std::vector<TagInfo> const& tags,\n+                          bool isFiltered ) {\n+        if ( isFiltered ) {\n+            out << \"Tags for matching test cases:\\n\";\n+        } else {\n+            out << \"All available tags:\\n\";\n+        }\n+\n+        for ( auto const& tagCount : tags ) {\n+            ReusableStringStream rss;\n+            rss << \"  \" << std::setw( 2 ) << tagCount.count << \"  \";\n+            auto str = rss.str();\n+            auto wrapper = TextFlow::Column( tagCount.all() )\n+                               .initialIndent( 0 )\n+                               .indent( str.size() )\n+                               .width( CATCH_CONFIG_CONSOLE_WIDTH - 10 );\n+            out << str << wrapper << '\\n';\n+        }\n+        out << pluralise( tags.size(), \"tag\" ) << '\\n' << std::endl;\n+    }\n+\n+    void defaultListTests(std::ostream& out, std::vector<TestCaseHandle> const& tests, bool isFiltered, Verbosity verbosity) {\n+        // We special case this to provide the equivalent of old\n+        // `--list-test-names-only`, which could then be used by the\n+        // `--input-file` option.\n+        if (verbosity == Verbosity::Quiet) {\n+            listTestNamesOnly(out, tests);\n+            return;\n+        }\n+\n+        if (isFiltered) {\n+            out << \"Matching test cases:\\n\";\n+        } else {\n+            out << \"All available test cases:\\n\";\n+        }\n+\n+        for (auto const& test : tests) {\n+            auto const& testCaseInfo = test.getTestCaseInfo();\n+            Colour::Code colour = testCaseInfo.isHidden()\n+                ? Colour::SecondaryText\n+                : Colour::None;\n+            Colour colourGuard(colour);\n+\n+            out << TextFlow::Column(testCaseInfo.name).initialIndent(2).indent(4) << '\\n';\n+            if (verbosity >= Verbosity::High) {\n+                out << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << std::endl;\n+            }\n+            if (!testCaseInfo.tags.empty() &&\n+                verbosity > Verbosity::Quiet) {\n+                out << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << '\\n';\n+            }\n+        }\n+\n+        if (isFiltered) {\n+            out << pluralise(tests.size(), \"matching test case\") << '\\n' << std::endl;\n+        } else {\n+            out << pluralise(tests.size(), \"test case\") << '\\n' << std::endl;\n+        }\n+    }\n+\n } // namespace Catch\n \n \n@@ -100,13 +222,10 @@ namespace Catch {\n     bool EventListenerBase::assertionEnded( AssertionStats const& ) {\n         return false;\n     }\n-    void\n-    EventListenerBase::listReporters( std::vector<ReporterDescription> const&,\n-                                      IConfig const& ) {}\n-    void EventListenerBase::listTests( std::vector<TestCaseHandle> const&,\n-                                       IConfig const& ) {}\n-    void EventListenerBase::listTags( std::vector<TagInfo> const&,\n-                                      IConfig const& ) {}\n+    void EventListenerBase::listReporters(\n+        std::vector<ReporterDescription> const& ) {}\n+    void EventListenerBase::listTests( std::vector<TestCaseHandle> const& ) {}\n+    void EventListenerBase::listTags( std::vector<TagInfo> const& ) {}\n     void EventListenerBase::noMatchingTestCases( std::string const& ) {}\n     void EventListenerBase::testRunStarting( TestRunInfo const& ) {}\n     void EventListenerBase::testGroupStarting( GroupInfo const& ) {}\ndiff --git a/src/catch2/reporters/catch_reporter_cumulative_base.cpp b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n--- a/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n+++ b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n@@ -6,6 +6,7 @@\n \n // SPDX-License-Identifier: BSL-1.0\n #include <catch2/reporters/catch_reporter_cumulative_base.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n \n #include <algorithm>\n #include <cassert>\n@@ -110,4 +111,19 @@ namespace Catch {\n         testRunEndedCumulative();\n     }\n \n+    void CumulativeReporterBase::listReporters(std::vector<ReporterDescription> const& descriptions) {\n+        defaultListReporters(stream, descriptions, m_config->verbosity());\n+    }\n+\n+    void CumulativeReporterBase::listTests(std::vector<TestCaseHandle> const& tests) {\n+        defaultListTests(stream,\n+                         tests,\n+                         m_config->hasTestFilters(),\n+                         m_config->verbosity());\n+    }\n+\n+    void CumulativeReporterBase::listTags(std::vector<TagInfo> const& tags) {\n+        defaultListTags( stream, tags, m_config->hasTestFilters() );\n+    }\n+\n } // end namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_cumulative_base.hpp b/src/catch2/reporters/catch_reporter_cumulative_base.hpp\n--- a/src/catch2/reporters/catch_reporter_cumulative_base.hpp\n+++ b/src/catch2/reporters/catch_reporter_cumulative_base.hpp\n@@ -46,7 +46,8 @@ namespace Catch {\n         using TestRunNode = Node<TestRunStats, TestGroupNode>;\n \n         CumulativeReporterBase( ReporterConfig const& _config ):\n-            m_config( _config.fullConfig() ), stream( _config.stream() ) {}\n+            IStreamingReporter( _config.fullConfig() ),\n+            stream( _config.stream() ) {}\n         ~CumulativeReporterBase() override;\n \n         void testRunStarting( TestRunInfo const& ) override {}\n@@ -68,7 +69,11 @@ namespace Catch {\n \n         void skipTest(TestCaseInfo const&) override {}\n \n-        IConfig const* m_config;\n+        void listReporters( std::vector<ReporterDescription> const& descriptions ) override;\n+        void listTests( std::vector<TestCaseHandle> const& tests ) override;\n+        void listTags( std::vector<TagInfo> const& tags ) override;\n+\n+\n         std::ostream& stream;\n         // Note: We rely on pointer identity being stable, which is why\n         //       which is why we store around pointers rather than values.\ndiff --git a/src/catch2/reporters/catch_reporter_event_listener.hpp b/src/catch2/reporters/catch_reporter_event_listener.hpp\n--- a/src/catch2/reporters/catch_reporter_event_listener.hpp\n+++ b/src/catch2/reporters/catch_reporter_event_listener.hpp\n@@ -20,22 +20,17 @@ namespace Catch {\n      * member functions it actually cares about.\n      */\n     class EventListenerBase : public IStreamingReporter {\n-        IConfig const* m_config;\n-\n     public:\n         EventListenerBase( ReporterConfig const& config ):\n-            m_config( config.fullConfig() ) {}\n+            IStreamingReporter( config.fullConfig() ) {}\n \n         void assertionStarting( AssertionInfo const& assertionInfo ) override;\n         bool assertionEnded( AssertionStats const& assertionStats ) override;\n \n-        void\n-        listReporters( std::vector<ReporterDescription> const& descriptions,\n-                       IConfig const& config ) override;\n-        void listTests( std::vector<TestCaseHandle> const& tests,\n-                        IConfig const& config ) override;\n-        void listTags( std::vector<TagInfo> const& tagInfos,\n-                       IConfig const& config ) override;\n+        void listReporters(\n+            std::vector<ReporterDescription> const& descriptions ) override;\n+        void listTests( std::vector<TestCaseHandle> const& tests ) override;\n+        void listTags( std::vector<TagInfo> const& tagInfos ) override;\n \n         void noMatchingTestCases( std::string const& spec ) override;\n         void testRunStarting( TestRunInfo const& testRunInfo ) override;\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.hpp b/src/catch2/reporters/catch_reporter_helpers.hpp\n--- a/src/catch2/reporters/catch_reporter_helpers.hpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.hpp\n@@ -12,9 +12,13 @@\n #include <string>\n #include <vector>\n \n+#include <catch2/internal/catch_list.hpp>\n+#include <catch2/interfaces/catch_interfaces_config.hpp>\n+\n namespace Catch {\n \n     struct IConfig;\n+    class TestCaseHandle;\n \n     // Returns double formatted as %.3f (format expected on output)\n     std::string getFormattedDuration( double duration );\n@@ -31,6 +35,42 @@ namespace Catch {\n         friend std::ostream& operator<<( std::ostream& out, lineOfChars value );\n     };\n \n+    /**\n+     * Lists reporter descriptions to the provided stream in user-friendly\n+     * format\n+     *\n+     * Used as the default listing implementation by the first party reporter\n+     * bases. The output should be backwards compatible with the output of\n+     * Catch2 v2 binaries.\n+     */\n+    void\n+    defaultListReporters( std::ostream& out,\n+                          std::vector<ReporterDescription> const& descriptions,\n+                          Verbosity verbosity );\n+\n+    /**\n+     * Lists tag information to the provided stream in user-friendly format\n+     *\n+     * Used as the default listing implementation by the first party reporter\n+     * bases. The output should be backwards compatible with the output of\n+     * Catch2 v2 binaries.\n+     */\n+    void defaultListTags( std::ostream& out, std::vector<TagInfo> const& tags, bool isFiltered );\n+\n+    /**\n+     * Lists test case information to the provided stream in user-friendly\n+     * format\n+     *\n+     * Used as the default listing implementation by the first party reporter\n+     * bases. The output is backwards compatible with the output of Catch2\n+     * v2 binaries, and also supports the format specific to the old\n+     * `--list-test-names-only` option, for people who used it in integrations.\n+     */\n+    void defaultListTests( std::ostream& out,\n+                           std::vector<TestCaseHandle> const& tests,\n+                           bool isFiltered,\n+                           Verbosity verbosity );\n+\n } // end namespace Catch\n \n #endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED\ndiff --git a/src/catch2/reporters/catch_reporter_listening.cpp b/src/catch2/reporters/catch_reporter_listening.cpp\n--- a/src/catch2/reporters/catch_reporter_listening.cpp\n+++ b/src/catch2/reporters/catch_reporter_listening.cpp\n@@ -11,11 +11,6 @@\n \n namespace Catch {\n \n-    ListeningReporter::ListeningReporter() {\n-        // We will assume that listeners will always want all assertions\n-        m_preferences.shouldReportAllAssertions = true;\n-    }\n-\n     void ListeningReporter::addListener( IStreamingReporterPtr&& listener ) {\n         m_listeners.push_back( std::move( listener ) );\n     }\n@@ -146,25 +141,25 @@ namespace Catch {\n         m_reporter->skipTest( testInfo );\n     }\n \n-    void ListeningReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) {\n+    void ListeningReporter::listReporters(std::vector<ReporterDescription> const& descriptions) {\n         for (auto const& listener : m_listeners) {\n-            listener->listReporters(descriptions, config);\n+            listener->listReporters(descriptions);\n         }\n-        m_reporter->listReporters(descriptions, config);\n+        m_reporter->listReporters(descriptions);\n     }\n \n-    void ListeningReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) {\n+    void ListeningReporter::listTests(std::vector<TestCaseHandle> const& tests) {\n         for (auto const& listener : m_listeners) {\n-            listener->listTests(tests, config);\n+            listener->listTests(tests);\n         }\n-        m_reporter->listTests(tests, config);\n+        m_reporter->listTests(tests);\n     }\n \n-    void ListeningReporter::listTags(std::vector<TagInfo> const& tags, IConfig const& config) {\n+    void ListeningReporter::listTags(std::vector<TagInfo> const& tags) {\n         for (auto const& listener : m_listeners) {\n-            listener->listTags(tags, config);\n+            listener->listTags(tags);\n         }\n-        m_reporter->listTags(tags, config);\n+        m_reporter->listTags(tags);\n     }\n \n } // end namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_listening.hpp b/src/catch2/reporters/catch_reporter_listening.hpp\n--- a/src/catch2/reporters/catch_reporter_listening.hpp\n+++ b/src/catch2/reporters/catch_reporter_listening.hpp\n@@ -18,7 +18,12 @@ namespace Catch {\n         IStreamingReporterPtr m_reporter = nullptr;\n \n     public:\n-        ListeningReporter();\n+        ListeningReporter( IConfig const* config ):\n+            IStreamingReporter( config ) {\n+            // We will assume that listeners will always want all assertions\n+            m_preferences.shouldReportAllAssertions = true;\n+        }\n+\n \n         void addListener( IStreamingReporterPtr&& listener );\n         void addReporter( IStreamingReporterPtr&& reporter );\n@@ -49,9 +54,9 @@ namespace Catch {\n \n         void skipTest( TestCaseInfo const& testInfo ) override;\n \n-        void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) override;\n-        void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) override;\n-        void listTags(std::vector<TagInfo> const& tags, IConfig const& config) override;\n+        void listReporters(std::vector<ReporterDescription> const& descriptions) override;\n+        void listTests(std::vector<TestCaseHandle> const& tests) override;\n+        void listTags(std::vector<TagInfo> const& tags) override;\n \n \n     };\ndiff --git a/src/catch2/reporters/catch_reporter_streaming_base.cpp b/src/catch2/reporters/catch_reporter_streaming_base.cpp\n--- a/src/catch2/reporters/catch_reporter_streaming_base.cpp\n+++ b/src/catch2/reporters/catch_reporter_streaming_base.cpp\n@@ -6,6 +6,7 @@\n \n // SPDX-License-Identifier: BSL-1.0\n #include <catch2/reporters/catch_reporter_streaming_base.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n \n namespace Catch {\n \n@@ -31,4 +32,19 @@ namespace Catch {\n         currentTestRunInfo.reset();\n     }\n \n+    void StreamingReporterBase::listReporters(std::vector<ReporterDescription> const& descriptions) {\n+        defaultListReporters( stream, descriptions, m_config->verbosity() );\n+    }\n+\n+    void StreamingReporterBase::listTests(std::vector<TestCaseHandle> const& tests) {\n+        defaultListTests(stream,\n+                         tests,\n+                         m_config->hasTestFilters(),\n+                         m_config->verbosity());\n+    }\n+\n+    void StreamingReporterBase::listTags(std::vector<TagInfo> const& tags) {\n+        defaultListTags( stream, tags, m_config->hasTestFilters() );\n+    }\n+\n } // end namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_streaming_base.hpp b/src/catch2/reporters/catch_reporter_streaming_base.hpp\n--- a/src/catch2/reporters/catch_reporter_streaming_base.hpp\n+++ b/src/catch2/reporters/catch_reporter_streaming_base.hpp\n@@ -36,8 +36,8 @@ namespace Catch {\n     struct StreamingReporterBase : IStreamingReporter {\n \n         StreamingReporterBase( ReporterConfig const& _config ):\n-            m_config( _config.fullConfig() ), stream( _config.stream() ) {\n-        }\n+            IStreamingReporter( _config.fullConfig() ),\n+            stream( _config.stream() ) {}\n \n \n         ~StreamingReporterBase() override;\n@@ -71,7 +71,10 @@ namespace Catch {\n             // It can optionally be overridden in the derived class.\n         }\n \n-        IConfig const* m_config;\n+        void listReporters( std::vector<ReporterDescription> const& descriptions ) override;\n+        void listTests( std::vector<TestCaseHandle> const& tests ) override;\n+        void listTags( std::vector<TagInfo> const& tags ) override;\n+\n         std::ostream& stream;\n \n         LazyStat<TestRunInfo> currentTestRunInfo;\ndiff --git a/src/catch2/reporters/catch_reporter_xml.cpp b/src/catch2/reporters/catch_reporter_xml.cpp\n--- a/src/catch2/reporters/catch_reporter_xml.cpp\n+++ b/src/catch2/reporters/catch_reporter_xml.cpp\n@@ -272,7 +272,7 @@ namespace Catch {\n         m_xml.endElement();\n     }\n \n-    void XmlReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const&) {\n+    void XmlReporter::listReporters(std::vector<ReporterDescription> const& descriptions) {\n         auto outerTag = m_xml.scopedElement(\"AvailableReporters\");\n         for (auto const& reporter : descriptions) {\n             auto inner = m_xml.scopedElement(\"Reporter\");\n@@ -285,7 +285,7 @@ namespace Catch {\n         }\n     }\n \n-    void XmlReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const&) {\n+    void XmlReporter::listTests(std::vector<TestCaseHandle> const& tests) {\n         auto outerTag = m_xml.scopedElement(\"MatchingTests\");\n         for (auto const& test : tests) {\n             auto innerTag = m_xml.scopedElement(\"TestCase\");\n@@ -310,7 +310,7 @@ namespace Catch {\n         }\n     }\n \n-    void XmlReporter::listTags(std::vector<TagInfo> const& tags, IConfig const&) {\n+    void XmlReporter::listTags(std::vector<TagInfo> const& tags) {\n         auto outerTag = m_xml.scopedElement(\"TagsFromMatchingTests\");\n         for (auto const& tag : tags) {\n             auto innerTag = m_xml.scopedElement(\"Tag\");\ndiff --git a/src/catch2/reporters/catch_reporter_xml.hpp b/src/catch2/reporters/catch_reporter_xml.hpp\n--- a/src/catch2/reporters/catch_reporter_xml.hpp\n+++ b/src/catch2/reporters/catch_reporter_xml.hpp\n@@ -56,9 +56,9 @@ namespace Catch {\n         void benchmarkEnded(BenchmarkStats<> const&) override;\n         void benchmarkFailed(std::string const&) override;\n \n-        void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) override;\n-        void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) override;\n-        void listTags(std::vector<TagInfo> const& tags, IConfig const& config) override;\n+        void listReporters(std::vector<ReporterDescription> const& descriptions) override;\n+        void listTests(std::vector<TestCaseHandle> const& tests) override;\n+        void listTags(std::vector<TagInfo> const& tags) override;\n \n     private:\n         Timer m_testCaseTimer;\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -23,6 +23,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/IntrospectiveTests/InternalBenchmark.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/PartTracker.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/RandomNumberGeneration.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/Reporters.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/String.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/StringManip.tests.cpp\ndiff --git a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n@@ -0,0 +1,109 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE_1_0.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/catch_config.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter_registry.hpp>\n+#include <catch2/internal/catch_list.hpp>\n+#include <catch2/matchers/catch_matchers_string.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n+\n+#include <sstream>\n+\n+TEST_CASE( \"The default listing implementation write to provided stream\",\n+           \"[reporters][reporter-helpers]\" ) {\n+    using Catch::Matchers::Contains;\n+    using namespace std::string_literals;\n+\n+    std::stringstream sstream;\n+    SECTION( \"Listing tags\" ) {\n+        std::vector<Catch::TagInfo> tags(1);\n+        tags[0].add(\"fakeTag\"_catch_sr);\n+        Catch::defaultListTags(sstream, tags, false);\n+\n+        auto listingString = sstream.str();\n+        REQUIRE_THAT(listingString, Contains(\"[fakeTag]\"s));\n+    }\n+    SECTION( \"Listing reporters\" ) {\n+        std::vector<Catch::ReporterDescription> reporters(\n+            { { \"fake reporter\", \"fake description\" } } );\n+        Catch::defaultListReporters(sstream, reporters, Catch::Verbosity::Normal);\n+\n+        auto listingString = sstream.str();\n+        REQUIRE_THAT(listingString, Contains(\"fake reporter\"s));\n+    }\n+    SECTION( \"Listing tests\" ) {\n+        Catch::TestCaseInfo fakeInfo{\n+            \"\"s,\n+            { \"fake test name\"_catch_sr, \"[fakeTestTag]\"_catch_sr },\n+            { \"fake-file.cpp\", 123456789 } };\n+        std::vector<Catch::TestCaseHandle> tests({ {&fakeInfo, nullptr} });\n+        Catch::defaultListTests(sstream, tests, false, Catch::Verbosity::Normal);\n+\n+        auto listingString = sstream.str();\n+        REQUIRE_THAT( listingString,\n+                      Contains( \"fake test name\"s ) &&\n+                          Contains( \"fakeTestTag\"s ) );\n+    }\n+}\n+\n+TEST_CASE( \"Reporter's write listings to provided stream\", \"[reporters]\" ) {\n+    using Catch::Matchers::Contains;\n+    using namespace std::string_literals;\n+\n+    auto const& factories = Catch::getRegistryHub().getReporterRegistry().getFactories();\n+    // If there are no reporters, the test would pass falsely\n+    // while there is something obviously broken\n+    REQUIRE_FALSE(factories.empty());\n+\n+    for (auto const& factory : factories) {\n+        INFO(\"Tested reporter: \" << factory.first);\n+        std::stringstream sstream;\n+\n+        Catch::ConfigData config_data;\n+        Catch::Config config( config_data );\n+        Catch::ReporterConfig rep_config( &config, sstream );\n+        auto reporter = factory.second->create( rep_config );\n+\n+        DYNAMIC_SECTION( factory.first << \" reporter lists tags\" ) {\n+            std::vector<Catch::TagInfo> tags(1);\n+            tags[0].add(\"fakeTag\"_catch_sr);\n+            reporter->listTags(tags);\n+\n+            auto listingString = sstream.str();\n+            REQUIRE_THAT(listingString, Contains(\"fakeTag\"s));\n+        }\n+\n+        DYNAMIC_SECTION( factory.first << \" reporter lists reporters\" ) {\n+            std::vector<Catch::ReporterDescription> reporters(\n+                { { \"fake reporter\", \"fake description\" } } );\n+            reporter->listReporters(reporters);\n+\n+            auto listingString = sstream.str();\n+            REQUIRE_THAT(listingString, Contains(\"fake reporter\"s));\n+        }\n+\n+        DYNAMIC_SECTION( factory.first << \" reporter lists tests\" ) {\n+            Catch::TestCaseInfo fakeInfo{\n+                \"\"s,\n+                { \"fake test name\"_catch_sr, \"[fakeTestTag]\"_catch_sr },\n+                { \"fake-file.cpp\", 123456789 } };\n+            std::vector<Catch::TestCaseHandle> tests({ {&fakeInfo, nullptr} });\n+            reporter->listTests(tests);\n+\n+            auto listingString = sstream.str();\n+            REQUIRE_THAT( listingString,\n+                          Contains( \"fake test name\"s ) &&\n+                              Contains( \"fakeTestTag\"s ) );\n+        }\n+    }\n+}\n", "problem_statement": "The output of --list-* options should obey -o flag\n**Description**\r\nCurrently, the output of `--list-*` options writes to stdout through `Catch::cout()`. It should obey the `-o` flag instead.\r\n\r\n**Additional context**\r\nBecause the default implementation of `--list*` flags is done in the `IStreamingReporter`  interface, we need to extend it to contain the stream it should write to, e.g. by giving it a `ReporterConfig` member and initializing it properly.\n", "hints_text": "", "created_at": "2021-01-26T17:45:37Z"}
{"repo": "catchorg/Catch2", "pull_number": 2128, "instance_id": "catchorg__Catch2-2128", "issue_numbers": ["2121"], "base_commit": "65c9a1d31a338f28ef93cd61c475efc40f6cc42e", "patch": "diff --git a/src/catch2/internal/catch_decomposer.hpp b/src/catch2/internal/catch_decomposer.hpp\n--- a/src/catch2/internal/catch_decomposer.hpp\n+++ b/src/catch2/internal/catch_decomposer.hpp\n@@ -183,60 +183,53 @@ namespace Catch {\n     public:\n         explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}\n \n-        template<typename RhsT>\n-        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n-        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs == rhs, m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareNotEqual( m_lhs, rhs ), m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n-        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs != rhs, m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs > rhs), m_lhs, \">\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs < rhs), m_lhs, \"<\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs >= rhs), m_lhs, \">=\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs | rhs), m_lhs, \"|\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs & rhs), m_lhs, \"&\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, \"^\"_sr, rhs };\n+    #define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(op) \\\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n+        } \\\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n         }\n \n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(|)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(&)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(^)\n+\n+    #undef CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR\n+\n         template<typename RhsT>\n-        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator && ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator&& is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n         }\n \n         template<typename RhsT>\n-        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator || ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator|| is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n@@ -247,21 +240,15 @@ namespace Catch {\n         }\n     };\n \n-    void handleExpression( ITransientExpression const& expr );\n-\n-    template<typename T>\n-    void handleExpression( ExprLhs<T> const& expr ) {\n-        handleExpression( expr.makeUnaryExpr() );\n-    }\n-\n     struct Decomposer {\n-        template<typename T>\n-        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {\n-            return ExprLhs<T const&>{ lhs };\n+        template<typename T, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<T>>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T && lhs ) -> ExprLhs<T const&> {\n+            return ExprLhs<const T&>{ lhs };\n         }\n \n-        auto operator <=( bool value ) -> ExprLhs<bool> {\n-            return ExprLhs<bool>{ value };\n+        template<typename T, std::enable_if_t<std::is_arithmetic<T>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T value ) -> ExprLhs<T> {\n+            return ExprLhs<T>{ value };\n         }\n     };\n \n", "test_patch": "diff --git a/tests/SelfTest/UsageTests/Compilation.tests.cpp b/tests/SelfTest/UsageTests/Compilation.tests.cpp\n--- a/tests/SelfTest/UsageTests/Compilation.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Compilation.tests.cpp\n@@ -277,3 +277,42 @@ namespace {\n TEST_CASE(\"Immovable types are supported in basic assertions\", \"[compilation][.approvals]\") {\n     REQUIRE(ImmovableType{} == ImmovableType{});\n }\n+\n+namespace adl {\n+\n+struct always_true {\n+    explicit operator bool() const { return true; }\n+};\n+\n+#define COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(op) \\\n+template <class T, class U> \\\n+auto operator op (T&&, U&&) { \\\n+    return always_true{}; \\\n+}\n+\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(==)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(!=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(|)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(&)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(^)\n+\n+#undef COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR\n+\n+}\n+\n+TEST_CASE(\"ADL universal operators don't hijack expression deconstruction\", \"[compilation][.approvals]\") {\n+    REQUIRE(adl::always_true{});\n+    REQUIRE(0 == adl::always_true{});\n+    REQUIRE(0 != adl::always_true{});\n+    REQUIRE(0 < adl::always_true{});\n+    REQUIRE(0 > adl::always_true{});\n+    REQUIRE(0 <= adl::always_true{});\n+    REQUIRE(0 >= adl::always_true{});\n+    REQUIRE(0 | adl::always_true{});\n+    REQUIRE(0 & adl::always_true{});\n+    REQUIRE(0 ^ adl::always_true{});\n+}\n", "problem_statement": "Problem with user provided operator == (with proposed fix)\n**Describe the bug**\r\nThe test doesn't compile when the user provides a more general `operator ==` overload than `ExprLhs`.\r\n`operator ==` in the code sample below is a better match when r-value reference is passed because it accepts forwarding reference (`U&&`) and `ExprLhs` accepts only const reference (`RhsT const& rhs`) https://github.com/catchorg/Catch2/blob/devel/src/catch2/internal/catch_decomposer.hpp#L187\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Expected behavior**\r\nThe test should compile.\r\n\r\n**Reproduction steps**\r\n```\r\nnamespace adl {\r\n\r\nstruct activate_adl {};\r\n\r\nstruct equality_expression {\r\n    operator bool() const { return true; }\r\n};\r\n\r\ntemplate <class T, class U>\r\nconstexpr auto operator == (T&&, U&&) {\r\n    return equality_expression{};\r\n}\r\n\r\n}\r\n\r\nTEST_CASE(\"User provided equality operator\", \"[compilation]\") {\r\n    REQUIRE(0 == adl::activate_adl{});\r\n}\r\n```\r\nerror: no matching member function for call to 'handleExpr' REQUIRE(0 == adl::activate_adl{});\r\n\r\n**Fix**\r\nMy first attempt was to change the `operator == ` definition (and similarly all other operators) to\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\nHowever, this broke a test for bitfields\r\nerror: non-const reference cannot bind to bit-field 'v' REQUIRE(0 == y.v);\r\n\r\nThis can be resolved by two not so clean overloads, maybe you know a better way:\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::decay_t<RhsT>>::value, int> = 0>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Unrelated note**\r\nI don't think const reference here prolongs the lifetime of rhs, because it's not local but stored in a class: `BinaryExpr<LhsT, RhsT const&>`. Not sure if it's a problem.\n", "hints_text": "", "created_at": "2020-12-20T00:12:15Z"}
{"repo": "catchorg/Catch2", "pull_number": 2058, "instance_id": "catchorg__Catch2-2058", "issue_numbers": ["2040", "2012"], "base_commit": "4b2bc8757c6d5a95e163b8a54a122d4c95b84310", "patch": "diff --git a/src/catch2/generators/catch_generators.hpp b/src/catch2/generators/catch_generators.hpp\n--- a/src/catch2/generators/catch_generators.hpp\n+++ b/src/catch2/generators/catch_generators.hpp\n@@ -70,8 +70,11 @@ namespace Detail {\n     class SingleValueGenerator final : public IGenerator<T> {\n         T m_value;\n     public:\n+        SingleValueGenerator(T const& value) :\n+            m_value(value)\n+        {}\n         SingleValueGenerator(T&& value):\n-            m_value(std::forward<T>(value))\n+            m_value(std::move(value))\n         {}\n \n         T const& get() const override {\n@@ -101,9 +104,11 @@ namespace Detail {\n         }\n     };\n \n-    template <typename T>\n-    GeneratorWrapper<T> value(T&& value) {\n-        return GeneratorWrapper<T>(Catch::Detail::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));\n+    template <typename T, typename DecayedT = std::decay_t<T>>\n+    GeneratorWrapper<DecayedT> value( T&& value ) {\n+        return GeneratorWrapper<DecayedT>(\n+            Catch::Detail::make_unique<SingleValueGenerator<DecayedT>>(\n+                std::forward<T>( value ) ) );\n     }\n     template <typename T>\n     GeneratorWrapper<T> values(std::initializer_list<T> values) {\n@@ -115,27 +120,36 @@ namespace Detail {\n         std::vector<GeneratorWrapper<T>> m_generators;\n         size_t m_current = 0;\n \n-        void populate(GeneratorWrapper<T>&& generator) {\n-            m_generators.emplace_back(std::move(generator));\n+        void add_generator( GeneratorWrapper<T>&& generator ) {\n+            m_generators.emplace_back( std::move( generator ) );\n+        }\n+        void add_generator( T const& val ) {\n+            m_generators.emplace_back( value( val ) );\n         }\n-        void populate(T&& val) {\n-            m_generators.emplace_back(value(std::forward<T>(val)));\n+        void add_generator( T&& val ) {\n+            m_generators.emplace_back( value( std::move( val ) ) );\n         }\n-        template<typename U>\n-        void populate(U&& val) {\n-            populate(T(std::forward<U>(val)));\n+        template <typename U>\n+        std::enable_if_t<!std::is_same<std::decay_t<U>, T>::value>\n+        add_generator( U&& val ) {\n+            add_generator( T( std::forward<U>( val ) ) );\n         }\n-        template<typename U, typename... Gs>\n-        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {\n-            populate(std::forward<U>(valueOrGenerator));\n-            populate(std::forward<Gs>(moreGenerators)...);\n+\n+        template <typename U> void add_generators( U&& valueOrGenerator ) {\n+            add_generator( std::forward<U>( valueOrGenerator ) );\n+        }\n+\n+        template <typename U, typename... Gs>\n+        void add_generators( U&& valueOrGenerator, Gs&&... moreGenerators ) {\n+            add_generator( std::forward<U>( valueOrGenerator ) );\n+            add_generators( std::forward<Gs>( moreGenerators )... );\n         }\n \n     public:\n         template <typename... Gs>\n         Generators(Gs &&... moreGenerators) {\n             m_generators.reserve(sizeof...(Gs));\n-            populate(std::forward<Gs>(moreGenerators)...);\n+            add_generators(std::forward<Gs>(moreGenerators)...);\n         }\n \n         T const& get() const override {\n@@ -155,8 +169,9 @@ namespace Detail {\n     };\n \n \n-    template<typename... Ts>\n-    GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {\n+    template <typename... Ts>\n+    GeneratorWrapper<std::tuple<std::decay_t<Ts>...>>\n+    table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {\n         return values<std::tuple<Ts...>>( tuples );\n     }\n \n@@ -173,7 +188,7 @@ namespace Detail {\n         return Generators<T>(std::move(generator));\n     }\n     template<typename T, typename... Gs>\n-    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<std::decay_t<T>> {\n         return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );\n     }\n     template<typename T, typename U, typename... Gs>\n", "test_patch": "diff --git a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -358,3 +358,33 @@ TEST_CASE(\"Multiple random generators in one test case output different values\",\n         REQUIRE(same < 200);\n     }\n }\n+\n+TEST_CASE(\"#2040 - infinite compilation recursion in GENERATE with MSVC\", \"[generators][compilation][approvals]\") {\n+    int x = 42;\n+    auto test = GENERATE_COPY(1, x, 2 * x);\n+    CHECK(test < 100);\n+}\n+\n+namespace {\n+    static bool always_true(int) {\n+        return true;\n+    }\n+\n+    static bool is_even(int n) {\n+        return n % 2 == 0;\n+    }\n+\n+    static bool is_multiple_of_3(int n) {\n+        return n % 3 == 0;\n+    }\n+}\n+\n+TEST_CASE(\"GENERATE handles function (pointers)\", \"[generators][compilation][approvals]\") {\n+    auto f = GENERATE(always_true, is_even, is_multiple_of_3);\n+    REQUIRE(f(6));\n+}\n+\n+TEST_CASE(\"GENERATE decays arrays\", \"[generators][compilation][approvals]\") {\n+    auto str = GENERATE(\"abc\", \"def\", \"gh\");\n+    STATIC_REQUIRE(std::is_same<decltype(str), const char*>::value);\n+}\n", "problem_statement": "Infinite recursion in Generators::populate with MSVC\n```\r\nCATCH_TEST_CASE(\"Recursion Bug\")\r\n{\r\n    int x = 42;\r\n    auto test = GENERATE_COPY(1, x, 2 * x);\r\n    CATCH_CHECK(test < 50);\r\n}\r\n```\r\nThis worked in `2.9.2` but now I get \r\n`single_include\\catch2\\catch.hpp(4027):warning C4717: 'Catch::Generators::Generators<int>::populate<int &>': recursive on all control paths, function will cause runtime stack overflow` with MSVC 2017 `Microsoft (R) C/C++ Optimizing Compiler Version 19.16.27042 for x64`.\r\nIt matches the wrong template.\r\n\r\nA possible work-around is `GENERATE_COPY(values<int>({1, x, 2 * x}));`, but the above should work, right?\nGENERATE() changes compile time length of arrays\n**Description**\r\nGENERATE macro takes type of first argument and cast all other args to it. It is ok for most cases but for string literals it is bad. It takes length of first literal and force it for all.\r\n`TEST_CASE(\"t\", \"[t]\") {\r\n    auto& str = GENERATE(\"123\", \"1\");\r\n    WARN(typeid(str).name());\r\n}`\r\nOutput\r\n`warning:\r\n  A4_c`\r\nUsually you don't see it. If you use std::string to store the result of GENERATE then everything works fine, all lengths are correct. But some string implementations use length from type of array. E.g., https://stackoverflow.com/questions/2384107/magic-arguments-in-function-templates\r\nThis template magic works wrong with GENERATE. I cann't say this is a bug, because I have no idea how to fix it. May be detect arrays and generate compilation error if lengths are different?\r\n\r\nIt is very bad rule in C++ that references to arrays with different lengths can be cast to each other. \n", "hints_text": "I can reproduce this with an up-to-date MSVC.\r\n\r\nHowever, it doesn't reproduce with Clang/GCC, so I suspect the code runs into some MSVC bug, which is going to be hard to debug.\nDoes not reproduce with `/permissive-`...\nSo, this was almost definitely introduced in 6c9a255dc2973e97b2d6a155d36f47e145382d32.\r\n\r\n\nRight, so, there are two parts to this.\r\n\r\n1) single `GENERATE` \"call\" can have only one return type. (even though for e.g. `TEMPLATE_TEST_CASE`, the type can differ across different input types...)\r\n2) deducing string literals as char arrays with specific size _can_ be a problem.\r\n\r\nI cannot change 1), and fixing 2) by forcing a pointer decay would break people who already use it with all literals having the same size.\r\n\r\nI will have to think about whether there is an use case for having different size string literals deduce as the same size, and if not, `static_assert` that they share length is indeed the best option.\r\n\r\n\r\nIn the meantime, if you have this issue in your code, consider passing `as<char const*>{}` as the first element in `GENERATE`. Doing so forces the type to be deduced as `char const*`.\nThank you for answer.\r\nYes, casting to string is how I solved this problem in my case.\r\n\r\nFor general case there is the only solution - detect reference to array. It is a question what to do with it. One option is static assert for length, but it is code breakage. If somebody used `std::string a = GENERATE(\"a\", \"ab\");` it worked well and, imho, should continue working. But static_assert breaks it. \r\nAnother option is cast to `const char*`. Correct code with std::string continues to compile and incorrect depends on situation. If it could not work without length then it wouldn't compile. And it is good because it was wrong code that worked with wrong length. If it can work with `const char*` instead of `char&[N]` then everything is OK like std::string.\r\n\r\nDetection itself can be implemented with function overload, e.g., `template<typename T,size_t N> \r\n void generate(T (&a)[N])`\nUpdate: I've decided that for v3 I am going to make arrays decay. Not sure if I will port this to v2 as well.", "created_at": "2020-10-20T09:04:14Z"}
{"repo": "catchorg/Catch2", "pull_number": 2049, "instance_id": "catchorg__Catch2-2049", "issue_numbers": ["2047"], "base_commit": "4ea18d6d17c52b0bae500180918eaff998ebb639", "patch": "diff --git a/src/catch2/internal/catch_compiler_capabilities.hpp b/src/catch2/internal/catch_compiler_capabilities.hpp\n--- a/src/catch2/internal/catch_compiler_capabilities.hpp\n+++ b/src/catch2/internal/catch_compiler_capabilities.hpp\n@@ -57,7 +57,7 @@\n \n #endif\n \n-#if defined(__clang__)\n+#if defined(__clang__) && !defined(_MSC_VER)\n \n #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( \"clang diagnostic push\" )\n #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( \"clang diagnostic pop\" )\n", "test_patch": "", "problem_statement": "Using Clang on Windows fail due to redefined macro in catch_compiler_capabilities.hpp (v3.0.0-preview3)\n**Describe the bug**\r\nAs per the title\r\n\r\n**Expected behavior**\r\nThere are no redefined symbols.\r\n\r\n**Reproduction steps**\r\n1. Use Clang on Windows\r\n2. Compile when including any of the Catch2 v3.0.0-preview3 headers\r\n\r\n**Platform information:**\r\n - OS: **Windows NT**\r\n - Compiler+version: **Clang 10**\r\n - Catch version: **v3.0.0-preview3**\r\n\r\n**Additional context**\r\nThe issue is line 62:\r\n```\r\n#if defined(__clang__)\r\n```\r\nwhich should probably be:\r\n```\r\n#if defined(__clang__) && !defined(_MSC_VER)\r\n```\n", "hints_text": "", "created_at": "2020-10-10T08:23:23Z"}
{"repo": "catchorg/Catch2", "pull_number": 2027, "instance_id": "catchorg__Catch2-2027", "issue_numbers": ["2005"], "base_commit": "2fc83e7e9c6f6014de465d9eee75d68dbcff8106", "patch": "diff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -45,7 +45,7 @@\n \n // We have to avoid both ICC and Clang, because they try to mask themselves\n // as gcc, and we want only GCC in this block\n-#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC)\n+#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && !defined(__CUDACC__)\n #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( \"GCC diagnostic push\" )\n #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( \"GCC diagnostic pop\" )\n \n@@ -69,7 +69,7 @@\n // ```\n //\n // Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.\n-#  if !defined(__ibmxl__)\n+#  if !defined(__ibmxl__) && !defined(__CUDACC__)\n #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) /* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */\n #  endif\n \n", "test_patch": "", "problem_statement": "nvcc crashes when compiling some simple tests\n`nvcc` crashes when compiling some simple tests. This looks like it may be a problem with `nvcc`, but a workaround or fix in Catch would be great.\r\n\r\n**Reproduction steps**\r\n\r\nFile `test.cu`:\r\n\r\n```c++\r\n#define CATCH_CONFIG_MAIN\r\n#include \"catch.hpp\"\r\n\r\nstd::string f() { return \"123\"; }\r\n\r\nTEST_CASE(\"A\")\r\n{\r\n   REQUIRE(f() == std::string(\"123\"));\r\n}\r\n```\r\n\r\nCompiling with `nvcc --std=c++11 test.cu` results in:\r\n```\r\nnvcc error   : 'cicc' died due to signal 11 (Invalid memory reference)\r\nnvcc error   : 'cicc' core dumped\r\n```\r\n\r\n\r\n**Platform information:**\r\n - OS: **RHEL 7.6**\r\n - Compiler+version: **Cuda compilation tools, release 10.1, V10.1.168**, tested with host compilers **GCC v8.3.1** and **GCC v4.8.5**\r\n - Catch version: **v2.13.0**\n", "hints_text": "Some possible workarounds that don't trigger this behavior include:\r\n```c++\r\nauto x = f();\r\nauto y = std::string(\"123\");\r\nREQUIRE(x == y);\r\n```\r\nand\r\n```c++\r\nauto x = f();\r\nREQUIRE(x == \"123\");\r\n```\r\nOn the other hand, this does not work:\r\n```c++\r\nauto x = f();\r\nREQUIRE(x == std::string(\"123\"));\r\n```\nIs this reproducible on a non-ancient version of NVCC? I'd be happy to file an internal bug against the compiler if that's the case and someone can reduce the test case to a minimum ;)\n> Is this reproducible on a non-ancient version of NVCC? I'd be happy to file an internal bug against the compiler if that's the case and someone can reduce the test case to a minimum ;)\r\n\r\nI can reproduce it with nvcc 11.0, V11.0.194 (CUDA 11.0.2). The following simple test reproduces it:\r\n```c++\r\n#define CATCH_CONFIG_MAIN\r\n#include \"catch.hpp\"\r\n#include <string>\r\nTEST_CASE()\r\n{\r\n   REQUIRE(std::string(\"x\") == \"x\");\r\n}\r\n```\r\nI think this could probably be made even simpler (e.g. using something simpler than `std::string`), but I don't entirely understand what's going on.\nIf the nvidia team provides a reasonable workaround I am willing to merge it, but I am not debugging a segfault in nvcc.\r\n\r\n@pazner At a glance, the compiler does not like rvalues in `REQUIRE`. There two more things to try and reduce the bug. \r\n\r\n1) See if the segfault happens without linking, and don't define `CATCH_CONFIG_MAIN` in the file. If yes, then that's a _lot_ less code that needs to be further pruned down.\r\n2) Try it with a much simpler type than full `std::string`.\r\n\n> If the nvidia team provides a reasonable workaround I am willing to merge it, but I am not debugging a segfault in nvcc.\r\n\r\nYes, of course that makes sense. Thanks.\r\n\r\n> @pazner At a glance, the compiler does not like rvalues in `REQUIRE`. There two more things to try and reduce the bug.\r\n> \r\n> 1. See if the segfault happens without linking, and don't define `CATCH_CONFIG_MAIN` in the file. If yes, then that's a _lot_ less code that needs to be further pruned down.\r\n\r\nIt still segfaults without linking and without `CATCH_CONFIG_MAIN`.\r\n\r\n> 2. Try it with a much simpler type than full `std::string`.\r\n\r\nThis is the simplest example I have found so far:\r\n```c++\r\n#include \"catch.hpp\"\r\nstruct A\r\n{\r\n   int x;\r\n   A() : x(10) { }\r\n};\r\nstruct B\r\n{\r\n   A *a;\r\n   B(A *a_) : a(a_) { }\r\n};\r\nTEST_CASE()\r\n{\r\n   REQUIRE(B(new A).a->x == 10); // nvcc segfaults\r\n}\r\n```\r\nInterestingly, the following two tests don't trigger the segfault:\r\n```c++\r\nREQUIRE(A().x == 10); // works\r\nA a;\r\nREQUIRE(B(&a).a->x == 10); // works\r\n```\r\n\r\n@griwes, do you think the above example is sufficiently minimal to file an internal bug report? Also I'd be happy to hear if you know of or hear of any workarounds.\nIt looks sufficiently minimal (together with the information about it being reproducible without catch's main) for me to run creduce on it once I'm back from vacation early next month and then file a bug, yes ;) (The cases that _don't_ crash cicc are super helpful for creducing it, thanks!) \nMinimized, with creduce, to:\r\n\r\n```cpp\r\nstruct A {\r\n  int x;\r\n  A();\r\n};\r\nstruct B {\r\n  A *a;\r\n  B(A *);\r\n};\r\nvoid d() { A a; __builtin_constant_p(EXPR); }\r\n```\r\n\r\nSegfaults with `-DEXPR=\"B(new A).a->x\"`, works with `-DEXPR=\"A().x\"` and `-DEXPR=\"B(&a).a->x\"`. Taking a guess, I further minimized it to\r\n\r\n```cpp\r\nstruct A {\r\n  A();\r\n};\r\nvoid d() { __builtin_constant_p(new A); }\r\n```\r\n\r\nwhich is a really nice reproducer, if I say so myself ;> Filed as an internal bug 3123443, \"nvcc segfaults when encountering a call to `__builtin_constant_p` with an argument that involves a new-expression trying to invoke a user-provided constructor\".\nIf you open up a PR to deactivate the use of `__builtin_constant_p` for nvcc, I'll merge it.", "created_at": "2020-09-17T16:49:49Z"}
{"repo": "catchorg/Catch2", "pull_number": 1996, "instance_id": "catchorg__Catch2-1996", "issue_numbers": ["1992"], "base_commit": "6859c683e09bb3c314d28e21bc1e382bd684fa7e", "patch": "diff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -240,7 +240,10 @@\n \n   // Check if byte is available and usable\n   #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)\n-  #    define CATCH_INTERNAL_CONFIG_CPP17_BYTE\n+  #    include <cstddef>\n+  #    if __cpp_lib_byte > 0\n+  #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE\n+  #    endif\n   #  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)\n \n   // Check if variant is available and usable\n", "test_patch": "", "problem_statement": "C++17 std::byte detection fails on ubuntu+clang-6.0\n**Describe the bug**\r\nClang6 and clang8 in c++17 mode cannot compile catch unit tests \r\n\r\n**Expected behavior**\r\nC++17 should be supported\r\n\r\n**Reproduction steps**\r\nUbuntu 16, clang++6.0 (and clang++-8) installed with \"apt install clang6.0\"\r\nSimple null unit test:\r\n```\r\n#include \"catch.hpp\"\r\nTEST_CASE(\"simple\", \"[simple]\") {\r\n}\r\n```\r\n```\r\n$ clang++-6.0 -std=c++17 -c cb.cpp \r\nIn file included from cb.cpp:1:\r\n./catch.hpp:1735:29: error: no member named 'byte' in namespace 'std'\r\n    struct StringMaker<std::byte> {\r\n                       ~~~~~^\r\n1 error generated.\r\n```\r\n\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: ubuntu 16\r\n - Compiler+version: \r\nclang version 6.0.0-1ubuntu2~16.04.1 (tags/RELEASE_600/final)\r\nTarget: x86_64-pc-linux-gnu\r\nThread model: posix\r\nInstalledDir: /usr/bin\r\n\r\n - Catch version: v2.13.0 downloaded in the single file version\r\n\r\n\r\n**Additional context**\r\nAlso happens with clang-8 package.\r\nCompiles fine in clang-6 or clang-8 in c+11 or c++14 mode.\r\n\r\nThis may be a packaging error in ubuntu, or it might be I have not installed some vital piece, or need to configure clang to use a better standard library or something.\r\n\n", "hints_text": "@gnbond\r\nI had similar problem and worked around it by adding the `CATCH_CONFIG_NO_CPP17_BYTE` definition:\r\n```\r\n    target_compile_options(my_binary PRIVATE\r\n      $<$<CXX_COMPILER_ID:Clang>:-DCATCH_CONFIG_NO_CPP17_BYTE=1>\r\n    )\r\n```\nAfter a bunch more experimentation, this appears to be a ubuntu 16-specific issue, clang packages on ubuntu-18 (and FreeBSD 11) work fine.  I think the issue is the clang packages are still using OS-default standard library, which is g++5 on ubuntu-16, and g++5 version of `<cstddef>` does not have `std::byte`.\r\n\r\nThe below patch seems to fix it, and seems in the spirit of the feature test macros , but I do not know if there are any adverse consequences of  #including in this circumstance.\r\n\r\n(line numbers are the single-file version 2.13.0)\r\n\r\n```\r\n --- a/catch.hpp\r\n+++ b/catch.hpp\r\n@@ -330,7 +330,10 @@ namespace Catch {\r\n \r\n   // Check if byte is available and usable\r\n   #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)\r\n-  #    define CATCH_INTERNAL_CONFIG_CPP17_BYTE\r\n+  #    include <cstddef>\r\n+  #    if __cpp_lib_byte\r\n+  #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE\r\n+  #    endif\r\n   #  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)\r\n \r\n   // Check if variant is available and usable\r\n```\nYeah, some feature checks still use the old and wrong way of doing them -- it is a legacy of most feature checks being for C++11/14, which did not have feature macros, so checking for C++ standard and then hoping for the best was a reasonable option.\r\n\r\nIf you open up a PR, I will merge it, otherwise it will have to wait until I get around to working on v2 branch again.", "created_at": "2020-08-03T03:07:14Z"}
{"repo": "catchorg/Catch2", "pull_number": 1886, "instance_id": "catchorg__Catch2-1886", "issue_numbers": ["1885", "1885"], "base_commit": "255aa5f2afe1a622c97422f65ace6ca915be0d8d", "patch": "diff --git a/include/reporters/catch_reporter_console.cpp b/include/reporters/catch_reporter_console.cpp\n--- a/include/reporters/catch_reporter_console.cpp\n+++ b/include/reporters/catch_reporter_console.cpp\n@@ -362,7 +362,7 @@ ConsoleReporter::ConsoleReporter(ReporterConfig const& config)\n         else\n         {\n             return{\n-                { \"benchmark name\", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },\n+                { \"benchmark name\", CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },\n                 { \"samples      mean       std dev\", 14, ColumnInfo::Right },\n                 { \"iterations   low mean   low std dev\", 14, ColumnInfo::Right },\n                 { \"estimated    high mean  high std dev\", 14, ColumnInfo::Right }\ndiff --git a/projects/ExtraTests/CMakeLists.txt b/projects/ExtraTests/CMakeLists.txt\n--- a/projects/ExtraTests/CMakeLists.txt\n+++ b/projects/ExtraTests/CMakeLists.txt\n@@ -123,7 +123,7 @@ add_test(NAME BenchmarkingMacros COMMAND BenchmarkingMacros -r console -s)\n set_tests_properties(\n     BenchmarkingMacros\n   PROPERTIES\n-    PASS_REGULAR_EXPRESSION \"benchmark name                                  samples       iterations    estimated\"\n+    PASS_REGULAR_EXPRESSION \"benchmark name[\\\\r\\\\n\\\\t ]+samples[\\\\r\\\\n\\\\t ]+iterations[\\\\r\\\\n\\\\t ]+estimated\"\n )\n \n # This test touches windows.h, so it should only be compiled under msvc\n", "test_patch": "", "problem_statement": "\"benchmark name\" has overly wide column width\n**Describe the bug**\r\nThe \"benchmark name\" column is too wide for the default `CATCH_CONFIG_CONSOLE_WIDTH` in full analysis mode, which prevents output from appearing as intended on a single line in a terminal which is 80 columns wide.\r\n\r\nExample of current output:\r\n```benchmark name                                  samples       iterations    estimated\r\n                                                mean          low mean      high mean\r\n                                                std dev       low std dev   high std dev\r\n-------------------------------------------------------------------------------\r\nto_hex_old 0                                              100            17     2.0876 ms \r\n                                                     1.188 us      1.177 us      1.215 us \r\n                                                        84 ns         36 ns        152 ns \r\n```\r\n\r\n**Expected behavior**\r\n\r\n```benchmark name                        samples       iterations    estimated\r\n                                      mean          low mean      high mean\r\n                                      std dev       low std dev   high std dev\r\n-------------------------------------------------------------------------------\r\nto_hex_old 0                                    100            17       2.04 ms \r\n                                           1.112 us      1.103 us      1.132 us \r\n                                              64 ns         34 ns        121 ns \r\n```\r\n\r\n\r\n**Reproduction steps**\r\nUse `BENCHMARK` in a test. See the output.\r\n\r\n**Additional context**\r\nThe problem is caused by setting the \"benchmark name\" column width to `CATCH_CONFIG_CONSOLE_WIDTH - 32` in `ConsoleReporter::ConsoleReporter()`, when the other three columns are each 14 characters wide. (14*3 = 42 > 32).\n\"benchmark name\" has overly wide column width\n**Describe the bug**\r\nThe \"benchmark name\" column is too wide for the default `CATCH_CONFIG_CONSOLE_WIDTH` in full analysis mode, which prevents output from appearing as intended on a single line in a terminal which is 80 columns wide.\r\n\r\nExample of current output:\r\n```benchmark name                                  samples       iterations    estimated\r\n                                                mean          low mean      high mean\r\n                                                std dev       low std dev   high std dev\r\n-------------------------------------------------------------------------------\r\nto_hex_old 0                                              100            17     2.0876 ms \r\n                                                     1.188 us      1.177 us      1.215 us \r\n                                                        84 ns         36 ns        152 ns \r\n```\r\n\r\n**Expected behavior**\r\n\r\n```benchmark name                        samples       iterations    estimated\r\n                                      mean          low mean      high mean\r\n                                      std dev       low std dev   high std dev\r\n-------------------------------------------------------------------------------\r\nto_hex_old 0                                    100            17       2.04 ms \r\n                                           1.112 us      1.103 us      1.132 us \r\n                                              64 ns         34 ns        121 ns \r\n```\r\n\r\n\r\n**Reproduction steps**\r\nUse `BENCHMARK` in a test. See the output.\r\n\r\n**Additional context**\r\nThe problem is caused by setting the \"benchmark name\" column width to `CATCH_CONFIG_CONSOLE_WIDTH - 32` in `ConsoleReporter::ConsoleReporter()`, when the other three columns are each 14 characters wide. (14*3 = 42 > 32).\n", "hints_text": "\n", "created_at": "2020-03-19T13:15:39Z"}
{"repo": "catchorg/Catch2", "pull_number": 1815, "instance_id": "catchorg__Catch2-1815", "issue_numbers": ["1809", "1809"], "base_commit": "9a8963133fb7ce9ce31802160d8e351e0ac5527c", "patch": "diff --git a/include/internal/catch_generators.hpp b/include/internal/catch_generators.hpp\n--- a/include/internal/catch_generators.hpp\n+++ b/include/internal/catch_generators.hpp\n@@ -57,7 +57,6 @@ namespace Generators {\n     class SingleValueGenerator final : public IGenerator<T> {\n         T m_value;\n     public:\n-        SingleValueGenerator(T const& value) : m_value( value ) {}\n         SingleValueGenerator(T&& value) : m_value(std::move(value)) {}\n \n         T const& get() const override {\n@@ -120,21 +119,21 @@ namespace Generators {\n             m_generators.emplace_back(std::move(generator));\n         }\n         void populate(T&& val) {\n-            m_generators.emplace_back(value(std::move(val)));\n+            m_generators.emplace_back(value(std::forward<T>(val)));\n         }\n         template<typename U>\n         void populate(U&& val) {\n-            populate(T(std::move(val)));\n+            populate(T(std::forward<U>(val)));\n         }\n         template<typename U, typename... Gs>\n-        void populate(U&& valueOrGenerator, Gs... moreGenerators) {\n+        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {\n             populate(std::forward<U>(valueOrGenerator));\n             populate(std::forward<Gs>(moreGenerators)...);\n         }\n \n     public:\n         template <typename... Gs>\n-        Generators(Gs... moreGenerators) {\n+        Generators(Gs &&... moreGenerators) {\n             m_generators.reserve(sizeof...(Gs));\n             populate(std::forward<Gs>(moreGenerators)...);\n         }\n@@ -166,7 +165,7 @@ namespace Generators {\n     struct as {};\n \n     template<typename T, typename... Gs>\n-    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {\n         return Generators<T>(std::move(generator), std::forward<Gs>(moreGenerators)...);\n     }\n     template<typename T>\n@@ -174,11 +173,11 @@ namespace Generators {\n         return Generators<T>(std::move(generator));\n     }\n     template<typename T, typename... Gs>\n-    auto makeGenerators( T&& val, Gs... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {\n         return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );\n     }\n     template<typename T, typename U, typename... Gs>\n-    auto makeGenerators( as<T>, U&& val, Gs... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {\n         return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );\n     }\n \n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -181,7 +181,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                     const auto step = .1;\n \n                     auto gen = range(rangeStart, rangeEnd, step);\n-                    auto expected = rangeStart; \n+                    auto expected = rangeStart;\n                     while( (rangeEnd - expected) > step ) {\n                         INFO( \"Current expected value is \" << expected )\n                         REQUIRE(gen.get() == Approx(expected));\n@@ -198,7 +198,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                     const auto step = .3;\n \n                     auto gen = range(rangeStart, rangeEnd, step);\n-                    auto expected = rangeStart; \n+                    auto expected = rangeStart;\n                     while( (rangeEnd - expected) > step ) {\n                        INFO( \"Current expected value is \" << expected )\n                        REQUIRE(gen.get() == Approx(expected));\n@@ -214,7 +214,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                     const auto step = .3;\n \n                     auto gen = range(rangeStart, rangeEnd, step);\n-                    auto expected = rangeStart; \n+                    auto expected = rangeStart;\n                     while( (rangeEnd - expected) > step ) {\n                        INFO( \"Current expected value is \" << expected )\n                        REQUIRE(gen.get() == Approx(expected));\n@@ -223,7 +223,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                        expected += step;\n                     }\n                     REQUIRE_FALSE(gen.next());\n-                }                \n+                }\n             }\n         }\n         SECTION(\"Negative manual step\") {\n@@ -311,6 +311,21 @@ TEST_CASE(\"GENERATE capture macros\", \"[generators][internals][approvals]\") {\n     REQUIRE(value == value2);\n }\n \n+TEST_CASE(\"#1809 - GENERATE_COPY and SingleValueGenerator does not compile\", \"[generators][compilation][approvals]\") {\n+    // Verify Issue #1809 fix, only needs to compile.\n+    auto a = GENERATE_COPY(1, 2);\n+    (void)a;\n+    auto b = GENERATE_COPY(as<long>{}, 1, 2);\n+    (void)b;\n+    int i = 1;\n+    int j = 2;\n+    auto c = GENERATE_COPY(i, j);\n+    (void)c;\n+    auto d = GENERATE_COPY(as<long>{}, i, j);\n+    (void)d;\n+    SUCCEED();\n+}\n+\n TEST_CASE(\"Multiple random generators in one test case output different values\", \"[generators][internals][approvals]\") {\n     SECTION(\"Integer\") {\n         auto random1 = Catch::Generators::random(0, 1000);\n", "problem_statement": "Can't compile SingleValueGenerator inside GENERATE_COPY\n**Describe the bug**\r\nAttempting to invoke the `SingleValueGenerator` (using external variables) inside `GENERATE_COPY` like so...\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( a,b );\r\n```\r\nresults in a compilation error:\r\n```C++\r\nerror: no matching function for call to 'Catch::Generators::GeneratorWrapper<const int&>::GeneratorWrapper(Catch::Generators::GeneratorWrapper<const int>)'\r\n  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\r\n```\r\n\r\n**Expected behavior**\r\nThe above example code should compile fine, since `GENERATE_COPY` should allow the use of external variables (`a` and `b`) in any generator. For example, the following code compiles totally fine (using `RangeGenerator`):\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( range(a,b) );\r\n```\r\n\r\n**Reproduction steps**\r\nself-contained code **`bugdemo.cpp`:**\r\n```C++\r\n#include \"catch.hpp\"\r\n\r\nTEST_CASE( \"bug \" ) {\r\n    \r\n    int a = 1;\r\n    int b = 2;\r\n    int c = GENERATE_COPY(a, b);\r\n    REQUIRE( true );\r\n}\r\n```\r\nand compiled simply with\r\n```\r\ng++ -std=c++14 -c bugdemo.cpp\r\n```\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **MacOS 10.14** and **Ubuntu 18.04**\r\n - Compiler+version: **GCC v8.2.0** and **GCC v7.4.0** and **clang v10.0.0** (and all other versions on system)\r\n - Catch version: **v2.10.0**\r\n\nCan't compile SingleValueGenerator inside GENERATE_COPY\n**Describe the bug**\r\nAttempting to invoke the `SingleValueGenerator` (using external variables) inside `GENERATE_COPY` like so...\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( a,b );\r\n```\r\nresults in a compilation error:\r\n```C++\r\nerror: no matching function for call to 'Catch::Generators::GeneratorWrapper<const int&>::GeneratorWrapper(Catch::Generators::GeneratorWrapper<const int>)'\r\n  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\r\n```\r\n\r\n**Expected behavior**\r\nThe above example code should compile fine, since `GENERATE_COPY` should allow the use of external variables (`a` and `b`) in any generator. For example, the following code compiles totally fine (using `RangeGenerator`):\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( range(a,b) );\r\n```\r\n\r\n**Reproduction steps**\r\nself-contained code **`bugdemo.cpp`:**\r\n```C++\r\n#include \"catch.hpp\"\r\n\r\nTEST_CASE( \"bug \" ) {\r\n    \r\n    int a = 1;\r\n    int b = 2;\r\n    int c = GENERATE_COPY(a, b);\r\n    REQUIRE( true );\r\n}\r\n```\r\nand compiled simply with\r\n```\r\ng++ -std=c++14 -c bugdemo.cpp\r\n```\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **MacOS 10.14** and **Ubuntu 18.04**\r\n - Compiler+version: **GCC v8.2.0** and **GCC v7.4.0** and **clang v10.0.0** (and all other versions on system)\r\n - Catch version: **v2.10.0**\r\n\n", "hints_text": "\n", "created_at": "2019-12-15T06:22:30Z"}
{"repo": "catchorg/Catch2", "pull_number": 1770, "instance_id": "catchorg__Catch2-1770", "issue_numbers": ["1766"], "base_commit": "01ef7076f50f5f2b481ddf082e1afca3c926983f", "patch": "diff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -49,9 +49,15 @@ namespace Catch {\n                     if( !line.empty() && !startsWith( line, '#' ) ) {\n                         if( !startsWith( line, '\"' ) )\n                             line = '\"' + line + '\"';\n-                        config.testsOrTags.push_back( line + ',' );\n+                        config.testsOrTags.push_back( line );\n+                        config.testsOrTags.push_back( \",\" );\n+                        \n                     }\n                 }\n+                //Remove comma in the end\n+                if(!config.testsOrTags.empty())\n+                    config.testsOrTags.erase( config.testsOrTags.end()-1 );\n+                \n                 return ParserResult::ok( ParseResultType::Matched );\n             };\n         auto const setTestOrder = [&]( std::string const& order ) {\ndiff --git a/include/internal/catch_interfaces_reporter.h b/include/internal/catch_interfaces_reporter.h\n--- a/include/internal/catch_interfaces_reporter.h\n+++ b/include/internal/catch_interfaces_reporter.h\n@@ -214,6 +214,8 @@ namespace Catch {\n \n         virtual void noMatchingTestCases( std::string const& spec ) = 0;\n \n+        virtual void reportInvalidArguments(std::string const&) {}\n+        \n         virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;\n         virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;\n \ndiff --git a/include/internal/catch_session.cpp b/include/internal/catch_session.cpp\n--- a/include/internal/catch_session.cpp\n+++ b/include/internal/catch_session.cpp\n@@ -68,8 +68,9 @@ namespace Catch {\n             {\n                 auto const& allTestCases = getAllTestCasesSorted(*m_config);\n                 m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);\n-\n-                if (m_matches.empty()) {\n+                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();\n+                \n+                if (m_matches.empty() && invalidArgs.empty()) {\n                     for (auto const& test : allTestCases)\n                         if (!test.isHidden())\n                             m_tests.emplace(&test);\n@@ -80,6 +81,7 @@ namespace Catch {\n             }\n \n             Totals execute() {\n+                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();\n                 Totals totals;\n                 m_context.testGroupStarting(m_config->name(), 1, 1);\n                 for (auto const& testCase : m_tests) {\n@@ -95,6 +97,12 @@ namespace Catch {\n                         totals.error = -1;\n                     }\n                 }\n+                \n+                if (!invalidArgs.empty()) {\n+                    for (auto const& invalidArg: invalidArgs)                   \n+                         m_context.reporter().reportInvalidArguments(invalidArg);\n+                }   \n+                \n                 m_context.testGroupEnded(m_config->name(), totals, 1, 1);\n                 return totals;\n             }\ndiff --git a/include/reporters/catch_reporter_bases.hpp b/include/reporters/catch_reporter_bases.hpp\n--- a/include/reporters/catch_reporter_bases.hpp\n+++ b/include/reporters/catch_reporter_bases.hpp\n@@ -51,6 +51,8 @@ namespace Catch {\n \n         void noMatchingTestCases(std::string const&) override {}\n \n+        void reportInvalidArguments(std::string const&) override {}\n+        \n         void testRunStarting(TestRunInfo const& _testRunInfo) override {\n             currentTestRunInfo = _testRunInfo;\n         }\n@@ -277,4 +279,4 @@ namespace Catch {\n \n } // end namespace Catch\n \n-#endif // TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED\n+#endif // TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_console.cpp b/include/reporters/catch_reporter_console.cpp\n--- a/include/reporters/catch_reporter_console.cpp\n+++ b/include/reporters/catch_reporter_console.cpp\n@@ -383,6 +383,10 @@ void ConsoleReporter::noMatchingTestCases(std::string const& spec) {\n     stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n }\n \n+void ConsoleReporter::reportInvalidArguments(std::string const&arg){\n+    stream << \"Invalid Filter: \" << arg << std::endl;\n+}\n+\n void ConsoleReporter::assertionStarting(AssertionInfo const&) {}\n \n bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n@@ -694,4 +698,4 @@ CATCH_REGISTER_REPORTER(\"console\", ConsoleReporter)\n \n #if defined(__clang__)\n #  pragma clang diagnostic pop\n-#endif\n+#endif\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_console.h b/include/reporters/catch_reporter_console.h\n--- a/include/reporters/catch_reporter_console.h\n+++ b/include/reporters/catch_reporter_console.h\n@@ -32,6 +32,8 @@ namespace Catch {\n \n         void noMatchingTestCases(std::string const& spec) override;\n \n+        void reportInvalidArguments(std::string const&arg) override;\n+\n         void assertionStarting(AssertionInfo const&) override;\n \n         bool assertionEnded(AssertionStats const& _assertionStats) override;\n@@ -84,4 +86,4 @@ namespace Catch {\n #pragma warning(pop)\n #endif\n \n-#endif // TWOBLUECUBES_CATCH_REPORTER_CONSOLE_H_INCLUDED\n+#endif // TWOBLUECUBES_CATCH_REPORTER_CONSOLE_H_INCLUDED\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_listening.cpp b/include/reporters/catch_reporter_listening.cpp\n--- a/include/reporters/catch_reporter_listening.cpp\n+++ b/include/reporters/catch_reporter_listening.cpp\n@@ -41,6 +41,13 @@ namespace Catch {\n         }\n         m_reporter->noMatchingTestCases( spec );\n     }\n+    \n+    void ListeningReporter::reportInvalidArguments(std::string const&arg){\n+        for ( auto const& listener : m_listeners ) {\n+            listener->reportInvalidArguments( arg );\n+        }\n+        m_reporter->reportInvalidArguments( arg );\n+    }    \n \n #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n     void ListeningReporter::benchmarkPreparing( std::string const& name ) {\n@@ -154,4 +161,4 @@ namespace Catch {\n         return true;\n     }\n \n-} // end namespace Catch\n+} // end namespace Catch\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_listening.h b/include/reporters/catch_reporter_listening.h\n--- a/include/reporters/catch_reporter_listening.h\n+++ b/include/reporters/catch_reporter_listening.h\n@@ -28,7 +28,9 @@ namespace Catch {\n         ReporterPreferences getPreferences() const override;\n \n         void noMatchingTestCases( std::string const& spec ) override;\n-\n+        \n+        void reportInvalidArguments(std::string const&arg) override;\n+        \n         static std::set<Verbosity> getSupportedVerbosities();\n \n #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n@@ -58,4 +60,4 @@ namespace Catch {\n \n } // end namespace Catch\n \n-#endif // TWOBLUECUBES_CATCH_MULTI_REPORTER_H_INCLUDED\n+#endif // TWOBLUECUBES_CATCH_MULTI_REPORTER_H_INCLUDED\n\\ No newline at end of file\n", "test_patch": "diff --git a/include/internal/catch_test_spec.cpp b/include/internal/catch_test_spec.cpp\n--- a/include/internal/catch_test_spec.cpp\n+++ b/include/internal/catch_test_spec.cpp\n@@ -91,5 +91,9 @@ namespace Catch {\n         } );\n         return matches;\n     }\n+    \n+    const TestSpec::vectorStrings& TestSpec::getInvalidArgs() const{\n+        return  (m_invalidArgs);\n+    }\n \n }\ndiff --git a/include/internal/catch_test_spec.h b/include/internal/catch_test_spec.h\n--- a/include/internal/catch_test_spec.h\n+++ b/include/internal/catch_test_spec.h\n@@ -73,14 +73,16 @@ namespace Catch {\n             std::vector<TestCase const*> tests;\n         };\n         using Matches = std::vector<FilterMatch>;\n+        using vectorStrings = std::vector<std::string>;\n \n         bool hasFilters() const;\n         bool matches( TestCaseInfo const& testCase ) const;\n         Matches matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const;\n+        const vectorStrings & getInvalidArgs() const;\n \n     private:\n         std::vector<Filter> m_filters;\n-\n+        std::vector<std::string> m_invalidArgs;\n         friend class TestSpecParser;\n     };\n }\ndiff --git a/include/internal/catch_test_spec_parser.cpp b/include/internal/catch_test_spec_parser.cpp\n--- a/include/internal/catch_test_spec_parser.cpp\n+++ b/include/internal/catch_test_spec_parser.cpp\n@@ -20,8 +20,13 @@ namespace Catch {\n         m_substring.reserve(m_arg.size());\n         m_patternName.reserve(m_arg.size());\n         m_realPatternPos = 0;\n+        \n         for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n-            visitChar( m_arg[m_pos] );\n+          //if visitChar fails\n+           if( !visitChar( m_arg[m_pos] ) ){ \n+               m_testSpec.m_invalidArgs.push_back(arg);\n+               break;\n+           }\n         endMode();\n         return *this;\n     }\n@@ -29,38 +34,32 @@ namespace Catch {\n         addFilter();\n         return m_testSpec;\n     }\n-    void TestSpecParser::visitChar( char c ) {\n+    bool TestSpecParser::visitChar( char c ) {\n         if( (m_mode != EscapedName) && (c == '\\\\') ) {\n             escape();\n-            m_substring += c;\n-            m_patternName += c;\n-            m_realPatternPos++;\n-            return;\n+            addCharToPattern(c);\n+            return true;\n         }else if((m_mode != EscapedName) && (c == ',') )  {\n-            endMode();\n-            addFilter();\n-            return;\n+            return separate();\n         }\n \n         switch( m_mode ) {\n         case None:\n             if( processNoneChar( c ) )\n-                return;\n+                return true;\n             break;\n         case Name:\n             processNameChar( c );\n             break;\n         case EscapedName:\n             endMode();\n-            m_substring += c;\n-            m_patternName += c;\n-            m_realPatternPos++;\n-            return;\n+            addCharToPattern(c);\n+            return true;\n         default:\n         case Tag:\n         case QuotedName:\n             if( processOtherChar( c ) )\n-                return;\n+                return true;\n             break;\n         }\n \n@@ -69,6 +68,7 @@ namespace Catch {\n             m_patternName += c;\n             m_realPatternPos++;\n         }\n+        return true;\n     }\n     // Two of the processing methods return true to signal the caller to return\n     // without adding the given character to the current pattern strings\n@@ -161,6 +161,20 @@ namespace Catch {\n       m_mode = lastMode;\n     }\n     \n+    bool TestSpecParser::separate() {  \n+      if( (m_mode==QuotedName) || (m_mode==Tag) ){\n+         //invalid argument, signal failure to previous scope.\n+         m_mode = None;\n+         m_pos = m_arg.size();\n+         m_substring.clear();\n+         m_patternName.clear();\n+         return false;\n+      }\n+      endMode();\n+      addFilter();\n+      return true; //success\n+    }\n+    \n     TestSpec parseTestSpec( std::string const& arg ) {\n         return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();\n     }\ndiff --git a/include/internal/catch_test_spec_parser.h b/include/internal/catch_test_spec_parser.h\n--- a/include/internal/catch_test_spec_parser.h\n+++ b/include/internal/catch_test_spec_parser.h\n@@ -41,7 +41,7 @@ namespace Catch {\n         TestSpec testSpec();\n \n     private:\n-        void visitChar( char c );\n+        bool visitChar( char c );\n         void startNewMode( Mode mode );\n         bool processNoneChar( char c );\n         void processNameChar( char c );\n@@ -51,6 +51,8 @@ namespace Catch {\n         bool isControlChar( char c ) const;\n         void saveLastMode();\n         void revertBackToLastMode();\n+        void addFilter();\n+        bool separate();\n         \n         template<typename T>\n         void addPattern() {\n@@ -73,8 +75,13 @@ namespace Catch {\n             m_exclusion = false;\n             m_mode = None;\n         }\n-\n-        void addFilter();\n+        \n+        inline void addCharToPattern(char c) {\n+            m_substring += c;\n+            m_patternName += c;\n+            m_realPatternPos++;\n+        }\n+        \n     };\n     TestSpec parseTestSpec( std::string const& arg );\n \n", "problem_statement": "Catch2 terminates when an invalid test name is passed\nPut the following test name in a file, say tests.in:\r\n```\r\nTest with special, characters \\\"in name\r\n```\r\nRun a Catch binary with `-f tests.in`. The program terminates with a runtime error thrown from\r\n```\r\n \tmsvcp140d.dll!00007ffc846a4ef9()\tUnknown\r\n>\tSelfTest.exe!std::_String_val<std::_Simple_types<char>>::_Xran() Line 2141\tC++\r\n \tSelfTest.exe!std::_String_val<std::_Simple_types<char>>::_Check_offset(const unsigned __int64 _Off) Line 2131\tC++\r\n \tSelfTest.exe!std::string::assign(const std::string & _Right, const unsigned __int64 _Roff, unsigned __int64 _Count) Line 2824\tC++\r\n \tSelfTest.exe!std::string::basic_string<char,std::char_traits<char>,std::allocator<char>>(const std::string & _Right, const unsigned __int64 _Roff, const unsigned __int64 _Count, const std::allocator<char> & _Al) Line 2278\tC++\r\n \tSelfTest.exe!std::string::substr(const unsigned __int64 _Off, const unsigned __int64 _Count) Line 3949\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::addPattern<Catch::TestSpec::NamePattern>() Line 58\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::endMode() Line 108\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::visitChar(char c) Line 38\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::parse(const std::string & arg) Line 22\tC++\r\n \tSelfTest.exe!Catch::Config::Config(const Catch::ConfigData & data) Line 34\tC++\r\n```\r\nI'd expect Catch to ignore the invalid test name.\n", "hints_text": "@amitherman95 You've worked on the parser recently, can you take a look at this?\nYes I will\nCan the input file also include tags? or test names only?\nLet's say test names only for now\nVery well, I pretty much solved the problem, I just need to add more robust tests for this feature and by tomorrow a PR will be ready. ", "created_at": "2019-10-10T09:55:07Z"}
{"repo": "catchorg/Catch2", "pull_number": 1723, "instance_id": "catchorg__Catch2-1723", "issue_numbers": ["1722"], "base_commit": "e2d863b090f54b648147df1ffd084babc94a5e99", "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -44,9 +44,9 @@ namespace Catch {\n \n         template<typename T>\n         class IsStreamInsertable {\n-            template<typename SS, typename TT>\n+            template<typename Stream, typename U>\n             static auto test(int)\n-                -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());\n+                -> decltype(std::declval<Stream&>() << std::declval<U>(), std::true_type());\n \n             template<typename, typename>\n             static auto test(...)->std::false_type;\n", "test_patch": "", "problem_statement": "Catch2 does not compile on Solaris.\nCurrent master does not compile on Solaris due to a name conflict with a #define in the <sys/regset.h> header.\r\n\r\nI was able to reproduce this bug in an isolated directory containing a main.cpp (below) and the single_include/catch2/catch.hpp header from commit e2d863b090f54b648147df1ffd084babc94a5e99. This is the simple main.cpp file that doesn't compile:\r\n\r\n```cpp\r\n#include \"catch.hpp\"\r\nint main() {}\r\n```\r\n\r\nCompilation command: **g++ -std=c++11 -I. main.cpp**\r\n\r\nThis bug originated in commit 004228efb2ccbd2f69eb443933507012fa82304c where the template parameter name \"SS\" was used. The conflicting define in the Solaris <sys/regset.h> header is this:\r\n\r\n```cpp\r\n#define SS              18      /* only stored on a privilege transition */\r\n```\r\n\r\nNaturally, g++ errors out when it encounters a numeric constant instead of a template parameter name: \r\n\r\n```\r\ncatch.hpp:1542:31: error: expected nested-name-specifier before **numeric constant**\r\ntemplate<typename SS, typename TT>\r\n                   ^\r\n```\r\n\r\nPlatform Info:\r\nOS: Solaris 11.4.0.15.0 i386\r\nCompiler: GCC 7.3.0\r\nCatch Version: e2d863b090f54b648147df1ffd084babc94a5e99\r\n\r\nA PR will be created to fix this issue.\n", "hints_text": "", "created_at": "2019-08-09T21:56:21Z"}
{"repo": "catchorg/Catch2", "pull_number": 1684, "instance_id": "catchorg__Catch2-1684", "issue_numbers": ["1449", "1683"], "base_commit": "fb74bb133ccc8b1bbf932071f3db039861dea73a", "patch": "diff --git a/include/internal/catch_session.cpp b/include/internal/catch_session.cpp\n--- a/include/internal/catch_session.cpp\n+++ b/include/internal/catch_session.cpp\n@@ -25,6 +25,8 @@\n \n #include <cstdlib>\n #include <iomanip>\n+#include <set>\n+#include <iterator>\n \n namespace Catch {\n \n@@ -58,46 +60,53 @@ namespace Catch {\n             return ret;\n         }\n \n-\n-        Catch::Totals runTests(std::shared_ptr<Config> const& config) {\n-            auto reporter = makeReporter(config);\n-\n-            RunContext context(config, std::move(reporter));\n-\n-            Totals totals;\n-\n-            context.testGroupStarting(config->name(), 1, 1);\n-\n-            TestSpec testSpec = config->testSpec();\n-\n-            auto const& allTestCases = getAllTestCasesSorted(*config);\n-            for (auto const& testCase : allTestCases) {\n-                bool matching = (!testSpec.hasFilters() && !testCase.isHidden()) ||\n-                                 (testSpec.hasFilters() && matchTest(testCase, testSpec, *config));\n-\n-                if (!context.aborting() && matching)\n-                    totals += context.runTest(testCase);\n-                else\n-                    context.reporter().skipTest(testCase);\n+        class TestGroup {\n+        public:\n+            explicit TestGroup(std::shared_ptr<Config> const& config)\n+            : m_config{config}\n+            , m_context{config, makeReporter(config)}\n+            {\n+                auto const& allTestCases = getAllTestCasesSorted(*m_config);\n+                m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);\n+\n+                if (m_matches.empty()) {\n+                    for (auto const& test : allTestCases)\n+                        if (!test.isHidden())\n+                            m_tests.emplace(&test);\n+                } else {\n+                    for (auto const& match : m_matches)\n+                        m_tests.insert(match.tests.begin(), match.tests.end());\n+                }\n             }\n \n-            if (config->warnAboutNoTests() && totals.testCases.total() == 0) {\n-                ReusableStringStream testConfig;\n-\n-                bool first = true;\n-                for (const auto& input : config->getTestsOrTags()) {\n-                    if (!first) { testConfig << ' '; }\n-                    first = false;\n-                    testConfig << input;\n+            Totals execute() {\n+                Totals totals;\n+                m_context.testGroupStarting(m_config->name(), 1, 1);\n+                for (auto const& testCase : m_tests) {\n+                    if (!m_context.aborting())\n+                        totals += m_context.runTest(*testCase);\n+                    else\n+                        m_context.reporter().skipTest(*testCase);\n                 }\n \n-                context.reporter().noMatchingTestCases(testConfig.str());\n-                totals.error = -1;\n+                for (auto const& match : m_matches) {\n+                    if (match.tests.empty()) {\n+                        m_context.reporter().noMatchingTestCases(match.name);\n+                        totals.error = -1;\n+                    }\n+                }\n+                m_context.testGroupEnded(m_config->name(), totals, 1, 1);\n+                return totals;\n             }\n \n-            context.testGroupEnded(config->name(), totals, 1, 1);\n-            return totals;\n-        }\n+        private:\n+            using Tests = std::set<TestCase const*>;\n+\n+            std::shared_ptr<Config> m_config;\n+            RunContext m_context;\n+            Tests m_tests;\n+            TestSpec::Matches m_matches;\n+        };\n \n         void applyFilenamesAsTags(Catch::IConfig const& config) {\n             auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\n@@ -274,7 +283,12 @@ namespace Catch {\n             if( Option<std::size_t> listed = list( m_config ) )\n                 return static_cast<int>( *listed );\n \n-            auto totals = runTests( m_config );\n+            TestGroup tests { m_config };\n+            auto const totals = tests.execute();\n+\n+            if( m_config->warnAboutNoTests() && totals.error == -1 )\n+                return 2;\n+\n             // Note that on unices only the lower 8 bits are usually used, clamping\n             // the return value to 255 prevents false negative when some multiple\n             // of 256 tests has failed\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -393,8 +393,19 @@ set_tests_properties(ListTestNamesOnly PROPERTIES\n add_test(NAME NoAssertions COMMAND $<TARGET_FILE:SelfTest> -w NoAssertions)\n set_tests_properties(NoAssertions PROPERTIES PASS_REGULAR_EXPRESSION \"No assertions in test case\")\n \n-add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> -w NoTests \"___nonexistent_test___\")\n-set_tests_properties(NoTest PROPERTIES PASS_REGULAR_EXPRESSION \"No test cases matched\")\n+add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> Tracker, \"___nonexistent_test___\")\n+set_tests_properties(NoTest PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"No test cases matched '___nonexistent_test___'\"\n+    FAIL_REGULAR_EXPRESSION \"No tests ran\"\n+)\n+\n+add_test(NAME WarnAboutNoTests COMMAND ${CMAKE_COMMAND} -P ${CATCH_DIR}/projects/SelfTest/WarnAboutNoTests.cmake $<TARGET_FILE:SelfTest>)\n+\n+add_test(NAME UnmatchedOutputFilter COMMAND $<TARGET_FILE:SelfTest> [this-tag-does-not-exist] -w NoTests)\n+set_tests_properties(UnmatchedOutputFilter\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"No test cases matched '\\\\[this-tag-does-not-exist\\\\]'\"\n+)\n \n add_test(NAME FilteredSection-1 COMMAND $<TARGET_FILE:SelfTest> \\#1394 -c RunSection)\n set_tests_properties(FilteredSection-1 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n", "test_patch": "diff --git a/include/internal/catch_interfaces_testcase.h b/include/internal/catch_interfaces_testcase.h\n--- a/include/internal/catch_interfaces_testcase.h\n+++ b/include/internal/catch_interfaces_testcase.h\n@@ -28,6 +28,7 @@ namespace Catch {\n         virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;\n     };\n \n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n     std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );\n     std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );\ndiff --git a/include/internal/catch_test_case_registry_impl.cpp b/include/internal/catch_test_case_registry_impl.cpp\n--- a/include/internal/catch_test_case_registry_impl.cpp\n+++ b/include/internal/catch_test_case_registry_impl.cpp\n@@ -36,8 +36,13 @@ namespace Catch {\n         }\n         return sorted;\n     }\n+\n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config ) {\n+        return !testCase.throws() || config.allowThrows();\n+    }\n+\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {\n-        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );\n+        return testSpec.matches( testCase ) && isThrowSafe( testCase, config );\n     }\n \n     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {\ndiff --git a/include/internal/catch_test_case_registry_impl.h b/include/internal/catch_test_case_registry_impl.h\n--- a/include/internal/catch_test_case_registry_impl.h\n+++ b/include/internal/catch_test_case_registry_impl.h\n@@ -23,6 +23,8 @@ namespace Catch {\n     struct IConfig;\n \n     std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );\n+\n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n \n     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );\ndiff --git a/include/internal/catch_test_spec.cpp b/include/internal/catch_test_spec.cpp\n--- a/include/internal/catch_test_spec.cpp\n+++ b/include/internal/catch_test_spec.cpp\n@@ -7,6 +7,7 @@\n \n #include \"catch_test_spec.h\"\n #include \"catch_string_manip.h\"\n+#include \"catch_interfaces_config.h\"\n \n #include <algorithm>\n #include <string>\n@@ -15,45 +16,80 @@\n \n namespace Catch {\n \n+    TestSpec::Pattern::Pattern( std::string const& name )\n+    : m_name( name )\n+    {}\n+\n     TestSpec::Pattern::~Pattern() = default;\n-    TestSpec::NamePattern::~NamePattern() = default;\n-    TestSpec::TagPattern::~TagPattern() = default;\n-    TestSpec::ExcludedPattern::~ExcludedPattern() = default;\n \n-    TestSpec::NamePattern::NamePattern( std::string const& name )\n-    : m_wildcardPattern( toLower( name ), CaseSensitive::No )\n+    std::string const& TestSpec::Pattern::name() const {\n+        return m_name;\n+    }\n+\n+\n+    TestSpec::NamePattern::NamePattern( std::string const& name, std::string const& filterString )\n+    : Pattern( filterString )\n+    , m_wildcardPattern( toLower( name ), CaseSensitive::No )\n     {}\n+\n     bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {\n         return m_wildcardPattern.matches( toLower( testCase.name ) );\n     }\n \n-    TestSpec::TagPattern::TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}\n+\n+    TestSpec::TagPattern::TagPattern( std::string const& tag, std::string const& filterString )\n+    : Pattern( filterString )\n+    , m_tag( toLower( tag ) )\n+    {}\n+\n     bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {\n         return std::find(begin(testCase.lcaseTags),\n                          end(testCase.lcaseTags),\n                          m_tag) != end(testCase.lcaseTags);\n     }\n \n-    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}\n-    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }\n+\n+    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern )\n+    : Pattern( underlyingPattern->name() )\n+    , m_underlyingPattern( underlyingPattern )\n+    {}\n+\n+    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const {\n+        return !m_underlyingPattern->matches( testCase );\n+    }\n+\n \n     bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {\n-        // All patterns in a filter must match for the filter to be a match\n-        for( auto const& pattern : m_patterns ) {\n-            if( !pattern->matches( testCase ) )\n-                return false;\n-        }\n-        return true;\n+        return std::all_of( m_patterns.begin(), m_patterns.end(), [&]( PatternPtr const& p ){ return p->matches( testCase ); } );\n+    }\n+\n+    std::string TestSpec::Filter::name() const {\n+        std::string name;\n+        for( auto const& p : m_patterns )\n+            name += p->name();\n+        return name;\n     }\n \n+\n     bool TestSpec::hasFilters() const {\n         return !m_filters.empty();\n     }\n+\n     bool TestSpec::matches( TestCaseInfo const& testCase ) const {\n-        // A TestSpec matches if any filter matches\n-        for( auto const& filter : m_filters )\n-            if( filter.matches( testCase ) )\n-                return true;\n-        return false;\n+        return std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter const& f ){ return f.matches( testCase ); } );\n     }\n+\n+    TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const\n+    {\n+        Matches matches( m_filters.size() );\n+        std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&]( Filter const& filter ){\n+            std::vector<TestCase const*> currentMatches;\n+            for( auto const& test : testCases )\n+                if( isThrowSafe( test, config ) && filter.matches( test ) )\n+                    currentMatches.emplace_back( &test );\n+            return FilterMatch{ filter.name(), currentMatches };\n+        } );\n+        return matches;\n+    }\n+\n }\ndiff --git a/include/internal/catch_test_spec.h b/include/internal/catch_test_spec.h\n--- a/include/internal/catch_test_spec.h\n+++ b/include/internal/catch_test_spec.h\n@@ -22,17 +22,23 @@\n \n namespace Catch {\n \n+    struct IConfig;\n+\n     class TestSpec {\n-        struct Pattern {\n+        class Pattern {\n+        public:\n+            explicit Pattern( std::string const& name );\n             virtual ~Pattern();\n             virtual bool matches( TestCaseInfo const& testCase ) const = 0;\n+            std::string const& name() const;\n+        private:\n+            std::string const m_name;\n         };\n         using PatternPtr = std::shared_ptr<Pattern>;\n \n         class NamePattern : public Pattern {\n         public:\n-            NamePattern( std::string const& name );\n-            virtual ~NamePattern();\n+            explicit NamePattern( std::string const& name, std::string const& filterString );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             WildcardPattern m_wildcardPattern;\n@@ -40,8 +46,7 @@ namespace Catch {\n \n         class TagPattern : public Pattern {\n         public:\n-            TagPattern( std::string const& tag );\n-            virtual ~TagPattern();\n+            explicit TagPattern( std::string const& tag, std::string const& filterString );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             std::string m_tag;\n@@ -49,8 +54,7 @@ namespace Catch {\n \n         class ExcludedPattern : public Pattern {\n         public:\n-            ExcludedPattern( PatternPtr const& underlyingPattern );\n-            virtual ~ExcludedPattern();\n+            explicit ExcludedPattern( PatternPtr const& underlyingPattern );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             PatternPtr m_underlyingPattern;\n@@ -60,11 +64,19 @@ namespace Catch {\n             std::vector<PatternPtr> m_patterns;\n \n             bool matches( TestCaseInfo const& testCase ) const;\n+            std::string name() const;\n         };\n \n     public:\n+        struct FilterMatch {\n+            std::string name;\n+            std::vector<TestCase const*> tests;\n+        };\n+        using Matches = std::vector<FilterMatch>;\n+\n         bool hasFilters() const;\n         bool matches( TestCaseInfo const& testCase ) const;\n+        Matches matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const;\n \n     private:\n         std::vector<Filter> m_filters;\ndiff --git a/include/internal/catch_test_spec_parser.cpp b/include/internal/catch_test_spec_parser.cpp\n--- a/include/internal/catch_test_spec_parser.cpp\n+++ b/include/internal/catch_test_spec_parser.cpp\n@@ -14,64 +14,125 @@ namespace Catch {\n     TestSpecParser& TestSpecParser::parse( std::string const& arg ) {\n         m_mode = None;\n         m_exclusion = false;\n-        m_start = std::string::npos;\n         m_arg = m_tagAliases->expandAliases( arg );\n         m_escapeChars.clear();\n+        m_substring.reserve(m_arg.size());\n+        m_patternName.reserve(m_arg.size());\n         for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n             visitChar( m_arg[m_pos] );\n-        if( m_mode == Name )\n-            addPattern<TestSpec::NamePattern>();\n+        endMode();\n         return *this;\n     }\n     TestSpec TestSpecParser::testSpec() {\n         addFilter();\n         return m_testSpec;\n     }\n-\n     void TestSpecParser::visitChar( char c ) {\n-        if( m_mode == None ) {\n-            switch( c ) {\n-            case ' ': return;\n-            case '~': m_exclusion = true; return;\n-            case '[': return startNewMode( Tag, ++m_pos );\n-            case '\"': return startNewMode( QuotedName, ++m_pos );\n-            case '\\\\': return escape();\n-            default: startNewMode( Name, m_pos ); break;\n-            }\n+        if( c == ',' ) {\n+            endMode();\n+            addFilter();\n+            return;\n+        }\n+\n+        switch( m_mode ) {\n+        case None:\n+            if( processNoneChar( c ) )\n+                return;\n+            break;\n+        case Name:\n+            processNameChar( c );\n+            break;\n+        case EscapedName:\n+            endMode();\n+            break;\n+        default:\n+        case Tag:\n+        case QuotedName:\n+            if( processOtherChar( c ) )\n+                return;\n+            break;\n+        }\n+\n+        m_substring += c;\n+        if( !isControlChar( c ) )\n+            m_patternName += c;\n+    }\n+    // Two of the processing methods return true to signal the caller to return\n+    // without adding the given character to the current pattern strings\n+    bool TestSpecParser::processNoneChar( char c ) {\n+        switch( c ) {\n+        case ' ':\n+            return true;\n+        case '~':\n+            m_exclusion = true;\n+            return false;\n+        case '[':\n+            startNewMode( Tag );\n+            return false;\n+        case '\"':\n+            startNewMode( QuotedName );\n+            return false;\n+        case '\\\\':\n+            escape();\n+            return true;\n+        default:\n+            startNewMode( Name );\n+            return false;\n         }\n-        if( m_mode == Name ) {\n-            if( c == ',' ) {\n-                addPattern<TestSpec::NamePattern>();\n-                addFilter();\n-            }\n-            else if( c == '[' ) {\n-                if( subString() == \"exclude:\" )\n-                    m_exclusion = true;\n-                else\n-                    addPattern<TestSpec::NamePattern>();\n-                startNewMode( Tag, ++m_pos );\n-            }\n-            else if( c == '\\\\' )\n-                escape();\n+    }\n+    void TestSpecParser::processNameChar( char c ) {\n+        if( c == '[' ) {\n+            if( m_substring == \"exclude:\" )\n+                m_exclusion = true;\n+            else\n+                endMode();\n+            startNewMode( Tag );\n         }\n-        else if( m_mode == EscapedName )\n-            m_mode = Name;\n-        else if( m_mode == QuotedName && c == '\"' )\n-            addPattern<TestSpec::NamePattern>();\n-        else if( m_mode == Tag && c == ']' )\n-            addPattern<TestSpec::TagPattern>();\n     }\n-    void TestSpecParser::startNewMode( Mode mode, std::size_t start ) {\n+    bool TestSpecParser::processOtherChar( char c ) {\n+        if( !isControlChar( c ) )\n+            return false;\n+        m_substring += c;\n+        endMode();\n+        return true;\n+    }\n+    void TestSpecParser::startNewMode( Mode mode ) {\n         m_mode = mode;\n-        m_start = start;\n+    }\n+    void TestSpecParser::endMode() {\n+        switch( m_mode ) {\n+        case Name:\n+        case QuotedName:\n+            return addPattern<TestSpec::NamePattern>();\n+        case Tag:\n+            return addPattern<TestSpec::TagPattern>();\n+        case EscapedName:\n+            return startNewMode( Name );\n+        case None:\n+        default:\n+            return startNewMode( None );\n+        }\n     }\n     void TestSpecParser::escape() {\n-        if( m_mode == None )\n-            m_start = m_pos;\n         m_mode = EscapedName;\n         m_escapeChars.push_back( m_pos );\n     }\n-    std::string TestSpecParser::subString() const { return m_arg.substr( m_start, m_pos - m_start ); }\n+    bool TestSpecParser::isControlChar( char c ) const {\n+        switch( m_mode ) {\n+            default:\n+                return false;\n+            case None:\n+                return c == '~';\n+            case Name:\n+                return c == '[';\n+            case EscapedName:\n+                return true;\n+            case QuotedName:\n+                return c == '\"';\n+            case Tag:\n+                return c == '[' || c == ']';\n+        }\n+    }\n \n     void TestSpecParser::addFilter() {\n         if( !m_currentFilter.m_patterns.empty() ) {\ndiff --git a/include/internal/catch_test_spec_parser.h b/include/internal/catch_test_spec_parser.h\n--- a/include/internal/catch_test_spec_parser.h\n+++ b/include/internal/catch_test_spec_parser.h\n@@ -23,8 +23,10 @@ namespace Catch {\n         enum Mode{ None, Name, QuotedName, Tag, EscapedName };\n         Mode m_mode = None;\n         bool m_exclusion = false;\n-        std::size_t m_start = std::string::npos, m_pos = 0;\n+        std::size_t m_pos = 0;\n         std::string m_arg;\n+        std::string m_substring;\n+        std::string m_patternName;\n         std::vector<std::size_t> m_escapeChars;\n         TestSpec::Filter m_currentFilter;\n         TestSpec m_testSpec;\n@@ -38,26 +40,32 @@ namespace Catch {\n \n     private:\n         void visitChar( char c );\n-        void startNewMode( Mode mode, std::size_t start );\n+        void startNewMode( Mode mode );\n+        bool processNoneChar( char c );\n+        void processNameChar( char c );\n+        bool processOtherChar( char c );\n+        void endMode();\n         void escape();\n-        std::string subString() const;\n+        bool isControlChar( char c ) const;\n \n         template<typename T>\n         void addPattern() {\n-            std::string token = subString();\n+            std::string token = m_patternName;\n             for( std::size_t i = 0; i < m_escapeChars.size(); ++i )\n-                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\n+                token = token.substr( 0, m_escapeChars[i] - i ) + token.substr( m_escapeChars[i] -i +1 );\n             m_escapeChars.clear();\n             if( startsWith( token, \"exclude:\" ) ) {\n                 m_exclusion = true;\n                 token = token.substr( 8 );\n             }\n             if( !token.empty() ) {\n-                TestSpec::PatternPtr pattern = std::make_shared<T>( token );\n+                TestSpec::PatternPtr pattern = std::make_shared<T>( token, m_substring );\n                 if( m_exclusion )\n                     pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );\n                 m_currentFilter.m_patterns.push_back( pattern );\n             }\n+            m_substring.clear();\n+            m_patternName.clear();\n             m_exclusion = false;\n             m_mode = None;\n         }\ndiff --git a/projects/SelfTest/WarnAboutNoTests.cmake b/projects/SelfTest/WarnAboutNoTests.cmake\nnew file mode 100644\n--- /dev/null\n+++ b/projects/SelfTest/WarnAboutNoTests.cmake\n@@ -0,0 +1,19 @@\n+# Workaround for a peculiarity where CTest disregards the return code from a\n+# test command if a PASS_REGULAR_EXPRESSION is also set\n+execute_process(\n+    COMMAND ${CMAKE_ARGV3} -w NoTests \"___nonexistent_test___\"\n+    RESULT_VARIABLE ret\n+    OUTPUT_VARIABLE out\n+)\n+\n+message(\"${out}\")\n+\n+if(NOT ${ret} MATCHES \"^[0-9]+$\")\n+    message(FATAL_ERROR \"${ret}\")\n+endif()\n+\n+if(${ret} EQUAL 0)\n+    message(FATAL_ERROR \"Expected nonzero return code\")\n+elseif(${out} MATCHES \"Helper failed with\")\n+    message(FATAL_ERROR \"Helper failed\")\n+endif()\n", "problem_statement": "Catch2 does not report unmatched parts of a partially-matched test spec\n## Description\r\nCatch2's runTests function calls the reporter's noMatchingTestCases if *no* tests match the spec, but if some test matches some part of the spec, nothing reports that the rest of the spec matched nothing. In other words, if I pass \"Test1 Test2\" as command-line args, and \"Test1\" matches some test, nothing complains about the fact that \"Test2\" matched nothing. This can lead the user to believe that they're running all the tests in the spec when they are not.\r\n\r\n### Steps to reproduce\r\nCreate a test file with one test. Run it with command-line args that specify two tests: the existing test and\r\nsome other, non-existent test. Everything will be green and happy, with no indication that the second test was not found.\r\n\r\n### Extra information\r\n* Catch version: **v2.4.1**\r\n* Operating System: **Windows 10**\r\n* Compiler+version: **MS VS 2015**\r\n\n-w NoTests should give non-zero status\ndocs/command-line.md says \"NoTests        // Return non-zero exit code when no test cases were run\" but I see a status of zero being returned instead of non-zero\r\n\r\nmy_bug.cpp:\r\n```#define CATCH_CONFIG_MAIN\r\n#include \"catch2/catch.hpp\"\r\n\r\nTEST_CASE(\"my case\", \"[foo]\") {\r\n  SECTION(\"my section\") {\r\n    CHECK(1);\r\n  }\r\n}\r\n```\r\n```\r\n> g++ -o my_bug my_bug.cpp -I ...\r\n> ./my_bug -w NoTests '[x]'\r\nFilters: [x]\r\nNo test cases matched '[x]'\r\n===============================================================================\r\nNo tests ran\r\n\r\nstatus=0\r\n```\r\n\r\nI expected a non-zero status.\r\n\r\n**Platform information:**\r\n - OS: **Linux CentOS 6**\r\n - Compiler+version: **GCC v7.3.0**\r\n - Catch version: **v2.9.1**\r\n\n", "hints_text": "This is actually true even if you run with just \"test2\". That is, you are told _\"No tests ran\"_, but the test calls `exit(0)`. So to my script it looks like everything ran as expected.\r\n\r\nI think that:\r\n\r\n1. It should report errors for any spec. which does not have a match; and\r\n2. If any such error is found, the test should return 1 (i.e. `exit(1)`) so my scripts break as expected on errors.\nYou're right. The main issue can be fixed with some changes to the test case filtering mechanism. As for the exit code issue, going by the documentation, the command-line option `-w NoTests` *should* do what @AlexisWilke wants, but the code does not seem to respect it. This is also easy to fix. I'll have a go at it soon.\n", "created_at": "2019-07-09T21:09:26Z"}
{"repo": "catchorg/Catch2", "pull_number": 1673, "instance_id": "catchorg__Catch2-1673", "issue_numbers": ["1670"], "base_commit": "6f32c67ea763ff189b55eeb24980ddc2522a80fb", "patch": "diff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -378,6 +378,8 @@ set_tests_properties(FilteredSection-2 PROPERTIES FAIL_REGULAR_EXPRESSION \"No te\n add_test(NAME ApprovalTests COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/scripts/approvalTests.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(ApprovalTests PROPERTIES FAIL_REGULAR_EXPRESSION \"Results differed\")\n \n+add_test(NAME RegressionCheck-1670 COMMAND $<TARGET_FILE:SelfTest> \"#1670 regression check\" -c A -r compact)\n+set_tests_properties(RegressionCheck-1670 PROPERTIES PASS_REGULAR_EXPRESSION \"Passed 1 test case with 2 assertions.\")\n \n if (CATCH_USE_VALGRIND)\n     add_test(NAME ValgrindRunTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest>)\n", "test_patch": "diff --git a/include/internal/catch_test_case_tracker.cpp b/include/internal/catch_test_case_tracker.cpp\n--- a/include/internal/catch_test_case_tracker.cpp\n+++ b/include/internal/catch_test_case_tracker.cpp\n@@ -139,7 +139,7 @@ namespace TestCaseTracking {\n                 m_runState = CompletedSuccessfully;\n                 break;\n             case ExecutingChildren:\n-                if( m_children.empty() || m_children.back()->isComplete() )\n+                if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const& t){ return t->isComplete(); }) )\n                     m_runState = CompletedSuccessfully;\n                 break;\n \ndiff --git a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n@@ -189,3 +189,18 @@ TEST_CASE( \"#1394 nested\", \"[.][approvals][tracker]\" ) {\n         REQUIRE(1 == 0);\n     }\n }\n+\n+// Selecting a \"not last\" section inside a test case via -c \"section\" would\n+// previously only run the first subsection, instead of running all of them.\n+// This allows us to check that `\"#1670 regression check\" -c A` leads to\n+// 2 successful assertions.\n+TEST_CASE(\"#1670 regression check\", \"[.approvals][tracker]\") {\n+    SECTION(\"A\") {\n+        SECTION(\"1\") SUCCEED();\n+        SECTION(\"2\") SUCCEED();\n+    }\n+    SECTION(\"B\") {\n+        SECTION(\"1\") SUCCEED();\n+        SECTION(\"2\") SUCCEED();\n+    }\n+}\n", "problem_statement": "Inconsistent behaviour of nested sections\n**Describe the bug**\r\nSuppose I have a test case with a structure like the following:\r\n```\r\nTEST_CASE(\"Nesting\")\r\n{\r\n    SECTION(\"A\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n    SECTION(\"B\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n}\r\n```\r\n\r\nUpon selecting the test case and section on the command line, I get the following results:\r\n* `./test Nesting`: All four assertions are executed;\r\n* `./test Nesting -c A`: *Only A1 is executed*;\r\n* `./test Nesting -c B`: B1 and B2 are executed.\r\n\r\n**Expected behavior**\r\n`./test Nesting -c A` should execute all subsections of section A.\r\n\r\n**Reproduction steps**\r\nSee description.\r\n\r\n**Platform information:**\r\n - Compiler+version: **GCC v9.1.1**\r\n - Catch version: **v2.8.0**, **v2.9.1**\r\n\n", "hints_text": "Thanks for the report.\r\n\r\nUpon further investigation, this was introduced by #1492 and affects all sections that are not the last section, in other words, in this\r\n\r\n```cpp\r\nTEST_CASE(\"Nesting\")\r\n{\r\n    SECTION(\"A\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n    SECTION(\"B\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n    SECTION(\"C\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n}\r\n```\r\nOnly \"C\" is unaffected.", "created_at": "2019-06-29T16:12:17Z"}
{"repo": "catchorg/Catch2", "pull_number": 1672, "instance_id": "catchorg__Catch2-1672", "issue_numbers": ["1671"], "base_commit": "6f32c67ea763ff189b55eeb24980ddc2522a80fb", "patch": "diff --git a/include/internal/catch_generators_generic.hpp b/include/internal/catch_generators_generic.hpp\n--- a/include/internal/catch_generators_generic.hpp\n+++ b/include/internal/catch_generators_generic.hpp\n@@ -205,12 +205,14 @@ namespace Generators {\n             m_chunk_size(size), m_generator(std::move(generator))\n         {\n             m_chunk.reserve(m_chunk_size);\n-            m_chunk.push_back(m_generator.get());\n-            for (size_t i = 1; i < m_chunk_size; ++i) {\n-                if (!m_generator.next()) {\n-                    Catch::throw_exception(GeneratorException(\"Not enough values to initialize the first chunk\"));\n-                }\n+            if (m_chunk_size != 0) {\n                 m_chunk.push_back(m_generator.get());\n+                for (size_t i = 1; i < m_chunk_size; ++i) {\n+                    if (!m_generator.next()) {\n+                        Catch::throw_exception(GeneratorException(\"Not enough values to initialize the first chunk\"));\n+                    }\n+                    m_chunk.push_back(m_generator.get());\n+                }\n             }\n         }\n         std::vector<T> const& get() const override {\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Generators.tests.cpp b/projects/SelfTest/UsageTests/Generators.tests.cpp\n--- a/projects/SelfTest/UsageTests/Generators.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Generators.tests.cpp\n@@ -167,6 +167,10 @@ TEST_CASE(\"Generators -- adapters\", \"[generators][generic]\") {\n             REQUIRE(chunk2.front() == chunk2.back());\n             REQUIRE(chunk2.front() < 3);\n         }\n+        SECTION(\"Chunk size of zero\") {\n+            auto chunk2 = GENERATE(take(3, chunk(0, value(1))));\n+            REQUIRE(chunk2.size() == 0);\n+        }\n         SECTION(\"Throws on too small generators\") {\n             using namespace Catch::Generators;\n             REQUIRE_THROWS_AS(chunk(2, value(1)), Catch::GeneratorException);\n", "problem_statement": "The first vector returned by ChunkGenerator is size 1 when chunk-size is 0\n**Describe the bug**\r\nWhen using `ChunkGenerator` with a chunk-size of 0, the first vector returned is size 1. Following vectors are size 0.\r\n\r\n**Expected behavior**\r\nThe first (and all following) vectors should be size 0.\r\n\r\n**Reproduction steps**\r\n```c++\r\nTEST_CASE(\"chunks\") {\r\n  auto vector = GENERATE(take(5, chunk(0, value(1))));\r\n  REQUIRE(vector.size() == 0);\r\n}\r\n```\r\n\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Linux 5.1.15-arch1-1-ARCH**\r\n - Compiler+version: **g++ (GCC) 9.1.0**\r\n - Catch version: **Catch v2.7.2** ([it looks like the bug still exists though](https://github.com/catchorg/Catch2/blob/54089c4c8c657ffb13d8f3a1425403335af5ba4d/include/internal/catch_generators_generic.hpp#L208-L209))\r\n\r\n\r\n**Additional context**\r\nMy specific use-case in which I ran into this is a test like this:\r\n\r\n```c++\r\nTEST_CASE(\"my function\") {\r\n  auto size = GENERATE(0, 1, 2, 3);\r\n  auto vector = GENERATE_COPY(take(1, chunk(size, random(-100, 100))));\r\n\r\n  auto list = VectorToList(vector);\r\n  \r\n  REQUIRE(list.size() == size);\r\n}\r\n```\r\n\r\nIt's possible that the intended behaviour was to return a minimum chunk-size of 1 for all chunks, but I think it would make much more sense to return empty vectors, otherwise the use-case above would be more annoying to write.\r\n\n", "hints_text": "", "created_at": "2019-06-29T13:50:00Z"}
{"repo": "catchorg/Catch2", "pull_number": 1642, "instance_id": "catchorg__Catch2-1642", "issue_numbers": ["1627"], "base_commit": "b468d7cbff70291200294732c3795c53b5c502f6", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -259,6 +259,8 @@\n #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)\n+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n@@ -268,6 +270,8 @@\n #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -31,4 +31,8 @@ struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args..\n \n } // namespace Catch\n \n+namespace mpl_{\n+    struct na;\n+}\n+\n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -107,6 +107,8 @@\n     constexpr auto append(L1<E1...>, L2<E2...>) noexcept -> L1<E1...,E2...> { return {}; }\\\n     template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\\n     constexpr auto append(L1<E1...>, L2<E2...>, Rest...) noexcept -> decltype(append(L1<E1...,E2...>{}, Rest{}...)) { return {}; }\\\n+    template< template<typename...> class L1, typename...E1, typename...Rest>\\\n+    constexpr auto append(L1<E1...>, TypeList<mpl_::na>, Rest...) noexcept -> L1<E1...> { return {}; }\\\n     \\\n     template< template<typename...> class Container, template<typename...> class List, typename...elems>\\\n     constexpr auto rewrap(List<elems...>) noexcept -> TypeList<Container<elems...>> { return {}; }\\\n@@ -114,7 +116,9 @@\n     constexpr auto rewrap(List<Elems...>,Elements...) noexcept -> decltype(append(TypeList<Container<Elems...>>{}, rewrap<Container>(Elements{}...))) { return {}; }\\\n     \\\n     template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\\n-    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\\\n+    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\\\n+    constexpr auto convert(List<Ts...>) noexcept -> decltype(append(Final<>{},TypeList<Ts>{}...)) { return {}; }\n \n #define INTERNAL_CATCH_NTTP_1(signature, ...)\\\n     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\\\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -96,8 +96,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by types, in the form of `TEMPLATE_TEST_CASE` and\n-`TEMPLATE_PRODUCT_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE`,\n+`TEMPLATE_PRODUCT_TEST_CASE` and `TEMPLATE_LIST_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -192,6 +192,23 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+* **TEMPLATE_LIST_TEST_CASE(** _test name_, _tags_, _type list_ **)**\n+\n+_type list_ is a generic list of types on which test case should be instantiated.\n+List can be `std::tuple`, `boost::mpl::list`, `boost::mp11::mp_list` or anything with\n+`template <typename...>` signature.\n+\n+This allows you to reuse the _type list_ in multiple test cases.\n+\n+Example:\n+```cpp\n+using MyTypes = std::tuple<int, char, float>;\n+TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n+{\n+    REQUIRE(sizeof(TestType) > 0);\n+}\n+```\n+\n \n ## Signature based parametrised test cases\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -111,6 +111,19 @@ TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TE\n }\n ```\n \n+Catch2 also provides `TEMPLATE_LIST_TEST_CASE_METHOD` to support template fixtures with types specified in\n+template type lists like `std::tuple`, `boost::mpl::list` or `boost::mp11::mp_list`. This test case works the same as `TEMPLATE_TEST_CASE_METHOD`,\n+only difference is the source of types. This allows you to reuse the template type list in multiple test cases.\n+\n+Example:\n+```cpp\n+using MyTypes = std::tuple<int, char, double>;\n+TEMPLATE_LIST_TEST_CASE_METHOD(Template_Fixture, \"Template test case method with test types specified inside std::tuple\", \"[class][template][list]\", MyTypes)\n+{\n+    REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -232,6 +232,35 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> static void TestFunc();       \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+        INTERNAL_CATCH_TYPE_GEN\\\n+        template<typename... Types>                               \\\n+        struct TestName {                                         \\\n+            void reg_tests() {                                          \\\n+                int index = 0;                                    \\\n+                using expander = int[];                           \\\n+                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + \" - \" + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */\\\n+            }                                                     \\\n+        };\\\n+        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = decltype(convert<TestName>(TmplList {})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n+                return 0;                                             \\\n+            }();                                                        \\\n+        }}\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFunc()\n+\n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \\\n+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )\n+\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n@@ -327,5 +356,36 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+            void test();\\\n+        };\\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                void reg_tests(){\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + \" - \" + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = decltype(convert<TestNameClass>(TmplList {}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n+                return 0;\\\n+            }(); \\\n+        }}\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \\\n+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )\n+\n \n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -98,6 +98,12 @@ TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TE\n     REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n }\n \n+using MyTypes = std::tuple<int, char, double>;\n+TEMPLATE_LIST_TEST_CASE_METHOD(Template_Fixture, \"Template test case method with test types specified inside std::tuple\", \"[class][template][list]\", MyTypes)\n+{\n+    REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -365,6 +365,12 @@ TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\n \n+using MyTypes = std::tuple<int, char, float>;\n+TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n+{\n+    REQUIRE(sizeof(TestType) > 0);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\n", "problem_statement": "Support for generic typelists in TEMPLATE_TEST_CASE\n**Description**\r\nOften I already have a typelist of some kind (std::tuple, boost::mpl::list (Boost.MPL), mp_list (Boost.mp11)) and I want to execute a test for each of the types contained in the typelist. I have not yet found a good way to do this with catch2. In my case the types in those lists depend on the current platform and other settings so it is hard if not impossible to write them into the test case header.\r\n\r\nCurrently I am working around this by iterating over the type list in the test body and calling a separate template test method for each type. However, with this approach the type is not part of the test name and it is not easily possible to see which type triggered the error.\r\n\r\nTo enable this use-case, a new macro called `TEMPLATE_LIST_TEST_CASE` or similar would have to be added which internally adds a test case for each of the contained types.\r\nThis is supported by [Boost.Test](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/boost_test/tests_organization/test_cases/test_organization_templates.html) as well as [gtest](https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#typed-tests).\r\n\r\n**Additional context**\r\nExample pseudo code usage:\r\n```\r\nusing Types = std::tuple<int, double, float>;\r\nTEMPLATE_LIST_TEST_CASE(\"test\", \"[test]\", Types)\r\n{\r\n    // Do something with the TestType here which would be `int`, `double` or `float`\r\n}\r\nTEMPLATE_LIST_TEST_CASE(\"test2\", \"[test]\", Types)\r\n{\r\n    // This allows to reuse the typelist for multiple tests\r\n}\r\n```\r\n\n", "hints_text": "", "created_at": "2019-05-27T18:46:18Z"}
{"repo": "catchorg/Catch2", "pull_number": 1638, "instance_id": "catchorg__Catch2-1638", "issue_numbers": ["1636"], "base_commit": "84f8e806b89a6b2491ed780001e074e175401701", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -8,6 +8,10 @@ endif()\n \n project(Catch2 LANGUAGES CXX VERSION 2.7.2)\n \n+if (CMAKE_BINARY_DIR STREQUAL CMAKE_SOURCE_DIR)\n+    message(FATAL_ERROR \"Building in-source is not supported! Create a build dir and remove ${CMAKE_SOURCE_DIR}/CMakeCache.txt\")\n+endif()\n+\n # Provide path for scripts\n list(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_LIST_DIR}/CMake\")\n \n", "test_patch": "", "problem_statement": "compile error with gcc9.1 on linux\n\r\nCompile error when building catch2, from the repository.\r\n\r\ncloned catch2 yesterday (May 18,2019) with:\r\n  git clone https://github.com/catchorg/Catch2.git\r\ninto a folder catch2.\r\nThen started a build in that folder with \r\n  cmake .\r\n  make\r\n\r\nThis produced the following error:\r\n[ 99%] Building CXX object projects/CMakeFiles/SelfTest.dir/SelfTest/SurrogateCpps/catch_xmlwriter.cpp.o\r\n[100%] Linking CXX executable SelfTest\r\n/usr/bin/ld: cannot open output file SelfTest: Is a directory\r\ncollect2: error: ld returned 1 exit status\r\nprojects/CMakeFiles/SelfTest.dir/build.make:1703: recipe for target 'projects/SelfTest' failed\r\nmake[2]: *** [projects/SelfTest] Error 1\r\nCMakeFiles/Makefile2:986: recipe for target 'projects/CMakeFiles/SelfTest.dir/all' failed\r\nmake[1]: *** [projects/CMakeFiles/SelfTest.dir/all] Error 2\r\nMakefile:162: recipe for target 'all' failed\r\nmake: *** [all] Error 2\r\nalan@alan-SH67H3:~/projects/functional/code-examples/3rd-party/catchorg/Catch2$  \r\n\r\nThis looks like an error that was previously encountered and has resurrected itself.\r\n\r\n**Platform information:**\r\nThis is on x86_64 with ubuntu 18.04.2\r\nUsing gcc 9.1.0\r\nand cmake 3.14.4\r\nand GNU make 4.1\n", "hints_text": "So I can compile everything, I added the `set_target_properties()` as follow:\r\n\r\n    add_executable(SelfTest ${TEST_SOURCES} ${IMPL_SOURCES} ${REPORTER_SOURCES} ${SURROGATE_SOURCES} ${HEADERS})\r\n    target_include_directories(SelfTest PRIVATE ${HEADER_DIR})\r\n    set_target_properties(SelfTest PROPERTIES OUTPUT_NAME SelfTest.exe)\r\n\r\nThis is in the `projects/CMakeLists.txt` file. That's probably not the right solution, but I could still run the executable and the 1245 assertions worked as expected.\nThat worked! Thank you.\nJust to be sure. Did you follow https://github.com/catchorg/Catch2/blob/master/projects/Where%20did%20the%20projects%20go.txt ?\r\nUsually the folder to build catch2 should be located at `<wherever Catch2 folder is>/projects/Generated`.\r\nAfter that from `Generated` folder running `cmake -G <generator name> ../..` does the trick\nOooh... That worked. Either way, this is really not conventional for `cmake` though.\r\n\r\nWhat I do with nearly all projects is extract the code:\r\n\r\n    tar xf catch2.tar.gz\r\n\r\nThen I create a build folder\r\n\r\n    mkdir BUILD\r\n\r\nand `cd` into it to run `cmake` and `make`:\r\n\r\n    cd BUILD\r\n    cmake ../catch2\r\n    make\r\n\r\nAny reason why you _had_ to break the usual scheme?\r\n\r\nDoing so with `catch2` fails completely. The `cmake` command from my `BUILD` folder says it can't find this and/or that. Files you should be able to find using `${CMAKE_SOURCE_DIR}`. So the next best thing was to run `cmake` in the root folder... (again, that's the expected `cmake` usage, separate build folder or the root folder of the source package.)\r\n\r\nMaybe a `${CMAKE_MODULE_PATH}` not updated properly? I often add my `project/cmake` folder like so:\r\n\r\n    set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake ${CMAKE_MODULE_PATH})\r\n\r\nAnyway. The Generated folder is better than having to apply a patch! :-)", "created_at": "2019-05-21T04:38:57Z"}
{"repo": "catchorg/Catch2", "pull_number": 1616, "instance_id": "catchorg__Catch2-1616", "issue_numbers": ["1186"], "base_commit": "00347f1e79260e76d5072cca5b3636868397dda5", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -53,7 +53,6 @@\n #include \"internal/catch_test_registry.h\"\n #include \"internal/catch_capture.hpp\"\n #include \"internal/catch_section.h\"\n-#include \"internal/catch_benchmark.h\"\n #include \"internal/catch_interfaces_exception.h\"\n #include \"internal/catch_approx.h\"\n #include \"internal/catch_compiler_capabilities.h\"\n@@ -79,6 +78,10 @@\n #include \"internal/catch_external_interfaces.h\"\n #endif\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#include \"internal/benchmark/catch_benchmark.hpp\"\n+#endif\n+\n #endif // ! CATCH_CONFIG_IMPL_ONLY\n \n #ifdef CATCH_IMPL\n@@ -89,6 +92,7 @@\n #include \"internal/catch_default_main.hpp\"\n #endif\n \n+\n #if !defined(CATCH_CONFIG_IMPL_ONLY)\n \n #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED\n@@ -188,6 +192,13 @@\n #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#define CATCH_BENCHMARK(...) \\\n+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))\n+#define CATCH_BENCHMARK_ADVANCED(name) \\\n+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required\n #else\n \n@@ -283,6 +294,13 @@\n #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#define BENCHMARK(...) \\\n+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))\n+#define BENCHMARK_ADVANCED(name) \\\n+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n using Catch::Detail::Approx;\n \n #else // CATCH_CONFIG_DISABLE\ndiff --git a/include/internal/benchmark/catch_benchmark.hpp b/include/internal/benchmark/catch_benchmark.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_benchmark.hpp\n@@ -0,0 +1,122 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Benchmark\n+#ifndef TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\n+\n+#include \"../catch_config.hpp\"\n+#include \"../catch_context.h\"\n+#include \"../catch_interfaces_reporter.h\"\n+#include \"../catch_test_registry.h\"\n+\n+#include \"catch_chronometer.hpp\"\n+#include \"catch_clock.hpp\"\n+#include \"catch_environment.hpp\"\n+#include \"catch_execution_plan.hpp\"\n+#include \"detail/catch_estimate_clock.hpp\"\n+#include \"detail/catch_complete_invoke.hpp\"\n+#include \"detail/catch_analyse.hpp\"\n+#include \"detail/catch_benchmark_function.hpp\"\n+#include \"detail/catch_run_for_at_least.hpp\"\n+\n+#include <algorithm>\n+#include <functional>\n+#include <string>\n+#include <vector>\n+#include <cmath>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        struct Benchmark {\n+            Benchmark(std::string &&name)\n+                : name(std::move(name)) {}\n+\n+            template <class FUN>\n+            Benchmark(std::string &&name, FUN &&func)\n+                : fun(std::move(func)), name(std::move(name)) {}\n+\n+            template <typename Clock>\n+            ExecutionPlan<FloatDuration<Clock>> prepare(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {\n+                auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;\n+                auto run_time = std::max(min_time, std::chrono::duration_cast<decltype(min_time)>(Detail::warmup_time));\n+                auto&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(run_time), 1, fun);\n+                int new_iters = static_cast<int>(std::ceil(min_time * test.iterations / test.elapsed));\n+                return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FloatDuration<Clock>>(Detail::warmup_time), Detail::warmup_iterations };\n+            }\n+\n+            template <typename Clock = default_clock>\n+            void run() {\n+                IConfigPtr cfg = getCurrentContext().getConfig();\n+\n+                auto env = Detail::measure_environment<Clock>();\n+\n+                getResultCapture().benchmarkPreparing(name);\n+                CATCH_TRY{\n+                    auto plan = user_code([&] {\n+                        return prepare<Clock>(*cfg, env);\n+                    });\n+\n+                    BenchmarkInfo info {\n+                        name,\n+                        plan.estimated_duration.count(),\n+                        plan.iterations_per_sample,\n+                        cfg->benchmarkSamples(),\n+                        cfg->benchmarkResamples(),\n+                        env.clock_resolution.mean.count(),\n+                        env.clock_cost.mean.count()\n+                    };\n+\n+                    getResultCapture().benchmarkStarting(info);\n+\n+                    auto samples = user_code([&] {\n+                        return plan.template run<Clock>(*cfg, env);\n+                    });\n+\n+                    auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());\n+                    BenchmarkStats<std::chrono::duration<double, std::nano>> stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };\n+                    getResultCapture().benchmarkEnded(stats);\n+\n+                } CATCH_CATCH_ALL{\n+                    if (translateActiveException() != Detail::benchmarkErrorMsg) // benchmark errors have been reported, otherwise rethrow.\n+                        std::rethrow_exception(std::current_exception());\n+                }\n+            }\n+\n+            // sets lambda to be used in fun *and* executes benchmark!\n+            template <typename Fun,\n+                typename std::enable_if<!Detail::is_related<Fun, Benchmark>::value, int>::type = 0>\n+                Benchmark & operator=(Fun func) {\n+                fun = Detail::BenchmarkFunction(func);\n+                run();\n+                return *this;\n+            }\n+\n+            explicit operator bool() {\n+                return true;\n+            }\n+\n+        private:\n+            Detail::BenchmarkFunction fun;\n+            std::string name;\n+        };\n+    }\n+} // namespace Catch\n+\n+#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1\n+#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2\n+\n+#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\\\n+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \\\n+        BenchmarkName = [&](int benchmarkIndex)\n+\n+#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\\\n+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \\\n+        BenchmarkName = [&]\n+\n+#endif // TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_chronometer.hpp b/include/internal/benchmark/catch_chronometer.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_chronometer.hpp\n@@ -0,0 +1,71 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// User-facing chronometer\n+\n+#ifndef TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_optimizer.hpp\"\n+#include \"detail/catch_complete_invoke.hpp\"\n+#include \"../catch_meta.hpp\"\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            struct ChronometerConcept {\n+                virtual void start() = 0;\n+                virtual void finish() = 0;\n+                virtual ~ChronometerConcept() = default;\n+            };\n+            template <typename Clock>\n+            struct ChronometerModel final : public ChronometerConcept {\n+                void start() override { started = Clock::now(); }\n+                void finish() override { finished = Clock::now(); }\n+\n+                ClockDuration<Clock> elapsed() const { return finished - started; }\n+\n+                TimePoint<Clock> started;\n+                TimePoint<Clock> finished;\n+            };\n+        } // namespace Detail\n+\n+        struct Chronometer {\n+        public:\n+            template <typename Fun>\n+            void measure(Fun&& fun) { measure(std::forward<Fun>(fun), is_callable<Fun(int)>()); }\n+\n+            int runs() const { return k; }\n+\n+            Chronometer(Detail::ChronometerConcept& meter, int k)\n+                : impl(&meter)\n+                , k(k) {}\n+\n+        private:\n+            template <typename Fun>\n+            void measure(Fun&& fun, std::false_type) {\n+                measure([&fun](int) { return fun(); }, std::true_type());\n+            }\n+\n+            template <typename Fun>\n+            void measure(Fun&& fun, std::true_type) {\n+                Detail::optimizer_barrier();\n+                impl->start();\n+                for (int i = 0; i < k; ++i) invoke_deoptimized(fun, i);\n+                impl->finish();\n+                Detail::optimizer_barrier();\n+            }\n+\n+            Detail::ChronometerConcept* impl;\n+            int k;\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_clock.hpp b/include/internal/benchmark/catch_clock.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_clock.hpp\n@@ -0,0 +1,40 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Clocks\n+\n+#ifndef TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\n+\n+#include <chrono>\n+#include <ratio>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Clock>\n+        using ClockDuration = typename Clock::duration;\n+        template <typename Clock>\n+        using FloatDuration = std::chrono::duration<double, typename Clock::period>;\n+\n+        template <typename Clock>\n+        using TimePoint = typename Clock::time_point;\n+\n+        using default_clock = std::chrono::steady_clock;\n+\n+        template <typename Clock>\n+        struct now {\n+            TimePoint<Clock> operator()() const {\n+                return Clock::now();\n+            }\n+        };\n+\n+        using fp_seconds = std::chrono::duration<double, std::ratio<1>>;\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_constructor.hpp b/include/internal/benchmark/catch_constructor.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_constructor.hpp\n@@ -0,0 +1,73 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Constructor and destructor helpers\n+\n+#ifndef TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\n+\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Detail {\n+        template <typename T, bool Destruct>\n+        struct ObjectStorage\n+        {\n+            using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;\n+\n+            ObjectStorage() : data() {}\n+\n+            ObjectStorage(const ObjectStorage& other)\n+            {\n+                new(&data) T(other.stored_object());\n+            }\n+\n+            ObjectStorage(ObjectStorage&& other)\n+            {\n+                new(&data) T(std::move(other.stored_object()));\n+            }\n+\n+            ~ObjectStorage() { destruct_on_exit<T>(); }\n+\n+            template <typename... Args>\n+            void construct(Args&&... args)\n+            {\n+                new (&data) T(std::forward<Args>(args)...);\n+            }\n+\n+            template <bool AllowManualDestruction = !Destruct>\n+            typename std::enable_if<AllowManualDestruction>::type destruct()\n+            {\n+                stored_object().~T();\n+            }\n+\n+        private:\n+            // If this is a constructor benchmark, destruct the underlying object\n+            template <typename U>\n+            void destruct_on_exit(typename std::enable_if<Destruct, U>::type* = 0) { destruct<true>(); }\n+            // Otherwise, don't\n+            template <typename U>\n+            void destruct_on_exit(typename std::enable_if<!Destruct, U>::type* = 0) { }\n+\n+            T& stored_object()\n+            {\n+                return *static_cast<T*>(static_cast<void*>(&data));\n+            }\n+\n+            TStorage data;\n+        };\n+    }\n+\n+    template <typename T>\n+    using storage_for = Detail::ObjectStorage<T, true>;\n+\n+    template <typename T>\n+    using destructable_object = Detail::ObjectStorage<T, false>;\n+}\n+\n+#endif // TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_environment.hpp b/include/internal/benchmark/catch_environment.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_environment.hpp\n@@ -0,0 +1,38 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Environment information\n+\n+#ifndef TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_outlier_classification.hpp\"\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct EnvironmentEstimate {\n+            Duration mean;\n+            OutlierClassification outliers;\n+\n+            template <typename Duration2>\n+            operator EnvironmentEstimate<Duration2>() const {\n+                return { mean, outliers };\n+            }\n+        };\n+        template <typename Clock>\n+        struct Environment {\n+            using clock_type = Clock;\n+            EnvironmentEstimate<FloatDuration<Clock>> clock_resolution;\n+            EnvironmentEstimate<FloatDuration<Clock>> clock_cost;\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_estimate.hpp b/include/internal/benchmark/catch_estimate.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_estimate.hpp\n@@ -0,0 +1,31 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Statistics estimates\n+\n+#ifndef TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct Estimate {\n+            Duration point;\n+            Duration lower_bound;\n+            Duration upper_bound;\n+            double confidence_interval;\n+\n+            template <typename Duration2>\n+            operator Estimate<Duration2>() const {\n+                return { point, lower_bound, upper_bound, confidence_interval };\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_execution_plan.hpp b/include/internal/benchmark/catch_execution_plan.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_execution_plan.hpp\n@@ -0,0 +1,58 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Execution plan\n+\n+#ifndef TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\n+\n+#include \"../catch_config.hpp\"\n+#include \"catch_clock.hpp\"\n+#include \"catch_environment.hpp\"\n+#include \"detail/catch_benchmark_function.hpp\"\n+#include \"detail/catch_repeat.hpp\"\n+#include \"detail/catch_run_for_at_least.hpp\"\n+\n+#include <algorithm>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct ExecutionPlan {\n+            int iterations_per_sample;\n+            Duration estimated_duration;\n+            Detail::BenchmarkFunction benchmark;\n+            Duration warmup_time;\n+            int warmup_iterations;\n+\n+            template <typename Duration2>\n+            operator ExecutionPlan<Duration2>() const {\n+                return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };\n+            }\n+\n+            template <typename Clock>\n+            std::vector<FloatDuration<Clock>> run(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {\n+                // warmup a bit\n+                Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_iterations, Detail::repeat(now<Clock>{}));\n+\n+                std::vector<FloatDuration<Clock>> times;\n+                times.reserve(cfg.benchmarkSamples());\n+                std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {\n+                    Detail::ChronometerModel<Clock> model;\n+                    this->benchmark(Chronometer(model, iterations_per_sample));\n+                    auto sample_time = model.elapsed() - env.clock_cost.mean;\n+                    if (sample_time < FloatDuration<Clock>::zero()) sample_time = FloatDuration<Clock>::zero();\n+                    return sample_time / iterations_per_sample;\n+                });\n+                return times;\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_optimizer.hpp b/include/internal/benchmark/catch_optimizer.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_optimizer.hpp\n@@ -0,0 +1,68 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Hinting the optimizer\n+\n+#ifndef TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\n+\n+#if defined(_MSC_VER)\n+#   include <atomic> // atomic_thread_fence\n+#endif\n+\n+namespace Catch {\n+    namespace Benchmark {\n+#if defined(__GNUC__) || defined(__clang__)\n+        template <typename T>\n+        inline void keep_memory(T* p) {\n+            asm volatile(\"\" : : \"g\"(p) : \"memory\");\n+        }\n+        inline void keep_memory() {\n+            asm volatile(\"\" : : : \"memory\");\n+        }\n+\n+        namespace Detail {\n+            inline void optimizer_barrier() { keep_memory(); }\n+        } // namespace Detail\n+#elif defined(_MSC_VER)\n+\n+#pragma optimize(\"\", off)\n+        template <typename T>\n+        inline void keep_memory(T* p) {\n+            // thanks @milleniumbug\n+            *reinterpret_cast<char volatile*>(p) = *reinterpret_cast<char const volatile*>(p);\n+        }\n+        // TODO equivalent keep_memory()\n+#pragma optimize(\"\", on)\n+\n+        namespace Detail {\n+            inline void optimizer_barrier() {\n+                std::atomic_thread_fence(std::memory_order_seq_cst);\n+            }\n+        } // namespace Detail\n+\n+#endif\n+\n+        template <typename T>\n+        inline void deoptimize_value(T&& x) {\n+            keep_memory(&x);\n+        }\n+\n+        template <typename Fn, typename... Args>\n+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<!std::is_same<void, decltype(fn(args...))>::value>::type {\n+            deoptimize_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));\n+        }\n+\n+        template <typename Fn, typename... Args>\n+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<std::is_same<void, decltype(fn(args...))>::value>::type {\n+            std::forward<Fn>(fn) (std::forward<Args...>(args...));\n+        }\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_outlier_classification.hpp b/include/internal/benchmark/catch_outlier_classification.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_outlier_classification.hpp\n@@ -0,0 +1,29 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Outlier information\n+#ifndef TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        struct OutlierClassification {\n+            int samples_seen = 0;\n+            int low_severe = 0;     // more than 3 times IQR below Q1\n+            int low_mild = 0;       // 1.5 to 3 times IQR below Q1\n+            int high_mild = 0;      // 1.5 to 3 times IQR above Q3\n+            int high_severe = 0;    // more than 3 times IQR above Q3\n+\n+            int total() const {\n+                return low_severe + low_mild + high_mild + high_severe;\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_sample_analysis.hpp b/include/internal/benchmark/catch_sample_analysis.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_sample_analysis.hpp\n@@ -0,0 +1,50 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Benchmark results\n+\n+#ifndef TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_estimate.hpp\"\n+#include \"catch_outlier_classification.hpp\"\n+\n+#include <algorithm>\n+#include <vector>\n+#include <string>\n+#include <iterator>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct SampleAnalysis {\n+            std::vector<Duration> samples;\n+            Estimate<Duration> mean;\n+            Estimate<Duration> standard_deviation;\n+            OutlierClassification outliers;\n+            double outlier_variance;\n+\n+            template <typename Duration2>\n+            operator SampleAnalysis<Duration2>() const {\n+                std::vector<Duration2> samples2;\n+                samples2.reserve(samples.size());\n+                std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });\n+                return {\n+                    std::move(samples2),\n+                    mean,\n+                    standard_deviation,\n+                    outliers,\n+                    outlier_variance,\n+                };\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_analyse.hpp b/include/internal/benchmark/detail/catch_analyse.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_analyse.hpp\n@@ -0,0 +1,78 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Run and analyse one benchmark\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_sample_analysis.hpp\"\n+#include \"catch_stats.hpp\"\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <vector>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Duration, typename Iterator>\n+            SampleAnalysis<Duration> analyse(const IConfig &cfg, Environment<Duration>, Iterator first, Iterator last) {\n+                if (!cfg.benchmarkNoAnalysis()) {\n+                    std::vector<double> samples;\n+                    samples.reserve(last - first);\n+                    std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });\n+\n+                    auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());\n+                    auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());\n+\n+                    auto wrap_estimate = [](Estimate<double> e) {\n+                        return Estimate<Duration> {\n+                            Duration(e.point),\n+                                Duration(e.lower_bound),\n+                                Duration(e.upper_bound),\n+                                e.confidence_interval,\n+                        };\n+                    };\n+                    std::vector<Duration> samples2;\n+                    samples2.reserve(samples.size());\n+                    std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });\n+                    return {\n+                        std::move(samples2),\n+                        wrap_estimate(analysis.mean),\n+                        wrap_estimate(analysis.standard_deviation),\n+                        outliers,\n+                        analysis.outlier_variance,\n+                    };\n+                } else {\n+                    std::vector<Duration> samples; \n+                    samples.reserve(last - first);\n+\n+                    Duration mean = Duration(0);\n+                    int i = 0;\n+                    for (auto it = first; it < last; ++it, ++i) {\n+                        samples.push_back(Duration(*it));\n+                        mean += Duration(*it);\n+                    }\n+                    mean /= i;\n+\n+                    return {\n+                        std::move(samples),\n+                        Estimate<Duration>{mean, mean, mean, 0.0},\n+                        Estimate<Duration>{Duration(0), Duration(0), Duration(0), 0.0},\n+                        OutlierClassification{},\n+                        0.0\n+                    };\n+                }\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_benchmark_function.hpp b/include/internal/benchmark/detail/catch_benchmark_function.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_benchmark_function.hpp\n@@ -0,0 +1,105 @@\n+    /*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Dumb std::function implementation for consistent call overhead\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\n+\n+#include \"../catch_chronometer.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"../../catch_meta.hpp\"\n+\n+#include <cassert>\n+#include <type_traits>\n+#include <utility>\n+#include <memory>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename T>\n+            using Decay = typename std::decay<T>::type;\n+            template <typename T, typename U>\n+            struct is_related\n+                : std::is_same<Decay<T>, Decay<U>> {};\n+\n+            /// We need to reinvent std::function because every piece of code that might add overhead\n+            /// in a measurement context needs to have consistent performance characteristics so that we\n+            /// can account for it in the measurement.\n+            /// Implementations of std::function with optimizations that aren't always applicable, like\n+            /// small buffer optimizations, are not uncommon.\n+            /// This is effectively an implementation of std::function without any such optimizations;\n+            /// it may be slow, but it is consistently slow.\n+            struct BenchmarkFunction {\n+            private:\n+                struct callable {\n+                    virtual void call(Chronometer meter) const = 0;\n+                    virtual callable* clone() const = 0;\n+                    virtual ~callable() = default;\n+                };\n+                template <typename Fun>\n+                struct model : public callable {\n+                    model(Fun&& fun) : fun(std::move(fun)) {}\n+                    model(Fun const& fun) : fun(fun) {}\n+\n+                    model<Fun>* clone() const override { return new model<Fun>(*this); }\n+\n+                    void call(Chronometer meter) const override {\n+                        call(meter, is_callable<Fun(Chronometer)>());\n+                    }\n+                    void call(Chronometer meter, std::true_type) const {\n+                        fun(meter);\n+                    }\n+                    void call(Chronometer meter, std::false_type) const {\n+                        meter.measure(fun);\n+                    }\n+\n+                    Fun fun;\n+                };\n+\n+                struct do_nothing { void operator()() const {} };\n+\n+                template <typename T>\n+                BenchmarkFunction(model<T>* c) : f(c) {}\n+\n+            public:\n+                BenchmarkFunction()\n+                    : f(new model<do_nothing>{ {} }) {}\n+\n+                template <typename Fun,\n+                    typename std::enable_if<!is_related<Fun, BenchmarkFunction>::value, int>::type = 0>\n+                    BenchmarkFunction(Fun&& fun)\n+                    : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) {}\n+\n+                BenchmarkFunction(BenchmarkFunction&& that)\n+                    : f(std::move(that.f)) {}\n+\n+                BenchmarkFunction(BenchmarkFunction const& that)\n+                    : f(that.f->clone()) {}\n+\n+                BenchmarkFunction& operator=(BenchmarkFunction&& that) {\n+                    f = std::move(that.f);\n+                    return *this;\n+                }\n+\n+                BenchmarkFunction& operator=(BenchmarkFunction const& that) {\n+                    f.reset(that.f->clone());\n+                    return *this;\n+                }\n+\n+                void operator()(Chronometer meter) const { f->call(meter); }\n+\n+            private:\n+                std::unique_ptr<callable> f;\n+            };\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_complete_invoke.hpp b/include/internal/benchmark/detail/catch_complete_invoke.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_complete_invoke.hpp\n@@ -0,0 +1,69 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Invoke with a special case for void\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\n+\n+#include \"../../catch_enforce.h\"\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename T>\n+            struct CompleteType { using type = T; };\n+            template <>\n+            struct CompleteType<void> { struct type {}; };\n+\n+            template <typename T>\n+            using CompleteType_t = typename CompleteType<T>::type;\n+\n+            template <typename Result>\n+            struct CompleteInvoker {\n+                template <typename Fun, typename... Args>\n+                static Result invoke(Fun&& fun, Args&&... args) {\n+                    return std::forward<Fun>(fun)(std::forward<Args>(args)...);\n+                }\n+            };\n+            template <>\n+            struct CompleteInvoker<void> {\n+                template <typename Fun, typename... Args>\n+                static CompleteType_t<void> invoke(Fun&& fun, Args&&... args) {\n+                    std::forward<Fun>(fun)(std::forward<Args>(args)...);\n+                    return {};\n+                }\n+            };\n+            template <typename Sig>\n+            using ResultOf_t = typename std::result_of<Sig>::type;\n+\n+            // invoke and not return void :(\n+            template <typename Fun, typename... Args>\n+            CompleteType_t<ResultOf_t<Fun(Args...)>> complete_invoke(Fun&& fun, Args&&... args) {\n+                return CompleteInvoker<ResultOf_t<Fun(Args...)>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);\n+            }\n+\n+            const std::string benchmarkErrorMsg = \"a benchmark failed to run successfully\";\n+        } // namespace Detail\n+\n+        template <typename Fun>\n+        Detail::CompleteType_t<Detail::ResultOf_t<Fun()>> user_code(Fun&& fun) {\n+            CATCH_TRY{\n+                return Detail::complete_invoke(std::forward<Fun>(fun));\n+            } CATCH_CATCH_ALL{\n+                getResultCapture().benchmarkFailed(translateActiveException());\n+                CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);\n+            }\n+        }\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_estimate_clock.hpp b/include/internal/benchmark/detail/catch_estimate_clock.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_estimate_clock.hpp\n@@ -0,0 +1,113 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Environment measurement\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_environment.hpp\"\n+#include \"catch_stats.hpp\"\n+#include \"catch_measure.hpp\"\n+#include \"catch_run_for_at_least.hpp\"\n+#include \"../catch_clock.hpp\"\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <tuple>\n+#include <vector>\n+#include <cmath>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock>\n+            std::vector<double> resolution(int k) {\n+                std::vector<TimePoint<Clock>> times;\n+                times.reserve(k + 1);\n+                std::generate_n(std::back_inserter(times), k + 1, now<Clock>{});\n+\n+                std::vector<double> deltas;\n+                deltas.reserve(k);\n+                std::transform(std::next(times.begin()), times.end(), times.begin(),\n+                    std::back_inserter(deltas),\n+                    [](TimePoint<Clock> a, TimePoint<Clock> b) { return static_cast<double>((a - b).count()); });\n+\n+                return deltas;\n+            }\n+\n+            const auto warmup_iterations = 10000;\n+            const auto warmup_time = std::chrono::milliseconds(100);\n+            const auto minimum_ticks = 1000;\n+            const auto warmup_seed = 10000;\n+            const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);\n+            const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);\n+            const auto clock_cost_estimation_tick_limit = 100000;\n+            const auto clock_cost_estimation_time = std::chrono::milliseconds(10);\n+            const auto clock_cost_estimation_iterations = 10000;\n+\n+            template <typename Clock>\n+            int warmup() {\n+                return run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_seed, &resolution<Clock>)\n+                    .iterations;\n+            }\n+            template <typename Clock>\n+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_resolution(int iterations) {\n+                auto r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_resolution_estimation_time), iterations, &resolution<Clock>)\n+                    .result;\n+                return {\n+                    FloatDuration<Clock>(mean(r.begin(), r.end())),\n+                    classify_outliers(r.begin(), r.end()),\n+                };\n+            }\n+            template <typename Clock>\n+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {\n+                auto time_limit = std::min(resolution * clock_cost_estimation_tick_limit, FloatDuration<Clock>(clock_cost_estimation_time_limit));\n+                auto time_clock = [](int k) {\n+                    return Detail::measure<Clock>([k] {\n+                        for (int i = 0; i < k; ++i) {\n+                            volatile auto ignored = Clock::now();\n+                            (void)ignored;\n+                        }\n+                    }).elapsed;\n+                };\n+                time_clock(1);\n+                int iters = clock_cost_estimation_iterations;\n+                auto&& r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_cost_estimation_time), iters, time_clock);\n+                std::vector<double> times;\n+                int nsamples = static_cast<int>(std::ceil(time_limit / r.elapsed));\n+                times.reserve(nsamples);\n+                std::generate_n(std::back_inserter(times), nsamples, [time_clock, &r] {\n+                    return static_cast<double>((time_clock(r.iterations) / r.iterations).count());\n+                });\n+                return {\n+                    FloatDuration<Clock>(mean(times.begin(), times.end())),\n+                    classify_outliers(times.begin(), times.end()),\n+                };\n+            }\n+\n+            template <typename Clock>\n+            Environment<FloatDuration<Clock>> measure_environment() {\n+                static Environment<FloatDuration<Clock>>* env = nullptr;\n+                if (env) {\n+                    return *env;\n+                }\n+\n+                auto iters = Detail::warmup<Clock>();\n+                auto resolution = Detail::estimate_clock_resolution<Clock>(iters);\n+                auto cost = Detail::estimate_clock_cost<Clock>(resolution.mean);\n+\n+                env = new Environment<FloatDuration<Clock>>{ resolution, cost };\n+                return *env;\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_measure.hpp b/include/internal/benchmark/detail/catch_measure.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_measure.hpp\n@@ -0,0 +1,35 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Measure\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"catch_timing.hpp\"\n+\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock, typename Fun, typename... Args>\n+            TimingOf<Clock, Fun(Args...)> measure(Fun&& fun, Args&&... args) {\n+                auto start = Clock::now();\n+                auto&& r = Detail::complete_invoke(fun, std::forward<Args>(args)...);\n+                auto end = Clock::now();\n+                auto delta = end - start;\n+                return { delta, std::forward<decltype(r)>(r), 1 };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_repeat.hpp b/include/internal/benchmark/detail/catch_repeat.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_repeat.hpp\n@@ -0,0 +1,37 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// repeat algorithm\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Fun>\n+            struct repeater {\n+                void operator()(int k) const {\n+                    for (int i = 0; i < k; ++i) {\n+                        fun();\n+                    }\n+                }\n+                Fun fun;\n+            };\n+            template <typename Fun>\n+            repeater<typename std::decay<Fun>::type> repeat(Fun&& fun) {\n+                return { std::forward<Fun>(fun) };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_run_for_at_least.hpp b/include/internal/benchmark/detail/catch_run_for_at_least.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_run_for_at_least.hpp\n@@ -0,0 +1,65 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Run a function for a minimum amount of time\n+\n+#ifndef TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_chronometer.hpp\"\n+#include \"catch_measure.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"catch_timing.hpp\"\n+#include \"../../catch_meta.hpp\"\n+\n+#include <utility>\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(int)> measure_one(Fun&& fun, int iters, std::false_type) {\n+                return Detail::measure<Clock>(fun, iters);\n+            }\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(Chronometer)> measure_one(Fun&& fun, int iters, std::true_type) {\n+                Detail::ChronometerModel<Clock> meter;\n+                auto&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));\n+\n+                return { meter.elapsed(), std::move(result), iters };\n+            }\n+\n+            template <typename Clock, typename Fun>\n+            using run_for_at_least_argument_t = typename std::conditional<is_callable<Fun(Chronometer)>::value, Chronometer, int>::type;\n+\n+            struct optimized_away_error : std::exception {\n+                const char* what() const noexcept override {\n+                    return \"could not measure benchmark, maybe it was optimized away\";\n+                }\n+            };\n+\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(run_for_at_least_argument_t<Clock, Fun>)> run_for_at_least(ClockDuration<Clock> how_long, int seed, Fun&& fun) {\n+                auto iters = seed;\n+                while (iters < (1 << 30)) {\n+                    auto&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());\n+\n+                    if (Timing.elapsed >= how_long) {\n+                        return { Timing.elapsed, std::move(Timing.result), iters };\n+                    }\n+                    iters *= 2;\n+                }\n+                throw optimized_away_error{};\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_stats.hpp b/include/internal/benchmark/detail/catch_stats.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_stats.hpp\n@@ -0,0 +1,342 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Statistical analysis tools\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_estimate.hpp\"\n+#include \"../catch_outlier_classification.hpp\"\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <functional>\n+#include <iterator>\n+#include <vector>\n+#include <array>\n+#include <random>\n+#include <numeric>\n+#include <tuple>\n+#include <cmath>\n+#include <utility>\n+#include <cstddef>\n+\n+#ifdef CATCH_USE_ASYNC\n+#include <future>\n+#endif\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            using sample = std::vector<double>;\n+\n+            template <typename Iterator>\n+            double weighted_average_quantile(int k, int q, Iterator first, Iterator last) {\n+                auto count = last - first;\n+                double idx = (count - 1) * k / static_cast<double>(q);\n+                int j = static_cast<int>(idx);\n+                double g = idx - j;\n+                std::nth_element(first, first + j, last);\n+                auto xj = first[j];\n+                if (g == 0) return xj;\n+\n+                auto xj1 = *std::min_element(first + (j + 1), last);\n+                return xj + g * (xj1 - xj);\n+            }\n+\n+            template <typename Iterator>\n+            OutlierClassification classify_outliers(Iterator first, Iterator last) {\n+                std::vector<double> copy(first, last);\n+\n+                auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());\n+                auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());\n+                auto iqr = q3 - q1;\n+                auto los = q1 - (iqr * 3.);\n+                auto lom = q1 - (iqr * 1.5);\n+                auto him = q3 + (iqr * 1.5);\n+                auto his = q3 + (iqr * 3.);\n+\n+                OutlierClassification o;\n+                for (; first != last; ++first) {\n+                    auto&& t = *first;\n+                    if (t < los) ++o.low_severe;\n+                    else if (t < lom) ++o.low_mild;\n+                    else if (t > his) ++o.high_severe;\n+                    else if (t > him) ++o.high_mild;\n+                    ++o.samples_seen;\n+                }\n+                return o;\n+            }\n+\n+            template <typename Iterator>\n+            double mean(Iterator first, Iterator last) {\n+                auto count = last - first;\n+                double sum = std::accumulate(first, last, 0.);\n+                return sum / count;\n+            }\n+\n+            template <typename Iterator>\n+            double standard_deviation(Iterator first, Iterator last) {\n+                auto m = mean(first, last);\n+                double variance = std::accumulate(first, last, 0., [m](double a, double b) {\n+                    double diff = b - m;\n+                    return a + diff * diff;\n+                }) / (last - first);\n+                return std::sqrt(variance);\n+            }\n+\n+            template <typename URng, typename Iterator, typename Estimator>\n+            sample resample(URng& rng, int resamples, Iterator first, Iterator last, Estimator& estimator) {\n+                auto n = last - first;\n+                std::uniform_int_distribution<decltype(n)> dist(0, n - 1);\n+\n+                sample out;\n+                out.reserve(resamples);\n+                std::generate_n(std::back_inserter(out), resamples, [n, first, &estimator, &dist, &rng] {\n+                    std::vector<double> resampled;\n+                    resampled.reserve(n);\n+                    std::generate_n(std::back_inserter(resampled), n, [first, &dist, &rng] { return first[dist(rng)]; });\n+                    return estimator(resampled.begin(), resampled.end());\n+                });\n+                std::sort(out.begin(), out.end());\n+                return out;\n+            }\n+\n+            template <typename Estimator, typename Iterator>\n+            sample jackknife(Estimator&& estimator, Iterator first, Iterator last) {\n+                auto n = last - first;\n+                auto second = std::next(first);\n+                sample results;\n+                results.reserve(n);\n+\n+                for (auto it = first; it != last; ++it) {\n+                    std::iter_swap(it, first);\n+                    results.push_back(estimator(second, last));\n+                }\n+\n+                return results;\n+            }\n+\n+            inline double normal_cdf(double x) {\n+                return std::erfc(-x / std::sqrt(2.0)) / 2.0;\n+            }\n+\n+            inline double erf_inv(double x) {\n+                // Code accompanying the article \"Approximating the erfinv function\" in GPU Computing Gems, Volume 2\n+                double w, p;\n+\n+                w = -log((1.0 - x)*(1.0 + x));\n+\n+                if (w < 6.250000) {\n+                    w = w - 3.125000;\n+                    p = -3.6444120640178196996e-21;\n+                    p = -1.685059138182016589e-19 + p * w;\n+                    p = 1.2858480715256400167e-18 + p * w;\n+                    p = 1.115787767802518096e-17 + p * w;\n+                    p = -1.333171662854620906e-16 + p * w;\n+                    p = 2.0972767875968561637e-17 + p * w;\n+                    p = 6.6376381343583238325e-15 + p * w;\n+                    p = -4.0545662729752068639e-14 + p * w;\n+                    p = -8.1519341976054721522e-14 + p * w;\n+                    p = 2.6335093153082322977e-12 + p * w;\n+                    p = -1.2975133253453532498e-11 + p * w;\n+                    p = -5.4154120542946279317e-11 + p * w;\n+                    p = 1.051212273321532285e-09 + p * w;\n+                    p = -4.1126339803469836976e-09 + p * w;\n+                    p = -2.9070369957882005086e-08 + p * w;\n+                    p = 4.2347877827932403518e-07 + p * w;\n+                    p = -1.3654692000834678645e-06 + p * w;\n+                    p = -1.3882523362786468719e-05 + p * w;\n+                    p = 0.0001867342080340571352 + p * w;\n+                    p = -0.00074070253416626697512 + p * w;\n+                    p = -0.0060336708714301490533 + p * w;\n+                    p = 0.24015818242558961693 + p * w;\n+                    p = 1.6536545626831027356 + p * w;\n+                } else if (w < 16.000000) {\n+                    w = sqrt(w) - 3.250000;\n+                    p = 2.2137376921775787049e-09;\n+                    p = 9.0756561938885390979e-08 + p * w;\n+                    p = -2.7517406297064545428e-07 + p * w;\n+                    p = 1.8239629214389227755e-08 + p * w;\n+                    p = 1.5027403968909827627e-06 + p * w;\n+                    p = -4.013867526981545969e-06 + p * w;\n+                    p = 2.9234449089955446044e-06 + p * w;\n+                    p = 1.2475304481671778723e-05 + p * w;\n+                    p = -4.7318229009055733981e-05 + p * w;\n+                    p = 6.8284851459573175448e-05 + p * w;\n+                    p = 2.4031110387097893999e-05 + p * w;\n+                    p = -0.0003550375203628474796 + p * w;\n+                    p = 0.00095328937973738049703 + p * w;\n+                    p = -0.0016882755560235047313 + p * w;\n+                    p = 0.0024914420961078508066 + p * w;\n+                    p = -0.0037512085075692412107 + p * w;\n+                    p = 0.005370914553590063617 + p * w;\n+                    p = 1.0052589676941592334 + p * w;\n+                    p = 3.0838856104922207635 + p * w;\n+                } else {\n+                    w = sqrt(w) - 5.000000;\n+                    p = -2.7109920616438573243e-11;\n+                    p = -2.5556418169965252055e-10 + p * w;\n+                    p = 1.5076572693500548083e-09 + p * w;\n+                    p = -3.7894654401267369937e-09 + p * w;\n+                    p = 7.6157012080783393804e-09 + p * w;\n+                    p = -1.4960026627149240478e-08 + p * w;\n+                    p = 2.9147953450901080826e-08 + p * w;\n+                    p = -6.7711997758452339498e-08 + p * w;\n+                    p = 2.2900482228026654717e-07 + p * w;\n+                    p = -9.9298272942317002539e-07 + p * w;\n+                    p = 4.5260625972231537039e-06 + p * w;\n+                    p = -1.9681778105531670567e-05 + p * w;\n+                    p = 7.5995277030017761139e-05 + p * w;\n+                    p = -0.00021503011930044477347 + p * w;\n+                    p = -0.00013871931833623122026 + p * w;\n+                    p = 1.0103004648645343977 + p * w;\n+                    p = 4.8499064014085844221 + p * w;\n+                }\n+                return p * x;\n+            }\n+\n+            inline double erfc_inv(double x) {\n+                return erf_inv(1.0 - x);\n+            }\n+\n+            inline double normal_quantile(double p) {\n+                static const double ROOT_TWO = std::sqrt(2.0);\n+\n+                double result = 0.0;\n+                assert(p >= 0 && p <= 1);\n+                if (p < 0 || p > 1) {\n+                    return result;\n+                }\n+\n+                result = -erfc_inv(2.0 * p);\n+                // result *= normal distribution standard deviation (1.0) * sqrt(2)\n+                result *= /*sd * */ ROOT_TWO;\n+                // result += normal disttribution mean (0)\n+                return result;\n+            }\n+\n+            template <typename Iterator, typename Estimator>\n+            Estimate<double> bootstrap(double confidence_level, Iterator first, Iterator last, sample const& resample, Estimator&& estimator) {\n+                auto n_samples = last - first;\n+\n+                double point = estimator(first, last);\n+                // Degenerate case with a single sample\n+                if (n_samples == 1) return { point, point, point, confidence_level };\n+\n+                sample jack = jackknife(estimator, first, last);\n+                double jack_mean = mean(jack.begin(), jack.end());\n+                double sum_squares, sum_cubes;\n+                std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair<double, double> sqcb, double x) -> std::pair<double, double> {\n+                    auto d = jack_mean - x;\n+                    auto d2 = d * d;\n+                    auto d3 = d2 * d;\n+                    return { sqcb.first + d2, sqcb.second + d3 };\n+                });\n+\n+                double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));\n+                int n = static_cast<int>(resample.size());\n+                double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x < point; }) / (double)n;\n+                // degenerate case with uniform samples\n+                if (prob_n == 0) return { point, point, point, confidence_level };\n+\n+                double bias = normal_quantile(prob_n);\n+                double z1 = normal_quantile((1. - confidence_level) / 2.);\n+\n+                auto cumn = [n](double x) -> int {\n+                    return std::lround(normal_cdf(x) * n); };\n+                auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };\n+                double b1 = bias + z1;\n+                double b2 = bias - z1;\n+                double a1 = a(b1);\n+                double a2 = a(b2);\n+                auto lo = std::max(cumn(a1), 0);\n+                auto hi = std::min(cumn(a2), n - 1);\n+\n+                return { point, resample[lo], resample[hi], confidence_level };\n+            }\n+\n+            inline double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n) {\n+                double sb = stddev.point;\n+                double mn = mean.point / n;\n+                double mg_min = mn / 2.;\n+                double sg = std::min(mg_min / 4., sb / std::sqrt(n));\n+                double sg2 = sg * sg;\n+                double sb2 = sb * sb;\n+\n+                auto c_max = [n, mn, sb2, sg2](double x) -> double {\n+                    double k = mn - x;\n+                    double d = k * k;\n+                    double nd = n * d;\n+                    double k0 = -n * nd;\n+                    double k1 = sb2 - n * sg2 + nd;\n+                    double det = k1 * k1 - 4 * sg2 * k0;\n+                    return (int)(-2. * k0 / (k1 + std::sqrt(det)));\n+                };\n+\n+                auto var_out = [n, sb2, sg2](double c) {\n+                    double nc = n - c;\n+                    return (nc / n) * (sb2 - nc * sg2);\n+                };\n+\n+                return std::min(var_out(1), var_out(std::min(c_max(0.), c_max(mg_min)))) / sb2;\n+            }\n+\n+            struct bootstrap_analysis {\n+                Estimate<double> mean;\n+                Estimate<double> standard_deviation;\n+                double outlier_variance;\n+            };\n+\n+            template <typename Iterator>\n+            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, Iterator first, Iterator last) {\n+                static std::random_device entropy;\n+\n+                auto n = static_cast<int>(last - first); // seriously, one can't use integral types without hell in C++\n+\n+                auto mean = &Detail::mean<Iterator>;\n+                auto stddev = &Detail::standard_deviation<Iterator>;\n+\n+#ifdef CATCH_USE_ASYNC\n+                auto Estimate = [=](double(*f)(Iterator, Iterator)) {\n+                    auto seed = entropy();\n+                    return std::async(std::launch::async, [=] {\n+                        std::mt19937 rng(seed);\n+                        auto resampled = resample(rng, n_resamples, first, last, f);\n+                        return bootstrap(confidence_level, first, last, resampled, f);\n+                    });\n+                };\n+\n+                auto mean_future = Estimate(mean);\n+                auto stddev_future = Estimate(stddev);\n+\n+                auto mean_estimate = mean_future.get();\n+                auto stddev_estimate = stddev_future.get();\n+#else\n+                auto Estimate = [=](double(*f)(Iterator, Iterator)) {\n+                    auto seed = entropy();\n+                    std::mt19937 rng(seed);\n+                    auto resampled = resample(rng, n_resamples, first, last, f);\n+                    return bootstrap(confidence_level, first, last, resampled, f);\n+                };\n+\n+                auto mean_estimate = Estimate(mean);\n+                auto stddev_estimate = Estimate(stddev);\n+#endif // CATCH_USE_ASYNC\n+\n+                double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);\n+\n+                return { mean_estimate, stddev_estimate, outlier_variance };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_timing.hpp b/include/internal/benchmark/detail/catch_timing.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_timing.hpp\n@@ -0,0 +1,33 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Timing\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+\n+#include <tuple>\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration, typename Result>\n+        struct Timing {\n+            Duration elapsed;\n+            Result result;\n+            int iterations;\n+        };\n+        template <typename Clock, typename Sig>\n+        using TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType_t<Detail::ResultOf_t<Sig>>>;\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\ndiff --git a/include/internal/catch_benchmark.cpp b/include/internal/catch_benchmark.cpp\ndeleted file mode 100644\n--- a/include/internal/catch_benchmark.cpp\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-/*\n- *  Created by Phil on 04/07/2017.\n- *  Copyright 2017 Two Blue Cubes Ltd. All rights reserved.\n- *\n- *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n- *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n- */\n-\n-#include \"catch_benchmark.h\"\n-#include \"catch_capture.hpp\"\n-#include \"catch_interfaces_reporter.h\"\n-#include \"catch_context.h\"\n-\n-namespace Catch {\n-\n-    auto BenchmarkLooper::getResolution() -> uint64_t {\n-        return getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();\n-    }\n-\n-    void BenchmarkLooper::reportStart() {\n-        getResultCapture().benchmarkStarting( { m_name } );\n-    }\n-    auto BenchmarkLooper::needsMoreIterations() -> bool {\n-        auto elapsed = m_timer.getElapsedNanoseconds();\n-\n-        // Exponentially increasing iterations until we're confident in our timer resolution\n-        if( elapsed < m_resolution ) {\n-            m_iterationsToRun *= 10;\n-            return true;\n-        }\n-\n-        getResultCapture().benchmarkEnded( { { m_name }, m_count, elapsed } );\n-        return false;\n-    }\n-\n-} // end namespace Catch\ndiff --git a/include/internal/catch_benchmark.h b/include/internal/catch_benchmark.h\ndeleted file mode 100644\n--- a/include/internal/catch_benchmark.h\n+++ /dev/null\n@@ -1,57 +0,0 @@\n-/*\n- *  Created by Phil on 04/07/2017.\n- *  Copyright 2017 Two Blue Cubes Ltd. All rights reserved.\n- *\n- *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n- *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n- */\n-#ifndef TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\n-#define TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\n-\n-#include \"catch_stringref.h\"\n-#include \"catch_timer.h\"\n-\n-#include <cstdint>\n-#include <string>\n-\n-namespace Catch {\n-\n-    class BenchmarkLooper {\n-\n-        std::string m_name;\n-        std::size_t m_count = 0;\n-        std::size_t m_iterationsToRun = 1;\n-        uint64_t m_resolution;\n-        Timer m_timer;\n-\n-        static auto getResolution() -> uint64_t;\n-    public:\n-        // Keep most of this inline as it's on the code path that is being timed\n-        BenchmarkLooper( StringRef name )\n-        :   m_name( name ),\n-            m_resolution( getResolution() )\n-        {\n-            reportStart();\n-            m_timer.start();\n-        }\n-\n-        explicit operator bool() {\n-            if( m_count < m_iterationsToRun )\n-                return true;\n-            return needsMoreIterations();\n-        }\n-\n-        void increment() {\n-            ++m_count;\n-        }\n-\n-        void reportStart();\n-        auto needsMoreIterations() -> bool;\n-    };\n-\n-} // end namespace Catch\n-\n-#define BENCHMARK( name ) \\\n-    for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )\n-\n-#endif // TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\ndiff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -196,11 +196,19 @@ namespace Catch {\n             | Opt( setWaitForKeypress, \"start|exit|both\" )\n                 [\"--wait-for-keypress\"]\n                 ( \"waits for a keypress before exiting\" )\n-            | Opt( config.benchmarkResolutionMultiple, \"multiplier\" )\n-                [\"--benchmark-resolution-multiple\"]\n-                ( \"multiple of clock resolution to run benchmarks\" )\n-\n-            | Arg( config.testsOrTags, \"test name|pattern|tags\" )\n+            | Opt( config.benchmarkSamples, \"samples\" )\n+                [\"--benchmark-samples\"]\n+                ( \"number of samples to collect (default: 100)\" )\n+            | Opt( config.benchmarkResamples, \"resamples\" )\n+                [\"--benchmark-resamples\"]\n+                ( \"number of resamples for the bootstrap (default: 100000)\" )\n+            | Opt( config.benchmarkConfidenceInterval, \"confidence interval\" )\n+                [\"--benchmark-confidence-interval\"]\n+                ( \"confidence interval for the bootstrap (between 0 and 1, default: 0.95)\" )\n+            | Opt( config.benchmarkNoAnalysis )\n+                [\"--benchmark-no-analysis\"]\n+                ( \"perform only measurements; do not perform any analysis\" )\n+\t\t\t| Arg( config.testsOrTags, \"test name|pattern|tags\" )\n                 ( \"which test or tests to use\" );\n \n         return cli;\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -118,9 +118,9 @@\n // some versions of cygwin (most) do not support std::to_string. Use the libstd check. \n // https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813\n # if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \\\n-\t       && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\n+           && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\n \n-#\tdefine CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING\n+#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING\n \n # endif\n #endif // __CYGWIN__\n@@ -148,7 +148,11 @@\n #  if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)\n #    define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #  endif\n+#endif // _MSC_VER\n \n+#if defined(_REENTRANT) || defined(_MSC_VER)\n+// Enable async processing, as -pthread is specified or no additional linking is required\n+# define CATCH_USE_ASYNC\n #endif // _MSC_VER\n \n ////////////////////////////////////////////////////////////////////////////////\ndiff --git a/include/internal/catch_config.cpp b/include/internal/catch_config.cpp\n--- a/include/internal/catch_config.cpp\n+++ b/include/internal/catch_config.cpp\n@@ -32,7 +32,7 @@ namespace Catch {\n     bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }\n     bool Config::listTags() const           { return m_data.listTags; }\n     bool Config::listReporters() const      { return m_data.listReporters; }\n-\n+\t\n     std::string Config::getProcessName() const { return m_data.processName; }\n     std::string const& Config::getReporterName() const { return m_data.reporterName; }\n \n@@ -54,13 +54,17 @@ namespace Catch {\n     ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }\n     RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }\n     unsigned int Config::rngSeed() const               { return m_data.rngSeed; }\n-    int Config::benchmarkResolutionMultiple() const    { return m_data.benchmarkResolutionMultiple; }\n     UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }\n     bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }\n     int Config::abortAfter() const                     { return m_data.abortAfter; }\n     bool Config::showInvisibles() const                { return m_data.showInvisibles; }\n     Verbosity Config::verbosity() const                { return m_data.verbosity; }\n \n+    bool Config::benchmarkNoAnalysis() const           { return m_data.benchmarkNoAnalysis; }\n+    int Config::benchmarkSamples() const               { return m_data.benchmarkSamples; }\n+    double Config::benchmarkConfidenceInterval() const { return m_data.benchmarkConfidenceInterval; }\n+    unsigned int Config::benchmarkResamples() const    { return m_data.benchmarkResamples; }\n+\n     IStream const* Config::openStream() {\n         return Catch::makeStream(m_data.outputFilename);\n     }\ndiff --git a/include/internal/catch_config.hpp b/include/internal/catch_config.hpp\n--- a/include/internal/catch_config.hpp\n+++ b/include/internal/catch_config.hpp\n@@ -42,7 +42,11 @@ namespace Catch {\n \n         int abortAfter = -1;\n         unsigned int rngSeed = 0;\n-        int benchmarkResolutionMultiple = 100;\n+\n+        bool benchmarkNoAnalysis = false;\n+        unsigned int benchmarkSamples = 100;\n+        double benchmarkConfidenceInterval = 0.95;\n+        unsigned int benchmarkResamples = 100000;\n \n         Verbosity verbosity = Verbosity::Normal;\n         WarnAbout::What warnings = WarnAbout::Nothing;\n@@ -100,12 +104,15 @@ namespace Catch {\n         ShowDurations::OrNot showDurations() const override;\n         RunTests::InWhatOrder runOrder() const override;\n         unsigned int rngSeed() const override;\n-        int benchmarkResolutionMultiple() const override;\n         UseColour::YesOrNo useColour() const override;\n         bool shouldDebugBreak() const override;\n         int abortAfter() const override;\n         bool showInvisibles() const override;\n         Verbosity verbosity() const override;\n+        bool benchmarkNoAnalysis() const override;\n+        int benchmarkSamples() const override;\n+        double benchmarkConfidenceInterval() const override;\n+        unsigned int benchmarkResamples() const override;\n \n     private:\n \ndiff --git a/include/internal/catch_interfaces_capture.h b/include/internal/catch_interfaces_capture.h\n--- a/include/internal/catch_interfaces_capture.h\n+++ b/include/internal/catch_interfaces_capture.h\n@@ -9,6 +9,7 @@\n #define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED\n \n #include <string>\n+#include <chrono>\n \n #include \"catch_stringref.h\"\n #include \"catch_result_type.h\"\n@@ -22,14 +23,18 @@ namespace Catch {\n     struct MessageInfo;\n     struct MessageBuilder;\n     struct Counts;\n-    struct BenchmarkInfo;\n-    struct BenchmarkStats;\n     struct AssertionReaction;\n     struct SourceLineInfo;\n \n     struct ITransientExpression;\n     struct IGeneratorTracker;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    struct BenchmarkInfo;\n+    template <typename Duration = std::chrono::duration<double, std::nano>>\n+    struct BenchmarkStats;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     struct IResultCapture {\n \n         virtual ~IResultCapture();\n@@ -41,8 +46,12 @@ namespace Catch {\n \n         virtual auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        virtual void benchmarkPreparing( std::string const& name ) = 0;\n         virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;\n-        virtual void benchmarkEnded( BenchmarkStats const& stats ) = 0;\n+        virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;\n+        virtual void benchmarkFailed( std::string const& error ) = 0;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         virtual void pushScopedMessage( MessageInfo const& message ) = 0;\n         virtual void popScopedMessage( MessageInfo const& message ) = 0;\ndiff --git a/include/internal/catch_interfaces_config.h b/include/internal/catch_interfaces_config.h\n--- a/include/internal/catch_interfaces_config.h\n+++ b/include/internal/catch_interfaces_config.h\n@@ -9,6 +9,7 @@\n #define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED\n \n #include \"catch_common.h\"\n+#include \"catch_option.hpp\"\n \n #include <iosfwd>\n #include <string>\n@@ -50,7 +51,7 @@ namespace Catch {\n         BeforeExit = 2,\n         BeforeStartAndExit = BeforeStart | BeforeExit\n     }; };\n-\n+    \n     class TestSpec;\n \n     struct IConfig : NonCopyable {\n@@ -72,10 +73,14 @@ namespace Catch {\n         virtual std::vector<std::string> const& getTestsOrTags() const = 0;\n         virtual RunTests::InWhatOrder runOrder() const = 0;\n         virtual unsigned int rngSeed() const = 0;\n-        virtual int benchmarkResolutionMultiple() const = 0;\n         virtual UseColour::YesOrNo useColour() const = 0;\n         virtual std::vector<std::string> const& getSectionsToRun() const = 0;\n         virtual Verbosity verbosity() const = 0;\n+\n+        virtual bool benchmarkNoAnalysis() const = 0;\n+        virtual int benchmarkSamples() const = 0;\n+        virtual double benchmarkConfidenceInterval() const = 0;\n+        virtual unsigned int benchmarkResamples() const = 0;\n     };\n \n     using IConfigPtr = std::shared_ptr<IConfig const>;\ndiff --git a/include/internal/catch_interfaces_reporter.h b/include/internal/catch_interfaces_reporter.h\n--- a/include/internal/catch_interfaces_reporter.h\n+++ b/include/internal/catch_interfaces_reporter.h\n@@ -18,12 +18,18 @@\n #include \"catch_option.hpp\"\n #include \"catch_stringref.h\"\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#include \"benchmark/catch_estimate.hpp\"\n+#include \"benchmark/catch_outlier_classification.hpp\"\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n \n #include <string>\n #include <iosfwd>\n #include <map>\n #include <set>\n #include <memory>\n+#include <algorithm>\n \n namespace Catch {\n \n@@ -159,14 +165,43 @@ namespace Catch {\n         bool aborting;\n     };\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n     struct BenchmarkInfo {\n         std::string name;\n+        double estimatedDuration;\n+        int iterations;\n+        int samples;\n+        unsigned int resamples;\n+        double clockResolution;\n+        double clockCost;\n     };\n+\n+    template <class Duration>\n     struct BenchmarkStats {\n         BenchmarkInfo info;\n-        std::size_t iterations;\n-        uint64_t elapsedTimeInNanoseconds;\n+\n+        std::vector<Duration> samples;\n+        Benchmark::Estimate<Duration> mean;\n+        Benchmark::Estimate<Duration> standardDeviation;\n+        Benchmark::OutlierClassification outliers;\n+        double outlierVariance;\n+\n+        template <typename Duration2>\n+        operator BenchmarkStats<Duration2>() const {\n+            std::vector<Duration2> samples2;\n+            samples2.reserve(samples.size());\n+            std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });\n+            return {\n+                info,\n+                std::move(samples2),\n+                mean,\n+                standardDeviation,\n+                outliers,\n+                outlierVariance,\n+            };\n+        }\n     };\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n     struct IStreamingReporter {\n         virtual ~IStreamingReporter() = default;\n@@ -185,17 +220,18 @@ namespace Catch {\n         virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;\n         virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;\n \n-        // *** experimental ***\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        virtual void benchmarkPreparing( std::string const& ) {}\n         virtual void benchmarkStarting( BenchmarkInfo const& ) {}\n+        virtual void benchmarkEnded( BenchmarkStats<> const& ) {}\n+        virtual void benchmarkFailed( std::string const& ) {}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;\n \n         // The return value indicates if the messages buffer should be cleared:\n         virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;\n \n-        // *** experimental ***\n-        virtual void benchmarkEnded( BenchmarkStats const& ) {}\n-\n         virtual void sectionEnded( SectionStats const& sectionStats ) = 0;\n         virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;\n         virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -12,8 +12,23 @@\n #include <type_traits>\n \n namespace Catch {\n-    template<typename T>\n-    struct always_false : std::false_type {};\n+template<typename T>\n+struct always_false : std::false_type {};\n+\n+template <typename> struct true_given : std::true_type {};\n+struct is_callable_tester {\n+    template <typename Fun, typename... Args>\n+    true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);\n+    template <typename...>\n+    std::false_type static test(...);\n+};\n+\n+template <typename T>\n+struct is_callable;\n+\n+template <typename Fun, typename... Args>\n+struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};\n+\n } // namespace Catch\n \n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_run_context.cpp b/include/internal/catch_run_context.cpp\n--- a/include/internal/catch_run_context.cpp\n+++ b/include/internal/catch_run_context.cpp\n@@ -230,12 +230,21 @@ namespace Catch {\n \n         m_unfinishedSections.push_back(endInfo);\n     }\n+\t\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void RunContext::benchmarkPreparing(std::string const& name) {\n+\t\tm_reporter->benchmarkPreparing(name);\n+\t}\n     void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {\n         m_reporter->benchmarkStarting( info );\n     }\n-    void RunContext::benchmarkEnded( BenchmarkStats const& stats ) {\n+    void RunContext::benchmarkEnded( BenchmarkStats<> const& stats ) {\n         m_reporter->benchmarkEnded( stats );\n     }\n+\tvoid RunContext::benchmarkFailed(std::string const & error) {\n+\t\tm_reporter->benchmarkFailed(error);\n+\t}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n     void RunContext::pushScopedMessage(MessageInfo const & message) {\n         m_messages.push_back(message);\ndiff --git a/include/internal/catch_run_context.h b/include/internal/catch_run_context.h\n--- a/include/internal/catch_run_context.h\n+++ b/include/internal/catch_run_context.h\n@@ -82,8 +82,12 @@ namespace Catch {\n \n         auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& override;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing( std::string const& name ) override;\n         void benchmarkStarting( BenchmarkInfo const& info ) override;\n-        void benchmarkEnded( BenchmarkStats const& stats ) override;\n+        void benchmarkEnded( BenchmarkStats<> const& stats ) override;\n+        void benchmarkFailed( std::string const& error ) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void pushScopedMessage( MessageInfo const& message ) override;\n         void popScopedMessage( MessageInfo const& message ) override;\ndiff --git a/include/internal/catch_stream.cpp b/include/internal/catch_stream.cpp\n--- a/include/internal/catch_stream.cpp\n+++ b/include/internal/catch_stream.cpp\n@@ -25,7 +25,7 @@ namespace Catch {\n \n     Catch::IStream::~IStream() = default;\n \n-    namespace detail { namespace {\n+    namespace Detail { namespace {\n         template<typename WriterF, std::size_t bufferSize=256>\n         class StreamBufImpl : public std::streambuf {\n             char data[bufferSize];\n@@ -124,15 +124,15 @@ namespace Catch {\n \n     auto makeStream( StringRef const &filename ) -> IStream const* {\n         if( filename.empty() )\n-            return new detail::CoutStream();\n+            return new Detail::CoutStream();\n         else if( filename[0] == '%' ) {\n             if( filename == \"%debug\" )\n-                return new detail::DebugOutStream();\n+                return new Detail::DebugOutStream();\n             else\n                 CATCH_ERROR( \"Unrecognised stream: '\" << filename << \"'\" );\n         }\n         else\n-            return new detail::FileStream( filename );\n+            return new Detail::FileStream( filename );\n     }\n \n \ndiff --git a/include/reporters/catch_reporter_console.cpp b/include/reporters/catch_reporter_console.cpp\n--- a/include/reporters/catch_reporter_console.cpp\n+++ b/include/reporters/catch_reporter_console.cpp\n@@ -20,10 +20,16 @@\n #if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch\n- // Note that 4062 (not all labels are handled\n- // and default is missing) is enabled\n+ // Note that 4062 (not all labels are handled and default is missing) is enabled\n #endif\n \n+#if defined(__clang__)\n+#  pragma clang diagnostic push\n+// For simplicity, benchmarking-only helpers are always enabled\n+#  pragma clang diagnostic ignored \"-Wunused-function\"\n+#endif\n+\n+\n \n namespace Catch {\n \n@@ -208,6 +214,10 @@ class Duration {\n     Unit m_units;\n \n public:\n+\texplicit Duration(double inNanoseconds, Unit units = Unit::Auto)\n+        : Duration(static_cast<uint64_t>(inNanoseconds), units) {\n+    }\n+\n     explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\n         : m_inNanoseconds(inNanoseconds),\n         m_units(units) {\n@@ -283,9 +293,15 @@ class TablePrinter {\n         if (!m_isOpen) {\n             m_isOpen = true;\n             *this << RowBreak();\n-            for (auto const& info : m_columnInfos)\n-                *this << info.name << ColumnBreak();\n-            *this << RowBreak();\n+\n+\t\t\tColumns headerCols;\n+\t\t\tSpacer spacer(2);\n+\t\t\tfor (auto const& info : m_columnInfos) {\n+\t\t\t\theaderCols += Column(info.name).width(static_cast<std::size_t>(info.width - 2));\n+\t\t\t\theaderCols += spacer;\n+\t\t\t}\n+\t\t\tm_os << headerCols << \"\\n\";\n+\n             m_os << Catch::getLineOfChars<'-'>() << \"\\n\";\n         }\n     }\n@@ -340,9 +356,9 @@ ConsoleReporter::ConsoleReporter(ReporterConfig const& config)\n     m_tablePrinter(new TablePrinter(config.stream(),\n     {\n         { \"benchmark name\", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },\n-        { \"iters\", 8, ColumnInfo::Right },\n-        { \"elapsed ns\", 14, ColumnInfo::Right },\n-        { \"average\", 14, ColumnInfo::Right }\n+        { \"samples      mean       std dev\", 14, ColumnInfo::Right },\n+        { \"iterations   low mean   low std dev\", 14, ColumnInfo::Right },\n+        { \"estimated    high mean  high std dev\", 14, ColumnInfo::Right }\n     })) {}\n ConsoleReporter::~ConsoleReporter() = default;\n \n@@ -374,6 +390,7 @@ bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n }\n \n void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {\n+    m_tablePrinter->close();\n     m_headerPrinted = false;\n     StreamingReporterBase::sectionStarting(_sectionInfo);\n }\n@@ -397,29 +414,45 @@ void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {\n     StreamingReporterBase::sectionEnded(_sectionStats);\n }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+void ConsoleReporter::benchmarkPreparing(std::string const& name) {\n+\tlazyPrintWithoutClosingBenchmarkTable();\n \n-void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n-    lazyPrintWithoutClosingBenchmarkTable();\n+\tauto nameCol = Column(name).width(static_cast<std::size_t>(m_tablePrinter->columnInfos()[0].width - 2));\n \n-    auto nameCol = Column( info.name ).width( static_cast<std::size_t>( m_tablePrinter->columnInfos()[0].width - 2 ) );\n+\tbool firstLine = true;\n+\tfor (auto line : nameCol) {\n+\t\tif (!firstLine)\n+\t\t\t(*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n+\t\telse\n+\t\t\tfirstLine = false;\n \n-    bool firstLine = true;\n-    for (auto line : nameCol) {\n-        if (!firstLine)\n-            (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n-        else\n-            firstLine = false;\n+\t\t(*m_tablePrinter) << line << ColumnBreak();\n+\t}\n+}\n \n-        (*m_tablePrinter) << line << ColumnBreak();\n-    }\n+void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n+\t(*m_tablePrinter) << info.samples << ColumnBreak()\n+\t\t<< info.iterations << ColumnBreak()\n+\t\t<< Duration(info.estimatedDuration) << ColumnBreak();\n }\n-void ConsoleReporter::benchmarkEnded(BenchmarkStats const& stats) {\n-    Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);\n+void ConsoleReporter::benchmarkEnded(BenchmarkStats<> const& stats) {\n+\t(*m_tablePrinter) << ColumnBreak()\n+\t\t<< Duration(stats.mean.point.count()) << ColumnBreak()\n+\t\t<< Duration(stats.mean.lower_bound.count()) << ColumnBreak()\n+\t\t<< Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.point.count()) << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();\n+}\n+\n+void ConsoleReporter::benchmarkFailed(std::string const& error) {\n+\tColour colour(Colour::Red);\n     (*m_tablePrinter)\n-        << stats.iterations << ColumnBreak()\n-        << stats.elapsedTimeInNanoseconds << ColumnBreak()\n-        << average << ColumnBreak();\n+        << \"Benchmark failed (\" << error << \")\"\n+        << ColumnBreak() << RowBreak();\n }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n     m_tablePrinter->close();\n@@ -638,3 +671,7 @@ CATCH_REGISTER_REPORTER(\"console\", ConsoleReporter)\n #if defined(_MSC_VER)\n #pragma warning(pop)\n #endif\n+\n+#if defined(__clang__)\n+#  pragma clang diagnostic pop\n+#endif\ndiff --git a/include/reporters/catch_reporter_console.h b/include/reporters/catch_reporter_console.h\n--- a/include/reporters/catch_reporter_console.h\n+++ b/include/reporters/catch_reporter_console.h\n@@ -39,9 +39,12 @@ namespace Catch {\n         void sectionStarting(SectionInfo const& _sectionInfo) override;\n         void sectionEnded(SectionStats const& _sectionStats) override;\n \n-\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing(std::string const& name) override;\n         void benchmarkStarting(BenchmarkInfo const& info) override;\n-        void benchmarkEnded(BenchmarkStats const& stats) override;\n+        void benchmarkEnded(BenchmarkStats<> const& stats) override;\n+        void benchmarkFailed(std::string const& error) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void testCaseEnded(TestCaseStats const& _testCaseStats) override;\n         void testGroupEnded(TestGroupStats const& _testGroupStats) override;\ndiff --git a/include/reporters/catch_reporter_listening.cpp b/include/reporters/catch_reporter_listening.cpp\n--- a/include/reporters/catch_reporter_listening.cpp\n+++ b/include/reporters/catch_reporter_listening.cpp\n@@ -42,19 +42,34 @@ namespace Catch {\n         m_reporter->noMatchingTestCases( spec );\n     }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void ListeningReporter::benchmarkPreparing( std::string const& name ) {\n+\t\tfor (auto const& listener : m_listeners) {\n+\t\t\tlistener->benchmarkPreparing(name);\n+\t\t}\n+\t\tm_reporter->benchmarkPreparing(name);\n+\t}\n     void ListeningReporter::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->benchmarkStarting( benchmarkInfo );\n         }\n         m_reporter->benchmarkStarting( benchmarkInfo );\n     }\n-    void ListeningReporter::benchmarkEnded( BenchmarkStats const& benchmarkStats ) {\n+    void ListeningReporter::benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->benchmarkEnded( benchmarkStats );\n         }\n         m_reporter->benchmarkEnded( benchmarkStats );\n     }\n \n+\tvoid ListeningReporter::benchmarkFailed( std::string const& error ) {\n+\t\tfor (auto const& listener : m_listeners) {\n+\t\t\tlistener->benchmarkFailed(error);\n+\t\t}\n+\t\tm_reporter->benchmarkFailed(error);\n+\t}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     void ListeningReporter::testRunStarting( TestRunInfo const& testRunInfo ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->testRunStarting( testRunInfo );\ndiff --git a/include/reporters/catch_reporter_listening.h b/include/reporters/catch_reporter_listening.h\n--- a/include/reporters/catch_reporter_listening.h\n+++ b/include/reporters/catch_reporter_listening.h\n@@ -31,8 +31,12 @@ namespace Catch {\n \n         static std::set<Verbosity> getSupportedVerbosities();\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing(std::string const& name) override;\n         void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;\n-        void benchmarkEnded( BenchmarkStats const& benchmarkStats ) override;\n+        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;\n+        void benchmarkFailed(std::string const&) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void testRunStarting( TestRunInfo const& testRunInfo ) override;\n         void testGroupStarting( GroupInfo const& groupInfo ) override;\ndiff --git a/include/reporters/catch_reporter_xml.cpp b/include/reporters/catch_reporter_xml.cpp\n--- a/include/reporters/catch_reporter_xml.cpp\n+++ b/include/reporters/catch_reporter_xml.cpp\n@@ -219,6 +219,48 @@ namespace Catch {\n         m_xml.endElement();\n     }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void XmlReporter::benchmarkStarting(BenchmarkInfo const &info) {\n+        m_xml.startElement(\"BenchmarkResults\")\n+            .writeAttribute(\"name\", info.name)\n+            .writeAttribute(\"samples\", info.samples)\n+            .writeAttribute(\"resamples\", info.resamples)\n+            .writeAttribute(\"iterations\", info.iterations)\n+            .writeAttribute(\"clockResolution\", static_cast<uint64_t>(info.clockResolution))\n+            .writeAttribute(\"estimatedDuration\", static_cast<uint64_t>(info.estimatedDuration))\n+            .writeComment(\"All values in nano seconds\");\n+    }\n+\n+    void XmlReporter::benchmarkEnded(BenchmarkStats<> const& benchmarkStats) {\n+        m_xml.startElement(\"mean\")\n+            .writeAttribute(\"value\", static_cast<uint64_t>(benchmarkStats.mean.point.count()))\n+            .writeAttribute(\"lowerBound\", static_cast<uint64_t>(benchmarkStats.mean.lower_bound.count()))\n+            .writeAttribute(\"upperBound\", static_cast<uint64_t>(benchmarkStats.mean.upper_bound.count()))\n+            .writeAttribute(\"ci\", benchmarkStats.mean.confidence_interval);\n+        m_xml.endElement();\n+        m_xml.startElement(\"standardDeviation\")\n+            .writeAttribute(\"value\", benchmarkStats.standardDeviation.point.count())\n+            .writeAttribute(\"lowerBound\", benchmarkStats.standardDeviation.lower_bound.count())\n+            .writeAttribute(\"upperBound\", benchmarkStats.standardDeviation.upper_bound.count())\n+            .writeAttribute(\"ci\", benchmarkStats.standardDeviation.confidence_interval);\n+        m_xml.endElement();\n+        m_xml.startElement(\"outliers\")\n+            .writeAttribute(\"variance\", benchmarkStats.outlierVariance)\n+            .writeAttribute(\"lowMild\", benchmarkStats.outliers.low_mild)\n+            .writeAttribute(\"lowSevere\", benchmarkStats.outliers.low_severe)\n+            .writeAttribute(\"highMild\", benchmarkStats.outliers.high_mild)\n+            .writeAttribute(\"highSevere\", benchmarkStats.outliers.high_severe);\n+        m_xml.endElement();\n+        m_xml.endElement();\n+    }\n+\n+    void XmlReporter::benchmarkFailed(std::string const &error) {\n+        m_xml.scopedElement(\"failed\").\n+            writeAttribute(\"message\", error);\n+        m_xml.endElement();\n+    }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     CATCH_REGISTER_REPORTER( \"xml\", XmlReporter )\n \n } // end namespace Catch\ndiff --git a/include/reporters/catch_reporter_xml.h b/include/reporters/catch_reporter_xml.h\n--- a/include/reporters/catch_reporter_xml.h\n+++ b/include/reporters/catch_reporter_xml.h\n@@ -50,6 +50,12 @@ namespace Catch {\n \n         void testRunEnded(TestRunStats const& testRunStats) override;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkStarting(BenchmarkInfo const&) override;\n+        void benchmarkEnded(BenchmarkStats<> const&) override;\n+        void benchmarkFailed(std::string const&) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     private:\n         Timer m_testCaseTimer;\n         XmlWriter m_xml;\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -18,6 +18,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/TestMain.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLine.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/InternalBenchmark.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/PartTracker.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/String.tests.cpp\n@@ -79,6 +80,28 @@ CheckFileList(EXTERNAL_HEADERS ${HEADER_DIR}/external)\n \n \n # Please keep these ordered alphabetically\n+set(BENCHMARK_HEADERS\n+\t\t${HEADER_DIR}/internal/benchmark/catch_benchmark.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_chronometer.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_clock.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_constructor.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_environment.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_estimate.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_execution_plan.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_optimizer.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_outlier_classification.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_sample_analysis.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_analyse.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_benchmark_function.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_complete_invoke.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_estimate_clock.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_measure.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_repeat.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_run_for_at_least.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_stats.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_timing.hpp\n+)\n+SOURCE_GROUP(\"benchmark\" FILES ${BENCHMARK_HEADERS})\n set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_approx.h\n         ${HEADER_DIR}/internal/catch_assertionhandler.h\n@@ -138,7 +161,6 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_reporter_registry.h\n         ${HEADER_DIR}/internal/catch_result_type.h\n         ${HEADER_DIR}/internal/catch_run_context.h\n-        ${HEADER_DIR}/internal/catch_benchmark.h\n         ${HEADER_DIR}/internal/catch_section.h\n         ${HEADER_DIR}/internal/catch_section_info.h\n         ${HEADER_DIR}/internal/catch_session.h\n@@ -174,7 +196,6 @@ set(IMPL_SOURCES\n         ${HEADER_DIR}/internal/catch_approx.cpp\n         ${HEADER_DIR}/internal/catch_assertionhandler.cpp\n         ${HEADER_DIR}/internal/catch_assertionresult.cpp\n-        ${HEADER_DIR}/internal/catch_benchmark.cpp\n         ${HEADER_DIR}/internal/catch_capture_matchers.cpp\n         ${HEADER_DIR}/internal/catch_commandline.cpp\n         ${HEADER_DIR}/internal/catch_common.cpp\n@@ -269,6 +290,7 @@ set(HEADERS\n         ${EXTERNAL_HEADERS}\n         ${INTERNAL_HEADERS}\n         ${REPORTER_HEADERS}\n+\t\t${BENCHMARK_HEADERS}\n         )\n \n # Provide some groupings for IDEs\ndiff --git a/projects/ExtraTests/CMakeLists.txt b/projects/ExtraTests/CMakeLists.txt\n--- a/projects/ExtraTests/CMakeLists.txt\n+++ b/projects/ExtraTests/CMakeLists.txt\n@@ -116,6 +116,17 @@ set_tests_properties(\n )\n \n \n+add_executable(BenchmarkingMacros ${TESTS_DIR}/X20-BenchmarkingMacros.cpp)\n+target_compile_definitions( BenchmarkingMacros PRIVATE CATCH_CONFIG_ENABLE_BENCHMARKING )\n+\n+add_test(NAME BenchmarkingMacros COMMAND BenchmarkingMacros -r console -s)\n+set_tests_properties(\n+    BenchmarkingMacros\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"benchmark name                                  samples       iterations    estimated\"\n+)\n+\n+\n set( EXTRA_TEST_BINARIES\n     PrefixedMacros\n     DisabledMacros\n@@ -123,6 +134,7 @@ set( EXTRA_TEST_BINARIES\n     DisabledExceptions-CustomHandler\n     FallbackStringifier\n     DisableStringification\n+    BenchmarkingMacros\n )\n \n # Shared config\ndiff --git a/projects/ExtraTests/X20-BenchmarkingMacros.cpp b/projects/ExtraTests/X20-BenchmarkingMacros.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/projects/ExtraTests/X20-BenchmarkingMacros.cpp\n@@ -0,0 +1,133 @@\n+// X20-BenchmarkingMacros.cpp\n+// Test that the benchmarking support macros compile properly with the single header\n+\n+#define CATCH_CONFIG_MAIN\n+#include <catch2/catch.hpp>\n+\n+namespace {\n+std::uint64_t factorial(std::uint64_t number) {\n+    if (number < 2) {\n+        return 1;\n+    }\n+    return number * factorial(number - 1);\n+}\n+}\n+\n+TEST_CASE(\"Benchmark factorial\", \"[benchmark]\") {\n+    CHECK(factorial(0) == 1);\n+    // some more asserts..\n+    CHECK(factorial(10) == 3628800);\n+\n+    BENCHMARK(\"factorial 10\") {\n+        return factorial(10);\n+    };\n+\n+    CHECK(factorial(14) == 87178291200ull);\n+    BENCHMARK(\"factorial 14\") {\n+        return factorial(14);\n+    };\n+//\n+//    BENCHMARK(\"factorial 20\") {\n+//        return factorial(20);\n+//    };\n+//\n+//    BENCHMARK(\"factorial 35\") {\n+//        return factorial(35);\n+//    };\n+}\n+\n+TEST_CASE(\"Benchmark containers\", \"[.][benchmark]\") {\n+    static const int size = 100;\n+\n+    std::vector<int> v;\n+    std::map<int, int> m;\n+\n+    SECTION(\"without generator\") {\n+        BENCHMARK(\"Load up a vector\") {\n+            v = std::vector<int>();\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        // test optimizer control\n+        BENCHMARK(\"Add up a vector's content\") {\n+            uint64_t add = 0;\n+            for (int i = 0; i < size; ++i)\n+                add += v[i];\n+            return add;\n+        };\n+\n+        BENCHMARK(\"Load up a map\") {\n+            m = std::map<int, int>();\n+            for (int i = 0; i < size; ++i)\n+                m.insert({ i, i + 1 });\n+        };\n+        REQUIRE(m.size() == size);\n+\n+        BENCHMARK(\"Reserved vector\") {\n+            v = std::vector<int>();\n+            v.reserve(size);\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        BENCHMARK(\"Resized vector\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = i;\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        int array[size];\n+        BENCHMARK(\"A fixed size array that should require no allocations\") {\n+            for (int i = 0; i < size; ++i)\n+                array[i] = i;\n+        };\n+        int sum = 0;\n+        for (int i = 0; i < size; ++i)\n+            sum += array[i];\n+        REQUIRE(sum > size);\n+\n+        SECTION(\"XYZ\") {\n+\n+            BENCHMARK_ADVANCED(\"Load up vector with chronometer\")(Catch::Benchmark::Chronometer meter) {\n+                std::vector<int> k;\n+                meter.measure([&](int idx) {\n+                    k = std::vector<int>();\n+                    for (int i = 0; i < size; ++i)\n+                        k.push_back(idx);\n+                });\n+                REQUIRE(k.size() == size);\n+            };\n+\n+            int runs = 0;\n+            BENCHMARK(\"Fill vector indexed\", benchmarkIndex) {\n+                v = std::vector<int>();\n+                v.resize(size);\n+                for (int i = 0; i < size; ++i)\n+                    v[i] = benchmarkIndex;\n+                runs = benchmarkIndex;\n+            };\n+\n+            for (size_t i = 0; i < v.size(); ++i) {\n+                REQUIRE(v[i] == runs);\n+            }\n+        }\n+    }\n+\n+    SECTION(\"with generator\") {\n+        auto generated = GENERATE(range(0, 10));\n+        BENCHMARK(\"Fill vector generated\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = generated;\n+        };\n+        for (size_t i = 0; i < v.size(); ++i) {\n+            REQUIRE(v[i] == generated);\n+        }\n+    }\n+}\n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n@@ -462,4 +462,30 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n #endif\n         }\n     }\n+\n+    SECTION(\"Benchmark options\") {\n+        SECTION(\"samples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-samples=200\" }));\n+\n+            REQUIRE(config.benchmarkSamples == 200);\n+        }\n+        \n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-resamples=20000\" }));\n+\n+            REQUIRE(config.benchmarkResamples == 20000);\n+        }\n+\n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-confidence-interval=0.99\" }));\n+\n+            REQUIRE(config.benchmarkConfidenceInterval == Catch::Detail::Approx(0.99));\n+        }\n+\n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-no-analysis\" }));\n+\n+            REQUIRE(config.benchmarkNoAnalysis);\n+        }\n+    }\n }\ndiff --git a/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp b/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp\n@@ -0,0 +1,405 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#include \"catch.hpp\"\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+namespace {\n+    struct manual_clock {\n+    public:\n+        using duration = std::chrono::nanoseconds;\n+        using time_point = std::chrono::time_point<manual_clock, duration>;\n+        using rep = duration::rep;\n+        using period = duration::period;\n+        enum { is_steady = true };\n+\n+        static time_point now() {\n+            return time_point(duration(tick()));\n+        }\n+\n+        static void advance(int ticks = 1) {\n+            tick() += ticks;\n+        }\n+\n+    private:\n+        static rep& tick() {\n+            static rep the_tick = 0;\n+            return the_tick;\n+        }\n+    };\n+\n+    struct counting_clock {\n+    public:\n+        using duration = std::chrono::nanoseconds;\n+        using time_point = std::chrono::time_point<counting_clock, duration>;\n+        using rep = duration::rep;\n+        using period = duration::period;\n+        enum { is_steady = true };\n+\n+        static time_point now() {\n+            static rep ticks = 0;\n+            return time_point(duration(ticks += rate()));\n+        }\n+\n+        static void set_rate(rep new_rate) { rate() = new_rate; }\n+\n+    private:\n+        static rep& rate() {\n+            static rep the_rate = 1;\n+            return the_rate;\n+        }\n+    };\n+\n+    struct TestChronometerModel : Catch::Benchmark::Detail::ChronometerConcept {\n+        int started = 0;\n+        int finished = 0;\n+\n+        void start() override { ++started; }\n+        void finish() override { ++finished; }\n+    };\n+} // namespace\n+\n+TEST_CASE(\"warmup\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    auto start = counting_clock::now();\n+    auto iterations = Catch::Benchmark::Detail::warmup<counting_clock>();\n+    auto end = counting_clock::now();\n+\n+    REQUIRE((iterations * rate) > Catch::Benchmark::Detail::warmup_time.count());\n+    REQUIRE((end - start) > Catch::Benchmark::Detail::warmup_time);\n+}\n+\n+TEST_CASE(\"resolution\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    size_t count = 10;\n+    auto res = Catch::Benchmark::Detail::resolution<counting_clock>(static_cast<int>(count));\n+\n+    REQUIRE(res.size() == count);\n+\n+    for (size_t i = 1; i < count; ++i) {\n+        REQUIRE(res[i] == rate);\n+    }\n+}\n+\n+TEST_CASE(\"estimate_clock_resolution\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    int iters = 160000;\n+    auto res = Catch::Benchmark::Detail::estimate_clock_resolution<counting_clock>(iters);\n+\n+    REQUIRE(res.mean.count() == rate);\n+    REQUIRE(res.outliers.total() == 0);\n+}\n+\n+TEST_CASE(\"benchmark function call\", \"[benchmark]\") {\n+    SECTION(\"without chronometer\") {\n+        auto called = 0;\n+        auto model = TestChronometerModel{};\n+        auto meter = Catch::Benchmark::Chronometer{ model, 1 };\n+        auto fn = Catch::Benchmark::Detail::BenchmarkFunction{ [&] {\n+                CHECK(model.started == 1);\n+                CHECK(model.finished == 0);\n+                ++called;\n+            } };\n+\n+        fn(meter);\n+\n+        CHECK(model.started == 1);\n+        CHECK(model.finished == 1);\n+        CHECK(called == 1);\n+    }\n+\n+    SECTION(\"with chronometer\") {\n+        auto called = 0;\n+        auto model = TestChronometerModel{};\n+        auto meter = Catch::Benchmark::Chronometer{ model, 1 };\n+        auto fn = Catch::Benchmark::Detail::BenchmarkFunction{ [&](Catch::Benchmark::Chronometer) {\n+                CHECK(model.started == 0);\n+                CHECK(model.finished == 0);\n+                ++called;\n+            } };\n+\n+        fn(meter);\n+\n+        CHECK(model.started == 0);\n+        CHECK(model.finished == 0);\n+        CHECK(called == 1);\n+    }\n+}\n+\n+TEST_CASE(\"uniform samples\", \"[benchmark]\") {\n+    std::vector<double> samples(100);\n+    std::fill(samples.begin(), samples.end(), 23);\n+\n+    using it = std::vector<double>::iterator;\n+    auto e = Catch::Benchmark::Detail::bootstrap(0.95, samples.begin(), samples.end(), samples, [](it a, it b) {\n+        auto sum = std::accumulate(a, b, 0.);\n+        return sum / (b - a);\n+    });\n+    CHECK(e.point == 23);\n+    CHECK(e.upper_bound == 23);\n+    CHECK(e.lower_bound == 23);\n+    CHECK(e.confidence_interval == 0.95);\n+}\n+\n+\n+TEST_CASE(\"normal_cdf\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::normal_cdf;\n+    CHECK(normal_cdf(0.000000) == Approx(0.50000000000000000));\n+    CHECK(normal_cdf(1.000000) == Approx(0.84134474606854293));\n+    CHECK(normal_cdf(-1.000000) == Approx(0.15865525393145705));\n+    CHECK(normal_cdf(2.809729) == Approx(0.99752083845315409));\n+    CHECK(normal_cdf(-1.352570) == Approx(0.08809652095066035));\n+}\n+\n+TEST_CASE(\"erfc_inv\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::erfc_inv;\n+    CHECK(erfc_inv(1.103560) == Approx(-0.09203687623843015));\n+    CHECK(erfc_inv(1.067400) == Approx(-0.05980291115763361));\n+    CHECK(erfc_inv(0.050000) == Approx(1.38590382434967796));\n+}\n+\n+TEST_CASE(\"normal_quantile\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::normal_quantile;\n+    CHECK(normal_quantile(0.551780) == Approx(0.13015979861484198));\n+    CHECK(normal_quantile(0.533700) == Approx(0.08457408802851875));\n+    CHECK(normal_quantile(0.025000) == Approx(-1.95996398454005449));\n+}\n+\n+\n+TEST_CASE(\"mean\", \"[benchmark]\") {\n+    std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+    auto m = Catch::Benchmark::Detail::mean(x.begin(), x.end());\n+\n+    REQUIRE(m == 19.);\n+}\n+\n+TEST_CASE(\"weighted_average_quantile\", \"[benchmark]\") {\n+    std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+    auto q1 = Catch::Benchmark::Detail::weighted_average_quantile(1, 4, x.begin(), x.end());\n+    auto med = Catch::Benchmark::Detail::weighted_average_quantile(1, 2, x.begin(), x.end());\n+    auto q3 = Catch::Benchmark::Detail::weighted_average_quantile(3, 4, x.begin(), x.end());\n+\n+    REQUIRE(q1 == 14.5);\n+    REQUIRE(med == 18.);\n+    REQUIRE(q3 == 23.);\n+}\n+\n+TEST_CASE(\"classify_outliers\", \"[benchmark]\") {\n+    auto require_outliers = [](Catch::Benchmark::OutlierClassification o, int los, int lom, int him, int his) {\n+        REQUIRE(o.low_severe == los);\n+        REQUIRE(o.low_mild == lom);\n+        REQUIRE(o.high_mild == him);\n+        REQUIRE(o.high_severe == his);\n+        REQUIRE(o.total() == los + lom + him + his);\n+    };\n+\n+    SECTION(\"none\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 0, 0);\n+    }\n+    SECTION(\"low severe\") {\n+        std::vector<double> x{ -12., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 1, 0, 0, 0);\n+    }\n+    SECTION(\"low mild\") {\n+        std::vector<double> x{ 1., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 1, 0, 0);\n+    }\n+    SECTION(\"high mild\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 36., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 1, 0);\n+    }\n+    SECTION(\"high severe\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 49., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 0, 1);\n+    }\n+    SECTION(\"mixed\") {\n+        std::vector<double> x{ -20., 20., 14., 16., 39., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 1, 0, 1, 0);\n+    }\n+}\n+\n+TEST_CASE(\"analyse\", \"[benchmark]\") {\n+    Catch::ConfigData data{};\n+    data.benchmarkConfidenceInterval = 0.95;\n+    data.benchmarkNoAnalysis = false;\n+    data.benchmarkResamples = 1000;\n+    data.benchmarkSamples = 99;\n+    Catch::Config config{data};\n+\n+    using Duration = Catch::Benchmark::FloatDuration<Catch::Benchmark::default_clock>;\n+\n+    Catch::Benchmark::Environment<Duration> env;\n+    std::vector<Duration> samples(99);\n+    for (size_t i = 0; i < samples.size(); ++i) {\n+        samples[i] = Duration(23 + (i % 3 - 1));\n+    }\n+\n+    auto analysis = Catch::Benchmark::Detail::analyse(config, env, samples.begin(), samples.end());\n+    CHECK(analysis.mean.point.count() == 23);\n+    CHECK(analysis.mean.lower_bound.count() < 23);\n+    CHECK(analysis.mean.lower_bound.count() > 22);\n+    CHECK(analysis.mean.upper_bound.count() > 23);\n+    CHECK(analysis.mean.upper_bound.count() < 24);\n+\n+    CHECK(analysis.standard_deviation.point.count() > 0.5);\n+    CHECK(analysis.standard_deviation.point.count() < 1);\n+    CHECK(analysis.standard_deviation.lower_bound.count() > 0.5);\n+    CHECK(analysis.standard_deviation.lower_bound.count() < 1);\n+    CHECK(analysis.standard_deviation.upper_bound.count() > 0.5);\n+    CHECK(analysis.standard_deviation.upper_bound.count() < 1);\n+\n+    CHECK(analysis.outliers.total() == 0);\n+    CHECK(analysis.outliers.low_mild == 0);\n+    CHECK(analysis.outliers.low_severe == 0);\n+    CHECK(analysis.outliers.high_mild == 0);\n+    CHECK(analysis.outliers.high_severe == 0);\n+    CHECK(analysis.outliers.samples_seen == samples.size());\n+\n+    CHECK(analysis.outlier_variance < 0.5);\n+    CHECK(analysis.outlier_variance > 0);\n+}\n+\n+TEST_CASE(\"analyse no analysis\", \"[benchmark]\") {\n+    Catch::ConfigData data{};\n+    data.benchmarkConfidenceInterval = 0.95;\n+    data.benchmarkNoAnalysis = true;\n+    data.benchmarkResamples = 1000;\n+    data.benchmarkSamples = 99;\n+    Catch::Config config{ data };\n+\n+    using Duration = Catch::Benchmark::FloatDuration<Catch::Benchmark::default_clock>;\n+\n+    Catch::Benchmark::Environment<Duration> env;\n+    std::vector<Duration> samples(99);\n+    for (size_t i = 0; i < samples.size(); ++i) {\n+        samples[i] = Duration(23 + (i % 3 - 1));\n+    }\n+\n+    auto analysis = Catch::Benchmark::Detail::analyse(config, env, samples.begin(), samples.end());\n+    CHECK(analysis.mean.point.count() == 23);\n+    CHECK(analysis.mean.lower_bound.count() == 23);\n+    CHECK(analysis.mean.upper_bound.count() == 23);\n+\n+    CHECK(analysis.standard_deviation.point.count() == 0);\n+    CHECK(analysis.standard_deviation.lower_bound.count() == 0);\n+    CHECK(analysis.standard_deviation.upper_bound.count() == 0);\n+\n+    CHECK(analysis.outliers.total() == 0);\n+    CHECK(analysis.outliers.low_mild == 0);\n+    CHECK(analysis.outliers.low_severe == 0);\n+    CHECK(analysis.outliers.high_mild == 0);\n+    CHECK(analysis.outliers.high_severe == 0);\n+    CHECK(analysis.outliers.samples_seen == 0);\n+\n+    CHECK(analysis.outlier_variance == 0);\n+}\n+\n+TEST_CASE(\"run_for_at_least, int\", \"[benchmark]\") {\n+    manual_clock::duration time(100);\n+\n+    int old_x = 1;\n+    auto Timing = Catch::Benchmark::Detail::run_for_at_least<manual_clock>(time, 1, [&old_x](int x) -> int {\n+        CHECK(x >= old_x);\n+        manual_clock::advance(x);\n+        old_x = x;\n+        return x + 17;\n+    });\n+\n+    REQUIRE(Timing.elapsed >= time);\n+    REQUIRE(Timing.result == Timing.iterations + 17);\n+    REQUIRE(Timing.iterations >= time.count());\n+}\n+\n+TEST_CASE(\"run_for_at_least, chronometer\", \"[benchmark]\") {\n+    manual_clock::duration time(100);\n+\n+    int old_runs = 1;\n+    auto Timing = Catch::Benchmark::Detail::run_for_at_least<manual_clock>(time, 1, [&old_runs](Catch::Benchmark::Chronometer meter) -> int {\n+        CHECK(meter.runs() >= old_runs);\n+        manual_clock::advance(100);\n+        meter.measure([] {\n+            manual_clock::advance(1);\n+        });\n+        old_runs = meter.runs();\n+        return meter.runs() + 17;\n+    });\n+\n+    REQUIRE(Timing.elapsed >= time);\n+    REQUIRE(Timing.result == Timing.iterations + 17);\n+    REQUIRE(Timing.iterations >= time.count());\n+}\n+\n+\n+TEST_CASE(\"measure\", \"[benchmark]\") {\n+    auto r = Catch::Benchmark::Detail::measure<manual_clock>([](int x) -> int {\n+        CHECK(x == 17);\n+        manual_clock::advance(42);\n+        return 23;\n+    }, 17);\n+    auto s = Catch::Benchmark::Detail::measure<manual_clock>([](int x) -> int {\n+        CHECK(x == 23);\n+        manual_clock::advance(69);\n+        return 17;\n+    }, 23);\n+\n+    CHECK(r.elapsed.count() == 42);\n+    CHECK(r.result == 23);\n+    CHECK(r.iterations == 1);\n+\n+    CHECK(s.elapsed.count() == 69);\n+    CHECK(s.result == 17);\n+    CHECK(s.iterations == 1);\n+}\n+\n+TEST_CASE(\"run benchmark\", \"[benchmark]\") {\n+    counting_clock::set_rate(1000);\n+    auto start = counting_clock::now();\n+    \n+    Catch::Benchmark::Benchmark bench{ \"Test Benchmark\", [](Catch::Benchmark::Chronometer meter) {\n+        counting_clock::set_rate(100000);\n+        meter.measure([] { return counting_clock::now(); });\n+    } };\n+\n+    bench.run<counting_clock>();\n+    auto end = counting_clock::now();\n+\n+    CHECK((end - start).count() == 2867251000);\n+}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\ndiff --git a/projects/SelfTest/UsageTests/Benchmark.tests.cpp b/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n--- a/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n@@ -2,42 +2,129 @@\n \n #include <map>\n \n-TEST_CASE( \"benchmarked\", \"[!benchmark]\" ) {\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+namespace {\n+    std::uint64_t Fibonacci(std::uint64_t number) {\n+        return number < 2 ? 1 : Fibonacci(number - 1) + Fibonacci(number - 2);\n+    }\n+}\n+\n+TEST_CASE(\"Benchmark Fibonacci\", \"[!benchmark]\") {\n+    CHECK(Fibonacci(0) == 1);\n+    // some more asserts..\n+    CHECK(Fibonacci(5) == 8);\n+    // some more asserts..\n+\n+    BENCHMARK(\"Fibonacci 20\") {\n+        return Fibonacci(20);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 25\") {\n+        return Fibonacci(25);\n+    };\n \n+    BENCHMARK(\"Fibonacci 30\") {\n+        return Fibonacci(30);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 35\") {\n+        return Fibonacci(35);\n+    };\n+}\n+\n+TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n     static const int size = 100;\n \n     std::vector<int> v;\n     std::map<int, int> m;\n \n-    BENCHMARK( \"Load up a vector\" ) {\n-        v = std::vector<int>();\n-        for(int i =0; i < size; ++i )\n-            v.push_back( i );\n-    }\n-    REQUIRE( v.size() == size );\n+    SECTION(\"without generator\") {\n+        BENCHMARK(\"Load up a vector\") {\n+            v = std::vector<int>();\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n \n-    BENCHMARK( \"Load up a map\" ) {\n-        m = std::map<int, int>();\n-        for(int i =0; i < size; ++i )\n-            m.insert( { i, i+1 } );\n-    }\n-    REQUIRE( m.size() == size );\n+        // test optimizer control\n+        BENCHMARK(\"Add up a vector's content\") {\n+            uint64_t add = 0;\n+            for (int i = 0; i < size; ++i)\n+                add += v[i];\n+            return add;\n+        };\n+\n+        BENCHMARK(\"Load up a map\") {\n+            m = std::map<int, int>();\n+            for (int i = 0; i < size; ++i)\n+                m.insert({ i, i + 1 });\n+        };\n+        REQUIRE(m.size() == size);\n+\n+        BENCHMARK(\"Reserved vector\") {\n+            v = std::vector<int>();\n+            v.reserve(size);\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        BENCHMARK(\"Resized vector\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = i;\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        int array[size];\n+        BENCHMARK(\"A fixed size array that should require no allocations\") {\n+            for (int i = 0; i < size; ++i)\n+                array[i] = i;\n+        };\n+        int sum = 0;\n+        for (int i = 0; i < size; ++i)\n+            sum += array[i];\n+        REQUIRE(sum > size);\n+\n+        SECTION(\"XYZ\") {\n+\n+            BENCHMARK_ADVANCED(\"Load up vector with chronometer\")(Catch::Benchmark::Chronometer meter) {\n+                std::vector<int> k;\n+                meter.measure([&](int idx) {\n+                    k = std::vector<int>();\n+                    for (int i = 0; i < size; ++i)\n+                        k.push_back(idx);\n+                });\n+                REQUIRE(k.size() == size);\n+            };\n+\n+            int runs = 0;\n+            BENCHMARK(\"Fill vector indexed\", benchmarkIndex) {\n+                v = std::vector<int>();\n+                v.resize(size);\n+                for (int i = 0; i < size; ++i)\n+                    v[i] = benchmarkIndex;\n+                runs = benchmarkIndex;\n+            };\n \n-    BENCHMARK( \"Reserved vector\" ) {\n-        v = std::vector<int>();\n-        v.reserve(size);\n-        for(int i =0; i < size; ++i )\n-            v.push_back( i );\n+            for (size_t i = 0; i < v.size(); ++i) {\n+                REQUIRE(v[i] == runs);\n+            }\n+        }\n     }\n-    REQUIRE( v.size() == size );\n \n-    int array[size];\n-    BENCHMARK( \"A fixed size array that should require no allocations\" ) {\n-        for(int i =0; i < size; ++i )\n-            array[i] = i;\n+    SECTION(\"with generator\") {\n+        auto generated = GENERATE(range(0, 10));\n+        BENCHMARK(\"Fill vector generated\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = generated;\n+        };\n+        for (size_t i = 0; i < v.size(); ++i) {\n+            REQUIRE(v[i] == generated);\n+        }\n     }\n-    int sum = 0;\n-    for(int i =0; i < size; ++i )\n-        sum += array[i];\n-    REQUIRE( sum > size );\n }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n", "problem_statement": "Rename #define BENCHMARK or allow disabling benchmark feature\n## Description\r\n\r\nThe `#define BENCHMARK` in https://github.com/catchorg/Catch2/commit/a9b6813ad9e423ddcd6559f52b503a68fe0f624c#diff-c06d59fb4f39c13fb9a355b49d321fcfR52 is an unfortunate name, with high potential of clashes.\r\n\r\nFor example, it clashes with (older) benchmarking framework, see https://github.com/DigitalInBlue/Celero/commit/dc6853478aece4da17e177f285896648b23dc2fd#diff-f1b66ca763828028068774e33319efb4R137 The generic `BENCHMARK` name issue also reported to Celero https://github.com/DigitalInBlue/Celero/issues/114\r\n\r\nIt would be extremely helpful Catch offers a `#define` to allow disabling the whole benchmarking feature all the way.\r\n\r\n\n", "hints_text": "I may be missing something obvious, but is there a good reason why you have both Catch2 and Celero in the same translation unit?\nIt happens, there are/were some files which included both (eg. shared fixtures for both, benchmark and test, so benchmark is actually tested for correctness - in non-optimised builds)", "created_at": "2019-04-27T17:04:30Z"}
{"repo": "catchorg/Catch2", "pull_number": 1614, "instance_id": "catchorg__Catch2-1614", "issue_numbers": ["1612"], "base_commit": "9c741fe96073ed620ffc032afbed1f3c789d2b68", "patch": "diff --git a/include/internal/catch_tostring.cpp b/include/internal/catch_tostring.cpp\n--- a/include/internal/catch_tostring.cpp\n+++ b/include/internal/catch_tostring.cpp\n@@ -234,11 +234,16 @@ std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {\n     return \"nullptr\";\n }\n \n+int StringMaker<float>::precision = 5;\n+   \n std::string StringMaker<float>::convert(float value) {\n-    return fpToString(value, 5) + 'f';\n+    return fpToString(value, precision) + 'f';\n }\n+\n+int StringMaker<double>::precision = 10;\n+    \n std::string StringMaker<double>::convert(double value) {\n-    return fpToString(value, 10);\n+    return fpToString(value, precision);\n }\n \n std::string ratio_string<std::atto>::symbol() { return \"a\"; }\ndiff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -261,10 +261,13 @@ namespace Catch {\n     template<>\n     struct StringMaker<float> {\n         static std::string convert(float value);\n+        static int precision;\n     };\n+\n     template<>\n     struct StringMaker<double> {\n         static std::string convert(double value);\n+        static int precision;\n     };\n \n     template <typename T>\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n@@ -128,6 +128,40 @@ TEST_CASE(\"String views are stringified like other strings\", \"[toString][approva\n \n #endif\n \n+TEST_CASE(\"Precision of floating point stringification can be set\", \"[toString][floatingPoint]\") {\n+    SECTION(\"Floats\") {\n+        using sm = Catch::StringMaker<float>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const float testFloat = 1.12345678901234567899f;\n+        auto str1 = sm::convert(testFloat);\n+        sm::precision = 5;\n+        // \"1.\" prefix = 2 chars, f suffix is another char\n+        CHECK(str1.size() == 3 + 5);\n+\n+        sm::precision = 10;\n+        auto str2 = sm::convert(testFloat);\n+        REQUIRE(str2.size() == 3 + 10);\n+        sm::precision = oldPrecision;\n+    }\n+    SECTION(\"Double\") {\n+        using sm = Catch::StringMaker<double>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const double testDouble = 1.123456789012345678901234567899;\n+        sm::precision = 5;\n+        auto str1 = sm::convert(testDouble);\n+        // \"1.\" prefix = 2 chars\n+        CHECK(str1.size() == 2 + 5);\n+\n+        sm::precision = 15;\n+        auto str2 = sm::convert(testDouble);\n+        REQUIRE(str2.size() == 2 + 15);\n+\n+        sm::precision = oldPrecision;\n+    }\n+}\n+\n namespace {\n \n struct WhatException : std::exception {\n", "problem_statement": "Allow custom precision in error reports for floating-point numbers\n**Description**\r\nAs in [this SO Q&A](https://stackoverflow.com/q/55867570/201787), it would be nice to allow customization of the precision of floating-point values that fail. At present, the precision for float and double are hard-coded within Catch2 to 5 and 10, respectively:\r\n```cpp\r\nstd::string StringMaker<float>::convert(float value) {\r\n    return fpToString(value, 5) + 'f';\r\n}\r\nstd::string StringMaker<double>::convert(double value) {\r\n    return fpToString(value, 10);\r\n}\r\n```\r\nSometimes things will fail (even with `Approx()`), but the precision of the failure message doesn't show enough precision to be meaningful.\r\n```\r\nprog.cc:22: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.0f\r\n```\r\nThe proposal here is to add a `setPrecision()` function to allow the user to control this. I have prototyped this, which you can see running [live on Wandbox](https://wandbox.org/permlink/mZXPLEuET5ZeTg1t). Here's the test:\r\n```cpp\r\nTEMPLATE_TEST_CASE( \"Double, double, toil and trouble\", \"[double]\", float, double ) \r\n{\r\n    const auto precision = GENERATE( -1, 0, 3, std::numeric_limits<TestType>::max_digits10 );\r\n\r\n    if( precision >= 0 )\r\n    {\r\n        Catch::StringMaker<TestType>::setPrecision( precision );\r\n    }\r\n    \r\n    // Expected to fail to demonstrate the problem\r\n    REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() ); \r\n}\r\n```\r\nThe output shows as expected for floats and doubles. For instance:\r\n```\r\nprog.cc:15: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.000000119f\r\n```\r\nMaking a unit test for this is a little iffy since the actual string values are dependent on the usual floating-point fuzziness. I guess it could compare string length without looking too closely at the value.\n", "hints_text": "", "created_at": "2019-04-26T18:37:28Z"}
{"repo": "catchorg/Catch2", "pull_number": 1609, "instance_id": "catchorg__Catch2-1609", "issue_numbers": ["1531"], "base_commit": "bd703dd74be7fd2413eb0c01662a491bcebea430", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -150,14 +150,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -233,14 +241,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -324,15 +340,23 @@ using Catch::Detail::Approx;\n #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -400,15 +424,23 @@ using Catch::Detail::Approx;\n #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -64,6 +64,12 @@\n #       define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS \\\n             _Pragma( \"clang diagnostic pop\" )\n \n+#       define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic push\" ) \\\n+            _Pragma( \"clang diagnostic ignored \\\"-Wgnu-zero-variadic-macro-arguments\\\"\" )\n+#       define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic pop\" )\n+\n #endif // __clang__\n \n \n@@ -274,6 +280,10 @@\n #   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS\n #   define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS\n #endif\n+#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)\n+#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS\n+#   define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\n+#endif\n \n #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)\n #define CATCH_TRY if ((true))\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -12,66 +12,8 @@\n #include <type_traits>\n \n namespace Catch {\n-template< typename... >\n-struct TypeList {};\n-\n-template< typename... >\n-struct append;\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n->\n-struct append< L1<E1...>, L2<E2...> > {\n-    using type = L1<E1..., E2...>;\n-};\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n-    , typename...Rest\n->\n-struct append< L1<E1...>, L2<E2...>, Rest...> {\n-    using type = typename append< L1<E1..., E2...>, Rest... >::type;\n-};\n-\n-template< template<typename...> class\n-    , typename...\n->\n-struct rewrap;\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , typename...elems\n->\n-struct rewrap<Container, List<elems...>> {\n-    using type = TypeList< Container< elems... > >;\n-};\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , class...Elems\n-    , typename...Elements>\n-    struct rewrap<Container, List<Elems...>, Elements...> {\n-    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n-};\n-\n-template< template<typename...> class...Containers >\n-struct combine {\n-    template< typename...Types >\n-    struct with_types {\n-        template< template <typename...> class Final >\n-        struct into {\n-            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n-        };\n-    };\n-};\n-\n-template<typename T>\n-struct always_false : std::false_type {};\n-\n+    template<typename T>\n+    struct always_false : std::false_type {};\n } // namespace Catch\n \n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -68,22 +68,151 @@\n #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)\n #endif\n \n+#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__\n+#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)\n+\n #define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)\n \n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name, __VA_ARGS__)\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" - \" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name,...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n #else\n-// MSVC is adding extra space and needs more calls to properly remove ()\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" -\" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, __VA_ARGS__)\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) Catch::TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)\n+\n+#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)\n+#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)\n+#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)\n+#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)\n+#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)\n+#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)\n+#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _4, _5, _6)\n+#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)\n+#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)\n+#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)\n+#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)\n+\n+#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n+\n+#define INTERNAL_CATCH_TYPE_GEN\\\n+    template<typename...> struct TypeList {};\\\n+    template<typename...Ts>\\\n+    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\\\n+    \\\n+    template<template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2> \\\n+    constexpr auto append(L1<E1...>, L2<E2...>) noexcept -> L1<E1...,E2...> { return {}; }\\\n+    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\\n+    constexpr auto append(L1<E1...>, L2<E2...>, Rest...) noexcept -> decltype(append(L1<E1...,E2...>{}, Rest{}...)) { return {}; }\\\n+    \\\n+    template< template<typename...> class Container, template<typename...> class List, typename...elems>\\\n+    constexpr auto rewrap(List<elems...>) noexcept -> TypeList<Container<elems...>> { return {}; }\\\n+    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\\\n+    constexpr auto rewrap(List<Elems...>,Elements...) noexcept -> decltype(append(TypeList<Container<Elems...>>{}, rewrap<Container>(Elements{}...))) { return {}; }\\\n+    \\\n+    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_NTTP_1(signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \\\n+    \\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>) noexcept -> TypeList<Container<__VA_ARGS__>> { return {}; }\\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>,Elements...elems) noexcept -> decltype(append(TypeList<Container<__VA_ARGS__>>{}, rewrap<Container>(elems...))) { return {}; }\\\n+    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\\\n+    template<typename TestType> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\\\n+    template<typename TestType> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n-    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+#define INTERNAL_CATCH_NTTP_0\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)\n+#else\n+#define INTERNAL_CATCH_NTTP_0(signature)\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))\n+#endif\n \n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -6,6 +6,7 @@\n [Tag aliases](#tag-aliases)<br>\n [BDD-style test cases](#bdd-style-test-cases)<br>\n [Type parametrised test cases](#type-parametrised-test-cases)<br>\n+[Signature based parametrised test cases](#signature-based-parametrised-test-cases)<br>\n \n While Catch fully supports the traditional, xUnit, style of class-based fixtures containing test case methods this is not the preferred style.\n \n@@ -191,6 +192,56 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+\n+## Signature based parametrised test cases\n+\n+In addition to [type parametrised test cases](#type-parametrised-test-cases) Catch2 also supports\n+signature base parametrised test cases, in form of `TEMPLATE_TEST_CASE_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_SIG`.\n+These test cases have similar syntax like [type parametrised test cases](#type-parametrised-test-cases), with one\n+additional positional argument which specifies the signature.\n+\n+### Signature\n+Signature has some strict rules for these tests cases to work properly:\n+* signature with multiple template parameters e.g. `typename T, size_t S` must have this format in test case declaration\n+  `((typename T, size_t S), T, S)`\n+* signature with variadic template arguments e.g. `typename T, size_t S, typename...Ts` must have this format in test case declaration\n+  `((typename T, size_t S, typename...Ts), T, S, Ts...)`\n+* signature with single non type template parameter e.g. `int V` must have this format in test case declaration `((int V), V)`\n+* signature with single type template parameter e.g. `typename T` should not be used as it is in fact `TEMPLATE_TEST_CASE`\n+\n+Currently Catch2 support up to 11 template parameters in signature\n+\n+### Examples\n+\n+* **TEMPLATE_TEST_CASE_SIG(** _test name_ , _tags_,  _signature_, _type1_, _type2_, ..., _typen_ **)**\n+\n+Inside `TEMPLATE_TEST_CASE_SIG` test case you can use the names of template parameters as defined in _signature_. \n+\n+```cpp\n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: arrays can be created from NTTP arguments\", \"[vector][template][nttp]\",\n+  ((typename T, int V), T, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::array<T, V> v;\n+    REQUIRE(v.size() > 1);\n+}\n+```\n+\n+* **TEMPLATE_PRODUCT_TEST_CASE_SIG(** _test name_ , _tags_, _signature_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+```cpp\n+\n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+```\n+\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -84,6 +84,33 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n the limit is very high and should not be encountered in practice._\n \n+\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG` to support\n+fixtures using non-type template parameters. These test cases work similar to `TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+with additional positional argument for [signature](test-cases-and-sections.md#signature-based-parametrised-test-cases).\n+\n+Example:\n+```cpp\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n+\n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -60,18 +60,47 @@ struct AutoReg : NonCopyable {\n             };                            \\\n         }                                 \\\n         void TestName::test()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION( TestName, ... )  \\\n-        template<typename TestType>                                             \\\n-        static void TestName()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... )    \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \\\n         namespace{                                                                                  \\\n-            template<typename TestType>                                                             \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) {     \\\n-                void test();                                                                        \\\n-            };                                                                                      \\\n+            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         }                                                                                           \\\n-        template<typename TestType>                                                                 \\\n-        void TestName::test()\n+        }                                                                                           \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+    #endif  \n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n #endif\n \n     ///////////////////////////////////////////////////////////////////////////////\n@@ -111,46 +140,61 @@ struct AutoReg : NonCopyable {\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n     ///////////////////////////////////////////////////////////////////////////////\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, ... )\\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc();\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestName{\\\n-                template<typename...Ts> \\\n-                TestName(Ts...names){\\\n+                TestName(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, __VA_ARGS__) \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+            return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n-#endif\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+#endif  \n \n-    #define INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, ...)\\\n-        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-            TestName<CATCH_REC_LIST(INTERNAL_CATCH_REMOVE_PARENS, __VA_ARGS__)>(CATCH_REC_LIST_UD(INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME,Name, __VA_ARGS__));\\\n-            return 0;\\\n-        }();\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\\n         template<typename TestType> static void TestFuncName();       \\\n-        namespace {                                                   \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \\\n+            INTERNAL_CATCH_TYPE_GEN                                                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\\n             template<typename... Types>                               \\\n             struct TestName {                                         \\\n-                TestName() {                                          \\\n+                void reg_tests() {                                          \\\n                     int index = 0;                                    \\\n                     using expander = int[];                           \\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -160,63 +204,92 @@ struct AutoReg : NonCopyable {\n                 }                                                     \\\n             };                                                        \\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n-                TestInit();                                           \\\n+                using TestInit = decltype(create<TestName, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n                 return 0;                                             \\\n             }();                                                      \\\n         }                                                             \\\n+        }                                                             \\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS              \\\n         template<typename TestType>                                   \\\n         static void TestFuncName()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )\n+#endif\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        namespace{ \\\n-            template<typename TestType> \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n-                void test();\\\n-            };\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n+            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestNameClass{\\\n-                template<typename...Ts> \\\n-                TestNameClass(Ts...names){\\\n+                TestNameClass(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestNameClass, Name, __VA_ARGS__)\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+                return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\\\n-        template<typename TestType> \\\n-        void TestName<TestType>::test()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n+\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n                 void test();\\\n             };\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\\\n+            INTERNAL_CATCH_TYPE_GEN                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types>\\\n             struct TestNameClass{\\\n-                TestNameClass(){\\\n+                void reg_tests(){\\\n                     int index = 0;\\\n                     using expander = int[];\\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -226,22 +299,33 @@ struct AutoReg : NonCopyable {\n                 }\\\n             };\\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n-                TestInit();\\\n+                using TestInit = decltype(create<TestNameClass, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n                 return 0;\\\n             }(); \\\n         }\\\n+        }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n         void TestName<TestType>::test()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )\n #endif\n \n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n+#endif\n+\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -7,6 +7,7 @@\n  */\n \n #include \"catch.hpp\"\n+#include <array>\n \n namespace{ namespace ClassTests {\n \n@@ -58,6 +59,15 @@ struct Template_Foo {\n     size_t size() { return 0; }\n };\n \n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n #endif\n \n \n@@ -74,11 +84,20 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n {\n     REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -92,10 +111,19 @@ namespace Inner\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n \n+    TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][nttp][failing]\", ((int V), V), 1, 3, 6) {\n+        REQUIRE(Nttp_Fixture<V>::value == 0);\n+    }\n+\n     TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n     {\n         REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][product][nttp][failing]\", ((typename T, size_t S), T, S), (std::array, Template_Foo_2), ((int, 2), (float, 6)))\n+    {\n+        REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() < 2);\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -18,6 +18,7 @@\n #include <cerrno>\n #include <limits>\n #include <sstream>\n+#include <array>\n \n namespace { namespace MiscTests {\n \n@@ -66,6 +67,10 @@ struct Foo {\n     size_t size() { return 0; }\n };\n \n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -306,11 +311,56 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: vectors can be sized and resized\", \"[vector][template][nttp]\", ((typename TestType, int V), TestType, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::vector<TestType> v(V);\n+\n+    REQUIRE(v.size() == V);\n+    REQUIRE(v.capacity() >= V);\n+\n+    SECTION(\"resizing bigger changes size and capacity\") {\n+        v.resize(2 * V);\n+\n+        REQUIRE(v.size() == 2 * V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"resizing smaller changes size but not capacity\") {\n+        v.resize(0);\n+\n+        REQUIRE(v.size() == 0);\n+        REQUIRE(v.capacity() >= V);\n+\n+        SECTION(\"We can use the 'swap trick' to reset the capacity\") {\n+            std::vector<TestType> empty;\n+            empty.swap(v);\n+\n+            REQUIRE(v.capacity() == 0);\n+        }\n+    }\n+    SECTION(\"reserving bigger changes capacity but not size\") {\n+        v.reserve(2 * V);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"reserving smaller does not change size or capacity\") {\n+        v.reserve(0);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= V);\n+    }\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n     TestType x;\n     REQUIRE(x.size() == 0);\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\n", "problem_statement": "Type parametrised test case: support for non-type template parameters\nRight now, TEMPLATE_TEST_CASE and friends only seem to support type template parameters. Would be nice if we can also do something like this:\r\n\r\n    template<std::size_t,typename> struct Type;\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", 1, 2, 3, 4) {\r\n       Type<TestType, float> test;\r\n    }\r\n\r\n or even\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (1, int), (2, float), (3, int), (4, float)) {\r\n       Type<TestType> test;\r\n    }\r\n  \r\nP.S. Right now I am circumventing it like this:\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (Type<1, float), (Type<2, float), (Type<3, float), (Type<4, float)) {\r\n       TestType test;\r\n    }\r\n\r\nwhich does work\n", "hints_text": "@tzakharko actually we thought about NTTP support for `TEMPLATE_PRODUCT_TEST_CASE`.\r\nWe decided that it would not be so trivial since the whole generation of the final `TestType` depends on the template signature for that type.\r\nEither way I think that I will take a deeper look on this feature.", "created_at": "2019-04-24T18:06:50Z"}
{"repo": "catchorg/Catch2", "pull_number": 1608, "instance_id": "catchorg__Catch2-1608", "issue_numbers": ["1607"], "base_commit": "979bbf03bb00bc55ca09783791b5091a2247df68", "patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -9,6 +9,7 @@\n #include \"catch_message.h\"\n #include \"catch_interfaces_capture.h\"\n #include \"catch_uncaught_exceptions.h\"\n+#include \"catch_enforce.h\"\n \n #include <cassert>\n #include <stack>\n@@ -76,6 +77,15 @@ namespace Catch {\n             }\n             return names.substr(start, end - start + 1);\n         };\n+        auto skipq = [&] (size_t start, char quote) {\n+            for (auto i = start + 1; i < names.size() ; ++i) {\n+                if (names[i] == quote)\n+                    return i;\n+                if (names[i] == '\\\\')\n+                    ++i;\n+            }\n+            CATCH_INTERNAL_ERROR(\"CAPTURE parsing encountered unmatched parentheses\");\n+        };\n \n         size_t start = 0;\n         std::stack<char> openings;\n@@ -96,6 +106,10 @@ namespace Catch {\n //           case '>':\n                 openings.pop();\n                 break;\n+            case '\"':\n+            case '\\'':\n+                pos = skipq(pos, c);\n+                break;\n             case ',':\n                 if (start != pos && openings.size() == 0) {\n                     m_messages.emplace_back(macroName, lineInfo, resultType);\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -251,6 +251,13 @@ TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messag\n     SUCCEED();\n }\n \n+TEST_CASE(\"CAPTURE parses string and character constants\", \"[messages][capture]\") {\n+    CAPTURE((\"comma, in string\", \"escaped, \\\", \"), \"single quote in string,',\", \"some escapes, \\\\,\\\\\\\\\");\n+    CAPTURE(\"some, ), unmatched, } prenheses {[<\");\n+    CAPTURE('\"', '\\'', ',', '}', ')', '(', '{');\n+    SUCCEED();\n+}\n+\n #ifdef __clang__\n #pragma clang diagnostic pop\n #endif\n", "problem_statement": "CAPTURE(\"text, with comma\") fails\n**Describe the bug**\r\nWhen string containing comma is passed to CAPTURE and test succeeds, the program will fail assertion \r\n`Capturer::~Capturer() : assert( m_captured == m_messages.size() );`\r\n\r\n**Expected behavior**\r\nDocumenting this behavior is probably enough. CAPTURE((\"test, with comma\")) works as expected. \r\n\r\n**Reproduction steps**\r\n```\r\nTEST_CASE(\"catch\") {\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(false);\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(true);\r\n}\r\n```\r\nproduces:\r\n```\r\ntest/test_suite.cpp:35: FAILED:\r\n  CHECK( false )\r\nwith message:\r\n  \"test := \"test, with comma\"\r\n\r\ntest_suite: test/catch.hpp:9638: Catch::Capturer::~Capturer(): Assertion `m_captured == m_messages.size()' failed.\r\n```\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Debian stretch**\r\n - Compiler+version: **gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516**\r\n - Catch version: **Catch v2.7.0**\r\n\r\n\r\n**Additional context**\r\nCapturer::Capturer() does not expect quotation in names. It should be quite easy to fix (just add `bool isquoted` into parsing algorithm.\r\n\r\nBTW: Capturing string is quite useful when capturing __VA_ARGS__ in macro ... \r\n\n", "hints_text": "", "created_at": "2019-04-24T14:13:38Z"}
{"repo": "catchorg/Catch2", "pull_number": 1589, "instance_id": "catchorg__Catch2-1589", "issue_numbers": ["1588", "1588"], "base_commit": "08147a23f923103c87d1eac3dc30a9ecc4a753c4", "patch": "diff --git a/include/internal/catch_debugger.cpp b/include/internal/catch_debugger.cpp\n--- a/include/internal/catch_debugger.cpp\n+++ b/include/internal/catch_debugger.cpp\n@@ -18,19 +18,23 @@\n #  include <stdbool.h>\n #  include <sys/types.h>\n #  include <unistd.h>\n-#  include <sys/sysctl.h>\n #  include <cstddef>\n #  include <ostream>\n \n-namespace Catch {\n+#ifdef __apple_build_version__\n+    // These headers will only compile with AppleClang (XCode)\n+    // For other compilers (Clang, GCC, ... ) we need to exclude them\n+#  include <sys/sysctl.h>\n+#endif\n \n+    namespace Catch {\n+        #ifdef __apple_build_version__\n         // The following function is taken directly from the following technical note:\n-        // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html\n+        // https://developer.apple.com/library/archive/qa/qa1361/_index.html\n \n         // Returns true if the current process is being debugged (either\n         // running under the debugger or has a debugger attached post facto).\n         bool isDebuggerActive(){\n-\n             int                 mib[4];\n             struct kinfo_proc   info;\n             std::size_t         size;\n@@ -60,6 +64,12 @@ namespace Catch {\n \n             return ( (info.kp_proc.p_flag & P_TRACED) != 0 );\n         }\n+        #else\n+        bool isDebuggerActive() {\n+            // We need to find another way to determine this for non-appleclang compilers on macOS\n+            return false;\n+        }\n+        #endif\n     } // namespace Catch\n \n #elif defined(CATCH_PLATFORM_LINUX)\n", "test_patch": "", "problem_statement": "Catch2 does not compile with clang-8 on macOS\n**Describe the bug**\r\nCatch2 does not compile with LLVM clang-8 on macOS. I get the following error message:\r\n\r\n```\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/sysctl.h:83,\r\n                 from /Users/torfinn/.conan/data/Catch2/2.7.0/catchorg/stable/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/catch2/catch.hpp:8405,\r\n                 from /Users/torfinn/.conan/data/<...>/stable/package/5926da2a8f608c60dbd4ba8eb9c5b650bd6fbdcb/src/main.cpp:18:\r\n/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/ucred.h:94:2: error: '_Atomic' does not name a type\r\n```\r\n\r\n**Expected behavior**\r\nThe program should compile with clang on macOS.\r\n\r\n**Reproduction steps**\r\nOn macOS, install LLVM with `brew install llvm`.\r\nCompile a main file with clang:\r\n\r\n```\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch2/catch.hpp>\r\n```\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **macOS 10.14.3**\r\n - Compiler+version: **Clang v8.0.0**\r\n - Catch version: **v2.7.0**\r\n - XCode **10.2**\r\n\r\n**Additional information**\r\nIt seems clang doesn't like the macOS system header `sys/sysctl.h`. The program compiles just fine with AppleClang 10.0.1\nCatch2 does not compile with clang-8 on macOS\n**Describe the bug**\r\nCatch2 does not compile with LLVM clang-8 on macOS. I get the following error message:\r\n\r\n```\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/sysctl.h:83,\r\n                 from /Users/torfinn/.conan/data/Catch2/2.7.0/catchorg/stable/package/5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9/include/catch2/catch.hpp:8405,\r\n                 from /Users/torfinn/.conan/data/<...>/stable/package/5926da2a8f608c60dbd4ba8eb9c5b650bd6fbdcb/src/main.cpp:18:\r\n/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/ucred.h:94:2: error: '_Atomic' does not name a type\r\n```\r\n\r\n**Expected behavior**\r\nThe program should compile with clang on macOS.\r\n\r\n**Reproduction steps**\r\nOn macOS, install LLVM with `brew install llvm`.\r\nCompile a main file with clang:\r\n\r\n```\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch2/catch.hpp>\r\n```\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **macOS 10.14.3**\r\n - Compiler+version: **Clang v8.0.0**\r\n - Catch version: **v2.7.0**\r\n - XCode **10.2**\r\n\r\n**Additional information**\r\nIt seems clang doesn't like the macOS system header `sys/sysctl.h`. The program compiles just fine with AppleClang 10.0.1\n", "hints_text": "\n", "created_at": "2019-04-05T09:46:19Z"}
{"repo": "catchorg/Catch2", "pull_number": 1521, "instance_id": "catchorg__Catch2-1521", "issue_numbers": ["1520"], "base_commit": "67308bb606e2640d3622861a0e45d83169bdebb5", "patch": "diff --git a/include/reporters/catch_reporter_junit.cpp b/include/reporters/catch_reporter_junit.cpp\n--- a/include/reporters/catch_reporter_junit.cpp\n+++ b/include/reporters/catch_reporter_junit.cpp\n@@ -76,6 +76,13 @@ namespace Catch {\n     void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {\n         CumulativeReporterBase::testRunStarting( runInfo );\n         xml.startElement( \"testsuites\" );\n+        if( m_config->rngSeed() != 0 ) {\n+            xml.startElement( \"properties\" );\n+            xml.scopedElement( \"property\" )\n+                .writeAttribute( \"name\", \"random-seed\" )\n+                .writeAttribute( \"value\", m_config->rngSeed() );\n+            xml.endElement();\n+        }\n     }\n \n     void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {\n", "test_patch": "", "problem_statement": "'--reporter junit' should contain --rng-seed value\n**Description**\r\nThe junit reporter should also report the value supplied to `--rng-seed`, as a continuation of #1402, which was for the XML reporter only\r\n\r\n\n", "hints_text": "", "created_at": "2019-01-31T21:05:41Z"}
{"repo": "catchorg/Catch2", "pull_number": 1492, "instance_id": "catchorg__Catch2-1492", "issue_numbers": ["1394", "1394", "1394"], "base_commit": "0387fb64ced7c3626b3164207c2d29aadb9ceaf2", "patch": "diff --git a/misc/coverage-helper.cpp b/misc/coverage-helper.cpp\n--- a/misc/coverage-helper.cpp\n+++ b/misc/coverage-helper.cpp\n@@ -9,6 +9,38 @@\n #include <string>\n #include <vector>\n \n+std::string escape_arg(const std::string& arg) {\n+    if (arg.empty() == false &&\n+        arg.find_first_of(\" \\t\\n\\v\\\"\") == arg.npos) {\n+        return arg;\n+    }\n+\n+    std::string escaped;\n+    escaped.push_back('\"');\n+    for (auto it = arg.begin(); ; ++it) {\n+        int num_backslashes = 0;\n+\n+        while (it != arg.end() && *it == '\\\\') {\n+            ++it;\n+            ++num_backslashes;\n+        }\n+\n+        if (it == arg.end()) {\n+            escaped.append(num_backslashes * 2, '\\\\');\n+            break;\n+        } else if (*it == '\"') {\n+            escaped.append(num_backslashes * 2 + 1, '\\\\');\n+            escaped.push_back(*it);\n+        } else {\n+            escaped.append(num_backslashes, '\\\\');\n+            escaped.push_back(*it);\n+        }\n+    }\n+    escaped.push_back('\"');\n+\n+    return escaped;\n+}\n+\n \n void create_empty_file(std::string const& path) {\n     std::ofstream ofs(path);\n@@ -60,8 +92,9 @@ std::string windowsify_path(std::string path) {\n void exec_cmd(std::string const& cmd, int log_num, std::string const& path) {\n     std::array<char, 128> buffer;\n #if defined(_WIN32)\n+    // cmd has already been escaped outside this function.\n     auto real_cmd = \"OpenCppCoverage --export_type binary:cov-report\" + std::to_string(log_num)\n-        + \".bin --quiet \" + \"--sources \" + path + \" --cover_children -- \" + cmd;\n+        + \".bin --quiet \" + \"--sources \" + escape_arg(path) + \" --cover_children -- \" + cmd;\n     std::cout << \"=== Marker ===: Cmd: \" << real_cmd << '\\n';\n     std::shared_ptr<FILE> pipe(_popen(real_cmd.c_str(), \"r\"), _pclose);\n #else // Just for testing, in the real world we will always work under WIN32\n@@ -91,9 +124,9 @@ int main(int argc, char** argv) {\n     assert(sep - begin(args) == 2 && \"Structure differs from expected!\");\n \n     auto num = parse_log_file_arg(args[1]);\n-\n+    \n     auto cmdline = std::accumulate(++sep, end(args), std::string{}, [] (const std::string& lhs, const std::string& rhs) {\n-        return lhs + ' ' + rhs;\n+        return lhs + ' ' + escape_arg(rhs);\n     });\n \n     try {\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -345,10 +345,16 @@ set_tests_properties(NoAssertions PROPERTIES PASS_REGULAR_EXPRESSION \"No asserti\n add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> -w NoTests \"___nonexistent_test___\")\n set_tests_properties(NoTest PROPERTIES PASS_REGULAR_EXPRESSION \"No test cases matched\")\n \n+add_test(NAME FilteredSection-1 COMMAND $<TARGET_FILE:SelfTest> \\#1394 -c RunSection)\n+set_tests_properties(FilteredSection-1 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+add_test(NAME FilteredSection-2 COMMAND $<TARGET_FILE:SelfTest> \\#1394\\ nested -c NestedRunSection -c s1)\n+set_tests_properties(FilteredSection-2 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+\n # AppVeyor has a Python 2.7 in path, but doesn't have .py files as autorunnable\n add_test(NAME ApprovalTests COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/scripts/approvalTests.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(ApprovalTests PROPERTIES FAIL_REGULAR_EXPRESSION \"Results differed\")\n \n+\n if (CATCH_USE_VALGRIND)\n     add_test(NAME ValgrindRunTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest>)\n     add_test(NAME ValgrindListTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest> --list-tests --verbosity high)\n", "test_patch": "diff --git a/include/internal/catch_test_case_tracker.cpp b/include/internal/catch_test_case_tracker.cpp\n--- a/include/internal/catch_test_case_tracker.cpp\n+++ b/include/internal/catch_test_case_tracker.cpp\n@@ -190,6 +190,17 @@ namespace TestCaseTracking {\n         }\n     }\n \n+    bool SectionTracker::isComplete() const {\n+        bool complete = true;\n+\n+        if ((m_filters.empty() || m_filters[0] == \"\") ||\n+             std::find(m_filters.begin(), m_filters.end(),\n+                       m_nameAndLocation.name) != m_filters.end())\n+            complete = TrackerBase::isComplete();\n+        return complete;\n+\n+    }\n+\n     bool SectionTracker::isSectionTracker() const { return true; }\n \n     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\ndiff --git a/include/internal/catch_test_case_tracker.h b/include/internal/catch_test_case_tracker.h\n--- a/include/internal/catch_test_case_tracker.h\n+++ b/include/internal/catch_test_case_tracker.h\n@@ -140,6 +140,8 @@ namespace TestCaseTracking {\n \n         bool isSectionTracker() const override;\n \n+        bool isComplete() const override;\n+\n         static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n \n         void tryOpen();\ndiff --git a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n@@ -324,3 +324,33 @@ TEST_CASE( \"Tracker\" ) {\n         //   two sections within a generator\n     }\n }\n+\n+static bool previouslyRun = false;\n+static bool previouslyRunNested = false;\n+\n+TEST_CASE( \"#1394\", \"[.][approvals][tracker]\" ) {\n+    // -- Don't re-run after specified section is done\n+    REQUIRE(previouslyRun == false);\n+\n+    SECTION( \"RunSection\" ) {\n+        previouslyRun = true;\n+    }\n+    SECTION( \"SkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n+\n+TEST_CASE( \"#1394 nested\", \"[.][approvals][tracker]\" ) {\n+    REQUIRE(previouslyRunNested == false);\n+\n+    SECTION( \"NestedRunSection\" ) {\n+        SECTION( \"s1\" ) {\n+            previouslyRunNested = true;\n+        }\n+    }\n+    SECTION( \"NestedSkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n", "problem_statement": "If a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\n", "hints_text": "I agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.", "created_at": "2019-01-08T13:45:01Z"}
{"repo": "catchorg/Catch2", "pull_number": 1480, "instance_id": "catchorg__Catch2-1480", "issue_numbers": ["1273"], "base_commit": "e7fce90b493b1546c8a13407b7fa40466f21a4f2", "patch": "diff --git a/include/internal/catch_decomposer.h b/include/internal/catch_decomposer.h\n--- a/include/internal/catch_decomposer.h\n+++ b/include/internal/catch_decomposer.h\n@@ -10,6 +10,7 @@\n \n #include \"catch_tostring.h\"\n #include \"catch_stringref.h\"\n+#include \"catch_meta.hpp\"\n \n #include <iosfwd>\n \n@@ -143,6 +144,20 @@ namespace Catch {\n             return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\", rhs };\n         }\n \n+        template<typename RhsT>\n+        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+            static_assert(always_false<RhsT>::value,\n+            \"operator&& is not supported inside assertions, \"\n+            \"wrap the expression inside parentheses, or decompose it\");\n+        }\n+\n+        template<typename RhsT>\n+        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+            static_assert(always_false<RhsT>::value,\n+            \"operator|| is not supported inside assertions, \"\n+            \"wrap the expression inside parentheses, or decompose it\");\n+        }\n+\n         auto makeUnaryExpr() const -> UnaryExpr<LhsT> {\n             return UnaryExpr<LhsT>{ m_lhs };\n         }\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -9,6 +9,8 @@\n #ifndef TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n #define TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n \n+#include <type_traits>\n+\n template< typename... >\n struct TypeList{};\n \n@@ -73,4 +75,7 @@ struct combine\n     };\n };\n \n+template<typename T>\n+struct always_false : std::false_type {};\n+\n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n", "test_patch": "", "problem_statement": "Catch2 does not provide a helpful message when logical operators are used in an assertion\n## Description\r\n\r\nCatch Classic used to provide a fairly helpful error message when `&&` or `||` was used in an assertion, as the compilation failed inside a type whose name explained the error. For Catch2, the error message looks like this \r\n\r\n```\r\ntest1.cpp(6): error C2676: binary '&&': 'Catch::ExprLhs<int *const &>' does not define this operator or a conversion to a type acceptable to the predefined operator\r\n```\r\n\r\nwhich is not exactly helpful.\r\n\r\n### Extra information\r\nThis was changed during the rewrite of capture layer, likely as an oversight.\r\n\r\n* Catch version: **v2.x.x**\r\n\n", "hints_text": "", "created_at": "2018-12-30T22:47:49Z"}
{"repo": "catchorg/Catch2", "pull_number": 1468, "instance_id": "catchorg__Catch2-1468", "issue_numbers": ["1454"], "base_commit": "4902cd721586822ded795afe0c418c553137306a", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -148,9 +148,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -226,9 +230,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -313,9 +321,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -384,9 +396,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/catch_meta.hpp\n@@ -0,0 +1,76 @@\n+/*\n+ *  Created by Jozef on 02/12/2018.\n+ *  Copyright 2018 Two Blue Cubes Ltd. All rights reserved.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#ifndef TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+\n+template< typename... >\n+struct TypeList{};\n+\n+template< typename... >\n+struct append;\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t>\n+struct append< L1<E1...>, L2<E2...> >\n+{\n+\tusing type = L1<E1..., E2...>;\n+};\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t, typename...Rest\n+\t>\n+struct append< L1<E1...>, L2<E2...>, Rest...>\n+{\n+\tusing type = typename append< L1<E1..., E2...>, Rest... >::type;\n+};\n+\n+template< template<typename...> class\n+        , typename...\n+        >\n+struct rewrap;\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , typename...elems\n+        >\n+struct rewrap<Container, List<elems...>>\n+{\n+    using type = TypeList< Container< elems... > >;\n+};\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , class...Elems\n+        , typename...Elements>\n+struct rewrap<Container, List<Elems...>, Elements...>\n+{\n+    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n+};\n+\n+template< template<typename...> class...Containers >\n+struct combine\n+{\n+    template< typename...Types >\n+    struct with_types\n+    {\n+        template< template <typename...> class Final >\n+        struct into\n+        {\n+            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n+        };\n+    };\n+};\n+\n+#endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -71,4 +71,9 @@\n #define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+\n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -118,6 +118,7 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_matchers_string.h\n         ${HEADER_DIR}/internal/catch_matchers_vector.h\n         ${HEADER_DIR}/internal/catch_message.h\n+        ${HEADER_DIR}/internal/catch_meta.hpp\n         ${HEADER_DIR}/internal/catch_objc.hpp\n         ${HEADER_DIR}/internal/catch_objc_arc.hpp\n         ${HEADER_DIR}/internal/catch_option.hpp\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -95,7 +95,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by type, in the form of `TEMPLATE_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE` and\n+`TEMPLATE_PRODUCT_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -147,9 +148,48 @@ TEMPLATE_TEST_CASE( \"vectors can be sized and resized\", \"[vector][template]\", in\n }\n ```\n \n+* **TEMPLATE_PRODUCT_TEST_CASE(** _test name_ , _tags_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+_template-type1_ through _template-typen_ is list of template template\n+types which should be combined with each of _template-arg1_ through\n+ _template-argm_, resulting in _n * m_ test cases. Inside the test case,\n+the resulting type is available under the name of `TestType`.\n+\n+To specify more than 1 type as a single _template-type_ or _template-arg_,\n+you must enclose the types in an additional set of parentheses, e.g.\n+`((int, float), (char, double))` specifies 2 template-args, each\n+consisting of 2 concrete types (`int`, `float` and `char`, `double`\n+respectively). You can also omit the outer set of parentheses if you\n+specify only one type as the full set of either the _template-types_,\n+or the _template-args_.\n+\n+\n+Example:\n+```\n+template< typename T>\n+struct Foo {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+```\n+\n+You can also have different arities in the _template-arg_ packs:\n+```\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    TestType x;\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+```\n+\n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n+is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -31,16 +31,22 @@ class UniqueTestsFixture {\n The two test cases here will create uniquely-named derived classes of UniqueTestsFixture and thus can access the `getID()` protected method and `conn` member variables. This ensures that both the test cases are able to create a DBConnection using the same method (DRY principle) and that any ID's created are unique such that the order that tests are executed does not matter.\n \n \n-Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` that can be used together\n-with templated fixtures to perform tests for multiple different types.\n-However, unlike `TEST_CASE_METHOD`, `TEMPLATE_TEST_CASE_METHOD` requires\n-the tag specification to be non-empty, as it is followed by further macros\n-arguments.\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` and\n+`TEMPLATE_PRODUCT_TEST_CASE_METHOD` that can be used together\n+with templated fixtures and templated template fixtures to perform\n+tests for multiple different types. Unlike `TEST_CASE_METHOD`,\n+`TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD` do\n+require the tag specification to be non-empty, as it is followed by\n+further macro arguments.\n \n Also note that, because of limitations of the C++ preprocessor, if you\n want to specify a type with multiple template parameters, you need to\n enclose it in parentheses, e.g. `std::map<int, std::string>` needs to be\n passed as `(std::map<int, std::string>)`.\n+In the case of `TEMPLATE_PRODUCT_TEST_CASE_METHOD`, if a member of the\n+type list should consist of more than single type, it needs to be enclosed\n+in another pair of parentheses, e.g. `(std::map, std::pair)` and\n+`((int, float), (char, double))`.\n \n Example:\n ```cpp\n@@ -54,11 +60,29 @@ struct Template_Fixture {\n TEMPLATE_TEST_CASE_METHOD(Template_Fixture,\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds\", \"[class][template]\", int, float, double) {\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n+\n+template<typename T>\n+struct Template_Template_Fixture {\n+    Template_Template_Fixture() {}\n+\n+    T m_a;\n+};\n+\n+template<typename T>\n+struct Foo_class {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Template_Fixture, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test succeeds\", \"[class][template]\", (Foo_class, std::vector), int) {\n+    REQUIRE( Template_Template_Fixture<TestType>::m_a.size() == 0 );\n+}\n ```\n \n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+the limit is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -14,6 +14,7 @@\n #include \"catch_stringref.h\"\n #include \"catch_type_traits.hpp\"\n #include \"catch_preprocessor.hpp\"\n+#include \"catch_meta.hpp\"\n \n namespace Catch {\n \n@@ -150,6 +151,38 @@ struct AutoReg : NonCopyable {\n             return 0;\\\n         }();\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        template<typename TestType> static void TestFuncName();       \\\n+        namespace {                                                   \\\n+            template<typename... Types>                               \\\n+            struct TestName {                                         \\\n+                TestName() {                                          \\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)       \\\n+                    int index = 0;                                    \\\n+                    using expander = int[];                           \\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }                                                     \\\n+            };                                                        \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n+                TestInit();                                           \\\n+                return 0;                                             \\\n+            }();                                                      \\\n+        }                                                             \\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFuncName()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         namespace{ \\\n@@ -180,4 +213,39 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+                void test();\\\n+            };\\\n+        namespace {\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                TestNameClass(){\\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n+                TestInit();\\\n+                return 0;\\\n+            }(); \\\n+        }\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -46,6 +46,18 @@ struct Template_Fixture {\n     T m_a;\n };\n \n+template<typename T>\n+struct Template_Fixture_2 {\n+    Template_Fixture_2() {}\n+\n+    T m_a;\n+};\n+\n+template< typename T>\n+struct Template_Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n \n@@ -62,6 +74,11 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n+{\n+    REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -74,6 +91,11 @@ namespace Inner\n     {\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n+    {\n+        REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -61,6 +61,11 @@ CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\n static AutoTestReg autoTestReg;\n CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n+template<typename T>\n+struct Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -301,6 +306,15 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\n", "problem_statement": "TEMPLATE_TEST_CASE does not support template templates\n## Description\r\nTEMPLATE_TEST_CASE only supports substitution of simple types, and not template templates.\r\n\r\n### Steps to reproduce\r\n\r\n```cpp\r\ntemplate <template <typename> typename T>\r\nstruct Foo { };\r\n\r\nTEMPLATE_TEST_CASE(\"instantiate a template template with int\", \"\", Foo) {\r\n     using T = TestType<int>;  // ... or something\r\n}\r\n```\n", "hints_text": "@porpoises in your example you probably wanted to do\r\n```c++\r\ntemplate<typename T>\r\nstruct Foo {};\r\n```\r\nin linked PR #1457 i added support for this kind of types. For this kind of tests you will have to use\r\n`TEMPLATE_TEMPLATE_TEST_CASE`.\r\n\nAwesome, thanks!", "created_at": "2018-12-06T19:16:07Z"}
{"repo": "catchorg/Catch2", "pull_number": 1448, "instance_id": "catchorg__Catch2-1448", "issue_numbers": ["1436"], "base_commit": "62460fafe6b54c3173bc5cbc46d05a5f071017ff", "patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -11,6 +11,7 @@\n #include \"catch_uncaught_exceptions.h\"\n \n #include <cassert>\n+#include <stack>\n \n namespace Catch {\n \n@@ -60,19 +61,48 @@ namespace Catch {\n \n \n     Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {\n-        auto start = std::string::npos;\n-        for( size_t pos = 0; pos <= names.size(); ++pos ) {\n+        auto trimmed = [&] (size_t start, size_t end) {\n+            while (names[start] == ',' || isspace(names[start])) {\n+                ++start;\n+            }\n+            while (names[end] == ',' || isspace(names[end])) {\n+                --end;\n+            }\n+            return names.substr(start, end - start + 1);\n+        };\n+\n+        size_t start = 0;\n+        std::stack<char> openings;\n+        for (size_t pos = 0; pos < names.size(); ++pos) {\n             char c = names[pos];\n-            if( pos == names.size() || c == ' ' || c == '\\t' || c == ',' || c == ']' ) {\n-                if( start != std::string::npos ) {\n-                    m_messages.push_back( MessageInfo( macroName, lineInfo, resultType ) );\n-                    m_messages.back().message = names.substr( start, pos-start) + \" := \";\n-                    start = std::string::npos;\n+            switch (c) {\n+            case '[':\n+            case '{':\n+            case '(':\n+            // It is basically impossible to disambiguate between\n+            // comparison and start of template args in this context\n+//            case '<':\n+                openings.push(c);\n+                break;\n+            case ']':\n+            case '}':\n+            case ')':\n+//           case '>':\n+                openings.pop();\n+                break;\n+            case ',':\n+                if (start != pos && openings.size() == 0) {\n+                    m_messages.emplace_back(macroName, lineInfo, resultType);\n+                    m_messages.back().message = trimmed(start, pos);\n+                    m_messages.back().message += \" := \";\n+                    start = pos;\n                 }\n             }\n-            else if( c != '[' && c != ']' && start == std::string::npos )\n-                start = pos;\n         }\n+        assert(openings.size() == 0 && \"Mismatched openings\");\n+        m_messages.emplace_back(macroName, lineInfo, resultType);\n+        m_messages.back().message = trimmed(start, names.size() - 1);\n+        m_messages.back().message += \" := \";\n     }\n     Capturer::~Capturer() {\n         if ( !uncaught_exceptions() ){\n@@ -82,7 +112,7 @@ namespace Catch {\n         }\n     }\n \n-    void Capturer::captureValue( size_t index, StringRef value ) {\n+    void Capturer::captureValue( size_t index, std::string const& value ) {\n         assert( index < m_messages.size() );\n         m_messages[index].message += value;\n         m_resultCapture.pushScopedMessage( m_messages[index] );\ndiff --git a/include/internal/catch_message.h b/include/internal/catch_message.h\n--- a/include/internal/catch_message.h\n+++ b/include/internal/catch_message.h\n@@ -77,16 +77,16 @@ namespace Catch {\n         Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );\n         ~Capturer();\n \n-        void captureValue( size_t index, StringRef value );\n+        void captureValue( size_t index, std::string const& value );\n \n         template<typename T>\n-        void captureValues( size_t index, T&& value ) {\n+        void captureValues( size_t index, T const& value ) {\n             captureValue( index, Catch::Detail::stringify( value ) );\n         }\n \n         template<typename T, typename... Ts>\n-        void captureValues( size_t index, T&& value, Ts&&... values ) {\n-            captureValues( index, value );\n+        void captureValues( size_t index, T const& value, Ts const&... values ) {\n+            captureValue( index, Catch::Detail::stringify(value) );\n             captureValues( index+1, values... );\n         }\n     };\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -9,10 +9,6 @@\n #include \"catch.hpp\"\n #include <iostream>\n \n-#ifdef __clang__\n-#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n-#endif\n-\n TEST_CASE( \"INFO and WARN do not abort tests\", \"[messages][.]\" ) {\n     INFO( \"this is a \" << \"message\" );    // This should output the message if a failure occurs\n     WARN( \"this is a \" << \"warning\" );    // This should always output the message but then continue\n@@ -135,3 +131,60 @@ TEST_CASE( \"Pointers can be converted to strings\", \"[messages][.][approvals]\" )\n     WARN( \"actual address of p: \" << &p );\n     WARN( \"toString(p): \" << ::Catch::Detail::stringify( &p ) );\n }\n+\n+TEST_CASE( \"CAPTURE can deal with complex expressions\", \"[messages][capture]\" ) {\n+    int a = 1;\n+    int b = 2;\n+    int c = 3;\n+    CAPTURE( a, b, c, a + b, a+b, c > b, a == 1 );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wunused-value\" // In (1, 2), the \"1\" is unused ...\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-value\" // All the comma operators are side-effect free\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(push)\n+#pragma warning(disable:4709) // comma in indexing operator\n+#endif\n+\n+template <typename T1, typename T2>\n+struct helper_1436 {\n+    helper_1436(T1 t1, T2 t2):\n+        t1{ t1 },\n+        t2{ t2 }\n+    {}\n+    T1 t1;\n+    T2 t2;\n+};\n+\n+template <typename T1, typename T2>\n+std::ostream& operator<<(std::ostream& out, helper_1436<T1, T2> const& helper) {\n+    out << \"{ \" << helper.t1 << \", \" << helper.t2 << \" }\";\n+    return out;\n+}\n+\n+TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messages][capture]\") {\n+    CAPTURE(std::vector<int>{1, 2, 3}[0, 1, 2],\n+            std::vector<int>{1, 2, 3}[(0, 1)],\n+            std::vector<int>{1, 2, 3}[0]);\n+    CAPTURE((helper_1436<int, int>{12, -12}),\n+            (helper_1436<int, int>(-12, 12)));\n+    CAPTURE( (1, 2), (2, 3) );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic pop\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(pop)\n+#endif\n", "problem_statement": "Capturer destructor asserts due to bad expression parsing\nThe following asserts:\r\n\r\n```\r\nTEST_CASE(\"Explodes\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a + b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe following does not:\r\n```\r\nTEST_CASE(\"Works\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a+b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe assertion that fires:\r\nhttps://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L79\r\n\r\nThe issue appears to have been caused here: https://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L66\r\n\r\n\n", "hints_text": "Looks like you'd want to only count `,` instead of all whitespace as an argument delimiter, and also only when `,` appears at the top level (not nested within `[]`, `{}`, or `()`). You can count the nesting depth of each bracket type in one variable since mismatching brackets would cause the compilation to fail anyway.", "created_at": "2018-11-19T22:15:46Z"}
{"repo": "catchorg/Catch2", "pull_number": 1433, "instance_id": "catchorg__Catch2-1433", "issue_numbers": ["360"], "base_commit": "d0eb9dfb9b95b97d31656acd13bb9cfb445bc734", "patch": "diff --git a/include/reporters/catch_reporter_console.cpp b/include/reporters/catch_reporter_console.cpp\n--- a/include/reporters/catch_reporter_console.cpp\n+++ b/include/reporters/catch_reporter_console.cpp\n@@ -111,8 +111,6 @@ class ConsoleAssertionPrinter {\n     void print() const {\n         printSourceInfo();\n         if (stats.totals.assertions.total() > 0) {\n-            if (result.isOk())\n-                stream << '\\n';\n             printResultType();\n             printOriginalExpression();\n             printReconstructedExpression();\n", "test_patch": "", "problem_statement": "Reporting message formatting\nThere is a minor inconsistency with FAILED and PASSED message formatting.\n\n1)\n\n```\ntest.cpp:19: FAILED\n    CHECK(add(2,2)==5)\nwith expansion\n    4 == 5\n```\n\n2)\n\n```\ntest.cpp:19: \nPASSED:\n     CHECK(add(2,2)==4)\nwith expansion\n     4 == 4\n```\n\nIt would be good if PASSED appears on the same line as filename and line number, just like the case with FAILED message formatting.\n\nFix suggested by commenting in this snippet:\n\n```\n 8198  if  (stats.totals.assertions.total() > 0) {\n 8199         //if ( results.isOk() )      //commented by snawaz\n 8200         //    stream << \"\\n\";        //commented by snawaz\n 8201         printResultType();\n 8202         printOriginalExpression();\n 8203         printReconstructedExpression();\n 8204  }\n```\n\n", "hints_text": "", "created_at": "2018-11-04T19:41:01Z"}
{"repo": "catchorg/Catch2", "pull_number": 1422, "instance_id": "catchorg__Catch2-1422", "issue_numbers": ["1351"], "base_commit": "1faccd601d904a951142d8fba82914a8325b764e", "patch": "diff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -10,6 +10,9 @@\n \n #include \"catch_string_manip.h\"\n \n+#include \"catch_interfaces_registry_hub.h\"\n+#include \"catch_interfaces_reporter.h\"\n+\n #include <fstream>\n #include <ctime>\n \n@@ -105,6 +108,18 @@ namespace Catch {\n                 return ParserResult::runtimeError( \"Unrecognised verbosity, '\" + verbosity + \"'\" );\n             return ParserResult::ok( ParseResultType::Matched );\n         };\n+        auto const setReporter = [&]( std::string const& reporter ) {\n+            IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n+\n+            auto lcReporter = toLower( reporter );\n+            auto result = factories.find( lcReporter );\n+\n+            if( factories.end() != result )\n+                config.reporterName = lcReporter;\n+            else\n+                return ParserResult::runtimeError( \"Unrecognized reporter, '\" + reporter + \"'. Check available with --list-reporters\" );\n+            return ParserResult::ok( ParseResultType::Matched );\n+        };\n \n         auto cli\n             = ExeName( config.processName )\n@@ -130,7 +145,7 @@ namespace Catch {\n             | Opt( config.outputFilename, \"filename\" )\n                 [\"-o\"][\"--out\"]\n                 ( \"output filename\" )\n-            | Opt( config.reporterName, \"name\" )\n+            | Opt( setReporter, \"name\" )\n                 [\"-r\"][\"--reporter\"]\n                 ( \"reporter to use (defaults to console)\" )\n             | Opt( config.name, \"name\" )\ndiff --git a/include/internal/catch_list.cpp b/include/internal/catch_list.cpp\n--- a/include/internal/catch_list.cpp\n+++ b/include/internal/catch_list.cpp\n@@ -124,7 +124,7 @@ namespace Catch {\n         return tagCounts.size();\n     }\n \n-    std::size_t listReporters( Config const& /*config*/ ) {\n+    std::size_t listReporters() {\n         Catch::cout() << \"Available reporters:\\n\";\n         IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n         std::size_t maxNameLen = 0;\n@@ -155,7 +155,7 @@ namespace Catch {\n         if( config.listTags() )\n             listedCount = listedCount.valueOr(0) + listTags( config );\n         if( config.listReporters() )\n-            listedCount = listedCount.valueOr(0) + listReporters( config );\n+            listedCount = listedCount.valueOr(0) + listReporters();\n         return listedCount;\n     }\n \ndiff --git a/include/internal/catch_list.h b/include/internal/catch_list.h\n--- a/include/internal/catch_list.h\n+++ b/include/internal/catch_list.h\n@@ -29,7 +29,7 @@ namespace Catch {\n \n     std::size_t listTags( Config const& config );\n \n-    std::size_t listReporters( Config const& /*config*/ );\n+    std::size_t listReporters();\n     \n     Option<std::size_t> list( Config const& config );\n \n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n@@ -280,7 +280,6 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n         CHECK(config.processName == \"\");\n     }\n \n-\n     SECTION(\"default - no arguments\") {\n         auto result = cli.parse({\"test\"});\n         CHECK(result);\n@@ -345,8 +344,15 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n         SECTION(\"Only one reporter is accepted\") {\n             REQUIRE_FALSE(cli.parse({ \"test\", \"-r\", \"xml\", \"-r\", \"junit\" }));\n         }\n-    }\n+        SECTION(\"must match one of the available ones\") {\n+            auto result = cli.parse({\"test\", \"--reporter\", \"unsupported\"});\n+            CHECK(!result);\n \n+#ifndef CATCH_CONFIG_DISABLE_MATCHERS\n+            REQUIRE_THAT(result.errorMessage(), Contains(\"Unrecognized reporter\"));\n+#endif\n+        }\n+    }\n \n     SECTION(\"debugger\") {\n         SECTION(\"-b\") {\n", "problem_statement": "unregistered reporter is not considered a command line error\n## Description\r\nwhen `session.applyCommandLine()` is called with an unregistered reporter, the function simply returns 0 and the later call to `session.run()` just outputs a text: `No reporter registered with name: 'foo'`\r\n\r\n### Steps to reproduce\r\n    int main()\r\n    {\r\n      const char* argv[] = { \"runner\", \"-r foo\" };\r\n\r\n      Catch::Session session;\r\n\r\n      const int command_line_errors = session.applyCommandLine( std::size( argv ), const_cast< char** >( argv ) );\r\n\r\n      if ( command_line_errors == 0 )\r\n      {\r\n        session.run();\r\n      }\r\n      else\r\n      {\r\n        Catch::cerr() << \"Error parsing following command line: \" << *std::prev( std::end( argv ) ) << std::endl;\r\n      }\r\n    }\r\n\r\nI would expect the parser to recognize this as command line argument error.\r\n\r\n* Catch version: v2.3\r\n* Operating System: No Operation System; bare metal\r\n* Compiler+version: gcc version 7.3.1 20180622 (release) [ARM/embedded-7-branch revision 261907] (GNU Tools for Arm Embedded Processors 7-2018-q2-update) \n", "hints_text": "", "created_at": "2018-10-22T14:08:24Z"}
{"repo": "catchorg/Catch2", "pull_number": 1397, "instance_id": "catchorg__Catch2-1397", "issue_numbers": ["1396"], "base_commit": "de06340e7d2862bbdb55796f86a2090e915f9c19", "patch": "diff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -109,7 +109,14 @@\n // Required for some versions of Cygwin to declare gettimeofday\n // see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin\n #   define _BSD_SOURCE\n+// some versions of cygwin (most) do not support std::to_string. Use the libstd check. \n+// https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813\n+# if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \\\n+\t       && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\n \n+#\tdefine CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING\n+\n+# endif\n #endif // __CYGWIN__\n \n ////////////////////////////////////////////////////////////////////////////////\n", "test_patch": "", "problem_statement": "std::to_string is not a member of 'std'\n## Description \r\n\r\nIt's my understanding that this is due to [cygwin issues](https://stackoverflow.com/questions/33500074/cygwin-g-5-2-to-string-is-not-a-member-of-std)\r\nMailing list: [here](https://cygwin.com/ml/cygwin/2015-10/msg00421.html)\r\n\r\nI cannot modify my gcc:cygwin. \r\n\r\n### Steps to reproduce\r\n<!--\r\nThis is only relevant for bug reports, but if you do have one,\r\nplease provide a minimal set of steps to reproduce the problem.\r\n\r\nUsually this means providing a small and self-contained code using Catch\r\nand specifying compiler flags/tools used if relevant.\r\n-->\r\n\r\n```powershell\r\nPS C:\\application\\common\\tests> g++ -std=c++11 -Wfatal-errors -Wall -I. -c 000-CatchMain.cpp\r\nIn file included from 000-CatchMain.cpp:9:0:\r\ncatch.hpp: In function 'std::string Catch::to_string(const T&)':\r\ncatch.hpp:8418:16: error: 'to_string' is not a member of 'std'\r\n         return std::to_string(t);\r\n                ^\r\ncompilation terminated due to -Wfatal-errors.\r\n```\r\n\r\n\r\n### Extra information\r\n<!--\r\nFill in any extra information that might be important for your issue.\r\n\r\nIf your issue is a bugreport, definitely fill out at least the following.\r\n-->\r\n```powershell\r\nPS C:\\application\\common\\tests> head -n 3 .\\catch.hpp\r\n/*\r\n *  Catch v2.4.0\r\n *  Generated: 2018-09-04 11:55:01.682061\r\n```\r\n\r\n```cmd\r\nC:\\Users\\me>ver\r\n\r\nMicrosoft Windows [Version 10.0.16299.611]\r\n```\r\n\r\n\r\n```powershell\r\nPS C:\\application\\common\\tests> g++ --version\r\ng++ (GCC) 4.9.3\r\nCopyright (C) 2015 Free Software Foundation, Inc.\r\nThis is free software; see the source for copying conditions.  There is NO\r\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n```\r\n\n", "hints_text": "", "created_at": "2018-09-26T20:58:54Z"}
{"repo": "catchorg/Catch2", "pull_number": 1376, "instance_id": "catchorg__Catch2-1376", "issue_numbers": ["1375"], "base_commit": "1eb42eed974f944401091325bbe8e61b38fd0678", "patch": "diff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -29,11 +29,11 @@\n \n #ifdef __cplusplus\n \n-#  if __cplusplus >= 201402L\n+#  if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)\n #    define CATCH_CPP14_OR_GREATER\n #  endif\n \n-#  if __cplusplus >= 201703L\n+#  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)\n #    define CATCH_CPP17_OR_GREATER\n #  endif\n \n@@ -154,6 +154,16 @@\n     #define CATCH_INTERNAL_CONFIG_COUNTER\n #endif\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Check if string_view is available and usable\n+// The check is split apart to work around v140 (VS2015) preprocessor issue...\n+#if defined(__has_include)\n+#if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)\n+#    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW\n+#endif\n+#endif\n+\n+\n #if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)\n #   define CATCH_CONFIG_COUNTER\n #endif\n@@ -177,6 +187,10 @@\n #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n #endif\n \n+#if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)\n+#  define CATCH_CONFIG_CPP17_STRING_VIEW\n+#endif\n+\n #if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)\n #  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE\n #endif\ndiff --git a/include/internal/catch_tostring.cpp b/include/internal/catch_tostring.cpp\n--- a/include/internal/catch_tostring.cpp\n+++ b/include/internal/catch_tostring.cpp\n@@ -116,14 +116,9 @@ std::string StringMaker<std::string>::convert(const std::string& str) {\n     return s;\n }\n \n-#ifdef CATCH_CONFIG_WCHAR\n-std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {\n-    std::string s;\n-    s.reserve(wstr.size());\n-    for (auto c : wstr) {\n-        s += (c <= 0xff) ? static_cast<char>(c) : '?';\n-    }\n-    return ::Catch::Detail::stringify(s);\n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+std::string StringMaker<std::string_view>::convert(std::string_view str) {\n+    return ::Catch::Detail::stringify(std::string{ str });\n }\n #endif\n \n@@ -141,7 +136,23 @@ std::string StringMaker<char*>::convert(char* str) {\n         return{ \"{null string}\" };\n     }\n }\n+\n #ifdef CATCH_CONFIG_WCHAR\n+std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {\n+    std::string s;\n+    s.reserve(wstr.size());\n+    for (auto c : wstr) {\n+        s += (c <= 0xff) ? static_cast<char>(c) : '?';\n+    }\n+    return ::Catch::Detail::stringify(s);\n+}\n+\n+# ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+std::string StringMaker<std::wstring_view>::convert(std::wstring_view str) {\n+    return StringMaker<std::wstring>::convert(std::wstring(str));\n+}\n+# endif\n+\n std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {\n     if (str) {\n         return ::Catch::Detail::stringify(std::wstring{ str });\ndiff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -16,6 +16,10 @@\n #include \"catch_compiler_capabilities.h\"\n #include \"catch_stream.h\"\n \n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+#include <string_view>\n+#endif\n+\n #ifdef __OBJC__\n #include \"catch_objc_arc.hpp\"\n #endif\n@@ -152,10 +156,11 @@ namespace Catch {\n     struct StringMaker<std::string> {\n         static std::string convert(const std::string& str);\n     };\n-#ifdef CATCH_CONFIG_WCHAR\n+\n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n     template<>\n-    struct StringMaker<std::wstring> {\n-        static std::string convert(const std::wstring& wstr);\n+    struct StringMaker<std::string_view> {\n+        static std::string convert(std::string_view str);\n     };\n #endif\n \n@@ -169,6 +174,18 @@ namespace Catch {\n     };\n \n #ifdef CATCH_CONFIG_WCHAR\n+    template<>\n+    struct StringMaker<std::wstring> {\n+        static std::string convert(const std::wstring& wstr);\n+    };\n+\n+# ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+    template<>\n+    struct StringMaker<std::wstring_view> {\n+        static std::string convert(std::wstring_view str);\n+    };\n+# endif\n+\n     template<>\n     struct StringMaker<wchar_t const *> {\n         static std::string convert(wchar_t const * str);\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n@@ -116,6 +116,18 @@ TEST_CASE(\"Static arrays are convertible to string\", \"[toString]\") {\n     }\n }\n \n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+\n+TEST_CASE(\"String views are stringified like other strings\", \"[toString][approvals]\") {\n+    std::string_view view{\"abc\"};\n+    CHECK(Catch::Detail::stringify(view) == R\"(\"abc\")\");\n+\n+    std::string_view arr[] { view };\n+    CHECK(Catch::Detail::stringify(arr) == R\"({ \"abc\" })\");\n+}\n+\n+#endif\n+\n namespace {\n \n struct WhatException : std::exception {\n", "problem_statement": "std::string_view is stringified without quotes\n## Description\r\n`std::string_view` probably uses some fallback stringification, and is expanded without quotes (and also bypasses pretty printing of invisibles).\r\n\r\n\r\n### Steps to reproduce\r\n```cpp\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch2/catch.hpp>\r\n\r\n#include <string>\r\n#include <string_view>\r\n\r\nTEST_CASE(\"string_view == string\") {\r\n    std::string s = \"foo\";\r\n    std::string_view v = s;\r\n\r\n    CHECK(s == v);\r\n}\r\n```\r\nrun with `-s`:\r\n```\r\nPASSED:\r\n  CHECK( s == v )\r\nwith expansion:\r\n  \"foo\" == foo\r\n```\r\n\r\n\r\n### Extra information\r\nCatch version: **v2.4.0**\r\n\n", "hints_text": "", "created_at": "2018-09-04T18:46:47Z"}
{"repo": "catchorg/Catch2", "pull_number": 1363, "instance_id": "catchorg__Catch2-1363", "issue_numbers": ["1360"], "base_commit": "c9de7dd12d2971c63f9d32ce5459eb98f2fec13d", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -147,11 +147,12 @@\n // \"BDD-style\" convenience wrappers\n #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n-#define CATCH_GIVEN( desc )    INTERNAL_CATCH_DYNAMIC_SECTION( \"   Given: \" << desc )\n-#define CATCH_WHEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    When: \" << desc )\n-#define CATCH_AND_WHEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And when: \" << desc )\n-#define CATCH_THEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Then: \" << desc )\n-#define CATCH_AND_THEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"     And: \" << desc )\n+#define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Given: \" << desc )\n+#define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And given: \" << desc )\n+#define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     When: \" << desc )\n+#define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \" And when: \" << desc )\n+#define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n+#define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required\n #else\n@@ -211,11 +212,12 @@\n #define SCENARIO( ... ) TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n \n-#define GIVEN( desc )    INTERNAL_CATCH_DYNAMIC_SECTION( \"   Given: \" << desc )\n-#define WHEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    When: \" << desc )\n-#define AND_WHEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And when: \" << desc )\n-#define THEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Then: \" << desc )\n-#define AND_THEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"     And: \" << desc )\n+#define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Given: \" << desc )\n+#define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And given: \" << desc )\n+#define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     When: \" << desc )\n+#define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \" And when: \" << desc )\n+#define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n+#define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n using Catch::Detail::Approx;\n \n@@ -276,6 +278,7 @@ using Catch::Detail::Approx;\n #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n #define CATCH_GIVEN( desc )\n+#define CATCH_AND_GIVEN( desc )\n #define CATCH_WHEN( desc )\n #define CATCH_AND_WHEN( desc )\n #define CATCH_THEN( desc )\n@@ -340,6 +343,7 @@ using Catch::Detail::Approx;\n #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n \n #define GIVEN( desc )\n+#define AND_GIVEN( desc )\n #define WHEN( desc )\n #define AND_WHEN( desc )\n #define THEN( desc )\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/BDD.tests.cpp b/projects/SelfTest/UsageTests/BDD.tests.cpp\n--- a/projects/SelfTest/UsageTests/BDD.tests.cpp\n+++ b/projects/SelfTest/UsageTests/BDD.tests.cpp\n@@ -38,11 +38,14 @@ namespace { namespace BDDTests {\n     SCENARIO(\"Do that thing with the thing\", \"[Tags]\") {\n         GIVEN(\"This stuff exists\") {\n             // make stuff exist\n-            WHEN(\"I do this\") {\n-                // do this\n-                THEN(\"it should do this\") {\n-                    REQUIRE(itDoesThis());\n-                    AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+            AND_GIVEN(\"And some assumption\") {\n+                // Validate assumption\n+                WHEN(\"I do this\") {\n+                    // do this\n+                    THEN(\"it should do this\") {\n+                        REQUIRE(itDoesThis());\n+                        AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+                    }\n                 }\n             }\n         }\n", "problem_statement": "Feature Request: AND_GIVEN\n\r\nTo be consistent with the `AND_WHEN` and `AND_THEN`; \r\n\r\nWith BDD:\r\n\r\nthere are times when you require to expand the context, if you feel a need to type *'and'* in the context of a `GIVEN`, `WHEN`, and/or `THEN`, you should use `AND`.\r\n\r\nwe don't have an `AND`, because that just doesn't work in this abstraction; thus we have `AND_WHEN` and `AND_THEN`; thus we should also have `AND_GIVEN`.\n", "hints_text": "", "created_at": "2018-08-14T10:25:40Z"}
{"repo": "catchorg/Catch2", "pull_number": 1306, "instance_id": "catchorg__Catch2-1306", "issue_numbers": ["1285", "1285"], "base_commit": "021fcee63667e346c619e04bbae932bcea562334", "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -105,7 +105,9 @@ namespace Catch {\n         typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\n             convert(const Fake& value) {\n                 ReusableStringStream rss;\n-                rss << value;\n+                // NB: call using the function-like syntax to avoid ambiguity with\n+                // user-defined templated operator<< under clang.\n+                rss.operator<<(value);\n                 return rss.str();\n         }\n \n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp b/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n@@ -20,6 +20,7 @@ struct has_operator { };\n struct has_maker {};\n struct has_maker_and_operator {};\n struct has_neither {};\n+struct has_template_operator {};\n \n std::ostream& operator<<(std::ostream& os, const has_operator&) {\n     os << \"operator<<( has_operator )\";\n@@ -31,6 +32,12 @@ std::ostream& operator<<(std::ostream& os, const has_maker_and_operator&) {\n     return os;\n }\n \n+template <typename StreamT>\n+StreamT& operator<<(StreamT& os, const has_template_operator&) {\n+    os << \"operator<<( has_template_operator )\";\n+    return os;\n+}\n+\n namespace Catch {\n     template<>\n     struct StringMaker<has_maker> {\n@@ -69,6 +76,12 @@ TEST_CASE(\"stringify( has_neither )\", \"[toString]\") {\n     REQUIRE( ::Catch::Detail::stringify(item) == \"{ !!! }\" );\n }\n \n+// Call the templated operator\n+TEST_CASE( \"stringify( has_template_operator )\", \"[toString]\" ) {\n+    has_template_operator item;\n+    REQUIRE( ::Catch::Detail::stringify( item ) == \"operator<<( has_template_operator )\" );\n+}\n+\n \n // Vectors...\n \n", "problem_statement": "Clang compilation fails when using REQUIRE with custom string classes that overload the << operator\n## Description\r\n\r\nWe have our own custom string class that overloads the << operator, and it's causing issues when using the REQUIRE macro and compiling under Clang in Linux.\r\n\r\nThe REQUIRE line looks like this:\r\n\r\nREQUIRE(str1 == \"Item1\");\r\n\r\nThe error we get is the following:\r\n\r\n19>project_path\\catch.hpp(810,21): error : use of overloaded operator '<<' is ambiguous (with operand types 'Catch::ReusableStringStream' and 'const MyCustomStringClass<char>')\r\n19>                rss << value;\r\n19>                ~~~ ^  ~~~~~\r\n19>project_path\\catch.hpp(829,114): note: in instantiation of function template specialization 'Catch::StringMaker<type, void>::convert<MyCustomStringClass<char> >' requested here\r\n19>            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\r\n19>                                                                                                                 ^\r\n19>project_path\\catch.hpp(1325,42): note: in instantiation of function template specialization 'Catch::Detail::stringify<MyCustomStringClass<char> >' requested here\r\n19>                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\r\n19>                                         ^\r\n19>project_path\\MyCppFile.cpp(243,75): note: in instantiation of member function 'Catch::BinaryExpr<const MyCustomStringClass<char> &, char const &[6]>::streamReconstructedExpression' requested here\r\n19>                    REQUIRE(str1 == \"Item1\");\r\n\r\n\r\n### Extra information\r\n  Disabling stringification with CATCH_CONFIG_DISABLE_STRINGIFICATION does not help solve this issue.\r\n\r\n   Commenting out the following line in catch.hpp fixes the compilation error:\r\n   This code starts in line 801:\r\n\r\n    template <typename T, typename = void>\r\n    struct StringMaker {\r\n        template <typename Fake = T>\r\n        static\r\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\r\n            convert(const Fake& value) {\r\n                ReusableStringStream rss;\r\n\r\n                // this line causes the problem\r\n                // rss << value;\r\n\r\n                return rss.str();\r\n        }\r\n\r\n\r\n* Catch version: **v2.2.2**\r\n* Operating System: **Linux**\r\n* Compiler+version: **Clang**\r\n\nClang compilation fails when using REQUIRE with custom string classes that overload the << operator\n## Description\r\n\r\nWe have our own custom string class that overloads the << operator, and it's causing issues when using the REQUIRE macro and compiling under Clang in Linux.\r\n\r\nThe REQUIRE line looks like this:\r\n\r\nREQUIRE(str1 == \"Item1\");\r\n\r\nThe error we get is the following:\r\n\r\n19>project_path\\catch.hpp(810,21): error : use of overloaded operator '<<' is ambiguous (with operand types 'Catch::ReusableStringStream' and 'const MyCustomStringClass<char>')\r\n19>                rss << value;\r\n19>                ~~~ ^  ~~~~~\r\n19>project_path\\catch.hpp(829,114): note: in instantiation of function template specialization 'Catch::StringMaker<type, void>::convert<MyCustomStringClass<char> >' requested here\r\n19>            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\r\n19>                                                                                                                 ^\r\n19>project_path\\catch.hpp(1325,42): note: in instantiation of function template specialization 'Catch::Detail::stringify<MyCustomStringClass<char> >' requested here\r\n19>                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\r\n19>                                         ^\r\n19>project_path\\MyCppFile.cpp(243,75): note: in instantiation of member function 'Catch::BinaryExpr<const MyCustomStringClass<char> &, char const &[6]>::streamReconstructedExpression' requested here\r\n19>                    REQUIRE(str1 == \"Item1\");\r\n\r\n\r\n### Extra information\r\n  Disabling stringification with CATCH_CONFIG_DISABLE_STRINGIFICATION does not help solve this issue.\r\n\r\n   Commenting out the following line in catch.hpp fixes the compilation error:\r\n   This code starts in line 801:\r\n\r\n    template <typename T, typename = void>\r\n    struct StringMaker {\r\n        template <typename Fake = T>\r\n        static\r\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\r\n            convert(const Fake& value) {\r\n                ReusableStringStream rss;\r\n\r\n                // this line causes the problem\r\n                // rss << value;\r\n\r\n                return rss.str();\r\n        }\r\n\r\n\r\n* Catch version: **v2.2.2**\r\n* Operating System: **Linux**\r\n* Compiler+version: **Clang**\r\n\n", "hints_text": "This seems to be the case when operator<< is templated. Otherwise there should be no ambiguity.\r\nSpecializing StringMaker<> for the type works around the issue.\nThis seems to be the case when operator<< is templated. Otherwise there should be no ambiguity.\r\nSpecializing StringMaker<> for the type works around the issue.", "created_at": "2018-06-05T04:30:07Z"}
{"repo": "catchorg/Catch2", "pull_number": 1296, "instance_id": "catchorg__Catch2-1296", "issue_numbers": ["1225"], "base_commit": "df0b0e64e11e1dd3c8364630cfb41397d21795a5", "patch": "diff --git a/include/internal/catch_fatal_condition.cpp b/include/internal/catch_fatal_condition.cpp\n--- a/include/internal/catch_fatal_condition.cpp\n+++ b/include/internal/catch_fatal_condition.cpp\n@@ -94,6 +94,11 @@ namespace Catch {\n         int id;\n         const char* name;\n     };\n+    \n+    // 32kb for the alternate stack seems to be sufficient. However, this value\n+    // is experimentally determined, so that's not guaranteed.\n+    constexpr static std::size_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;\n+\n     static SignalDefs signalDefs[] = {\n         { SIGINT,  \"SIGINT - Terminal interrupt signal\" },\n         { SIGILL,  \"SIGILL - Illegal instruction signal\" },\n@@ -121,7 +126,7 @@ namespace Catch {\n         isSet = true;\n         stack_t sigStack;\n         sigStack.ss_sp = altStackMem;\n-        sigStack.ss_size = SIGSTKSZ;\n+        sigStack.ss_size = sigStackSize;\n         sigStack.ss_flags = 0;\n         sigaltstack(&sigStack, &oldSigStack);\n         struct sigaction sa = { };\n@@ -153,7 +158,7 @@ namespace Catch {\n     bool FatalConditionHandler::isSet = false;\n     struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};\n     stack_t FatalConditionHandler::oldSigStack = {};\n-    char FatalConditionHandler::altStackMem[SIGSTKSZ] = {};\n+    char FatalConditionHandler::altStackMem[sigStackSize] = {};\n \n \n } // namespace Catch\n", "test_patch": "", "problem_statement": "Buffer Overflow\n## Description\r\n\r\nIt seems to me that there is a buffer overflow in the signal handling routine.\r\nAre you doing shenanigans in there? The only _C++_ legal thing to do in a signal handler is setting a `volatile sigatomic_t`, anything else is UB.\r\n(POSIX has a different opinion on that, and is saying that pretty much all the syscalls are fine. C or C++ stdlib is still off-limits, though)\r\n\r\n\r\n### Steps to reproduce\r\n- Compile with ASan enabled\r\n- Trigger an error in a catch `TEST_CASE`\r\n\r\n### Report\r\n\r\n```\r\n=================================================================\r\n==21739==ERROR: AddressSanitizer: global-buffer-overflow on address 0x000001ed0efc at pc 0x0000004abab2 bp 0x000001ed0e70 sp 0x000001ed0620\r\nREAD of size 1 at 0x000001ed0efc thread T0\r\n    #0 0x4abab1 in fwrite /root/tmp/llvm/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1051\r\n    #1 0x7fcf91b2c58d in std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long) (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0x10d58d)\r\n    #2 0x7fcf91b2c827 in std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char) (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0x10d827)\r\n    #3 0x686dd1 in Catch::(anonymous namespace)::PosixColourImpl::setColour(char const*) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:6763:27\r\n    #4 0x686ac2 in Catch::(anonymous namespace)::PosixColourImpl::use(Catch::Colour::Code) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:6748:52\r\n    #5 0x6372a5 in Catch::Colour::use(Catch::Colour::Code) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:6819:15\r\n    #6 0x6371cc in Catch::Colour::Colour(Catch::Colour::Code) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:6804:42\r\n    #7 0x68974d in Catch::(anonymous namespace)::AssertionPrinter::printSourceInfo() const /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:11110:16\r\n    #8 0x66be0f in Catch::(anonymous namespace)::AssertionPrinter::print() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:11041:9\r\n    #9 0x66b6e2 in Catch::CompactReporter::assertionEnded(Catch::AssertionStats const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:11226:21\r\n    #10 0x64c2e1 in Catch::RunContext::assertionEnded(Catch::AssertionResult const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8466:39\r\n    #11 0x64e3f3 in Catch::RunContext::handleFatalErrorCondition(Catch::StringRef) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8565:9\r\n    #12 0x638ff8 in (anonymous namespace)::reportFatal(char const*) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:7127:56\r\n    #13 0x638d3d in Catch::FatalConditionHandler::handleSignal(int) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:7235:9\r\n    #14 0x7fcf916b302f  (/lib/x86_64-linux-gnu/libc.so.6+0x3302f)\r\n    #15 0x56531b in a::atomic::detail::load_relaxed(a::atomic::detail::uint128_atomic const*) /root/p4/depot/_out/../liba/include/a/bits/atomic_gcc.hxx:659:5\r\n    #16 0x5651d7 in a::atomic::detail::uint128_atomic::Type a::atomic::LoadSeqCst<a::atomic::detail::uint128_atomic>(a::atomic::detail::uint128_atomic const*) /root/p4/depot/_out/../liba/include/a/bits/atomic.hxx:73:28\r\n    #17 0x564d0a in a::atomic::detail::uint128_atomic::Type a::atomic::Load<a::atomic::detail::uint128_atomic>(a::atomic::detail::uint128_atomic const*, a::atomic::MemoryOrder) /root/p4/depot/_out/../liba/include/a/bits/atomic.hxx:91:16\r\n    #18 0x5622ee in a::Atomic128::Load(a::MemoryOrder) const /root/p4/depot/_out/../liba/include/a/atomic.hxx:303:16\r\n    #19 0x55acec in ____C_A_T_C_H____T_E_S_T____25() /root/p4/depot/_out/../liba/tests/atomic.cxx:188:30\r\n    #20 0x65d6ba in Catch::TestInvokerAsFunction::invoke() const /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9870:9\r\n    #21 0x64f625 in Catch::TestCase::invoke() const /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9771:15\r\n    #22 0x64f46a in Catch::RunContext::invokeActiveTestCase() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8655:27\r\n    #23 0x64b403 in Catch::RunContext::runCurrentTest(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8630:17\r\n    #24 0x648eeb in Catch::RunContext::runTest(Catch::TestCase const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8419:13\r\n    #25 0x6559f9 in Catch::(anonymous namespace)::runTests(std::shared_ptr<Catch::Config> const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8967:39\r\n    #26 0x6542b3 in Catch::Session::runInternal() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9151:63\r\n    #27 0x653d0d in Catch::Session::run() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9108:24\r\n    #28 0x6862f6 in main /root/p4/depot/_out/../liba/tests/driver.cxx:36:20\r\n    #29 0x7fcf916a02b0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202b0)\r\n    #30 0x42ed49 in _start (/root/p4/depot/_out/tests/a+0x42ed49)\r\n\r\n0x000001ed0efc is located 36 bytes to the left of global variable 'Catch::FatalConditionHandler::altStackMem' defined in '../extern/lib/catch2/single_include/catch.hpp:7274:33' (0x1ed0f20) of size 8192\r\n0x000001ed0efc is located 204 bytes to the right of global variable 'Catch::FatalConditionHandler::oldSigActions' defined in '../extern/lib/catch2/single_include/catch.hpp:7272:45' (0x1ed0aa0) of size 912\r\nSUMMARY: AddressSanitizer: global-buffer-overflow /root/tmp/llvm/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1051 in fwrite\r\nShadow bytes around the buggy address:\r\n  0x0000803d2180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0000803d2190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0000803d21a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0000803d21b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0000803d21c0: 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9\r\n=>0x0000803d21d0: f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9[f9]\r\n  0x0000803d21e0: f9 f9 f9 f9 00 00 00 00 f1 f1 f1 f1 f8 f8 f8 f8\r\n  0x0000803d21f0: f2 f2 f2 f2 f8 f8 f2 f2 f8 f8 f3 f3 00 00 00 00\r\n  0x0000803d2200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0000803d2210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x0000803d2220: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n==21739==ABORTING\r\n```\r\n\r\n### Extra information\r\n* Catch version: **v2.1.0**\r\n* Operating System: **Linux arvid.io 4.9.0-3-amd64 #1 SMP Debian 4.9.30-2+deb9u2 (2017-06-26) x86_64 GNU/Linux**\r\n* Compiler+version: **clang 5.0.1**\r\n\n", "hints_text": "There is more:\r\n\r\n```\r\n=================================================================\r\n==2961==ERROR: AddressSanitizer: heap-use-after-free on address 0x604000005950 at pc 0x0000006382da bp 0x000001feb0d0 sp 0x000001feb0c8\r\nREAD of size 8 at 0x604000005950 thread T0\r\n    #0 0x6382d9 in Catch::Colour::use(Catch::Colour::Code) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:6819:15\r\n    #1 0x638241 in Catch::Colour::Colour(Catch::Colour::Code) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:6804:42\r\n    #2 0x68c556 in Catch::(anonymous namespace)::AssertionPrinter::printExpressionWas() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:11132:24\r\n    #3 0x66dc10 in Catch::(anonymous namespace)::AssertionPrinter::print() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:11075:13\r\n    #4 0x66cbe2 in Catch::CompactReporter::assertionEnded(Catch::AssertionStats const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:11226:21\r\n    #5 0x64d4a0 in Catch::RunContext::assertionEnded(Catch::AssertionResult const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8466:39\r\n    #6 0x64f5c3 in Catch::RunContext::handleFatalErrorCondition(Catch::StringRef) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8565:9\r\n    #7 0x63a0b8 in (anonymous namespace)::reportFatal(char const*) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:7127:56\r\n    #8 0x639df2 in Catch::FatalConditionHandler::handleSignal(int) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:7235:9\r\n    #9 0x7f169df2e02f  (/lib/x86_64-linux-gnu/libc.so.6+0x3302f)\r\n    #10 0x564b9b in a::atomic::detail::load_relaxed(a::atomic::detail::uint128_atomic const*) /root/p4/depot/_out/../liba/include/a/bits/atomic_gcc.hxx:659:5\r\n    #11 0x564a57 in a::atomic::detail::uint128_atomic::Type a::atomic::LoadSeqCst<a::atomic::detail::uint128_atomic>(a::atomic::detail::uint128_atomic const*) /root/p4/depot/_out/../liba/include/a/bits/atomic.hxx:73:28\r\n    #12 0x56458a in a::atomic::detail::uint128_atomic::Type a::atomic::Load<a::atomic::detail::uint128_atomic>(a::atomic::detail::uint128_atomic const*, a::atomic::MemoryOrder) /root/p4/depot/_out/../liba/include/a/bits/atomic.hxx:91:16\r\n    #13 0x561e2e in a::Atomic128::Load(a::MemoryOrder) const /root/p4/depot/_out/../liba/include/a/atomic.hxx:303:16\r\n    #14 0x55b59a in ____C_A_T_C_H____T_E_S_T____25() /root/p4/depot/_out/../liba/tests/atomic.cxx:199:30\r\n    #15 0x65e9ba in Catch::TestInvokerAsFunction::invoke() const /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9870:9\r\n    #16 0x6507f5 in Catch::TestCase::invoke() const /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9771:15\r\n    #17 0x65063a in Catch::RunContext::invokeActiveTestCase() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8655:27\r\n    #18 0x64c5b7 in Catch::RunContext::runCurrentTest(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8630:17\r\n    #19 0x64a08b in Catch::RunContext::runTest(Catch::TestCase const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8419:13\r\n    #20 0x656c79 in Catch::(anonymous namespace)::runTests(std::shared_ptr<Catch::Config> const&) /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:8967:39\r\n    #21 0x655527 in Catch::Session::runInternal() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9151:63\r\n    #22 0x654f62 in Catch::Session::run() /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:9108:24\r\n    #23 0x6878f6 in main /root/p4/depot/_out/../liba/tests/driver.cxx:36:20\r\n    #24 0x7f169df1b2b0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202b0)\r\n    #25 0x42ed89 in _start (/root/p4/depot/_out/tests/a+0x42ed89)\r\n\r\n0x604000005950 is located 0 bytes inside of 36-byte region [0x604000005950,0x604000005974)\r\nfreed by thread T0 here:\r\n    #0 0x523d70 in operator delete(void*) /root/tmp/llvm/compiler-rt/lib/asan/asan_new_delete.cc:137\r\n\r\npreviously allocated by thread T0 here:\r\n    #0 0x522ff8 in operator new(unsigned long) /root/tmp/llvm/compiler-rt/lib/asan/asan_new_delete.cc:92\r\n\r\nSUMMARY: AddressSanitizer: heap-use-after-free /root/p4/depot/_out/../extern/lib/catch2/single_include/catch.hpp:6819:15 in Catch::Colour::use(Catch::Colour::Code)\r\nShadow bytes around the buggy address:\r\n  0x0c087fff8ad0: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fd\r\n  0x0c087fff8ae0: fa fa fd fd fd fd fd fd fa fa fd fd fd fd fd fd\r\n  0x0c087fff8af0: fa fa 00 00 00 00 00 fa fa fa 00 00 00 00 00 fa\r\n  0x0c087fff8b00: fa fa 00 00 00 00 00 fa fa fa fd fd fd fd fd fa\r\n  0x0c087fff8b10: fa fa fd fd fd fd fd fa fa fa 00 00 00 00 00 fa\r\n=>0x0c087fff8b20: fa fa 00 00 00 00 00 fa fa fa[fd]fd fd fd fd fa\r\n  0x0c087fff8b30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c087fff8b40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c087fff8b50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c087fff8b60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c087fff8b70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n```\nPotentially false positives, due to not having instrumented the standard library. Take with a grain of salt, and re-test with an instrumented libcxx.", "created_at": "2018-05-27T16:28:57Z"}
{"repo": "catchorg/Catch2", "pull_number": 1271, "instance_id": "catchorg__Catch2-1271", "issue_numbers": ["1257"], "base_commit": "7abd7db2c8f03cc2e51ea49fff5247ee5e83464b", "patch": "diff --git a/include/internal/catch_output_redirect.cpp b/include/internal/catch_output_redirect.cpp\n--- a/include/internal/catch_output_redirect.cpp\n+++ b/include/internal/catch_output_redirect.cpp\n@@ -49,7 +49,7 @@ namespace Catch {\n \n \n \n-#if defined(CATCH_PLATFORM_WINDOWS)\n+#if defined(_MSC_VER)\n     TempFile::TempFile() {\n         if (tmpnam_s(m_buffer)) {\n             throw std::runtime_error(\"Could not get a temp filename\");\n@@ -77,7 +77,7 @@ namespace Catch {\n          std::fclose(m_file);\n          // We manually create the file on Windows only, on Linux\n          // it will be autodeleted\n-#if defined(CATCH_PLATFORM_WINDOWS)\n+#if defined(_MSC_VER)\n          std::remove(m_buffer);\n #endif\n     }\n@@ -125,7 +125,7 @@ namespace Catch {\n \n } // namespace Catch\n \n-#if defined(CATCH_PLATFORM_WINDOWS)\n+#if defined(_MSC_VER)\n #undef dup\n #undef dup2\n #undef fileno\n", "test_patch": "", "problem_statement": "Cannot compile library\n## Description\r\nI can't compile this library.\r\n![Error](https://i.imgur.com/cAHYGIA.png)\r\n\r\n### Steps to reproduce\r\nJust try to compile the library using CMake `GLOB_RECURSE` and compiler which you can see in `Extra information`. If you want to full reproduce, you'll look through [this repo](https://github.com/Good-Pudge/okhttp-fork). Use this script:\r\n```bash\r\ngit clone --recursive https://github.com/Good-Pudge/okhttp-fork.git\r\ncd okhttp-fork\r\nmkdir build\r\ncd build\r\ncmake .. -DBUILD_TESTING=ON -G \"MinGW Makefiles\"\r\ncmake --build . --target ohf_tests -- -j4\r\n```\r\n\r\n### <a name=\"extra\"></a> Extra information\r\n* Catch version: **v2.2.2**\r\n* Operating System: **Windows 10 Pro v1709 x64**\r\n* Compiler+version: **MinGW-w64 7.2.0**\r\n\n", "hints_text": "Define `CATCH_CONFIG_NO_POSIX_SIGNALS` to fix it for now.\r\n\r\nThe underlying problem is that MinGW is detected as generic GCC variant, so POSIX signals are expected to work. However, they do not.", "created_at": "2018-05-01T12:40:21Z"}
{"repo": "catchorg/Catch2", "pull_number": 1163, "instance_id": "catchorg__Catch2-1163", "issue_numbers": ["1162"], "base_commit": "5e484862f2198b3501457f054f52228960d4d9a3", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -187,6 +187,7 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_timer.h\n         ${HEADER_DIR}/internal/catch_tostring.h\n         ${HEADER_DIR}/internal/catch_totals.h\n+        ${HEADER_DIR}/internal/catch_uncaught_exceptions.h\n         ${HEADER_DIR}/internal/catch_user_interfaces.h\n         ${HEADER_DIR}/internal/catch_version.h\n         ${HEADER_DIR}/internal/catch_wildcard_pattern.h\n@@ -247,6 +248,7 @@ set(IMPL_SOURCES\n         ${HEADER_DIR}/internal/catch_timer.cpp\n         ${HEADER_DIR}/internal/catch_tostring.cpp\n         ${HEADER_DIR}/internal/catch_totals.cpp\n+        ${HEADER_DIR}/internal/catch_uncaught_exceptions.cpp\n         ${HEADER_DIR}/internal/catch_version.cpp\n         ${HEADER_DIR}/internal/catch_wildcard_pattern.cpp\n         ${HEADER_DIR}/internal/catch_xmlwriter.cpp\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -31,6 +31,14 @@\n #    define CATCH_CPP14_OR_GREATER\n #  endif\n \n+#  if __cplusplus >= 201703L\n+#    define CATCH_CPP17_OR_GREATER\n+#  endif\n+\n+#endif\n+\n+#if defined(CATCH_CPP17_OR_GREATER)\n+#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n #endif\n \n #ifdef __clang__\n@@ -80,6 +88,11 @@\n // Visual C++\n #ifdef _MSC_VER\n \n+\n+#  if _MSC_VER >= 1900 // Visual Studio 2015 or newer\n+#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n+#  endif\n+\n // Universal Windows platform does not support SEH\n // Or console colours (or console at all...)\n #  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)\n@@ -112,6 +125,11 @@\n #   define CATCH_CONFIG_POSIX_SIGNALS\n #endif\n \n+#if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_INTERNAL_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)\n+#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n+#endif\n+\n+\n #if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)\n #   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS\n #   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS\ndiff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -8,6 +8,7 @@\n \n #include \"catch_message.h\"\n #include \"catch_interfaces_capture.h\"\n+#include \"catch_uncaught_exceptions.h\"\n \n namespace Catch {\n \n@@ -49,18 +50,9 @@ namespace Catch {\n         getResultCapture().pushScopedMessage( m_info );\n     }\n \n-#if defined(_MSC_VER)\n-#pragma warning(push)\n-#pragma warning(disable:4996) // std::uncaught_exception is deprecated in C++17\n-#endif\n     ScopedMessage::~ScopedMessage() {\n-        if ( !std::uncaught_exception() ){\n+        if ( !uncaught_exceptions() ){\n             getResultCapture().popScopedMessage(m_info);\n         }\n     }\n-#if defined(_MSC_VER)\n-#pragma warning(pop)\n-#endif\n-\n-\n } // end namespace Catch\ndiff --git a/include/internal/catch_section.cpp b/include/internal/catch_section.cpp\n--- a/include/internal/catch_section.cpp\n+++ b/include/internal/catch_section.cpp\n@@ -8,6 +8,7 @@\n \n #include \"catch_section.h\"\n #include \"catch_capture.hpp\"\n+#include \"catch_uncaught_exceptions.h\"\n \n namespace Catch {\n \n@@ -18,22 +19,15 @@ namespace Catch {\n         m_timer.start();\n     }\n \n-#if defined(_MSC_VER)\n-#pragma warning(push)\n-#pragma warning(disable:4996) // std::uncaught_exception is deprecated in C++17\n-#endif\n     Section::~Section() {\n         if( m_sectionIncluded ) {\n             SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );\n-            if( std::uncaught_exception() )\n+            if( uncaught_exceptions() )\n                 getResultCapture().sectionEndedEarly( endInfo );\n             else\n                 getResultCapture().sectionEnded( endInfo );\n         }\n     }\n-#if defined(_MSC_VER)\n-#pragma warning(pop)\n-#endif\n \n     // This indicates whether the section should be executed or not\n     Section::operator bool() const {\ndiff --git a/include/internal/catch_uncaught_exceptions.cpp b/include/internal/catch_uncaught_exceptions.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/catch_uncaught_exceptions.cpp\n@@ -0,0 +1,22 @@\n+/*\n+ *  Created by Josh on 1/2/2018.\n+ *  Copyright 2018 Two Blue Cubes Ltd. All rights reserved.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#include \"catch_compiler_capabilities.h\"\n+#include \"catch_uncaught_exceptions.h\"\n+#include <exception>\n+\n+namespace Catch {\n+    bool uncaught_exceptions() {\n+// https://github.com/catchorg/Catch2/issues/1162\n+#if defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)\n+        return std::uncaught_exceptions() > 0;\n+#else\n+        return std::uncaught_exception();\n+#endif\n+  }\n+} // end namespace Catch\ndiff --git a/include/internal/catch_uncaught_exceptions.h b/include/internal/catch_uncaught_exceptions.h\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/catch_uncaught_exceptions.h\n@@ -0,0 +1,15 @@\n+/*\n+ *  Created by Josh on 1/2/2018.\n+ *  Copyright 2018 Two Blue Cubes Ltd. All rights reserved.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+#ifndef TWOBLUECUBES_CATCH_UNCAUGHT_EXCEPTIONS_H_INCLUDED\n+#define TWOBLUECUBES_CATCH_UNCAUGHT_EXCEPTIONS_H_INCLUDED\n+\n+namespace Catch {\n+    bool uncaught_exceptions();\n+} // end namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_UNCAUGHT_EXCEPTIONS_H_INCLUDED\n", "test_patch": "", "problem_statement": "std::uncaught_exception() is deprecated \n## Description\r\nWarning in VS2017 15.5.1:\r\n\r\n```Severity\tCode\tDescription\tProject\tFile\tLine\tSuppression State\r\nWarning\tC4996\t'std::uncaught_exception': warning STL4006: std::uncaught_exception() is deprecated in C++17. It is superseded by std::uncaught_exceptions(), plural. You can define _SILENCE_CXX17_UNCAUGHT_EXCEPTION_DEPRECATION_WARNING or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to acknowledge that you have received this warning.\tdata_structs\tc:\\users\\josh\\projects\\cpp-book\\manuscript\\part_2\\11-utilities\\examples\\catch.hpp\t7196\r\n```\r\n\r\n\r\n### Steps to reproduce\r\nCompile any file including the `catch.hpp` header with VS2017 15.5.1\r\n\r\n### Extra information\r\n\r\n* Catch version: master\r\n* Operating System: Win10\r\n* Compiler+version:  VS2017 15.5.1\r\n\n", "hints_text": "", "created_at": "2018-01-26T16:11:37Z"}
{"repo": "catchorg/Catch2", "pull_number": 1091, "instance_id": "catchorg__Catch2-1091", "issue_numbers": ["1090"], "base_commit": "3b801c4fda8a642c638791e7493f8b83f6c210b8", "patch": "diff --git a/include/internal/catch_suppress_warnings.h b/include/internal/catch_suppress_warnings.h\n--- a/include/internal/catch_suppress_warnings.h\n+++ b/include/internal/catch_suppress_warnings.h\n@@ -17,8 +17,8 @@\n #       pragma clang diagnostic ignored \"-Wcovered-switch-default\"\n #    endif\n #elif defined __GNUC__\n-#    pragma GCC diagnostic ignored \"-Wunused-variable\"\n #    pragma GCC diagnostic ignored \"-Wparentheses\"\n #    pragma GCC diagnostic push\n+#    pragma GCC diagnostic ignored \"-Wunused-variable\"\n #    pragma GCC diagnostic ignored \"-Wpadded\"\n #endif\n", "test_patch": "", "problem_statement": "Catch disables GCC unused variable warnings in test files.\n## Description\r\nWhen compiling a test file with an unused variable no warning was generated under GCC.\r\nAfter removing the catch #include the compiler warning came back.\r\n\r\nDiscovered this when debugging a unit test and found an unused variable and expected that my compiler should be throwing a warning.\r\n\r\n### Steps to reproduce\r\nGiven:\r\n```cpp\r\n#include \"catch.hpp\"\r\nstatic int test;\r\n```\r\nCompile with\r\n```bash\r\ng++ test.cpp -Wall\r\n```\r\nExpecting a warning but none given.\r\n\r\nAfter removing the catch include we get:\r\n```\r\ntest.cpp:3:12: warning: 'test' defined but not used [-Wunused-variable]\r\n```\r\n\r\n### Extra information\r\n* Catch version: **v2.0.1**\r\n* Operating System: **Windows 7**\r\n* Compiler+version: **GCC v7.1.0 (MinGW-W64)**\r\n\r\nSeems to a from this section in catch_suppress_warnings.h:\r\n```c\r\n#elif defined __GNUC__\r\n#    pragma GCC diagnostic ignored \"-Wvariadic-macros\"\r\n#    pragma GCC diagnostic ignored \"-Wunused-variable\"\r\n#    pragma GCC diagnostic ignored \"-Wparentheses\"\r\n\r\n#    pragma GCC diagnostic push\r\n#    pragma GCC diagnostic ignored \"-Wpadded\"\r\n#endif\r\n```\r\nLooks like the three warnings suppression are leaked to user code. Should they be moved to after the `push`?\r\n\r\nMoving the push to be the first GCC pragma seems to fix it for me and no other warnings are reported.\n", "hints_text": "", "created_at": "2017-11-09T23:09:25Z"}
{"repo": "catchorg/Catch2", "pull_number": 963, "instance_id": "catchorg__Catch2-963", "issue_numbers": ["961"], "base_commit": "7a22bad76340f8b48094b46bc586e76ac9ea93ac", "patch": "diff --git a/include/reporters/catch_reporter_bases.hpp b/include/reporters/catch_reporter_bases.hpp\n--- a/include/reporters/catch_reporter_bases.hpp\n+++ b/include/reporters/catch_reporter_bases.hpp\n@@ -137,7 +137,8 @@ namespace Catch {\n             BySectionInfo( SectionInfo const& other ) : m_other( other ) {}\n             BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}\n             bool operator() ( Ptr<SectionNode> const& node ) const {\n-                return node->stats.sectionInfo.lineInfo == m_other.lineInfo;\n+                return ((node->stats.sectionInfo.name == m_other.name) &&\n+                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));\n             }\n         private:\n             void operator=( BySectionInfo const& );\n", "test_patch": "", "problem_statement": "Dynamically created sections not reported when using JUnit reporter\nHi, first of all thank you for your work in Catch. I 'm having a problem when running test sections under for loops and using JUnit reporter. \r\n\r\nIf I do something like this:\r\n\r\n```\r\n#define CATCH_CONFIG_MAIN\r\n#include \"catch.hpp\"\r\n\r\nTEST_CASE(\"LoopedTest\"){\r\n\r\n    for (int i=1; i<6; i++){\r\n        SECTION(\"LoopedSection\"+std::to_string(i)){\r\n            CHECK(true);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd run it with: `./CatchTest -s -r junit`. I get:\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<testsuites>\r\n<testsuite name=\"CatchTest\" errors=\"0\" failures=\"0\" tests=\"5\" hostname=\"tbd\" time=\"0.000208\" timestamp=\"2017-07-21T08:11:26Z\">\r\n<testcase classname=\"LoopedTest\" name=\"LoopedSection5\" time=\"0.000006\"/>\r\n<system-out/>\r\n<system-err/>\r\n</testsuite>\r\n</testsuites>\r\n```\r\n\r\nWhen I would like to get something like:\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<testsuites>\r\n<testsuite name=\"CatchTest\" errors=\"0\" failures=\"0\" tests=\"5\" hostname=\"tbd\" time=\"0.000208\" timestamp=\"2017-07-21T08:11:26Z\">\r\n<testcase classname=\"LoopedTest\" name=\"LoopedSection1\" time=\"0.000006\"/>   \r\n<testcase classname=\"LoopedTest\" name=\"LoopedSection2\" time=\"0.000006\"/>\r\n<testcase classname=\"LoopedTest\" name=\"LoopedSection3\" time=\"0.000006\"/>\r\n<testcase classname=\"LoopedTest\" name=\"LoopedSection4\" time=\"0.000006\"/>\r\n<testcase classname=\"LoopedTest\" name=\"LoopedSection5\" time=\"0.000006\"/>\r\n<system-out/>\r\n<system-err/>\r\n</testsuite>\r\n</testsuites>\r\n```\r\n\r\nIf I use the console or compact reporter I can see that all the dynamically created sections are being called:\r\n```\r\n./CatchTest -s -r compact\r\n/home/fgarcia/Proyectos/CatchTest/main.cpp:8: passed: true\r\n/home/fgarcia/Proyectos/CatchTest/main.cpp:8: passed: true\r\n/home/fgarcia/Proyectos/CatchTest/main.cpp:8: passed: true\r\n/home/fgarcia/Proyectos/CatchTest/main.cpp:8: passed: true\r\n/home/fgarcia/Proyectos/CatchTest/main.cpp:8: passed: true\r\nPassed 1 test case with 5 assertions.\r\n\r\n ./CatchTest -r console\r\n===============================================================================\r\nAll tests passed (5 assertions in 1 test case)\r\n```\r\nIs this a bug in JUnit reporter?\r\n\r\n* Catch version: **Catch v1.9.6**\r\n* Operating System: **Ubuntu 16.04.2 LTS x64**\r\n* Compiler+version: **gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4)**\r\n\n", "hints_text": "Definitely a bug, there is nothing in the JUnit spec saying that dynamically created sections shouldn't be reported", "created_at": "2017-07-22T10:52:11Z"}
{"repo": "catchorg/Catch2", "pull_number": 877, "instance_id": "catchorg__Catch2-877", "issue_numbers": ["872"], "base_commit": "0354d50278d725d52084601300eb955cee6756d8", "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -72,6 +72,7 @@ namespace Detail {\n \n     extern const std::string unprintableString;\n \n+ #if !defined(CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)\n     struct BorgType {\n         template<typename T> BorgType( T const& );\n     };\n@@ -90,6 +91,20 @@ namespace Detail {\n         static T  const&t;\n         enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };\n     };\n+#else\n+    template<typename T>\n+    class IsStreamInsertable {\n+        template<typename SS, typename TT>\n+        static auto test(int)\n+        -> decltype( std::declval<SS&>() << std::declval<TT>(), std::true_type() );\n+\n+        template<typename, typename>\n+        static auto test(...) -> std::false_type;\n+\n+    public:\n+        static const bool value = decltype(test<std::ostream,const T&>(0))::value;\n+    };\n+#endif\n \n #if defined(CATCH_CONFIG_CPP11_IS_ENUM)\n     template<typename T,\n", "test_patch": "diff --git a/projects/SelfTest/CompilationTests.cpp b/projects/SelfTest/CompilationTests.cpp\n--- a/projects/SelfTest/CompilationTests.cpp\n+++ b/projects/SelfTest/CompilationTests.cpp\n@@ -51,3 +51,22 @@ TEST_CASE(\"#833\") {\n     REQUIRE(templated_tests<int>(3));\n }\n \n+// Test containing example where original stream insertable check breaks compilation\n+#if defined (CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)\n+namespace {\n+    struct A {};\n+    std::ostream& operator<< (std::ostream &o, const A &) { return o << 0; }\n+\n+    struct B : private A {\n+        bool operator== (int) const { return true; }\n+    };\n+\n+    B f ();\n+    std::ostream g ();\n+}\n+\n+TEST_CASE( \"#872\" ) {\n+    B x;\n+    REQUIRE (x == 4);\n+}\n+#endif\n", "problem_statement": "Compilation error when private base of class of tested variable is \"ostreamable\" but class itself isn't\n## Description\r\nWhen private base of class of tested variable is \"ostreamable\" but class itself isn't test code fails to compile.\r\n\r\n### Steps to reproduce\r\n```\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch.hpp>\r\nstruct A {};\r\nstd::ostream &operator<< (std::ostream &o, const A &v) { return o << 0;}\r\n\r\nstruct B : private A\r\n{\r\n    bool operator==(int){ return true;}\r\n};\r\n\r\nB f ();\r\nstd::ostream g ();\r\n\r\nTEST_CASE (\"asdas\")\r\n{\r\n    B x;\r\n    REQUIRE (x == 4);\r\n}\r\n\r\n```\r\n\r\n>main.cpp:1579:49: error: 'A' is an inaccessible base of 'B'\r\n>         enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };\r\n\r\nSo the problem is in `IsStreamInsertable` check which features converting type to some bogus stremable type named `Borgtype` which everything converts to but it's pretty obvious that converting to your base class is still easier and thus error happens. It seems like replacing this check to the one featured in [this stackoverflow answer](http://stackoverflow.com/a/22759544/1269661) fixes this problem. I can send pull-request if that's needed and proposed solution is fine.\r\n\r\n### Extra information\r\n* Catch version: 1.8.2\r\n* Operating System: Windows + online compilers\r\n* Compiler+version: g++ 6.3.0, clang 3.8, MSVC 2017\r\n\n", "hints_text": "Thanks for bringing this up, @Predelnik. We haven't had an `IsStreamInsertable` issue for a while.\r\nThat SO answer is interesting. It can't be used as-is as it relies on (quite a few, actually) C++11 features - and Catch (1.x, at least) needs to keep working on pre-C++11 compilers.\r\nBut if the approach there is genuinely better we could do something conditionally (and would also be useful for Catch2 - which will assume C++11).\r\nThe \"genuinely better\" qualification is there because I know from looking at this before that every technique I investigated had one trade-off or another. That was a few years ago and I don't recall seeing anything like this one - so maybe it's better? But I'd like to see it more road tested before I switch it in by default (even for C++11 compilers) as if it has different trade-offs to the current approach then it will break currently working code.\r\n\r\nSo I think a starting point is to include it as an \"opt-in\" alternative.\r\n\r\nIf you're happy to put together a PR for that I'd be grateful. Otherwise I'll try and get to it myself in the near future (but not this week).\r\n", "created_at": "2017-04-02T11:09:42Z"}
{"repo": "catchorg/Catch2", "pull_number": 876, "instance_id": "catchorg__Catch2-876", "issue_numbers": ["748"], "base_commit": "3a3f1529794059e1f8947c1d44ed10327b2a35d8", "patch": "diff --git a/include/internal/catch_message.hpp b/include/internal/catch_message.hpp\n--- a/include/internal/catch_message.hpp\n+++ b/include/internal/catch_message.hpp\n@@ -38,7 +38,10 @@ namespace Catch {\n     {}\n \n     ScopedMessage::~ScopedMessage() {\n-        getResultCapture().popScopedMessage( m_info );\n+        if (!std::uncaught_exception())\n+        {\n+            getResultCapture().popScopedMessage(m_info);\n+        }\n     }\n \n \ndiff --git a/include/reporters/catch_reporter_console.hpp b/include/reporters/catch_reporter_console.hpp\n--- a/include/reporters/catch_reporter_console.hpp\n+++ b/include/reporters/catch_reporter_console.hpp\n@@ -138,7 +138,11 @@ namespace Catch {\n                     case ResultWas::ThrewException:\n                         colour = Colour::Error;\n                         passOrFail = \"FAILED\";\n-                        messageLabel = \"due to unexpected exception with message\";\n+                        messageLabel = \"due to unexpected exception with \";\n+                        if (_stats.infoMessages.size() == 1)\n+                            messageLabel += \"message\";\n+                        if (_stats.infoMessages.size() > 1)\n+                            messageLabel += \"messages\";\n                         break;\n                     case ResultWas::FatalErrorCondition:\n                         colour = Colour::Error;\n", "test_patch": "diff --git a/projects/SelfTest/ExceptionTests.cpp b/projects/SelfTest/ExceptionTests.cpp\n--- a/projects/SelfTest/ExceptionTests.cpp\n+++ b/projects/SelfTest/ExceptionTests.cpp\n@@ -209,3 +209,18 @@ TEST_CASE( \"Mismatching exception messages failing the test\", \"[.][failing][!thr\n     REQUIRE_THROWS_WITH( thisThrows(), \"should fail\" );\n     REQUIRE_THROWS_WITH( thisThrows(), \"expected exception\" );\n }\n+\n+TEST_CASE( \"#748 - captures with unexpected exceptions\", \"[!shouldfail]\" ) {\n+    int answer = 42;\n+    CAPTURE(answer);\n+    // the message should be printed on the first two sections but not on the third\n+    SECTION( \"outside assertions\" ) {\n+        thisThrows();\n+    }\n+    SECTION( \"inside REQUIRE_NOTHROW\" ) {\n+        REQUIRE_NOTHROW(thisThrows());\n+    }\n+    SECTION( \"inside REQUIRE_THROWS\" ) {\n+        REQUIRE_THROWS(thisThrows());\n+    }\n+}\n\\ No newline at end of file\n", "problem_statement": "captures with unexpected exceptions\nIs it possible to make CAPTURE print its value when an unexpected exception occurs?\r\nCurrently, for the following code\r\n\r\n```c++\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch.hpp>\r\n#include <stdexcept>\r\n\r\nvoid foo()\r\n{\r\n    throw std::logic_error(\"error\");\r\n}\r\n\r\nTEST_CASE(\"test\")\r\n{\r\n    int i = 2;\r\n    CAPTURE(i);\r\n    foo();\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nI get \r\n```cmd\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nTest.exe is a Catch v1.1 b3 host application.\r\nRun with -? for options\r\n\r\n-------------------------------------------------------------------------------\r\ntest\r\n-------------------------------------------------------------------------------\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n0)\r\n...............................................................................\r\n\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n0): FAILED:\r\ndue to unexpected exception with message:\r\n  error\r\n\r\n===============================================================================\r\ntest cases: 1 | 1 failed\r\nassertions: 1 | 1 failed\r\n\r\nPress any key to continue . . .\r\n```\r\n\r\nWhile without calling `foo()` it's\r\n```cmd\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nTest.exe is a Catch v1.1 b3 host application.\r\nRun with -? for options\r\n\r\n-------------------------------------------------------------------------------\r\ntest\r\n-------------------------------------------------------------------------------\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n0)\r\n...............................................................................\r\n\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n5): FAILED:\r\n  REQUIRE( false )\r\nwith message:\r\n  i := 2\r\n\r\n===============================================================================\r\ntest cases: 1 | 1 failed\r\nassertions: 1 | 1 failed\r\n\r\nPress any key to continue . . .\r\n```\n", "hints_text": "No it's not possible, because captures are local to the scope they appear in. When an unCHECKed exception occurs, that scope is finished (local objects holding CAPTURE destroyed) before entering the handler (the one that prints \"FAILED: due to unexpected exception\").\r\n\nI think it could be possible with the use of C++17's [```std::uncaught_exceptions```](http://en.cppreference.com/w/cpp/error/uncaught_exception) to do something when the local objects (the capture stuff) are destroyed during stack unwinding due to an exception...\r\n\r\nor maybe just logging in globals in the destructor of the local capture stuff", "created_at": "2017-03-30T22:09:47Z"}
{"repo": "catchorg/Catch2", "pull_number": 859, "instance_id": "catchorg__Catch2-859", "issue_numbers": ["858"], "base_commit": "4dc06bdb7034d36071caa2219f14c4b2ce52c80a", "patch": "diff --git a/include/catch_session.hpp b/include/catch_session.hpp\n--- a/include/catch_session.hpp\n+++ b/include/catch_session.hpp\n@@ -125,7 +125,7 @@ namespace Catch {\n         }\n \n         void showHelp( std::string const& processName ) {\n-            Catch::cout() << \"\\nCatch v\" << libraryVersion << \"\\n\";\n+            Catch::cout() << \"\\nCatch v\" << libraryVersion() << \"\\n\";\n \n             m_cli.usage( Catch::cout(), processName );\n             Catch::cout() << \"For more detail usage please see the project docs\\n\" << std::endl;\ndiff --git a/include/internal/catch_version.h b/include/internal/catch_version.h\n--- a/include/internal/catch_version.h\n+++ b/include/internal/catch_version.h\n@@ -32,7 +32,7 @@ namespace Catch {\n         void operator=( Version const& );\n     };\n \n-    extern Version libraryVersion;\n+    inline Version libraryVersion();\n }\n \n #endif // TWOBLUECUBES_CATCH_VERSION_H_INCLUDED\ndiff --git a/include/internal/catch_version.hpp b/include/internal/catch_version.hpp\n--- a/include/internal/catch_version.hpp\n+++ b/include/internal/catch_version.hpp\n@@ -37,7 +37,10 @@ namespace Catch {\n         return os;\n     }\n \n-    Version libraryVersion( 1, 8, 2, \"\", 0 );\n+    inline Version libraryVersion() {\n+        static Version version(1, 8, 2, \"\", 0);\n+        return version;\n+    }\n \n }\n \ndiff --git a/include/reporters/catch_reporter_console.hpp b/include/reporters/catch_reporter_console.hpp\n--- a/include/reporters/catch_reporter_console.hpp\n+++ b/include/reporters/catch_reporter_console.hpp\n@@ -254,7 +254,7 @@ namespace Catch {\n             stream  << '\\n' << getLineOfChars<'~'>() << '\\n';\n             Colour colour( Colour::SecondaryText );\n             stream  << currentTestRunInfo->name\n-                    << \" is a Catch v\"  << libraryVersion << \" host application.\\n\"\n+                    << \" is a Catch v\"  << libraryVersion() << \" host application.\\n\"\n                     << \"Run with -? for options\\n\\n\";\n \n             if( m_config->rngSeed() != 0 )\n", "test_patch": "", "problem_statement": "Catch crash when destructing 'Version' struct on exit\n## Description\r\n\r\nI'm seeing a weird crash when my process exits after running Catch unit tests. The gdb stack trace:\r\n\r\n```cpp\r\n#0  0x00007f8306345428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54\r\n#1  0x00007f830634702a in __GI_abort () at abort.c:89\r\n#2  0x00007f83063877ea in __libc_message (do_abort=do_abort@entry=2, fmt=fmt@entry=0x7f83064a02e0 \"*** Error in `%s': %s: 0x%s ***\\n\")\r\n    at ../sysdeps/posix/libc_fatal.c:175\r\n#3  0x00007f830638fe0a in malloc_printerr (ar_ptr=<optimized out>, ptr=<optimized out>, str=0x7f830649d0b2 \"free(): invalid pointer\",\r\n    action=3) at malloc.c:5004\r\n#4  _int_free (av=<optimized out>, p=<optimized out>, have_lock=0) at malloc.c:3865\r\n#5  0x00007f830639398c in __GI___libc_free (mem=<optimized out>) at malloc.c:2966\r\n#6  0x00007f8306cc70b4 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() ()\r\n   from /usr/lib/x86_64-linux-gnu/libstdc++.so.6\r\n#7  0x000000000137eeac in Catch::Version::~Version (this=0x22a2a60 <Catch::libraryVersion>, __in_chrg=<optimized out>)\r\n    at /home/kevin/rstudio/src/cpp/tests/cpp/tests/vendor/catch.hpp:5947\r\n#8  0x00007f8306349ff8 in __run_exit_handlers (status=0, listp=0x7f83066d35f8 <__exit_funcs>, run_list_atexit=run_list_atexit@entry=true)\r\n    at exit.c:82\r\n#9  0x00007f830634a045 in __GI_exit (status=<optimized out>) at exit.c:104\r\n#10 0x0000000001316133 in (anonymous namespace)::exitEarly (status=0) at /home/kevin/rstudio/src/cpp/session/SessionMain.cpp:336\r\n...\r\n```\r\n\r\nThe fact that the error is occurring when calling the `~Version()` destructor is really throwing me off -- perhaps I'm somehow hitting a double free, or something similar? This isn't necessarily a bug in Catch itself but I'm curious if anyone has ideas as to how I can try to run this down further.\r\n\r\n### Steps to reproduce\r\n\r\nI haven't been able to generate a minimally reproducible example yet \ud83d\ude1e . Any advice in further narrowing down what could be going on would be hugely appreciated.\r\n\r\n### Extra information\r\n\r\n* Catch version: **v1.8.2**\r\n* Operating System: **Ubuntu 16.04 64bit**\r\n* Compiler+version: **gcc 4.8.5**\r\n\n", "hints_text": "FWIW, some local testing seems to indicate that using an inline function rather than a static version struct works just fine. I'll try to clean that up and submit that as a PR (although entirely understand if we don't want to take it)", "created_at": "2017-03-16T18:21:50Z"}
{"repo": "catchorg/Catch2", "pull_number": 855, "instance_id": "catchorg__Catch2-855", "issue_numbers": ["278", "278"], "base_commit": "95fc8d62a28bea7f9833f1533259a127b9df67d8", "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -63,7 +63,7 @@ std::string toString( std::nullptr_t );\n \n #ifdef __OBJC__\n     std::string toString( NSString const * const& nsstring );\n-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );\n+    std::string toString( NSString * CATCH_ARC_STRONG & nsstring );\n     std::string toString( NSObject* const& nsObject );\n #endif\n \ndiff --git a/include/internal/catch_tostring.hpp b/include/internal/catch_tostring.hpp\n--- a/include/internal/catch_tostring.hpp\n+++ b/include/internal/catch_tostring.hpp\n@@ -198,7 +198,7 @@ std::string toString( std::nullptr_t ) {\n             return \"nil\";\n         return \"@\" + toString([nsstring UTF8String]);\n     }\n-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring ) {\n+    std::string toString( NSString * CATCH_ARC_STRONG & nsstring ) {\n         if( !nsstring )\n             return \"nil\";\n         return \"@\" + toString([nsstring UTF8String]);\n", "test_patch": "", "problem_statement": "Catch build 41 link error for ObjC++\nI have a very small .mm file that does a few tests with CATCH() macros.\n\nI just updated to build 41 and now my test binary fails to link with:\n\nUndefined symbols for architecture x86_64:\n  \"Catch::toString(NSString\\* const&)\", referenced from:\n      Catch::ExpressionResultBuilder& Catch::ExpressionLhs<long const&>::captureExpression<(Catch::Internal::Operator)1, NSString_>(NSString_ const&)\n\nI was using build 33 previously.\nXcode 5.1.1\n\nI checked the header and it seems the toString() on line 7165 should be the implementation needed. So I'm not sure what's going on.\n\nThe only tests that I have where an NSString\\* is a direct arg are like the following:\n\nNSString *string = ...\nCATCH(nil != string);\n\nCatch build 41 link error for ObjC++\nI have a very small .mm file that does a few tests with CATCH() macros.\n\nI just updated to build 41 and now my test binary fails to link with:\n\nUndefined symbols for architecture x86_64:\n  \"Catch::toString(NSString\\* const&)\", referenced from:\n      Catch::ExpressionResultBuilder& Catch::ExpressionLhs<long const&>::captureExpression<(Catch::Internal::Operator)1, NSString_>(NSString_ const&)\n\nI was using build 33 previously.\nXcode 5.1.1\n\nI checked the header and it seems the toString() on line 7165 should be the implementation needed. So I'm not sure what's going on.\n\nThe only tests that I have where an NSString\\* is a direct arg are like the following:\n\nNSString *string = ...\nCATCH(nil != string);\n\n", "hints_text": "Well that's weird.\nI did move the toString() impls a bit in either build 40 or 41 (they were inline but now the impl part - the bit you found at line 7165 - is only compiled in to the source file that #defines `CATCH_CONFIG_MAIN` or `CATCH_CONFIG_RUNNER`). The prototype is at line 844.\n\nBut I just checked (again) in my OC test project and it all seems to work fine. I even tried your example, to see if there was anything specific about it. A couple of things I noted there:\n1. You wrote `CATCH` for the assertion. I presume you meant `CHECK`?\n2. Because of the interplay between ARC and templates I can't compare the NSString directly against nil - I have to cast the nil to an NSString\\* - so my test was actually like this:\n\n```\nNSString *string = @\"not null\";\nCHECK((NSString*)nil != string);\n```\n\nBut that all builds fine.\n\nI'll take another look tomorrow. If you're able to boil it down to the minimal complete example that fails that might help too. Thanks!\n\nYeah, sorry I meant CHECK().\n\nI've narrowed it down and it's definitely the CHECK(nil != string). If I comment that out, it builds and links fine. Adding the explicit cast of nil does not make a difference.\n\nHere's a full example that's similar to my test.\n\n2 differences that I note from your test, I'm using MRC not ARC and my string is dynamically allocated (though I have no idea why that would matter).\n\nTEST_CASE(\"test\") {\n@autoreleasepool {\n\nSECTION(\"Section\") {\nNSString *string  = [[@\"hello world\" dataUsingEncoding:NSUTF8StringEncoding] base64EncodedStringWithOptions:0];\nCHECK(nil != string);\n}\n\n}\n}\n\nI started playing with this and removing const from the reference arg allows the above CHECK() to link properly.\n\nSo:\nstd::string toString( NSString \\* CATCH_ARC_STRONG & nsstring );\n\nInteresting - I wonder if it is an ARC thing? I don't remember the details - would have to play with it again - but presumably I needed that const in there.\nI'd been toying with the idea of taking the MRC support out at this point - I wasn't sure if anyone was using it!\nI'm not going to get a chance to look at this in more depth again until at least the end of this week. I hope you're workaround is ok to get you going for now?\n\nMaybe for iOS MRC has gone to almost to nil use, but I think there is still a lot of OSX MRC legacy code out there. For us there sure is. You could make the const conditional as part of the CATCH_ARC_STRONG macro or another macro CATCH_ARC_CONST_REF\n\nYeah - don't worry - I'm not going to remove MRC support. I'll have a look again (probably next week) at that reference. It certainly used to work without ARC - but not tried it for quite a while. Will try again with 5.1.1\n\nHi @bdb,\n\nSorry for the delay getting back - was pretty tied up last week.\nI've now tried your complete example, exactly as you wrote (thanks for providing that). I also disabled ARC.\nIt still compiles - and runs - just fine for me!\n\nWe're both using Xcode 5.1.1. I presume you're using LLVM 5.1?\nI tried it form both Mac and iOS targets.\nI can't think what else might be different (unless you're using GCC?).\n\nYes, Xcode 5.1.1 and LLVM/Clang. I just tried this again with a clean project and Catch 43 still gets a linker error. Catch 33 works fine.\n\nI wonder if its something to do with compiler flags. We are using -O0 (so auto-inline is off) -std=c++11 -stdlib=libc++   -fvisibility=hidden\n\nI wonder if it has something to do with auto-inline. Those functions are small enough they should be inlined, but since its not explicit in the header -O0 won't do it automatically.\n\nHere's a larger excerpt of the compile flags:\n\nexport LANG=en_US.US-ASCII\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c++ -arch x86_64 -O0 -Wno-missing-field-initializers -Wno-missing-prototypes -Wno-return-type -Wno-implicit-atomic-properties -Wno-receiver-is-weak -Wno-arc-repeated-use-of-weak -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-missing-braces -Wparentheses -Wswitch -Wno-unused-function -Wno-unused-label -Wno-unused-parameter -Wno-unused-variable -Wunused-value -Wno-empty-body -Wno-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wno-constant-conversion -Wno-int-conversion -Wno-bool-conversion -Wno-enum-conversion -Wno-shorten-64-to-32 -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wno-undeclared-selector -Wno-deprecated-implementations -Wno-c++11-extensions -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk -fasm-blocks -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -Winvalid-offsetof -mmacosx-version-min=10.7 -g -fvisibility=hidden\n\nI am unable to check this one on my own, can someone else try if it is still relevant?\r\n\r\nI'd expect its not, but apparently someone referenced this only couple of months ago.\nI've hit this again with 1.5.7 and had to work around it. Not sure why it cropped up again. Upgrading to 1.6.0 is on my todo list.\nGlad to see you're still watching, @bdb - but sorry to hear you're still having problems (or having them again).\r\nI very much doubt anything relevant has changed between 1.5.7 and 1.6.0 - although it's always worth getting confirmation.\r\nI'll try this again myself. I know I wasn't able to reproduce it before, but it looks like since I was last looking at this you posted your compiler flags, so I'll see if using those makes the difference.\nThanks Phil, I'm on Xcode 8.2.1 now. My workaround was the same as above, I simple removed const from the toString() functions.\r\n\r\nEdit: Unlike the original report, this is with ARC enabled.\r\n\r\nAgainst 1.5.7\r\n```\r\n@@ -1594,7 +1594,7 @@ std::string toString( std::nullptr_t );\r\n \r\n #ifdef __OBJC__\r\n     std::string toString( NSString const * const& nsstring );\r\n-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );\r\n+    std::string toString( NSString * CATCH_ARC_STRONG & nsstring );\r\n     std::string toString( NSObject* const& nsObject );\r\n #endif\r\n \r\n@@ -8202,7 +8202,7 @@ std::string toString( std::nullptr_t ) {\r\n             return \"nil\";\r\n         return \"@\" + toString([nsstring UTF8String]);\r\n     }\r\n-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring ) {\r\n+    std::string toString( NSString * CATCH_ARC_STRONG & nsstring ) {\r\n         if( !nsstring )\r\n             return \"nil\";\r\n         return \"@\" + toString([nsstring UTF8String]);\r\n-- \r\n```\n1.6 has the same issue and the same patch fixes it.\nLooks like to reproduce all you need is for main() to be in a C++ file, not Objective-C++. Then you'll get the error. ARC/MRC doesn't seem to be relevant.\nWell that's weird.\nI did move the toString() impls a bit in either build 40 or 41 (they were inline but now the impl part - the bit you found at line 7165 - is only compiled in to the source file that #defines `CATCH_CONFIG_MAIN` or `CATCH_CONFIG_RUNNER`). The prototype is at line 844.\n\nBut I just checked (again) in my OC test project and it all seems to work fine. I even tried your example, to see if there was anything specific about it. A couple of things I noted there:\n1. You wrote `CATCH` for the assertion. I presume you meant `CHECK`?\n2. Because of the interplay between ARC and templates I can't compare the NSString directly against nil - I have to cast the nil to an NSString\\* - so my test was actually like this:\n\n```\nNSString *string = @\"not null\";\nCHECK((NSString*)nil != string);\n```\n\nBut that all builds fine.\n\nI'll take another look tomorrow. If you're able to boil it down to the minimal complete example that fails that might help too. Thanks!\n\nYeah, sorry I meant CHECK().\n\nI've narrowed it down and it's definitely the CHECK(nil != string). If I comment that out, it builds and links fine. Adding the explicit cast of nil does not make a difference.\n\nHere's a full example that's similar to my test.\n\n2 differences that I note from your test, I'm using MRC not ARC and my string is dynamically allocated (though I have no idea why that would matter).\n\nTEST_CASE(\"test\") {\n@autoreleasepool {\n\nSECTION(\"Section\") {\nNSString *string  = [[@\"hello world\" dataUsingEncoding:NSUTF8StringEncoding] base64EncodedStringWithOptions:0];\nCHECK(nil != string);\n}\n\n}\n}\n\nI started playing with this and removing const from the reference arg allows the above CHECK() to link properly.\n\nSo:\nstd::string toString( NSString \\* CATCH_ARC_STRONG & nsstring );\n\nInteresting - I wonder if it is an ARC thing? I don't remember the details - would have to play with it again - but presumably I needed that const in there.\nI'd been toying with the idea of taking the MRC support out at this point - I wasn't sure if anyone was using it!\nI'm not going to get a chance to look at this in more depth again until at least the end of this week. I hope you're workaround is ok to get you going for now?\n\nMaybe for iOS MRC has gone to almost to nil use, but I think there is still a lot of OSX MRC legacy code out there. For us there sure is. You could make the const conditional as part of the CATCH_ARC_STRONG macro or another macro CATCH_ARC_CONST_REF\n\nYeah - don't worry - I'm not going to remove MRC support. I'll have a look again (probably next week) at that reference. It certainly used to work without ARC - but not tried it for quite a while. Will try again with 5.1.1\n\nHi @bdb,\n\nSorry for the delay getting back - was pretty tied up last week.\nI've now tried your complete example, exactly as you wrote (thanks for providing that). I also disabled ARC.\nIt still compiles - and runs - just fine for me!\n\nWe're both using Xcode 5.1.1. I presume you're using LLVM 5.1?\nI tried it form both Mac and iOS targets.\nI can't think what else might be different (unless you're using GCC?).\n\nYes, Xcode 5.1.1 and LLVM/Clang. I just tried this again with a clean project and Catch 43 still gets a linker error. Catch 33 works fine.\n\nI wonder if its something to do with compiler flags. We are using -O0 (so auto-inline is off) -std=c++11 -stdlib=libc++   -fvisibility=hidden\n\nI wonder if it has something to do with auto-inline. Those functions are small enough they should be inlined, but since its not explicit in the header -O0 won't do it automatically.\n\nHere's a larger excerpt of the compile flags:\n\nexport LANG=en_US.US-ASCII\n    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c++ -arch x86_64 -O0 -Wno-missing-field-initializers -Wno-missing-prototypes -Wno-return-type -Wno-implicit-atomic-properties -Wno-receiver-is-weak -Wno-arc-repeated-use-of-weak -Wno-non-virtual-dtor -Wno-overloaded-virtual -Wno-exit-time-destructors -Wno-missing-braces -Wparentheses -Wswitch -Wno-unused-function -Wno-unused-label -Wno-unused-parameter -Wno-unused-variable -Wunused-value -Wno-empty-body -Wno-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wno-constant-conversion -Wno-int-conversion -Wno-bool-conversion -Wno-enum-conversion -Wno-shorten-64-to-32 -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wno-undeclared-selector -Wno-deprecated-implementations -Wno-c++11-extensions -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk -fasm-blocks -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -Winvalid-offsetof -mmacosx-version-min=10.7 -g -fvisibility=hidden\n\nI am unable to check this one on my own, can someone else try if it is still relevant?\r\n\r\nI'd expect its not, but apparently someone referenced this only couple of months ago.\nI've hit this again with 1.5.7 and had to work around it. Not sure why it cropped up again. Upgrading to 1.6.0 is on my todo list.\nGlad to see you're still watching, @bdb - but sorry to hear you're still having problems (or having them again).\r\nI very much doubt anything relevant has changed between 1.5.7 and 1.6.0 - although it's always worth getting confirmation.\r\nI'll try this again myself. I know I wasn't able to reproduce it before, but it looks like since I was last looking at this you posted your compiler flags, so I'll see if using those makes the difference.\nThanks Phil, I'm on Xcode 8.2.1 now. My workaround was the same as above, I simple removed const from the toString() functions.\r\n\r\nEdit: Unlike the original report, this is with ARC enabled.\r\n\r\nAgainst 1.5.7\r\n```\r\n@@ -1594,7 +1594,7 @@ std::string toString( std::nullptr_t );\r\n \r\n #ifdef __OBJC__\r\n     std::string toString( NSString const * const& nsstring );\r\n-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );\r\n+    std::string toString( NSString * CATCH_ARC_STRONG & nsstring );\r\n     std::string toString( NSObject* const& nsObject );\r\n #endif\r\n \r\n@@ -8202,7 +8202,7 @@ std::string toString( std::nullptr_t ) {\r\n             return \"nil\";\r\n         return \"@\" + toString([nsstring UTF8String]);\r\n     }\r\n-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring ) {\r\n+    std::string toString( NSString * CATCH_ARC_STRONG & nsstring ) {\r\n         if( !nsstring )\r\n             return \"nil\";\r\n         return \"@\" + toString([nsstring UTF8String]);\r\n-- \r\n```\n1.6 has the same issue and the same patch fixes it.\nLooks like to reproduce all you need is for main() to be in a C++ file, not Objective-C++. Then you'll get the error. ARC/MRC doesn't seem to be relevant.", "created_at": "2017-03-14T18:55:28Z"}
{"repo": "catchorg/Catch2", "pull_number": 775, "instance_id": "catchorg__Catch2-775", "issue_numbers": ["774"], "base_commit": "737f4ea77c82f2d6d48d7ac36fd63bb9f3851ed4", "patch": "diff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -206,19 +206,19 @@\n #if defined(CATCH_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(CATCH_CONFIG_NO_VARIADIC_MACROS) && !defined(CATCH_CONFIG_VARIADIC_MACROS)\n #   define CATCH_CONFIG_VARIADIC_MACROS\n #endif\n-#if defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_CPP11)\n+#if defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_NO_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_CPP11)\n #   define CATCH_CONFIG_CPP11_LONG_LONG\n #endif\n-#if defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_CPP11)\n+#if defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_NO_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_CPP11)\n #   define CATCH_CONFIG_CPP11_OVERRIDE\n #endif\n-#if defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_CPP11)\n+#if defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_NO_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_CPP11)\n #   define CATCH_CONFIG_CPP11_UNIQUE_PTR\n #endif\n #if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)\n #   define CATCH_CONFIG_COUNTER\n #endif\n-#if defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_NO_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_NO_CPP11)\n+#if defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_NO_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_NO_CPP11)\n #   define CATCH_CONFIG_CPP11_SHUFFLE\n #endif\n \n", "test_patch": "", "problem_statement": "C++11 feature disable toggles are inconsistent\nAccording to documentation, feature toggle like `CATCH_CONFIG_CPP11_NOEXCEPT` can be explicitly disabled with `CATCH_CONFIG_CPP11_NO_NOEXCEPT`. For noexcept this works, but there are several inconsistencies, as an example `CATCH_CONFIG_CPP11_UNIQUE_PTR` is disabled with `CATCH_CONFIG_NO_UNIQUE_PTR`. According to documentation it should be `CATCH_CONFIG_CPP11_NO_UNIQUE_PTR`.\r\n\r\nI actually introduced one of those, in 6991549457a13aa73f4ca59862b794ee7ed5e177 because I looked at toggle for unique_ptr and didn't notice the inconsistency.\n", "hints_text": "", "created_at": "2017-01-10T21:56:14Z"}
{"repo": "catchorg/Catch2", "pull_number": 715, "instance_id": "catchorg__Catch2-715", "issue_numbers": ["651"], "base_commit": "88732e85b2ac0233bba6fec5c032d02f9c5c230b", "patch": "diff --git a/include/internal/catch_approx.hpp b/include/internal/catch_approx.hpp\n--- a/include/internal/catch_approx.hpp\n+++ b/include/internal/catch_approx.hpp\n@@ -58,6 +58,26 @@ namespace Detail {\n             return !operator==( rhs, lhs );\n         }\n \n+        friend bool operator <= ( double lhs, Approx const& rhs )\n+        {\n+          return lhs < rhs.m_value || lhs == rhs;\n+        }\n+\n+        friend bool operator <= ( Approx const& lhs, double rhs )\n+        {\n+          return lhs.m_value < rhs || lhs == rhs;\n+        }\n+\n+        friend bool operator >= ( double lhs, Approx const& rhs )\n+        {\n+          return lhs > rhs.m_value || lhs == rhs;\n+        }\n+\n+        friend bool operator >= ( Approx const& lhs, double rhs )\n+        {\n+          return lhs.m_value > rhs || lhs == rhs;\n+        }\n+\n         Approx& epsilon( double newEpsilon ) {\n             m_epsilon = newEpsilon;\n             return *this;\n", "test_patch": "diff --git a/projects/SelfTest/ApproxTests.cpp b/projects/SelfTest/ApproxTests.cpp\n--- a/projects/SelfTest/ApproxTests.cpp\n+++ b/projects/SelfTest/ApproxTests.cpp\n@@ -39,6 +39,36 @@ TEST_CASE\n     REQUIRE( d == Approx( 1.231 ).epsilon( 0.1 ) );\n }\n \n+///////////////////////////////////////////////////////////////////////////////\n+TEST_CASE\n+(\n+ \"Less-than inequalities with different epsilons\",\n+ \"[Approx]\"\n+)\n+{\n+  double d = 1.23;\n+\n+  REQUIRE( d <= Approx( 1.24 ) );\n+  REQUIRE( d <= Approx( 1.23 ) );\n+  REQUIRE_FALSE( d <= Approx( 1.22 ) );\n+  REQUIRE( d <= Approx( 1.22 ).epsilon(0.1) );\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+TEST_CASE\n+(\n+ \"Greater-than inequalities with different epsilons\",\n+ \"[Approx]\"\n+)\n+{\n+  double d = 1.23;\n+\n+  REQUIRE( d >= Approx( 1.22 ) );\n+  REQUIRE( d >= Approx( 1.23 ) );\n+  REQUIRE_FALSE( d >= Approx( 1.24 ) );\n+  REQUIRE( d >= Approx( 1.24 ).epsilon(0.1) );\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n TEST_CASE\n (\n", "problem_statement": "Add support for <=, >= to Approx\nApprox is very useful and I'd make further use of it if support for <=, >= could be added.\n\nI'll be happy to do this work.\n\n", "hints_text": "Updated issue following face-to-face discussion (small world):\n\nI agree that having < and > both true is daft. All the LP and QP libraries I've seen expose <= and >= instead. If Catch did the same and Approx supported <= and >= would that be ok?\n", "created_at": "2016-09-24T17:01:12Z"}
{"repo": "catchorg/Catch2", "pull_number": 647, "instance_id": "catchorg__Catch2-647", "issue_numbers": ["602"], "base_commit": "5aa2b82b17aeeb935919b1d0bbb93bd0adc86ddb", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -81,7 +81,7 @@\n #define CATCH_CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, \"CATCH_CHECKED_ELSE\" )\n #define CATCH_CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \"CATCH_CHECK_NOFAIL\" )\n \n-#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, \"CATCH_CHECK_THROWS\" )\n+#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, \"\", \"CATCH_CHECK_THROWS\" )\n #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, \"CATCH_CHECK_THROWS_AS\" )\n #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, matcher, \"CATCH_CHECK_THROWS_WITH\" )\n #define CATCH_CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, \"CATCH_CHECK_NOTHROW\" )\n", "test_patch": "", "problem_statement": "incorrect signature used for CATCH_CHECK_THROWS?\nCompare `CATCH_CHECK_THROWS` and `CATCH_REQUIRE_THROWS`:\n\nhttps://github.com/philsquared/Catch/blob/master/single_include/catch.hpp#L10286\nhttps://github.com/philsquared/Catch/blob/master/single_include/catch.hpp#L10275\n\nIt looks like the `INTERNAL_CATCH_THROWS` macro takes 4 arguments; however, `CATCH_CHECK_THROWS` only passes on 3. Should it pass along an empty 'matcher' argument?\n\n", "hints_text": "", "created_at": "2016-04-22T01:27:04Z"}
{"repo": "catchorg/Catch2", "pull_number": 350, "instance_id": "catchorg__Catch2-350", "issue_numbers": ["348", "348"], "base_commit": "d4e5f184369ce34592bb6f89e793bdb22d1d011a", "patch": "diff --git a/projects/SelfTest/makefile b/projects/SelfTest/makefile\n--- a/projects/SelfTest/makefile\n+++ b/projects/SelfTest/makefile\n@@ -1,21 +1,14 @@\n-SOURCES =\tApproxTests.cpp \\\n-\t\t\tClassTests.cpp \\\n-\t\t\tConditionTests.cpp \\\n-      \t\tExceptionTests.cpp \\\n-      \t\tGeneratorTests.cpp \\\n-      \t\tMessageTests.cpp \\\n-      \t\tMiscTests.cpp \\\n-      \t\tTestMain.cpp \\\n-      \t\tTrickyTests.cpp \\\n-      \t\tBDDTests.cpp \\\n-      \t\tVariadicMacrosTests.cpp \\\n-      \t\tcatch_self_test.cpp\n-OBJECTS    = $(patsubst %.cpp, %.o, $(SOURCES))\n+\n+EXEC=CatchSelfTest\n+SOURCES = $(wildcard *.cpp)\n+OBJECTS = $(SOURCES:.cpp=.o)\n+\n CXX = g++\n-CXXFLAGS  = -I../../include\n+CXXFLAGS  = -I../../include -I../../include/internal\n \n-CatchSelfTest: $(OBJECTS)\n+$(EXEC): $(OBJECTS)\n \t$(CXX) -o $@ $^\n \n clean:\n-\trm -f $(OBJECTS)\n+\t$(RM) $(OBJECTS)\n+\t$(RM) $(EXEC)\n", "test_patch": "", "problem_statement": "SelfTest build fails\nOn Mac OS X Yosemite, typing `make` from `projects/SelfTest` fails with the following error:\n\n> make: **\\* No rule to make target `catch_self_test.o', needed by`CatchSelfTest'.  Stop.\n\nSelfTest build fails\nOn Mac OS X Yosemite, typing `make` from `projects/SelfTest` fails with the following error:\n\n> make: **\\* No rule to make target `catch_self_test.o', needed by`CatchSelfTest'.  Stop.\n\n", "hints_text": "\n", "created_at": "2014-11-08T18:59:50Z"}
{"repo": "catchorg/Catch2", "pull_number": 264, "instance_id": "catchorg__Catch2-264", "issue_numbers": ["259"], "base_commit": "472dc2a61f9588ba817799742bac15d83c2432be", "patch": "diff --git a/include/internal/catch_assertionresult.h b/include/internal/catch_assertionresult.h\n--- a/include/internal/catch_assertionresult.h\n+++ b/include/internal/catch_assertionresult.h\n@@ -41,6 +41,12 @@ namespace Catch {\n         AssertionResult();\n         AssertionResult( AssertionInfo const& info, AssertionResultData const& data );\n         ~AssertionResult();\n+#  ifdef CATCH_CPP11_OR_GREATER\n+         AssertionResult( AssertionResult const& )              = default;\n+         AssertionResult( AssertionResult && )                  = default;\n+         AssertionResult& operator = ( AssertionResult const& ) = default;\n+         AssertionResult& operator = ( AssertionResult && )     = default;\n+#  endif\n \n         bool isOk() const;\n         bool succeeded() const;\ndiff --git a/include/internal/catch_common.h b/include/internal/catch_common.h\n--- a/include/internal/catch_common.h\n+++ b/include/internal/catch_common.h\n@@ -113,6 +113,11 @@ namespace Catch {\n         :   file( other.file ),\n             line( other.line )\n         {}\n+#  ifdef CATCH_CPP11_OR_GREATER\n+        SourceLineInfo( SourceLineInfo && )                  = default;\n+        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;\n+        SourceLineInfo& operator = ( SourceLineInfo && )     = default;\n+#  endif\n         bool empty() const {\n             return file.empty();\n         }\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -81,5 +81,27 @@\n \n #endif\n \n+////////////////////////////////////////////////////////////////////////////////\n+// C++ language feature support\n+\n+// detect language version:\n+#if (__cplusplus == 201103L)\n+#  define CATCH_CPP11\n+#  define CATCH_CPP11_OR_GREATER\n+#elif (__cplusplus >= 201103L)\n+#  define CATCH_CPP11_OR_GREATER\n+#endif\n+\n+// noexcept support:\n+#ifdef CATCH_CPP11_OR_GREATER\n+#  if (__has_feature(cxx_noexcept))\n+#    define CATCH_NOEXCEPT noexcept\n+#    define CATCH_NOEXCEPT_IS(x) noexcept(x)\n+#  endif\n+#else\n+#  define CATCH_NOEXCEPT throw()\n+#  define CATCH_NOEXCEPT_IS(x)\n+#endif\n+\n #endif // TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED\n \ndiff --git a/include/internal/catch_expression_lhs.hpp b/include/internal/catch_expression_lhs.hpp\n--- a/include/internal/catch_expression_lhs.hpp\n+++ b/include/internal/catch_expression_lhs.hpp\n@@ -14,14 +14,21 @@\n \n namespace Catch {\n \n-// Wraps the LHS of an expression and captures the operator and RHS (if any) - wrapping them all\n-// in an ExpressionResultBuilder object\n+// Wraps the LHS of an expression and captures the operator and RHS (if any) -\n+// wrapping them all in an ExpressionResultBuilder object\n template<typename T>\n class ExpressionLhs {\n-    void operator = ( ExpressionLhs const& );\n+    ExpressionLhs& operator = ( ExpressionLhs const& );\n+#  ifdef CATCH_CPP11_OR_GREATER\n+    ExpressionLhs& operator = ( ExpressionLhs && ) = delete;\n+#  endif\n \n public:\n     ExpressionLhs( T lhs ) : m_lhs( lhs ) {}\n+#  ifdef CATCH_CPP11_OR_GREATER\n+    ExpressionLhs( ExpressionLhs const& ) = default;\n+    ExpressionLhs( ExpressionLhs && )     = default;\n+#  endif\n \n     template<typename RhsT>\n     ExpressionResultBuilder& operator == ( RhsT const& rhs ) {\ndiff --git a/include/internal/catch_impl.hpp b/include/internal/catch_impl.hpp\n--- a/include/internal/catch_impl.hpp\n+++ b/include/internal/catch_impl.hpp\n@@ -39,7 +39,7 @@\n namespace Catch {\n     NonCopyable::~NonCopyable() {}\n     IShared::~IShared() {}\n-    StreamBufBase::~StreamBufBase() throw() {}\n+    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}\n     IContext::~IContext() {}\n     IResultCapture::~IResultCapture() {}\n     ITestCase::~ITestCase() {}\ndiff --git a/include/internal/catch_interfaces_reporter.h b/include/internal/catch_interfaces_reporter.h\n--- a/include/internal/catch_interfaces_reporter.h\n+++ b/include/internal/catch_interfaces_reporter.h\n@@ -114,6 +114,13 @@ namespace Catch\n         }\n         virtual ~AssertionStats();\n \n+#  ifdef CATCH_CPP11_OR_GREATER\n+        AssertionStats( AssertionStats const& )              = default;\n+        AssertionStats( AssertionStats && )                  = default;\n+        AssertionStats& operator = ( AssertionStats const& ) = default;\n+        AssertionStats& operator = ( AssertionStats && )     = default;\n+#  endif\n+\n         AssertionResult assertionResult;\n         std::vector<MessageInfo> infoMessages;\n         Totals totals;\n@@ -130,6 +137,12 @@ namespace Catch\n             missingAssertions( _missingAssertions )\n         {}\n         virtual ~SectionStats();\n+#  ifdef CATCH_CPP11_OR_GREATER\n+        SectionStats( SectionStats const& )              = default;\n+        SectionStats( SectionStats && )                  = default;\n+        SectionStats& operator = ( SectionStats const& ) = default;\n+        SectionStats& operator = ( SectionStats && )     = default;\n+#  endif\n \n         SectionInfo sectionInfo;\n         Counts assertions;\n@@ -151,6 +164,13 @@ namespace Catch\n         {}\n         virtual ~TestCaseStats();\n \n+#  ifdef CATCH_CPP11_OR_GREATER\n+        TestCaseStats( TestCaseStats const& )              = default;\n+        TestCaseStats( TestCaseStats && )                  = default;\n+        TestCaseStats& operator = ( TestCaseStats const& ) = default;\n+        TestCaseStats& operator = ( TestCaseStats && )     = default;\n+#  endif\n+\n         TestCaseInfo testInfo;\n         Totals totals;\n         std::string stdOut;\n@@ -172,6 +192,13 @@ namespace Catch\n         {}\n         virtual ~TestGroupStats();\n \n+#  ifdef CATCH_CPP11_OR_GREATER\n+        TestGroupStats( TestGroupStats const& )              = default;\n+        TestGroupStats( TestGroupStats && )                  = default;\n+        TestGroupStats& operator = ( TestGroupStats const& ) = default;\n+        TestGroupStats& operator = ( TestGroupStats && )     = default;\n+#  endif\n+\n         GroupInfo groupInfo;\n         Totals totals;\n         bool aborting;\n@@ -185,12 +212,20 @@ namespace Catch\n             totals( _totals ),\n             aborting( _aborting )\n         {}\n+        virtual ~TestRunStats();\n+\n+#  ifndef CATCH_CPP11_OR_GREATER\n         TestRunStats( TestRunStats const& _other )\n         :   runInfo( _other.runInfo ),\n             totals( _other.totals ),\n             aborting( _other.aborting )\n         {}\n-        virtual ~TestRunStats();\n+#  else\n+        TestRunStats( TestRunStats const& )              = default;\n+        TestRunStats( TestRunStats && )                  = default;\n+        TestRunStats& operator = ( TestRunStats const& ) = default;\n+        TestRunStats& operator = ( TestRunStats && )     = default;\n+#  endif\n \n         TestRunInfo runInfo;\n         Totals totals;\ndiff --git a/include/internal/catch_notimplemented_exception.h b/include/internal/catch_notimplemented_exception.h\n--- a/include/internal/catch_notimplemented_exception.h\n+++ b/include/internal/catch_notimplemented_exception.h\n@@ -18,9 +18,9 @@ namespace Catch {\n     public:\n         NotImplementedException( SourceLineInfo const& lineInfo );\n \n-        virtual ~NotImplementedException() throw() {}\n+        virtual ~NotImplementedException() CATCH_NOEXCEPT {}\n \n-        virtual const char* what() const throw();\n+        virtual const char* what() const CATCH_NOEXCEPT;\n \n     private:\n         std::string m_what;\ndiff --git a/include/internal/catch_notimplemented_exception.hpp b/include/internal/catch_notimplemented_exception.hpp\n--- a/include/internal/catch_notimplemented_exception.hpp\n+++ b/include/internal/catch_notimplemented_exception.hpp\n@@ -21,7 +21,7 @@ namespace Catch {\n         m_what = oss.str();\n     }\n \n-    const char* NotImplementedException::what() const throw() {\n+    const char* NotImplementedException::what() const CATCH_NOEXCEPT {\n         return m_what.c_str();\n     }\n \ndiff --git a/include/internal/catch_section.hpp b/include/internal/catch_section.hpp\n--- a/include/internal/catch_section.hpp\n+++ b/include/internal/catch_section.hpp\n@@ -33,6 +33,13 @@ namespace Catch {\n                 getCurrentContext().getResultCapture().sectionEnded( m_info, m_assertions, m_timer.getElapsedSeconds() );\n         }\n \n+#  ifdef CATCH_CPP11_OR_GREATER\n+        Section( Section const& )              = default;\n+        Section( Section && )                  = default;\n+        Section& operator = ( Section const& ) = default;\n+        Section& operator = ( Section && )     = default;\n+#  endif\n+\n         // This indicates whether the section should be executed or not\n         operator bool() {\n             return m_sectionIncluded;\ndiff --git a/include/internal/catch_stream.hpp b/include/internal/catch_stream.hpp\n--- a/include/internal/catch_stream.hpp\n+++ b/include/internal/catch_stream.hpp\n@@ -27,7 +27,7 @@ namespace Catch {\n             setp( data, data + sizeof(data) );\n         }\n \n-        ~StreamBufImpl() throw() {\n+        ~StreamBufImpl() CATCH_NOEXCEPT {\n             sync();\n         }\n \ndiff --git a/include/internal/catch_streambuf.h b/include/internal/catch_streambuf.h\n--- a/include/internal/catch_streambuf.h\n+++ b/include/internal/catch_streambuf.h\n@@ -14,7 +14,7 @@ namespace Catch {\n \n     class StreamBufBase : public std::streambuf {\n     public:\n-        virtual ~StreamBufBase() throw();\n+        virtual ~StreamBufBase() CATCH_NOEXCEPT;\n     };\n }\n \ndiff --git a/include/internal/catch_xmlwriter.hpp b/include/internal/catch_xmlwriter.hpp\n--- a/include/internal/catch_xmlwriter.hpp\n+++ b/include/internal/catch_xmlwriter.hpp\n@@ -66,11 +66,18 @@ namespace Catch {\n                 endElement();\n         }\n \n+#  ifndef CATCH_CPP11_OR_GREATER\n         XmlWriter& operator = ( XmlWriter const& other ) {\n             XmlWriter temp( other );\n             swap( temp );\n             return *this;\n         }\n+#  else\n+        XmlWriter( XmlWriter const& )              = default;\n+        XmlWriter( XmlWriter && )                  = default;\n+        XmlWriter& operator = ( XmlWriter const& ) = default;\n+        XmlWriter& operator = ( XmlWriter && )     = default;\n+#  endif\n \n         void swap( XmlWriter& other ) {\n             std::swap( m_tagIsOpen, other.m_tagIsOpen );\ndiff --git a/include/internal/clara.h b/include/internal/clara.h\n--- a/include/internal/clara.h\n+++ b/include/internal/clara.h\n@@ -52,6 +52,10 @@ namespace Clara {\n         template<typename ConfigT>\n         struct IArgFunction {\n             virtual ~IArgFunction() {}\n+#  ifdef CATCH_CPP11_OR_GREATER\n+            IArgFunction()                      = default;\n+            IArgFunction( IArgFunction const& ) = default;\n+#  endif\n             virtual void set( ConfigT& config, std::string const& value ) const = 0;\n             virtual void setFlag( ConfigT& config ) const = 0;\n             virtual bool takesArg() const = 0;\n", "test_patch": "", "problem_statement": "Usage of deprecated features\nClang warns about using deprecated C++ features with the \"-Wdeprecated\" warning.\n\nE.g. usage of dynamic exception specifications:\n\n``` shell\n/Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_notimplemented_exception.h:21:44: warning: \n      dynamic exception specifications are deprecated [-Wdeprecated]\n        virtual ~NotImplementedException() throw() {}\n                                           ^~~~~~~\n/Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_notimplemented_exception.h:21:44: note: use\n      'noexcept' instead\n        virtual ~NotImplementedException() throw() {}\n                                           ^~~~~~~\n                                           noexcept\n/Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_notimplemented_exception.h:23:42: warning: \n      dynamic exception specifications are deprecated [-Wdeprecated]\n        virtual const char* what() const throw();\n                                         ^~~~~~~\n/Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_notimplemented_exception.h:23:42: note: use\n      'noexcept' instead\n        virtual const char* what() const throw();\n                                         ^~~~~~~\n                                         noexcept\n```\n\nOr defining assignment operator without copy constructor (in C++>=11 the copy constructor is not implicitly generated anymore):\n\n``` shell\nIn file included from /Users/gnzlbg/projects/sideprojects/arithmetic_type/test/all_test.cpp:2:\nIn file included from /Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/catch.hpp:34:\nIn file included from /Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_capture.hpp:11:\nIn file included from /Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_expression_decomposer.hpp:11:\n/Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_expression_lhs.hpp:21:10: warning: \n      definition of implicit copy constructor for 'ExpressionLhs<bool>' is deprecated because it has a user-declared copy assignment operator\n      [-Wdeprecated]\n    void operator = ( ExpressionLhs const& );\n         ^\n/Users/gnzlbg/projects/sideprojects/arithmetic_type/ext/catch/catch-prefix/src/catch/include/internal/catch_expression_decomposer.hpp:25:16: note: \n      implicit copy constructor for 'ExpressionLhs<bool>' first required here\n        return ExpressionLhs<bool>( value );\n```\n\n", "hints_text": "", "created_at": "2014-03-20T13:05:03Z"}
