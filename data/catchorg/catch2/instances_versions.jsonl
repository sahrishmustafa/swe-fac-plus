{"repo": "catchorg/Catch2", "pull_number": 2128, "instance_id": "catchorg__Catch2-2128", "issue_numbers": ["2121"], "base_commit": "65c9a1d31a338f28ef93cd61c475efc40f6cc42e", "patch": "diff --git a/src/catch2/internal/catch_decomposer.hpp b/src/catch2/internal/catch_decomposer.hpp\n--- a/src/catch2/internal/catch_decomposer.hpp\n+++ b/src/catch2/internal/catch_decomposer.hpp\n@@ -183,60 +183,53 @@ namespace Catch {\n     public:\n         explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}\n \n-        template<typename RhsT>\n-        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n-        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs == rhs, m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareNotEqual( m_lhs, rhs ), m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n-        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs != rhs, m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs > rhs), m_lhs, \">\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs < rhs), m_lhs, \"<\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs >= rhs), m_lhs, \">=\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs | rhs), m_lhs, \"|\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs & rhs), m_lhs, \"&\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, \"^\"_sr, rhs };\n+    #define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(op) \\\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n+        } \\\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n         }\n \n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(|)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(&)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(^)\n+\n+    #undef CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR\n+\n         template<typename RhsT>\n-        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator && ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator&& is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n         }\n \n         template<typename RhsT>\n-        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator || ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator|| is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n@@ -247,21 +240,15 @@ namespace Catch {\n         }\n     };\n \n-    void handleExpression( ITransientExpression const& expr );\n-\n-    template<typename T>\n-    void handleExpression( ExprLhs<T> const& expr ) {\n-        handleExpression( expr.makeUnaryExpr() );\n-    }\n-\n     struct Decomposer {\n-        template<typename T>\n-        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {\n-            return ExprLhs<T const&>{ lhs };\n+        template<typename T, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<T>>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T && lhs ) -> ExprLhs<T const&> {\n+            return ExprLhs<const T&>{ lhs };\n         }\n \n-        auto operator <=( bool value ) -> ExprLhs<bool> {\n-            return ExprLhs<bool>{ value };\n+        template<typename T, std::enable_if_t<std::is_arithmetic<T>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T value ) -> ExprLhs<T> {\n+            return ExprLhs<T>{ value };\n         }\n     };\n \n", "test_patch": "diff --git a/tests/SelfTest/UsageTests/Compilation.tests.cpp b/tests/SelfTest/UsageTests/Compilation.tests.cpp\n--- a/tests/SelfTest/UsageTests/Compilation.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Compilation.tests.cpp\n@@ -277,3 +277,42 @@ namespace {\n TEST_CASE(\"Immovable types are supported in basic assertions\", \"[compilation][.approvals]\") {\n     REQUIRE(ImmovableType{} == ImmovableType{});\n }\n+\n+namespace adl {\n+\n+struct always_true {\n+    explicit operator bool() const { return true; }\n+};\n+\n+#define COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(op) \\\n+template <class T, class U> \\\n+auto operator op (T&&, U&&) { \\\n+    return always_true{}; \\\n+}\n+\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(==)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(!=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(|)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(&)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(^)\n+\n+#undef COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR\n+\n+}\n+\n+TEST_CASE(\"ADL universal operators don't hijack expression deconstruction\", \"[compilation][.approvals]\") {\n+    REQUIRE(adl::always_true{});\n+    REQUIRE(0 == adl::always_true{});\n+    REQUIRE(0 != adl::always_true{});\n+    REQUIRE(0 < adl::always_true{});\n+    REQUIRE(0 > adl::always_true{});\n+    REQUIRE(0 <= adl::always_true{});\n+    REQUIRE(0 >= adl::always_true{});\n+    REQUIRE(0 | adl::always_true{});\n+    REQUIRE(0 & adl::always_true{});\n+    REQUIRE(0 ^ adl::always_true{});\n+}\n", "problem_statement": "Problem with user provided operator == (with proposed fix)\n**Describe the bug**\r\nThe test doesn't compile when the user provides a more general `operator ==` overload than `ExprLhs`.\r\n`operator ==` in the code sample below is a better match when r-value reference is passed because it accepts forwarding reference (`U&&`) and `ExprLhs` accepts only const reference (`RhsT const& rhs`) https://github.com/catchorg/Catch2/blob/devel/src/catch2/internal/catch_decomposer.hpp#L187\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Expected behavior**\r\nThe test should compile.\r\n\r\n**Reproduction steps**\r\n```\r\nnamespace adl {\r\n\r\nstruct activate_adl {};\r\n\r\nstruct equality_expression {\r\n    operator bool() const { return true; }\r\n};\r\n\r\ntemplate <class T, class U>\r\nconstexpr auto operator == (T&&, U&&) {\r\n    return equality_expression{};\r\n}\r\n\r\n}\r\n\r\nTEST_CASE(\"User provided equality operator\", \"[compilation]\") {\r\n    REQUIRE(0 == adl::activate_adl{});\r\n}\r\n```\r\nerror: no matching member function for call to 'handleExpr' REQUIRE(0 == adl::activate_adl{});\r\n\r\n**Fix**\r\nMy first attempt was to change the `operator == ` definition (and similarly all other operators) to\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\nHowever, this broke a test for bitfields\r\nerror: non-const reference cannot bind to bit-field 'v' REQUIRE(0 == y.v);\r\n\r\nThis can be resolved by two not so clean overloads, maybe you know a better way:\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::decay_t<RhsT>>::value, int> = 0>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Unrelated note**\r\nI don't think const reference here prolongs the lifetime of rhs, because it's not local but stored in a class: `BinaryExpr<LhsT, RhsT const&>`. Not sure if it's a problem.\n", "hints_text": "", "created_at": "2020-12-20T00:12:15Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 2360, "instance_id": "catchorg__Catch2-2360", "issue_numbers": ["395"], "base_commit": "52066dbc2a53f4c3ab2a418d03f93200a8245451", "patch": "diff --git a/src/catch2/catch_session.cpp b/src/catch2/catch_session.cpp\n--- a/src/catch2/catch_session.cpp\n+++ b/src/catch2/catch_session.cpp\n@@ -341,6 +341,12 @@ namespace Catch {\n                 return 2;\n             }\n \n+            if ( totals.testCases.total() > 0 &&\n+                 totals.testCases.total() == totals.testCases.skipped\n+                && !m_config->zeroTestsCountAsSuccess() ) {\n+                return 4;\n+            }\n+\n             // Note that on unices only the lower 8 bits are usually used, clamping\n             // the return value to 255 prevents false negative when some multiple\n             // of 256 tests has failed\ndiff --git a/src/catch2/catch_totals.cpp b/src/catch2/catch_totals.cpp\n--- a/src/catch2/catch_totals.cpp\n+++ b/src/catch2/catch_totals.cpp\n@@ -14,6 +14,7 @@ namespace Catch {\n         diff.passed = passed - other.passed;\n         diff.failed = failed - other.failed;\n         diff.failedButOk = failedButOk - other.failedButOk;\n+        diff.skipped = skipped - other.skipped;\n         return diff;\n     }\n \n@@ -21,14 +22,15 @@ namespace Catch {\n         passed += other.passed;\n         failed += other.failed;\n         failedButOk += other.failedButOk;\n+        skipped += other.skipped;\n         return *this;\n     }\n \n     std::uint64_t Counts::total() const {\n-        return passed + failed + failedButOk;\n+        return passed + failed + failedButOk + skipped;\n     }\n     bool Counts::allPassed() const {\n-        return failed == 0 && failedButOk == 0;\n+        return failed == 0 && failedButOk == 0 && skipped == 0;\n     }\n     bool Counts::allOk() const {\n         return failed == 0;\n@@ -53,6 +55,8 @@ namespace Catch {\n             ++diff.testCases.failed;\n         else if( diff.assertions.failedButOk > 0 )\n             ++diff.testCases.failedButOk;\n+        else if ( diff.assertions.skipped > 0 )\n+            ++ diff.testCases.skipped;\n         else\n             ++diff.testCases.passed;\n         return diff;\ndiff --git a/src/catch2/catch_totals.hpp b/src/catch2/catch_totals.hpp\n--- a/src/catch2/catch_totals.hpp\n+++ b/src/catch2/catch_totals.hpp\n@@ -23,6 +23,7 @@ namespace Catch {\n         std::uint64_t passed = 0;\n         std::uint64_t failed = 0;\n         std::uint64_t failedButOk = 0;\n+        std::uint64_t skipped = 0;\n     };\n \n     struct Totals {\ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter.hpp b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter.hpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n@@ -242,7 +242,12 @@ namespace Catch {\n          */\n         virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;\n \n-        //! Called with test cases that are skipped due to the test run aborting\n+        /**\n+         * Called with test cases that are skipped due to the test run aborting.\n+         * NOT called for test cases that are explicitly skipped using the `SKIP` macro.\n+         *\n+         * Deprecated - will be removed in the next major release.\n+         */\n         virtual void skipTest( TestCaseInfo const& testInfo ) = 0;\n \n         //! Called if a fatal error (signal/structured exception) occured\ndiff --git a/src/catch2/internal/catch_assertion_handler.cpp b/src/catch2/internal/catch_assertion_handler.cpp\n--- a/src/catch2/internal/catch_assertion_handler.cpp\n+++ b/src/catch2/internal/catch_assertion_handler.cpp\n@@ -50,6 +50,13 @@ namespace Catch {\n         if (m_reaction.shouldThrow) {\n             throw_test_failure_exception();\n         }\n+        if ( m_reaction.shouldSkip ) {\n+#if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )\n+            throw Catch::TestSkipException();\n+#else\n+            CATCH_ERROR( \"Explicitly skipping tests during runtime requires exceptions\" );\n+#endif\n+        }\n     }\n     void AssertionHandler::setCompleted() {\n         m_completed = true;\ndiff --git a/src/catch2/internal/catch_assertion_handler.hpp b/src/catch2/internal/catch_assertion_handler.hpp\n--- a/src/catch2/internal/catch_assertion_handler.hpp\n+++ b/src/catch2/internal/catch_assertion_handler.hpp\n@@ -22,6 +22,7 @@ namespace Catch {\n     struct AssertionReaction {\n         bool shouldDebugBreak = false;\n         bool shouldThrow = false;\n+        bool shouldSkip = false;\n     };\n \n     class AssertionHandler {\ndiff --git a/src/catch2/internal/catch_console_colour.hpp b/src/catch2/internal/catch_console_colour.hpp\n--- a/src/catch2/internal/catch_console_colour.hpp\n+++ b/src/catch2/internal/catch_console_colour.hpp\n@@ -47,6 +47,7 @@ namespace Catch {\n \n             Error = BrightRed,\n             Success = Green,\n+            Skip = LightGrey,\n \n             OriginalExpression = Cyan,\n             ReconstructedExpression = BrightYellow,\ndiff --git a/src/catch2/internal/catch_exception_translator_registry.cpp b/src/catch2/internal/catch_exception_translator_registry.cpp\n--- a/src/catch2/internal/catch_exception_translator_registry.cpp\n+++ b/src/catch2/internal/catch_exception_translator_registry.cpp\n@@ -44,6 +44,9 @@ namespace Catch {\n         catch( TestFailureException& ) {\n             std::rethrow_exception(std::current_exception());\n         }\n+        catch( TestSkipException& ) {\n+            std::rethrow_exception(std::current_exception());\n+        }\n         catch( std::exception const& ex ) {\n             return ex.what();\n         }\ndiff --git a/src/catch2/internal/catch_result_type.hpp b/src/catch2/internal/catch_result_type.hpp\n--- a/src/catch2/internal/catch_result_type.hpp\n+++ b/src/catch2/internal/catch_result_type.hpp\n@@ -16,6 +16,8 @@ namespace Catch {\n         Ok = 0,\n         Info = 1,\n         Warning = 2,\n+        // TODO: Should explicit skip be considered \"not OK\" (cf. isOk)? I.e., should it have the failure bit?\n+        ExplicitSkip = 4,\n \n         FailureBit = 0x10,\n \ndiff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -270,6 +270,9 @@ namespace Catch {\n         if (result.getResultType() == ResultWas::Ok) {\n             m_totals.assertions.passed++;\n             m_lastAssertionPassed = true;\n+        } else if (result.getResultType() == ResultWas::ExplicitSkip) {\n+            m_totals.assertions.skipped++;\n+            m_lastAssertionPassed = true;\n         } else if (!result.succeeded()) {\n             m_lastAssertionPassed = false;\n             if (result.isOk()) {\n@@ -475,6 +478,8 @@ namespace Catch {\n             duration = timer.getElapsedSeconds();\n         } CATCH_CATCH_ANON (TestFailureException&) {\n             // This just means the test was aborted due to failure\n+        } CATCH_CATCH_ANON (TestSkipException&) {\n+            // This just means the test was explicitly skipped\n         } CATCH_CATCH_ALL {\n             // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions\n             // are reported without translation at the point of origin.\n@@ -571,8 +576,13 @@ namespace Catch {\n         data.message = static_cast<std::string>(message);\n         AssertionResult assertionResult{ m_lastAssertionInfo, data };\n         assertionEnded( assertionResult );\n-        if( !assertionResult.isOk() )\n+        if ( !assertionResult.isOk() ) {\n             populateReaction( reaction );\n+        } else if ( resultType == ResultWas::ExplicitSkip ) {\n+            // TODO: Need to handle this explicitly, as ExplicitSkip is\n+            // considered \"OK\"\n+            reaction.shouldSkip = true;\n+        }\n     }\n     void RunContext::handleUnexpectedExceptionNotThrown(\n             AssertionInfo const& info,\ndiff --git a/src/catch2/reporters/catch_reporter_automake.cpp b/src/catch2/reporters/catch_reporter_automake.cpp\n--- a/src/catch2/reporters/catch_reporter_automake.cpp\n+++ b/src/catch2/reporters/catch_reporter_automake.cpp\n@@ -17,7 +17,9 @@ namespace Catch {\n     void AutomakeReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n         // Possible values to emit are PASS, XFAIL, SKIP, FAIL, XPASS and ERROR.\n         m_stream << \":test-result: \";\n-        if (_testCaseStats.totals.assertions.allPassed()) {\n+        if ( _testCaseStats.totals.testCases.skipped > 0 ) {\n+            m_stream << \"SKIP\";\n+        } else if (_testCaseStats.totals.assertions.allPassed()) {\n             m_stream << \"PASS\";\n         } else if (_testCaseStats.totals.assertions.allOk()) {\n             m_stream << \"XFAIL\";\ndiff --git a/src/catch2/reporters/catch_reporter_compact.cpp b/src/catch2/reporters/catch_reporter_compact.cpp\n--- a/src/catch2/reporters/catch_reporter_compact.cpp\n+++ b/src/catch2/reporters/catch_reporter_compact.cpp\n@@ -105,6 +105,11 @@ class AssertionPrinter {\n             printIssue(\"explicitly\");\n             printRemainingMessages(Colour::None);\n             break;\n+        case ResultWas::ExplicitSkip:\n+            printResultType(Colour::Skip, \"skipped\"_sr);\n+            printMessage();\n+            printRemainingMessages();\n+            break;\n             // These cases are here to prevent compiler warnings\n         case ResultWas::Unknown:\n         case ResultWas::FailureBit:\n@@ -220,7 +225,7 @@ class AssertionPrinter {\n \n             // Drop out if result was successful and we're not printing those\n             if( !m_config->includeSuccessfulResults() && result.isOk() ) {\n-                if( result.getResultType() != ResultWas::Warning )\n+                if( result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip )\n                     return;\n                 printInfoMessages = false;\n             }\ndiff --git a/src/catch2/reporters/catch_reporter_console.cpp b/src/catch2/reporters/catch_reporter_console.cpp\n--- a/src/catch2/reporters/catch_reporter_console.cpp\n+++ b/src/catch2/reporters/catch_reporter_console.cpp\n@@ -111,6 +111,14 @@ class ConsoleAssertionPrinter {\n             if (_stats.infoMessages.size() > 1)\n                 messageLabel = \"explicitly with messages\";\n             break;\n+        case ResultWas::ExplicitSkip:\n+            colour = Colour::Skip;\n+            passOrFail = \"SKIPPED\"_sr;\n+            if (_stats.infoMessages.size() == 1)\n+                messageLabel = \"explicitly with message\";\n+            if (_stats.infoMessages.size() > 1)\n+                messageLabel = \"explicitly with messages\";\n+            break;\n             // These cases are here to prevent compiler warnings\n         case ResultWas::Unknown:\n         case ResultWas::FailureBit:\n@@ -185,13 +193,16 @@ std::size_t makeRatio( std::uint64_t number, std::uint64_t total ) {\n     return (ratio == 0 && number > 0) ? 1 : static_cast<std::size_t>(ratio);\n }\n \n-std::size_t& findMax( std::size_t& i, std::size_t& j, std::size_t& k ) {\n-    if (i > j && i > k)\n+std::size_t&\n+findMax( std::size_t& i, std::size_t& j, std::size_t& k, std::size_t& l ) {\n+    if (i > j && i > k && i > l)\n         return i;\n-    else if (j > k)\n+    else if (j > k && j > l)\n         return j;\n-    else\n+    else if (k > l)\n         return k;\n+    else\n+        return l;\n }\n \n enum class Justification { Left, Right };\n@@ -400,7 +411,8 @@ void ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n     bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();\n \n     // Drop out if result was successful but we're not printing them.\n-    if (!includeResults && result.getResultType() != ResultWas::Warning)\n+    // TODO: Make configurable whether skips should be printed\n+    if (!includeResults && result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip)\n         return;\n \n     lazyPrint();\n@@ -603,10 +615,11 @@ void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\n         std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());\n         std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());\n-        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\n-            findMax(failedRatio, failedButOkRatio, passedRatio)++;\n+        std::size_t skippedRatio = makeRatio(totals.testCases.skipped, totals.testCases.total());\n+        while (failedRatio + failedButOkRatio + passedRatio + skippedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\n+            findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)++;\n         while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)\n-            findMax(failedRatio, failedButOkRatio, passedRatio)--;\n+            findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)--;\n \n         m_stream << m_colour->guardColour( Colour::Error )\n                  << std::string( failedRatio, '=' )\n@@ -619,6 +632,8 @@ void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n             m_stream << m_colour->guardColour( Colour::Success )\n                      << std::string( passedRatio, '=' );\n         }\n+        m_stream << m_colour->guardColour( Colour::Skip )\n+                 << std::string( skippedRatio, '=' );\n     } else {\n         m_stream << m_colour->guardColour( Colour::Warning )\n                  << std::string( CATCH_CONFIG_CONSOLE_WIDTH - 1, '=' );\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.cpp b/src/catch2/reporters/catch_reporter_helpers.cpp\n--- a/src/catch2/reporters/catch_reporter_helpers.cpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.cpp\n@@ -316,15 +316,22 @@ namespace Catch {\n         }\n \n         std::vector<SummaryColumn> columns;\n+        // Don't include \"skipped assertions\" in total count\n+        const auto totalAssertionCount =\n+            totals.assertions.total() - totals.assertions.skipped;\n         columns.push_back( SummaryColumn( \"\", Colour::None )\n                                .addRow( totals.testCases.total() )\n-                               .addRow( totals.assertions.total() ) );\n+                               .addRow( totalAssertionCount ) );\n         columns.push_back( SummaryColumn( \"passed\", Colour::Success )\n                                .addRow( totals.testCases.passed )\n                                .addRow( totals.assertions.passed ) );\n         columns.push_back( SummaryColumn( \"failed\", Colour::ResultError )\n                                .addRow( totals.testCases.failed )\n                                .addRow( totals.assertions.failed ) );\n+        columns.push_back( SummaryColumn( \"skipped\", Colour::Skip )\n+                               .addRow( totals.testCases.skipped )\n+                               // Don't print \"skipped assertions\"\n+                               .addRow( 0 ) );\n         columns.push_back(\n             SummaryColumn( \"failed as expected\", Colour::ResultExpectedFailure )\n                 .addRow( totals.testCases.failedButOk )\ndiff --git a/src/catch2/reporters/catch_reporter_junit.cpp b/src/catch2/reporters/catch_reporter_junit.cpp\n--- a/src/catch2/reporters/catch_reporter_junit.cpp\n+++ b/src/catch2/reporters/catch_reporter_junit.cpp\n@@ -132,6 +132,7 @@ namespace Catch {\n         xml.writeAttribute( \"name\"_sr, stats.runInfo.name );\n         xml.writeAttribute( \"errors\"_sr, unexpectedExceptions );\n         xml.writeAttribute( \"failures\"_sr, stats.totals.assertions.failed-unexpectedExceptions );\n+        xml.writeAttribute( \"skipped\"_sr, stats.totals.assertions.skipped );\n         xml.writeAttribute( \"tests\"_sr, stats.totals.assertions.total() );\n         xml.writeAttribute( \"hostname\"_sr, \"tbd\"_sr ); // !TBD\n         if( m_config->showDurations() == ShowDurations::Never )\n@@ -244,7 +245,8 @@ namespace Catch {\n \n     void JunitReporter::writeAssertion( AssertionStats const& stats ) {\n         AssertionResult const& result = stats.assertionResult;\n-        if( !result.isOk() ) {\n+        if ( !result.isOk() ||\n+             result.getResultType() == ResultWas::ExplicitSkip ) {\n             std::string elementName;\n             switch( result.getResultType() ) {\n                 case ResultWas::ThrewException:\n@@ -256,7 +258,9 @@ namespace Catch {\n                 case ResultWas::DidntThrowException:\n                     elementName = \"failure\";\n                     break;\n-\n+                case ResultWas::ExplicitSkip:\n+                    elementName = \"skipped\";\n+                    break;\n                 // We should never see these here:\n                 case ResultWas::Info:\n                 case ResultWas::Warning:\n@@ -274,7 +278,9 @@ namespace Catch {\n             xml.writeAttribute( \"type\"_sr, result.getTestMacroName() );\n \n             ReusableStringStream rss;\n-            if (stats.totals.assertions.total() > 0) {\n+            if ( result.getResultType() == ResultWas::ExplicitSkip ) {\n+                rss << \"SKIPPED\\n\";\n+            } else {\n                 rss << \"FAILED\" << \":\\n\";\n                 if (result.hasExpression()) {\n                     rss << \"  \";\n@@ -285,8 +291,6 @@ namespace Catch {\n                     rss << \"with expansion:\\n\";\n                     rss << TextFlow::Column(result.getExpandedExpression()).indent(2) << '\\n';\n                 }\n-            } else {\n-                rss << '\\n';\n             }\n \n             if( !result.getMessage().empty() )\ndiff --git a/src/catch2/reporters/catch_reporter_sonarqube.cpp b/src/catch2/reporters/catch_reporter_sonarqube.cpp\n--- a/src/catch2/reporters/catch_reporter_sonarqube.cpp\n+++ b/src/catch2/reporters/catch_reporter_sonarqube.cpp\n@@ -97,7 +97,8 @@ namespace Catch {\n \n     void SonarQubeReporter::writeAssertion(AssertionStats const& stats, bool okToFail) {\n         AssertionResult const& result = stats.assertionResult;\n-        if (!result.isOk()) {\n+        if ( !result.isOk() ||\n+             result.getResultType() == ResultWas::ExplicitSkip ) {\n             std::string elementName;\n             if (okToFail) {\n                 elementName = \"skipped\";\n@@ -108,15 +109,13 @@ namespace Catch {\n                     elementName = \"error\";\n                     break;\n                 case ResultWas::ExplicitFailure:\n-                    elementName = \"failure\";\n-                    break;\n                 case ResultWas::ExpressionFailed:\n-                    elementName = \"failure\";\n-                    break;\n                 case ResultWas::DidntThrowException:\n                     elementName = \"failure\";\n                     break;\n-\n+                case ResultWas::ExplicitSkip:\n+                    elementName = \"skipped\";\n+                    break;\n                     // We should never see these here:\n                 case ResultWas::Info:\n                 case ResultWas::Warning:\n@@ -136,7 +135,9 @@ namespace Catch {\n             xml.writeAttribute(\"message\"_sr, messageRss.str());\n \n             ReusableStringStream textRss;\n-            if (stats.totals.assertions.total() > 0) {\n+            if ( result.getResultType() == ResultWas::ExplicitSkip ) {\n+                textRss << \"SKIPPED\\n\";\n+            } else {\n                 textRss << \"FAILED:\\n\";\n                 if (result.hasExpression()) {\n                     textRss << '\\t' << result.getExpressionInMacro() << '\\n';\ndiff --git a/src/catch2/reporters/catch_reporter_tap.cpp b/src/catch2/reporters/catch_reporter_tap.cpp\n--- a/src/catch2/reporters/catch_reporter_tap.cpp\n+++ b/src/catch2/reporters/catch_reporter_tap.cpp\n@@ -100,6 +100,12 @@ namespace Catch {\n                     printIssue(\"explicitly\"_sr);\n                     printRemainingMessages(Colour::None);\n                     break;\n+                case ResultWas::ExplicitSkip:\n+                    printResultType(tapPassedString);\n+                    printIssue(\" # SKIP\"_sr);\n+                    printMessage();\n+                    printRemainingMessages();\n+                    break;\n                     // These cases are here to prevent compiler warnings\n                 case ResultWas::Unknown:\n                 case ResultWas::FailureBit:\ndiff --git a/src/catch2/reporters/catch_reporter_teamcity.cpp b/src/catch2/reporters/catch_reporter_teamcity.cpp\n--- a/src/catch2/reporters/catch_reporter_teamcity.cpp\n+++ b/src/catch2/reporters/catch_reporter_teamcity.cpp\n@@ -59,7 +59,8 @@ namespace Catch {\n \n     void TeamCityReporter::assertionEnded(AssertionStats const& assertionStats) {\n         AssertionResult const& result = assertionStats.assertionResult;\n-        if (!result.isOk()) {\n+        if ( !result.isOk() ||\n+             result.getResultType() == ResultWas::ExplicitSkip ) {\n \n             ReusableStringStream msg;\n             if (!m_headerPrintedForThisSection)\n@@ -84,6 +85,9 @@ namespace Catch {\n             case ResultWas::ExplicitFailure:\n                 msg << \"explicit failure\";\n                 break;\n+            case ResultWas::ExplicitSkip:\n+                msg << \"explicit skip\";\n+                break;\n \n                 // We shouldn't get here because of the isOk() test\n             case ResultWas::Ok:\n@@ -111,18 +115,16 @@ namespace Catch {\n                     \"  \" << result.getExpandedExpression() << '\\n';\n             }\n \n-            if (currentTestCaseInfo->okToFail()) {\n+            if ( result.getResultType() == ResultWas::ExplicitSkip ) {\n+                m_stream << \"##teamcity[testIgnored\";\n+            } else if ( currentTestCaseInfo->okToFail() ) {\n                 msg << \"- failure ignore as test marked as 'ok to fail'\\n\";\n-                m_stream << \"##teamcity[testIgnored\"\n-                    << \" name='\" << escape(currentTestCaseInfo->name) << '\\''\n-                    << \" message='\" << escape(msg.str()) << '\\''\n-                    << \"]\\n\";\n+                m_stream << \"##teamcity[testIgnored\";\n             } else {\n-                m_stream << \"##teamcity[testFailed\"\n-                    << \" name='\" << escape(currentTestCaseInfo->name) << '\\''\n-                    << \" message='\" << escape(msg.str()) << '\\''\n-                    << \"]\\n\";\n+                m_stream << \"##teamcity[testFailed\";\n             }\n+            m_stream << \" name='\" << escape( currentTestCaseInfo->name ) << '\\''\n+                     << \" message='\" << escape( msg.str() ) << '\\'' << \"]\\n\";\n         }\n         m_stream.flush();\n     }\ndiff --git a/src/catch2/reporters/catch_reporter_xml.cpp b/src/catch2/reporters/catch_reporter_xml.cpp\n--- a/src/catch2/reporters/catch_reporter_xml.cpp\n+++ b/src/catch2/reporters/catch_reporter_xml.cpp\n@@ -108,9 +108,10 @@ namespace Catch {\n         }\n \n         // Drop out if result was successful but we're not printing them.\n-        if( !includeResults && result.getResultType() != ResultWas::Warning )\n+        if ( !includeResults && result.getResultType() != ResultWas::Warning &&\n+             result.getResultType() != ResultWas::ExplicitSkip ) {\n             return;\n-\n+        }\n \n         // Print the expression if there is one.\n         if( result.hasExpression() ) {\n@@ -153,6 +154,12 @@ namespace Catch {\n                 m_xml.writeText( result.getMessage() );\n                 m_xml.endElement();\n                 break;\n+            case ResultWas::ExplicitSkip:\n+                m_xml.startElement( \"Skip\" );\n+                writeSourceInfo( result.getSourceInfo() );\n+                m_xml.writeText( result.getMessage() );\n+                m_xml.endElement();\n+                break;\n             default:\n                 break;\n         }\n@@ -163,15 +170,18 @@ namespace Catch {\n \n     void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {\n         StreamingReporterBase::sectionEnded( sectionStats );\n-        if( --m_sectionDepth > 0 ) {\n-            XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResults\" );\n-            e.writeAttribute( \"successes\"_sr, sectionStats.assertions.passed );\n-            e.writeAttribute( \"failures\"_sr, sectionStats.assertions.failed );\n-            e.writeAttribute( \"expectedFailures\"_sr, sectionStats.assertions.failedButOk );\n-\n-            if ( m_config->showDurations() == ShowDurations::Always )\n-                e.writeAttribute( \"durationInSeconds\"_sr, sectionStats.durationInSeconds );\n-\n+        if ( --m_sectionDepth > 0 ) {\n+            {\n+                XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResults\" );\n+                e.writeAttribute( \"successes\"_sr, sectionStats.assertions.passed );\n+                e.writeAttribute( \"failures\"_sr, sectionStats.assertions.failed );\n+                e.writeAttribute( \"expectedFailures\"_sr, sectionStats.assertions.failedButOk );\n+                e.writeAttribute( \"skipped\"_sr, sectionStats.assertions.skipped > 0 );\n+\n+                if ( m_config->showDurations() == ShowDurations::Always )\n+                    e.writeAttribute( \"durationInSeconds\"_sr, sectionStats.durationInSeconds );\n+            }\n+            // Ends assertion tag\n             m_xml.endElement();\n         }\n     }\n@@ -180,6 +190,7 @@ namespace Catch {\n         StreamingReporterBase::testCaseEnded( testCaseStats );\n         XmlWriter::ScopedElement e = m_xml.scopedElement( \"OverallResult\" );\n         e.writeAttribute( \"success\"_sr, testCaseStats.totals.assertions.allOk() );\n+        e.writeAttribute( \"skips\"_sr, testCaseStats.totals.assertions.skipped );\n \n         if ( m_config->showDurations() == ShowDurations::Always )\n             e.writeAttribute( \"durationInSeconds\"_sr, m_testCaseTimer.getElapsedSeconds() );\n@@ -197,11 +208,13 @@ namespace Catch {\n         m_xml.scopedElement( \"OverallResults\" )\n             .writeAttribute( \"successes\"_sr, testRunStats.totals.assertions.passed )\n             .writeAttribute( \"failures\"_sr, testRunStats.totals.assertions.failed )\n-            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.assertions.failedButOk );\n+            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.assertions.failedButOk )\n+            .writeAttribute( \"skips\"_sr, testRunStats.totals.assertions.skipped );\n         m_xml.scopedElement( \"OverallResultsCases\")\n             .writeAttribute( \"successes\"_sr, testRunStats.totals.testCases.passed )\n             .writeAttribute( \"failures\"_sr, testRunStats.totals.testCases.failed )\n-            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.testCases.failedButOk );\n+            .writeAttribute( \"expectedFailures\"_sr, testRunStats.totals.testCases.failedButOk )\n+            .writeAttribute( \"skips\"_sr, testRunStats.totals.testCases.skipped );\n         m_xml.endElement();\n     }\n \n", "test_patch": "diff --git a/src/catch2/catch_test_macros.hpp b/src/catch2/catch_test_macros.hpp\n--- a/src/catch2/catch_test_macros.hpp\n+++ b/src/catch2/catch_test_macros.hpp\n@@ -49,6 +49,7 @@\n   #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n   #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"CATCH_FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( \"CATCH_SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CATCH_SKIP( ... ) INTERNAL_CATCH_MSG( \"SKIP\", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n \n \n   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)\n@@ -102,6 +103,7 @@\n   #define CATCH_FAIL( ... ) (void)(0)\n   #define CATCH_FAIL_CHECK( ... ) (void)(0)\n   #define CATCH_SUCCEED( ... ) (void)(0)\n+  #define CATCH_SKIP( ... ) (void)(0)\n \n   #define CATCH_STATIC_REQUIRE( ... )       (void)(0)\n   #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)\n@@ -146,6 +148,7 @@\n   #define FAIL( ... ) INTERNAL_CATCH_MSG( \"FAIL\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n   #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( \"FAIL_CHECK\", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define SUCCEED( ... ) INTERNAL_CATCH_MSG( \"SUCCEED\", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define SKIP( ... ) INTERNAL_CATCH_MSG( \"SKIP\", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )\n \n \n   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)\n@@ -198,6 +201,7 @@\n   #define FAIL( ... ) (void)(0)\n   #define FAIL_CHECK( ... ) (void)(0)\n   #define SUCCEED( ... ) (void)(0)\n+  #define SKIP( ... ) (void)(0)\n \n   #define STATIC_REQUIRE( ... )       (void)(0)\n   #define STATIC_REQUIRE_FALSE( ... ) (void)(0)\ndiff --git a/src/catch2/internal/catch_test_failure_exception.hpp b/src/catch2/internal/catch_test_failure_exception.hpp\n--- a/src/catch2/internal/catch_test_failure_exception.hpp\n+++ b/src/catch2/internal/catch_test_failure_exception.hpp\n@@ -20,6 +20,9 @@ namespace Catch {\n      */\n     [[noreturn]] void throw_test_failure_exception();\n \n+    //! Used to signal that the remainder of a test should be skipped\n+    struct TestSkipException{};\n+\n } // namespace Catch\n \n #endif // CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED\ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -116,6 +116,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/UsageTests/Generators.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/Message.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/Misc.tests.cpp\n+        ${SELF_TEST_DIR}/UsageTests/Skip.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/ToStringByte.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/ToStringChrono.tests.cpp\n         ${SELF_TEST_DIR}/UsageTests/ToStringGeneral.tests.cpp\n@@ -272,6 +273,10 @@ add_test(NAME TestSpecs::OverrideFailureWithNoMatchedTests\n   COMMAND $<TARGET_FILE:SelfTest> \"___nonexistent_test___\" --allow-running-no-tests\n )\n \n+add_test(NAME TestSpecs::OverrideAllSkipFailure\n+  COMMAND $<TARGET_FILE:SelfTest> \"tests can be skipped dynamically at runtime\" --allow-running-no-tests\n+)\n+\n add_test(NAME TestSpecs::NonMatchingTestSpecIsRoundTrippable\n     COMMAND $<TARGET_FILE:SelfTest> Tracker, \"this test does not exist\" \"[nor does this tag]\"\n )\ndiff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -488,15 +488,32 @@ set_tests_properties(TestSpecs::EmptySpecWithNoTestsFails\n   PROPERTIES\n     WILL_FAIL ON\n )\n+\n add_test(\n   NAME TestSpecs::OverrideFailureWithEmptySpec\n   COMMAND $<TARGET_FILE:NoTests> --allow-running-no-tests\n )\n+\n add_test(\n   NAME List::Listeners::WorksWithoutRegisteredListeners\n   COMMAND $<TARGET_FILE:NoTests> --list-listeners\n )\n+\n+\n+add_executable(AllSkipped ${TESTS_DIR}/X93-AllSkipped.cpp)\n+target_link_libraries(AllSkipped PRIVATE Catch2::Catch2WithMain)\n+\n+add_test(\n+  NAME TestSpecs::SkippingAllTestsFails\n+  COMMAND $<TARGET_FILE:AllSkipped>\n+)\n+set_tests_properties(TestSpecs::SkippingAllTestsFails\n+  PROPERTIES\n+    WILL_FAIL ON\n+)\n+\n set( EXTRA_TEST_BINARIES\n+    AllSkipped\n     PrefixedMacros\n     DisabledMacros\n     DisabledExceptions-DefaultHandler\ndiff --git a/tests/ExtraTests/X93-AllSkipped.cpp b/tests/ExtraTests/X93-AllSkipped.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ExtraTests/X93-AllSkipped.cpp\n@@ -0,0 +1,16 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+TEST_CASE( \"this test case is being skipped\" ) { SKIP(); }\n+\n+TEST_CASE( \"all sections in this test case are being skipped\" ) {\n+    SECTION( \"A\" ) { SKIP(); }\n+    SECTION( \"B\" ) { SKIP(); }\n+}\ndiff --git a/tests/SelfTest/UsageTests/Skip.tests.cpp b/tests/SelfTest/UsageTests/Skip.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/UsageTests/Skip.tests.cpp\n@@ -0,0 +1,73 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+#include <catch2/generators/catch_generators_range.hpp>\n+\n+#include <iostream>\n+\n+TEST_CASE( \"tests can be skipped dynamically at runtime\", \"[skipping]\" ) {\n+    SKIP();\n+    FAIL( \"this is not reached\" );\n+}\n+\n+TEST_CASE( \"skipped tests can optionally provide a reason\", \"[skipping]\" ) {\n+    const int answer = 43;\n+    SKIP( \"skipping because answer = \" << answer );\n+    FAIL( \"this is not reached\" );\n+}\n+\n+TEST_CASE( \"sections can be skipped dynamically at runtime\", \"[skipping]\" ) {\n+    SECTION( \"not skipped\" ) { SUCCEED(); }\n+    SECTION( \"skipped\" ) { SKIP(); }\n+    SECTION( \"also not skipped\" ) { SUCCEED(); }\n+}\n+\n+TEST_CASE( \"nested sections can be skipped dynamically at runtime\",\n+           \"[skipping]\" ) {\n+    SECTION( \"A\" ) { std::cout << \"a\"; }\n+    SECTION( \"B\" ) {\n+        SECTION( \"B1\" ) { std::cout << \"b1\"; }\n+        SECTION( \"B2\" ) { SKIP(); }\n+    }\n+    std::cout << \"!\\n\";\n+}\n+\n+TEST_CASE( \"dynamic skipping works with generators\", \"[skipping]\" ) {\n+    const int answer = GENERATE( 41, 42, 43 );\n+    if ( answer != 42 ) { SKIP( \"skipping because answer = \" << answer ); }\n+    SUCCEED();\n+}\n+\n+TEST_CASE( \"failed assertions before SKIP cause test case to fail\",\n+           \"[skipping][!shouldfail]\" ) {\n+    CHECK( 3 == 4 );\n+    SKIP();\n+}\n+\n+TEST_CASE( \"a succeeding test can still be skipped\",\n+           \"[skipping][!shouldfail]\" ) {\n+    SUCCEED();\n+    SKIP();\n+}\n+\n+TEST_CASE( \"failing in some unskipped sections causes entire test case to fail\",\n+           \"[skipping][!shouldfail]\" ) {\n+    SECTION( \"skipped\" ) { SKIP(); }\n+    SECTION( \"not skipped\" ) { FAIL(); }\n+}\n+\n+TEST_CASE( \"failing for some generator values causes entire test case to fail\",\n+           \"[skipping][!shouldfail]\" ) {\n+    int i = GENERATE( 1, 2, 3, 4 );\n+    if ( i % 2 == 0 ) {\n+        SKIP();\n+    } else {\n+        FAIL();\n+    }\n+}\n", "problem_statement": "Allow skipping tests at run-time.\nThis is another request for a way to skip tests, but it's not quite the same as #355 because in my case the condition determining if the test can be run or should be skipped is dynamic and determined by the program itself (basically it connects to the database specified on the command line and does different things depending on the exact kind of RDBMS).\n\nCurrently I just test the condition and use `WARN(\"Skipped because...\")`, but this is not ideal because the test still counts as passing when, in fact, it wasn't run at all.\n\n", "hints_text": "The next level would be to have a declarative way of describing dependencies between tests. And when one is skipped or failed skip the dependent ones.\n\nIt would be really great to have this facility for a bunch of tests I have, as their viability is determined only at runtime.", "created_at": "2022-01-31T16:16:06Z", "version": "3.2"}
{"repo": "catchorg/Catch2", "pull_number": 2554, "instance_id": "catchorg__Catch2-2554", "issue_numbers": ["878"], "base_commit": "8ce92d2c7288b6b3261caf1c016f8a779b6a8efc", "patch": "diff --git a/src/catch2/reporters/catch_reporter_compact.cpp b/src/catch2/reporters/catch_reporter_compact.cpp\n--- a/src/catch2/reporters/catch_reporter_compact.cpp\n+++ b/src/catch2/reporters/catch_reporter_compact.cpp\n@@ -18,22 +18,6 @@\n \n #include <ostream>\n \n-namespace {\n-\n-    constexpr Catch::StringRef bothOrAll( std::uint64_t count ) {\n-        switch (count) {\n-        case 1:\n-            return Catch::StringRef{};\n-        case 2:\n-            return \"both \"_catch_sr;\n-        default:\n-            return \"all \"_catch_sr;\n-        }\n-    }\n-\n-} // anon namespace\n-\n-\n namespace Catch {\n namespace {\n \n@@ -48,42 +32,6 @@ namespace {\n     static constexpr Catch::StringRef compactPassedString = \"passed\"_sr;\n #endif\n \n-// Colour, message variants:\n-// - white: No tests ran.\n-// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.\n-// - white: Passed [both/all] N test cases (no assertions).\n-// -   red: Failed N tests cases, failed M assertions.\n-// - green: Passed [both/all] N tests cases with M assertions.\n-void printTotals(std::ostream& out, const Totals& totals, ColourImpl* colourImpl) {\n-    if (totals.testCases.total() == 0) {\n-        out << \"No tests ran.\";\n-    } else if (totals.testCases.failed == totals.testCases.total()) {\n-        auto guard = colourImpl->guardColour( Colour::ResultError ).engage( out );\n-        const StringRef qualify_assertions_failed =\n-            totals.assertions.failed == totals.assertions.total() ?\n-            bothOrAll(totals.assertions.failed) : StringRef{};\n-        out <<\n-            \"Failed \" << bothOrAll(totals.testCases.failed)\n-            << pluralise(totals.testCases.failed, \"test case\"_sr) << \", \"\n-            \"failed \" << qualify_assertions_failed <<\n-            pluralise(totals.assertions.failed, \"assertion\"_sr) << '.';\n-    } else if (totals.assertions.total() == 0) {\n-        out <<\n-            \"Passed \" << bothOrAll(totals.testCases.total())\n-            << pluralise(totals.testCases.total(), \"test case\"_sr)\n-            << \" (no assertions).\";\n-    } else if (totals.assertions.failed) {\n-        out << colourImpl->guardColour( Colour::ResultError ) <<\n-            \"Failed \" << pluralise(totals.testCases.failed, \"test case\"_sr) << \", \"\n-            \"failed \" << pluralise(totals.assertions.failed, \"assertion\"_sr) << '.';\n-    } else {\n-        out << colourImpl->guardColour( Colour::ResultSuccess ) <<\n-            \"Passed \" << bothOrAll(totals.testCases.passed)\n-            << pluralise(totals.testCases.passed, \"test case\"_sr) <<\n-            \" with \" << pluralise(totals.assertions.passed, \"assertion\"_sr) << '.';\n-    }\n-}\n-\n // Implementation of CompactReporter formatting\n class AssertionPrinter {\n public:\n@@ -291,7 +239,7 @@ class AssertionPrinter {\n         }\n \n         void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {\n-            printTotals( m_stream, _testRunStats.totals, m_colour.get() );\n+            printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\n             m_stream << \"\\n\\n\" << std::flush;\n             StreamingReporterBase::testRunEnded( _testRunStats );\n         }\ndiff --git a/src/catch2/reporters/catch_reporter_console.cpp b/src/catch2/reporters/catch_reporter_console.cpp\n--- a/src/catch2/reporters/catch_reporter_console.cpp\n+++ b/src/catch2/reporters/catch_reporter_console.cpp\n@@ -491,7 +491,7 @@ void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n }\n void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {\n     printTotalsDivider(_testRunStats.totals);\n-    printTotals(_testRunStats.totals);\n+    printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\n     m_stream << '\\n' << std::flush;\n     StreamingReporterBase::testRunEnded(_testRunStats);\n }\n@@ -598,82 +598,6 @@ void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t\n            << '\\n';\n }\n \n-struct SummaryColumn {\n-\n-    SummaryColumn( std::string _label, Colour::Code _colour )\n-    :   label( CATCH_MOVE( _label ) ),\n-        colour( _colour ) {}\n-    SummaryColumn addRow( std::uint64_t count ) {\n-        ReusableStringStream rss;\n-        rss << count;\n-        std::string row = rss.str();\n-        for (auto& oldRow : rows) {\n-            while (oldRow.size() < row.size())\n-                oldRow = ' ' + oldRow;\n-            while (oldRow.size() > row.size())\n-                row = ' ' + row;\n-        }\n-        rows.push_back(row);\n-        return *this;\n-    }\n-\n-    std::string label;\n-    Colour::Code colour;\n-    std::vector<std::string> rows;\n-\n-};\n-\n-void ConsoleReporter::printTotals( Totals const& totals ) {\n-    if (totals.testCases.total() == 0) {\n-        m_stream << m_colour->guardColour( Colour::Warning )\n-                 << \"No tests ran\\n\";\n-    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {\n-        m_stream << m_colour->guardColour( Colour::ResultSuccess )\n-                 << \"All tests passed\";\n-        m_stream << \" (\"\n-            << pluralise(totals.assertions.passed, \"assertion\"_sr) << \" in \"\n-            << pluralise(totals.testCases.passed, \"test case\"_sr) << ')'\n-            << '\\n';\n-    } else {\n-\n-        std::vector<SummaryColumn> columns;\n-        columns.push_back(SummaryColumn(\"\", Colour::None)\n-                          .addRow(totals.testCases.total())\n-                          .addRow(totals.assertions.total()));\n-        columns.push_back(SummaryColumn(\"passed\", Colour::Success)\n-                          .addRow(totals.testCases.passed)\n-                          .addRow(totals.assertions.passed));\n-        columns.push_back(SummaryColumn(\"failed\", Colour::ResultError)\n-                          .addRow(totals.testCases.failed)\n-                          .addRow(totals.assertions.failed));\n-        columns.push_back(SummaryColumn(\"failed as expected\", Colour::ResultExpectedFailure)\n-                          .addRow(totals.testCases.failedButOk)\n-                          .addRow(totals.assertions.failedButOk));\n-\n-        printSummaryRow(\"test cases\"_sr, columns, 0);\n-        printSummaryRow(\"assertions\"_sr, columns, 1);\n-    }\n-}\n-void ConsoleReporter::printSummaryRow(StringRef label, std::vector<SummaryColumn> const& cols, std::size_t row) {\n-    for (auto col : cols) {\n-        std::string const& value = col.rows[row];\n-        if (col.label.empty()) {\n-            m_stream << label << \": \";\n-            if ( value != \"0\" ) {\n-                m_stream << value;\n-            } else {\n-                m_stream << m_colour->guardColour( Colour::Warning )\n-                         << \"- none -\";\n-            }\n-        } else if (value != \"0\") {\n-            m_stream << m_colour->guardColour( Colour::LightGrey ) << \" | \"\n-                     << m_colour->guardColour( col.colour ) << value << ' '\n-                     << col.label;\n-        }\n-    }\n-    m_stream << '\\n';\n-}\n-\n void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n     if (totals.testCases.total() > 0) {\n         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\n@@ -701,9 +625,6 @@ void ConsoleReporter::printTotalsDivider(Totals const& totals) {\n     }\n     m_stream << '\\n';\n }\n-void ConsoleReporter::printSummaryDivider() {\n-    m_stream << lineOfChars('-') << '\\n';\n-}\n \n } // end namespace Catch\n \ndiff --git a/src/catch2/reporters/catch_reporter_console.hpp b/src/catch2/reporters/catch_reporter_console.hpp\n--- a/src/catch2/reporters/catch_reporter_console.hpp\n+++ b/src/catch2/reporters/catch_reporter_console.hpp\n@@ -13,7 +13,6 @@\n \n namespace Catch {\n     // Fwd decls\n-    struct SummaryColumn;\n     class TablePrinter;\n \n     class ConsoleReporter final : public StreamingReporterBase {\n@@ -57,12 +56,7 @@ namespace Catch {\n         // subsequent lines\n         void printHeaderString(std::string const& _string, std::size_t indent = 0);\n \n-\n-        void printTotals(Totals const& totals);\n-        void printSummaryRow(StringRef label, std::vector<SummaryColumn> const& cols, std::size_t row);\n-\n         void printTotalsDivider(Totals const& totals);\n-        void printSummaryDivider();\n \n         bool m_headerPrinted = false;\n         bool m_testRunInfoPrinted = false;\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.cpp b/src/catch2/reporters/catch_reporter_helpers.cpp\n--- a/src/catch2/reporters/catch_reporter_helpers.cpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.cpp\n@@ -235,4 +235,102 @@ namespace Catch {\n         out << \"\\n\\n\" << std::flush;\n     }\n \n+    namespace {\n+        class SummaryColumn {\n+        public:\n+            SummaryColumn( std::string suffix, Colour::Code colour ):\n+                m_suffix( CATCH_MOVE( suffix ) ), m_colour( colour ) {}\n+\n+            SummaryColumn&& addRow( std::uint64_t count ) && {\n+                std::string row = std::to_string(count);\n+                auto const new_width = std::max( m_width, row.size() );\n+                if ( new_width > m_width ) {\n+                    for ( auto& oldRow : m_rows ) {\n+                        oldRow.insert( 0, new_width - m_width, ' ' );\n+                    }\n+                } else {\n+                    row.insert( 0, m_width - row.size(), ' ' );\n+                }\n+                m_width = new_width;\n+                m_rows.push_back( row );\n+                return std::move( *this );\n+            }\n+\n+            std::string const& getSuffix() const { return m_suffix; }\n+            Colour::Code getColour() const { return m_colour; }\n+            std::string const& getRow( std::size_t index ) const {\n+                return m_rows[index];\n+            }\n+\n+        private:\n+            std::string m_suffix;\n+            Colour::Code m_colour;\n+            std::size_t m_width = 0;\n+            std::vector<std::string> m_rows;\n+        };\n+\n+        void printSummaryRow( std::ostream& stream,\n+                              ColourImpl& colour,\n+                              StringRef label,\n+                              std::vector<SummaryColumn> const& cols,\n+                              std::size_t row ) {\n+            for ( auto const& col : cols ) {\n+                auto const& value = col.getRow( row );\n+                auto const& suffix = col.getSuffix();\n+                if ( suffix.empty() ) {\n+                    stream << label << \": \";\n+                    if ( value != \"0\" ) {\n+                        stream << value;\n+                    } else {\n+                        stream << colour.guardColour( Colour::Warning )\n+                               << \"- none -\";\n+                    }\n+                } else if ( value != \"0\" ) {\n+                    stream << colour.guardColour( Colour::LightGrey ) << \" | \"\n+                           << colour.guardColour( col.getColour() ) << value\n+                           << ' ' << suffix;\n+                }\n+            }\n+            stream << '\\n';\n+        }\n+    } // namespace\n+\n+    void printTestRunTotals( std::ostream& stream,\n+                             ColourImpl& streamColour,\n+                             Totals const& totals ) {\n+        if ( totals.testCases.total() == 0 ) {\n+            stream << streamColour.guardColour( Colour::Warning )\n+                   << \"No tests ran\\n\";\n+            return;\n+        }\n+\n+        if ( totals.assertions.total() > 0 && totals.testCases.allPassed() ) {\n+            stream << streamColour.guardColour( Colour::ResultSuccess )\n+                   << \"All tests passed\";\n+            stream << \" (\"\n+                   << pluralise( totals.assertions.passed, \"assertion\"_sr )\n+                   << \" in \"\n+                   << pluralise( totals.testCases.passed, \"test case\"_sr )\n+                   << ')' << '\\n';\n+            return;\n+        }\n+\n+        std::vector<SummaryColumn> columns;\n+        columns.push_back( SummaryColumn( \"\", Colour::None )\n+                               .addRow( totals.testCases.total() )\n+                               .addRow( totals.assertions.total() ) );\n+        columns.push_back( SummaryColumn( \"passed\", Colour::Success )\n+                               .addRow( totals.testCases.passed )\n+                               .addRow( totals.assertions.passed ) );\n+        columns.push_back( SummaryColumn( \"failed\", Colour::ResultError )\n+                               .addRow( totals.testCases.failed )\n+                               .addRow( totals.assertions.failed ) );\n+        columns.push_back(\n+            SummaryColumn( \"failed as expected\", Colour::ResultExpectedFailure )\n+                .addRow( totals.testCases.failedButOk )\n+                .addRow( totals.assertions.failedButOk ) );\n+        printSummaryRow( stream, streamColour, \"test cases\"_sr, columns, 0 );\n+        printSummaryRow( stream, streamColour, \"assertions\"_sr, columns, 1 );\n+    }\n+\n } // namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.hpp b/src/catch2/reporters/catch_reporter_helpers.hpp\n--- a/src/catch2/reporters/catch_reporter_helpers.hpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.hpp\n@@ -14,6 +14,7 @@\n \n #include <catch2/internal/catch_list.hpp>\n #include <catch2/interfaces/catch_interfaces_config.hpp>\n+#include <catch2/catch_totals.hpp>\n \n namespace Catch {\n \n@@ -80,6 +81,15 @@ namespace Catch {\n                            bool isFiltered,\n                            Verbosity verbosity );\n \n+    /**\n+     * Prints test run totals to the provided stream in user-friendly format\n+     *\n+     * Used by the console and compact reporters.\n+     */\n+    void printTestRunTotals( std::ostream& stream,\n+                      ColourImpl& streamColour,\n+                      Totals const& totals );\n+\n } // end namespace Catch\n \n #endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -336,7 +336,7 @@ set_tests_properties(ApprovalTests\n )\n \n add_test(NAME RegressionCheck-1670 COMMAND $<TARGET_FILE:SelfTest> \"#1670 regression check\" -c A -r compact)\n-set_tests_properties(RegressionCheck-1670 PROPERTIES PASS_REGULAR_EXPRESSION \"Passed 1 test case with 2 assertions.\")\n+set_tests_properties(RegressionCheck-1670 PROPERTIES PASS_REGULAR_EXPRESSION \"All tests passed \\\\(2 assertions in 1 test case\\\\)\")\n \n add_test(NAME VersionCheck COMMAND $<TARGET_FILE:SelfTest> -h)\n set_tests_properties(VersionCheck PROPERTIES PASS_REGULAR_EXPRESSION \"Catch2 v${PROJECT_VERSION}\")\ndiff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -210,7 +210,7 @@ add_test(NAME DeferredStaticChecks COMMAND DeferredStaticChecks -r compact)\n set_tests_properties(\n     DeferredStaticChecks\n   PROPERTIES\n-    PASS_REGULAR_EXPRESSION \"Failed 1 test case, failed all 3 assertions.\"\n+    PASS_REGULAR_EXPRESSION \"test cases: 1 \\\\| 1 failed\\nassertions: 3 \\\\| 3 failed\"\n )\n \n \n", "problem_statement": "Compact reporter does not handle [!shouldfail] properly\n## Description\r\nCompact reporter does not handle the `[!shouldfail]` tag properly. Given this code (from #876):\r\n```cpp\r\nbool thisThrows() {\r\n    throw std::runtime_error(\"Boom\");\r\n}\r\n\r\nTEST_CASE(\"#748 - captures with unexpected exceptions\", \"[!shouldfail]\") {\r\n    int answer = 42;\r\n    CAPTURE(answer);\r\n    // the message should be printed on the first two sections but not on the third\r\n    SECTION(\"outside assertions\") {\r\n        thisThrows();\r\n    }\r\n    SECTION(\"inside REQUIRE_NOTHROW\") {\r\n        REQUIRE_NOTHROW(thisThrows());\r\n    }\r\n    SECTION(\"inside REQUIRE_THROWS\") {\r\n        REQUIRE_THROWS(thisThrows());\r\n    }\r\n}\r\n```\r\ncompact reporter's output is\r\n```\r\n<snip>\r\nPassed all 0 test cases with 1 assertion.\r\n```\r\nwhich, while kind-of correct, is surprising. Standard console reporter's output looks like this:\r\n```\r\n<snip>\r\ntest cases: 1 | 1 failed as expected\r\nassertions: 3 | 1 passed | 2 failed as expected\r\n```\r\nwhich is much clearer about what happened and should be in some way replicated by the compact reporter.\r\n\r\n\r\n### Extra information\r\n* Catch version: **v1.8.2**\r\n\n", "hints_text": "I thought a bit about how this might look like but any attempts to have all the information on a single line ended up being quite messy (and it will only get worse with #2360). How about we just copy the output format from the console reporter exactly, save for the \"totals divider\"?\nYeah, that seems fine.\nOkay, stylistically, would you prefer (1) a common base class for console and compact reporter, (2) free functions used by both or (3) code duplication?\n2) or 3), depending on how annoying the signature would be. I don't think the console and compact reporters should have a shared base class.", "created_at": "2022-10-24T12:27:56Z", "version": "3.1"}
{"repo": "catchorg/Catch2", "pull_number": 2521, "instance_id": "catchorg__Catch2-2521", "issue_numbers": ["2520", "2520"], "base_commit": "359542d53ec142514da8a606ada8d9efd13b9678", "patch": "diff --git a/src/catch2/internal/catch_compiler_capabilities.hpp b/src/catch2/internal/catch_compiler_capabilities.hpp\n--- a/src/catch2/internal/catch_compiler_capabilities.hpp\n+++ b/src/catch2/internal/catch_compiler_capabilities.hpp\n@@ -53,6 +53,9 @@\n #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n          _Pragma( \"GCC diagnostic ignored \\\"-Wunused-variable\\\"\" )\n \n+#    define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n+         _Pragma( \"GCC diagnostic ignored \\\"-Wuseless-cast\\\"\" )\n+\n #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)\n \n #endif\n@@ -335,6 +338,9 @@\n #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS)\n #   define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS\n #endif\n+#if !defined(CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS)\n+#   define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS\n+#endif\n #if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)\n #   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS\n #endif\n", "test_patch": "diff --git a/src/catch2/internal/catch_test_macro_impl.hpp b/src/catch2/internal/catch_test_macro_impl.hpp\n--- a/src/catch2/internal/catch_test_macro_impl.hpp\n+++ b/src/catch2/internal/catch_test_macro_impl.hpp\n@@ -76,7 +76,10 @@\n     do { \\\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\n         try { \\\n+            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+            CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n             static_cast<void>(__VA_ARGS__); \\\n+            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n             catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\\n         } \\\n         catch( ... ) { \\\n@@ -91,7 +94,10 @@\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\\n         if( catchAssertionHandler.allowThrows() ) \\\n             try { \\\n+                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n                 static_cast<void>(__VA_ARGS__); \\\n+                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n             } \\\n             catch( ... ) { \\\n@@ -108,7 +114,10 @@\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) \", \" CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\\n         if( catchAssertionHandler.allowThrows() ) \\\n             try { \\\n+                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n                 static_cast<void>(expr); \\\n+                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n             } \\\n             catch( exceptionType const& ) { \\\n@@ -131,7 +140,10 @@\n         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) \", \" CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\n         if( catchAssertionHandler.allowThrows() ) \\\n             try { \\\n+                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n+                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\n                 static_cast<void>(__VA_ARGS__); \\\n+                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\n             } \\\n             catch( ... ) { \\\n", "problem_statement": "useless-cast warning from THROW macro family\n**Describe the bug**\r\nWe get the following error message (with -Werror) when using `REQUIRE_NOTHROW` on a void function.\r\n```\r\n.../Catch2/src/catch2/internal/catch_test_macro_impl.hpp:79:13: error: useless cast to type 'void' [-Werror=useless-cast]\r\n   79 |             static_cast<void>(__VA_ARGS__); \\\r\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n.../Catch2/src/catch2/catch_test_macros.hpp:128:34: note: in expansion of macro 'INTERNAL_CATCH_NO_THROW'\r\n  128 |   #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\r\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~\r\nmycode.cpp:47:41: note: in expansion of macro 'REQUIRE_NOTHROW'\r\n```\r\n\r\n**Expected behavior**\r\nNo Warning.\r\n\r\n**Reproduction steps**\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n\r\nvoid op();\r\n\r\nTEST_CASE(\"\") {\r\n    REQUIRE_NOTHROW(op());\r\n}\r\n```\r\nAlthough I was not able to reproduce it on godbolt.\r\n\r\n\r\n**Platform information:**\r\n - OS: **Windows 10**\r\n - Compiler+version: **g++.exe (Rev1, Built by MSYS2 project) 12.2.0**\r\n - We have `-Wuseless-cast` in our warning list\r\n - Catch version: **v3.1.0**\r\n\r\n\r\n**Additional context**\r\nWe just migrated from Catch 2.13.8 with the single include. Before the Code produced no warning.\r\n\r\nI'm also willing to fix this with\r\n```\r\n                if constexpr ( std::is_same_v<decltype( __VA_ARGS__ ),      \\\r\n                                              void> ) {                     \\\r\n                    __VA_ARGS__;                                            \\\r\n                } else {                                                    \\\r\n                    static_cast<void>( __VA_ARGS__ );                       \\\r\n                }                                                           \\\r\n```\nuseless-cast warning from THROW macro family\n**Describe the bug**\r\nWe get the following error message (with -Werror) when using `REQUIRE_NOTHROW` on a void function.\r\n```\r\n.../Catch2/src/catch2/internal/catch_test_macro_impl.hpp:79:13: error: useless cast to type 'void' [-Werror=useless-cast]\r\n   79 |             static_cast<void>(__VA_ARGS__); \\\r\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n.../Catch2/src/catch2/catch_test_macros.hpp:128:34: note: in expansion of macro 'INTERNAL_CATCH_NO_THROW'\r\n  128 |   #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( \"REQUIRE_NOTHROW\", Catch::ResultDisposition::Normal, __VA_ARGS__ )\r\n      |                                  ^~~~~~~~~~~~~~~~~~~~~~~\r\nmycode.cpp:47:41: note: in expansion of macro 'REQUIRE_NOTHROW'\r\n```\r\n\r\n**Expected behavior**\r\nNo Warning.\r\n\r\n**Reproduction steps**\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n\r\nvoid op();\r\n\r\nTEST_CASE(\"\") {\r\n    REQUIRE_NOTHROW(op());\r\n}\r\n```\r\nAlthough I was not able to reproduce it on godbolt.\r\n\r\n\r\n**Platform information:**\r\n - OS: **Windows 10**\r\n - Compiler+version: **g++.exe (Rev1, Built by MSYS2 project) 12.2.0**\r\n - We have `-Wuseless-cast` in our warning list\r\n - Catch version: **v3.1.0**\r\n\r\n\r\n**Additional context**\r\nWe just migrated from Catch 2.13.8 with the single include. Before the Code produced no warning.\r\n\r\nI'm also willing to fix this with\r\n```\r\n                if constexpr ( std::is_same_v<decltype( __VA_ARGS__ ),      \\\r\n                                              void> ) {                     \\\r\n                    __VA_ARGS__;                                            \\\r\n                } else {                                                    \\\r\n                    static_cast<void>( __VA_ARGS__ );                       \\\r\n                }                                                           \\\r\n```\n", "hints_text": "Okay that doesn't solve the warning. So one would need to suppress it?\nOkay that doesn't solve the warning. So one would need to suppress it?", "created_at": "2022-09-14T08:37:37Z", "version": "3.1"}
{"repo": "catchorg/Catch2", "pull_number": 1770, "instance_id": "catchorg__Catch2-1770", "issue_numbers": ["1766"], "base_commit": "01ef7076f50f5f2b481ddf082e1afca3c926983f", "patch": "diff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -49,9 +49,15 @@ namespace Catch {\n                     if( !line.empty() && !startsWith( line, '#' ) ) {\n                         if( !startsWith( line, '\"' ) )\n                             line = '\"' + line + '\"';\n-                        config.testsOrTags.push_back( line + ',' );\n+                        config.testsOrTags.push_back( line );\n+                        config.testsOrTags.push_back( \",\" );\n+                        \n                     }\n                 }\n+                //Remove comma in the end\n+                if(!config.testsOrTags.empty())\n+                    config.testsOrTags.erase( config.testsOrTags.end()-1 );\n+                \n                 return ParserResult::ok( ParseResultType::Matched );\n             };\n         auto const setTestOrder = [&]( std::string const& order ) {\ndiff --git a/include/internal/catch_interfaces_reporter.h b/include/internal/catch_interfaces_reporter.h\n--- a/include/internal/catch_interfaces_reporter.h\n+++ b/include/internal/catch_interfaces_reporter.h\n@@ -214,6 +214,8 @@ namespace Catch {\n \n         virtual void noMatchingTestCases( std::string const& spec ) = 0;\n \n+        virtual void reportInvalidArguments(std::string const&) {}\n+        \n         virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;\n         virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;\n \ndiff --git a/include/internal/catch_session.cpp b/include/internal/catch_session.cpp\n--- a/include/internal/catch_session.cpp\n+++ b/include/internal/catch_session.cpp\n@@ -68,8 +68,9 @@ namespace Catch {\n             {\n                 auto const& allTestCases = getAllTestCasesSorted(*m_config);\n                 m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);\n-\n-                if (m_matches.empty()) {\n+                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();\n+                \n+                if (m_matches.empty() && invalidArgs.empty()) {\n                     for (auto const& test : allTestCases)\n                         if (!test.isHidden())\n                             m_tests.emplace(&test);\n@@ -80,6 +81,7 @@ namespace Catch {\n             }\n \n             Totals execute() {\n+                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();\n                 Totals totals;\n                 m_context.testGroupStarting(m_config->name(), 1, 1);\n                 for (auto const& testCase : m_tests) {\n@@ -95,6 +97,12 @@ namespace Catch {\n                         totals.error = -1;\n                     }\n                 }\n+                \n+                if (!invalidArgs.empty()) {\n+                    for (auto const& invalidArg: invalidArgs)                   \n+                         m_context.reporter().reportInvalidArguments(invalidArg);\n+                }   \n+                \n                 m_context.testGroupEnded(m_config->name(), totals, 1, 1);\n                 return totals;\n             }\ndiff --git a/include/reporters/catch_reporter_bases.hpp b/include/reporters/catch_reporter_bases.hpp\n--- a/include/reporters/catch_reporter_bases.hpp\n+++ b/include/reporters/catch_reporter_bases.hpp\n@@ -51,6 +51,8 @@ namespace Catch {\n \n         void noMatchingTestCases(std::string const&) override {}\n \n+        void reportInvalidArguments(std::string const&) override {}\n+        \n         void testRunStarting(TestRunInfo const& _testRunInfo) override {\n             currentTestRunInfo = _testRunInfo;\n         }\n@@ -277,4 +279,4 @@ namespace Catch {\n \n } // end namespace Catch\n \n-#endif // TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED\n+#endif // TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_console.cpp b/include/reporters/catch_reporter_console.cpp\n--- a/include/reporters/catch_reporter_console.cpp\n+++ b/include/reporters/catch_reporter_console.cpp\n@@ -383,6 +383,10 @@ void ConsoleReporter::noMatchingTestCases(std::string const& spec) {\n     stream << \"No test cases matched '\" << spec << '\\'' << std::endl;\n }\n \n+void ConsoleReporter::reportInvalidArguments(std::string const&arg){\n+    stream << \"Invalid Filter: \" << arg << std::endl;\n+}\n+\n void ConsoleReporter::assertionStarting(AssertionInfo const&) {}\n \n bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n@@ -694,4 +698,4 @@ CATCH_REGISTER_REPORTER(\"console\", ConsoleReporter)\n \n #if defined(__clang__)\n #  pragma clang diagnostic pop\n-#endif\n+#endif\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_console.h b/include/reporters/catch_reporter_console.h\n--- a/include/reporters/catch_reporter_console.h\n+++ b/include/reporters/catch_reporter_console.h\n@@ -32,6 +32,8 @@ namespace Catch {\n \n         void noMatchingTestCases(std::string const& spec) override;\n \n+        void reportInvalidArguments(std::string const&arg) override;\n+\n         void assertionStarting(AssertionInfo const&) override;\n \n         bool assertionEnded(AssertionStats const& _assertionStats) override;\n@@ -84,4 +86,4 @@ namespace Catch {\n #pragma warning(pop)\n #endif\n \n-#endif // TWOBLUECUBES_CATCH_REPORTER_CONSOLE_H_INCLUDED\n+#endif // TWOBLUECUBES_CATCH_REPORTER_CONSOLE_H_INCLUDED\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_listening.cpp b/include/reporters/catch_reporter_listening.cpp\n--- a/include/reporters/catch_reporter_listening.cpp\n+++ b/include/reporters/catch_reporter_listening.cpp\n@@ -41,6 +41,13 @@ namespace Catch {\n         }\n         m_reporter->noMatchingTestCases( spec );\n     }\n+    \n+    void ListeningReporter::reportInvalidArguments(std::string const&arg){\n+        for ( auto const& listener : m_listeners ) {\n+            listener->reportInvalidArguments( arg );\n+        }\n+        m_reporter->reportInvalidArguments( arg );\n+    }    \n \n #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n     void ListeningReporter::benchmarkPreparing( std::string const& name ) {\n@@ -154,4 +161,4 @@ namespace Catch {\n         return true;\n     }\n \n-} // end namespace Catch\n+} // end namespace Catch\n\\ No newline at end of file\ndiff --git a/include/reporters/catch_reporter_listening.h b/include/reporters/catch_reporter_listening.h\n--- a/include/reporters/catch_reporter_listening.h\n+++ b/include/reporters/catch_reporter_listening.h\n@@ -28,7 +28,9 @@ namespace Catch {\n         ReporterPreferences getPreferences() const override;\n \n         void noMatchingTestCases( std::string const& spec ) override;\n-\n+        \n+        void reportInvalidArguments(std::string const&arg) override;\n+        \n         static std::set<Verbosity> getSupportedVerbosities();\n \n #if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n@@ -58,4 +60,4 @@ namespace Catch {\n \n } // end namespace Catch\n \n-#endif // TWOBLUECUBES_CATCH_MULTI_REPORTER_H_INCLUDED\n+#endif // TWOBLUECUBES_CATCH_MULTI_REPORTER_H_INCLUDED\n\\ No newline at end of file\n", "test_patch": "diff --git a/include/internal/catch_test_spec.cpp b/include/internal/catch_test_spec.cpp\n--- a/include/internal/catch_test_spec.cpp\n+++ b/include/internal/catch_test_spec.cpp\n@@ -91,5 +91,9 @@ namespace Catch {\n         } );\n         return matches;\n     }\n+    \n+    const TestSpec::vectorStrings& TestSpec::getInvalidArgs() const{\n+        return  (m_invalidArgs);\n+    }\n \n }\ndiff --git a/include/internal/catch_test_spec.h b/include/internal/catch_test_spec.h\n--- a/include/internal/catch_test_spec.h\n+++ b/include/internal/catch_test_spec.h\n@@ -73,14 +73,16 @@ namespace Catch {\n             std::vector<TestCase const*> tests;\n         };\n         using Matches = std::vector<FilterMatch>;\n+        using vectorStrings = std::vector<std::string>;\n \n         bool hasFilters() const;\n         bool matches( TestCaseInfo const& testCase ) const;\n         Matches matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const;\n+        const vectorStrings & getInvalidArgs() const;\n \n     private:\n         std::vector<Filter> m_filters;\n-\n+        std::vector<std::string> m_invalidArgs;\n         friend class TestSpecParser;\n     };\n }\ndiff --git a/include/internal/catch_test_spec_parser.cpp b/include/internal/catch_test_spec_parser.cpp\n--- a/include/internal/catch_test_spec_parser.cpp\n+++ b/include/internal/catch_test_spec_parser.cpp\n@@ -20,8 +20,13 @@ namespace Catch {\n         m_substring.reserve(m_arg.size());\n         m_patternName.reserve(m_arg.size());\n         m_realPatternPos = 0;\n+        \n         for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n-            visitChar( m_arg[m_pos] );\n+          //if visitChar fails\n+           if( !visitChar( m_arg[m_pos] ) ){ \n+               m_testSpec.m_invalidArgs.push_back(arg);\n+               break;\n+           }\n         endMode();\n         return *this;\n     }\n@@ -29,38 +34,32 @@ namespace Catch {\n         addFilter();\n         return m_testSpec;\n     }\n-    void TestSpecParser::visitChar( char c ) {\n+    bool TestSpecParser::visitChar( char c ) {\n         if( (m_mode != EscapedName) && (c == '\\\\') ) {\n             escape();\n-            m_substring += c;\n-            m_patternName += c;\n-            m_realPatternPos++;\n-            return;\n+            addCharToPattern(c);\n+            return true;\n         }else if((m_mode != EscapedName) && (c == ',') )  {\n-            endMode();\n-            addFilter();\n-            return;\n+            return separate();\n         }\n \n         switch( m_mode ) {\n         case None:\n             if( processNoneChar( c ) )\n-                return;\n+                return true;\n             break;\n         case Name:\n             processNameChar( c );\n             break;\n         case EscapedName:\n             endMode();\n-            m_substring += c;\n-            m_patternName += c;\n-            m_realPatternPos++;\n-            return;\n+            addCharToPattern(c);\n+            return true;\n         default:\n         case Tag:\n         case QuotedName:\n             if( processOtherChar( c ) )\n-                return;\n+                return true;\n             break;\n         }\n \n@@ -69,6 +68,7 @@ namespace Catch {\n             m_patternName += c;\n             m_realPatternPos++;\n         }\n+        return true;\n     }\n     // Two of the processing methods return true to signal the caller to return\n     // without adding the given character to the current pattern strings\n@@ -161,6 +161,20 @@ namespace Catch {\n       m_mode = lastMode;\n     }\n     \n+    bool TestSpecParser::separate() {  \n+      if( (m_mode==QuotedName) || (m_mode==Tag) ){\n+         //invalid argument, signal failure to previous scope.\n+         m_mode = None;\n+         m_pos = m_arg.size();\n+         m_substring.clear();\n+         m_patternName.clear();\n+         return false;\n+      }\n+      endMode();\n+      addFilter();\n+      return true; //success\n+    }\n+    \n     TestSpec parseTestSpec( std::string const& arg ) {\n         return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();\n     }\ndiff --git a/include/internal/catch_test_spec_parser.h b/include/internal/catch_test_spec_parser.h\n--- a/include/internal/catch_test_spec_parser.h\n+++ b/include/internal/catch_test_spec_parser.h\n@@ -41,7 +41,7 @@ namespace Catch {\n         TestSpec testSpec();\n \n     private:\n-        void visitChar( char c );\n+        bool visitChar( char c );\n         void startNewMode( Mode mode );\n         bool processNoneChar( char c );\n         void processNameChar( char c );\n@@ -51,6 +51,8 @@ namespace Catch {\n         bool isControlChar( char c ) const;\n         void saveLastMode();\n         void revertBackToLastMode();\n+        void addFilter();\n+        bool separate();\n         \n         template<typename T>\n         void addPattern() {\n@@ -73,8 +75,13 @@ namespace Catch {\n             m_exclusion = false;\n             m_mode = None;\n         }\n-\n-        void addFilter();\n+        \n+        inline void addCharToPattern(char c) {\n+            m_substring += c;\n+            m_patternName += c;\n+            m_realPatternPos++;\n+        }\n+        \n     };\n     TestSpec parseTestSpec( std::string const& arg );\n \n", "problem_statement": "Catch2 terminates when an invalid test name is passed\nPut the following test name in a file, say tests.in:\r\n```\r\nTest with special, characters \\\"in name\r\n```\r\nRun a Catch binary with `-f tests.in`. The program terminates with a runtime error thrown from\r\n```\r\n \tmsvcp140d.dll!00007ffc846a4ef9()\tUnknown\r\n>\tSelfTest.exe!std::_String_val<std::_Simple_types<char>>::_Xran() Line 2141\tC++\r\n \tSelfTest.exe!std::_String_val<std::_Simple_types<char>>::_Check_offset(const unsigned __int64 _Off) Line 2131\tC++\r\n \tSelfTest.exe!std::string::assign(const std::string & _Right, const unsigned __int64 _Roff, unsigned __int64 _Count) Line 2824\tC++\r\n \tSelfTest.exe!std::string::basic_string<char,std::char_traits<char>,std::allocator<char>>(const std::string & _Right, const unsigned __int64 _Roff, const unsigned __int64 _Count, const std::allocator<char> & _Al) Line 2278\tC++\r\n \tSelfTest.exe!std::string::substr(const unsigned __int64 _Off, const unsigned __int64 _Count) Line 3949\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::addPattern<Catch::TestSpec::NamePattern>() Line 58\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::endMode() Line 108\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::visitChar(char c) Line 38\tC++\r\n \tSelfTest.exe!Catch::TestSpecParser::parse(const std::string & arg) Line 22\tC++\r\n \tSelfTest.exe!Catch::Config::Config(const Catch::ConfigData & data) Line 34\tC++\r\n```\r\nI'd expect Catch to ignore the invalid test name.\n", "hints_text": "@amitherman95 You've worked on the parser recently, can you take a look at this?\nYes I will\nCan the input file also include tags? or test names only?\nLet's say test names only for now\nVery well, I pretty much solved the problem, I just need to add more robust tests for this feature and by tomorrow a PR will be ready. ", "created_at": "2019-10-10T09:55:07Z", "version": "2.10"}
{"repo": "catchorg/Catch2", "pull_number": 2919, "instance_id": "catchorg__Catch2-2919", "issue_numbers": ["2915"], "base_commit": "fa43b77429ba76c462b1898d6cd2f2d7a9416b14", "patch": "diff --git a/src/catch2/matchers/catch_matchers_range_equals.hpp b/src/catch2/matchers/catch_matchers_range_equals.hpp\n--- a/src/catch2/matchers/catch_matchers_range_equals.hpp\n+++ b/src/catch2/matchers/catch_matchers_range_equals.hpp\n@@ -96,55 +96,64 @@ namespace Catch {\n          * Creates a matcher that checks if all elements in a range are equal\n          * to all elements in another range.\n          *\n-         * Uses `std::equal_to` to do the comparison\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike>\n+        template <typename RangeLike,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        std::enable_if_t<!Detail::is_matcher<RangeLike>::value,\n-                         RangeEqualsMatcher<RangeLike, std::equal_to<>>>\n-        RangeEquals( RangeLike&& range ) {\n-            return { CATCH_FORWARD( range ), std::equal_to<>{} };\n+        RangeEqualsMatcher<RangeLike, Equality>\n+        RangeEquals( RangeLike&& range,\n+                     Equality&& predicate = std::equal_to<>{} ) {\n+            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range.\n+         * to all elements in an initializer list.\n          *\n-         * Uses to provided predicate `predicate` to do the comparisons\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike, typename Equality>\n+        template <typename T,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        RangeEqualsMatcher<RangeLike, Equality>\n-        RangeEquals( RangeLike&& range, Equality&& predicate ) {\n-            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n+        RangeEqualsMatcher<std::initializer_list<T>, Equality>\n+        RangeEquals( std::initializer_list<T> range,\n+                     Equality&& predicate = std::equal_to<>{} ) {\n+            return { range, CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range, in some permutation\n+         * to all elements in another range, in some permutation.\n          *\n-         * Uses `std::equal_to` to do the comparison\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike>\n+        template <typename RangeLike,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        std::enable_if_t<\n-            !Detail::is_matcher<RangeLike>::value,\n-            UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>\n-        UnorderedRangeEquals( RangeLike&& range ) {\n-            return { CATCH_FORWARD( range ), std::equal_to<>{} };\n+        UnorderedRangeEqualsMatcher<RangeLike, Equality>\n+        UnorderedRangeEquals( RangeLike&& range,\n+                              Equality&& predicate = std::equal_to<>{} ) {\n+            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range, in some permutation.\n+         * to all elements in an initializer list, in some permutation.\n          *\n-         * Uses to provided predicate `predicate` to do the comparisons\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike, typename Equality>\n+        template <typename T,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        UnorderedRangeEqualsMatcher<RangeLike, Equality>\n-        UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) {\n-            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n+        UnorderedRangeEqualsMatcher<std::initializer_list<T>, Equality>\n+        UnorderedRangeEquals( std::initializer_list<T> range,\n+                              Equality&& predicate = std::equal_to<>{} ) {\n+            return { range, CATCH_FORWARD( predicate ) };\n         }\n     } // namespace Matchers\n } // namespace Catch\n", "test_patch": "diff --git a/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp b/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n--- a/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n+++ b/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n@@ -727,6 +727,15 @@ TEST_CASE( \"Usage of RangeEquals range matcher\", \"[matchers][templated][quantifi\n                       } ) );\n     }\n \n+    SECTION( \"Compare against std::initializer_list\" ) {\n+        const std::array<int, 3> array_a{ { 1, 2, 3 } };\n+\n+        REQUIRE_THAT( array_a, RangeEquals( { 1, 2, 3 } ) );\n+        REQUIRE_THAT( array_a, RangeEquals( { 2, 4, 6 }, []( int l, int r ) {\n+                          return l * 2 == r;\n+                      } ) );\n+    }\n+\n     SECTION(\"Check short-circuiting behaviour\") {\n         with_mocked_iterator_access<int> const mocked1{ 1, 2, 3, 4 };\n \n@@ -820,6 +829,16 @@ TEST_CASE( \"Usage of UnorderedRangeEquals range matcher\",\n \n         REQUIRE_THAT( needs_adl1, UnorderedRangeEquals( needs_adl2 ) );\n     }\n+\n+    SECTION( \"Compare against std::initializer_list\" ) {\n+        const std::array<int, 3> array_a{ { 1, 10, 20 } };\n+\n+        REQUIRE_THAT( array_a, UnorderedRangeEquals( { 10, 20, 1 } ) );\n+        REQUIRE_THAT( array_a,\n+                      UnorderedRangeEquals( { 11, 21, 2 }, []( int l, int r ) {\n+                          return std::abs( l - r ) <= 1;\n+                      } ) );\n+    }\n }\n \n /**\n", "problem_statement": "RangeEquals doesn't support literal std::initializer_list\nIt would often be useful to write something like this:\r\n```c++\r\n  const auto v = calculateSomeVectorOfInts();\r\n  CHECK_THAT(v, RangeEquals({1, 2, 3}));\r\n```\r\nThis doesn't compile. It can be made to compile by adding an overload to RangeEquals that takes a std::initializer_list. Would a PR adding such an overload have a chance of being accepted?\r\n\r\nIt's not a huge issue since there are workarounds, including any of these:\r\n```c++\r\n  const auto expected = {1, 2, 3};\r\n  CHECK_THAT(v, RangeEquals(expected));\r\n\r\n  CHECK_THAT(v, RangeEquals(std::vector{1, 2, 3}));\r\n\r\n  CHECK_THAT(v, RangeEquals(std::initializer_list<int>{1, 2, 3}));\r\n```\r\nStill, the convenience of writing the initializer_list inline without extra qualification would be nice.\n", "hints_text": "Sure, why not.", "created_at": "2024-10-12T15:21:56Z", "version": "3.7"}
{"repo": "catchorg/Catch2", "pull_number": 2986, "instance_id": "catchorg__Catch2-2986", "issue_numbers": ["2755"], "base_commit": "1de7d0ed7be47080f0f436bc88cac73d0af53006", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -79,8 +79,8 @@ add_subdirectory(src)\n \n # Build tests only if requested\n if(BUILD_TESTING AND CATCH_BUILD_TESTING AND NOT_SUBPROJECT)\n-  find_package(PythonInterp 3 REQUIRED)\n-  if(NOT PYTHONINTERP_FOUND)\n+  find_package(Python3 REQUIRED COMPONENTS Interpreter)\n+  if(NOT TARGET Python3::Interpreter)\n     message(FATAL_ERROR \"Python not found, but required for tests\")\n   endif()\n   set(CMAKE_FOLDER \"tests\")\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -342,10 +342,9 @@ set_tests_properties(FilteredSection::GeneratorsDontCauseInfiniteLoop-2\n     PASS_REGULAR_EXPRESSION \"All tests passed \\\\(4 assertions in 1 test case\\\\)\"\n )\n \n-# AppVeyor has a Python 2.7 in path, but doesn't have .py files as autorunnable\n add_test(NAME ApprovalTests\n   COMMAND\n-    ${PYTHON_EXECUTABLE}\n+    Python3::Interpreter\n     ${CATCH_DIR}/tools/scripts/approvalTests.py\n     $<TARGET_FILE:SelfTest>\n     \"${CMAKE_CURRENT_BINARY_DIR}\"\n@@ -408,7 +407,7 @@ set_tests_properties(TagAlias PROPERTIES\n   FAIL_REGULAR_EXPRESSION \"0 matching test cases\"\n )\n \n-add_test(NAME RandomTestOrdering COMMAND ${PYTHON_EXECUTABLE}\n+add_test(NAME RandomTestOrdering COMMAND Python3::Interpreter\n   ${CATCH_DIR}/tests/TestScripts/testRandomOrder.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(RandomTestOrdering\n   PROPERTIES\n@@ -417,7 +416,7 @@ set_tests_properties(RandomTestOrdering\n \n add_test(NAME CheckConvenienceHeaders\n   COMMAND\n-    ${PYTHON_EXECUTABLE} ${CATCH_DIR}/tools/scripts/checkConvenienceHeaders.py\n+    Python3::Interpreter ${CATCH_DIR}/tools/scripts/checkConvenienceHeaders.py\n )\n set_tests_properties(CheckConvenienceHeaders\n   PROPERTIES\n@@ -602,7 +601,7 @@ if(CATCH_ENABLE_CONFIGURE_TESTS)\n                     \"ExperimentalRedirect\")\n     add_test(NAME \"CMakeConfig::${testName}\"\n       COMMAND\n-        \"${PYTHON_EXECUTABLE}\" \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/testConfigure${testName}.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n+        Python3::Interpreter \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/testConfigure${testName}.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n     )\n     set_tests_properties(\"CMakeConfig::${testName}\"\n       PROPERTIES\n@@ -615,7 +614,7 @@ endif()\n if(CATCH_ENABLE_CMAKE_HELPER_TESTS)\n   add_test(NAME \"CMakeHelper::DiscoverTests\"\n     COMMAND\n-      \"${PYTHON_EXECUTABLE}\" \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/DiscoverTests/VerifyRegistration.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n+      Python3::Interpreter \"${CMAKE_CURRENT_LIST_DIR}/TestScripts/DiscoverTests/VerifyRegistration.py\" \"${CATCH_DIR}\" \"${CMAKE_CURRENT_BINARY_DIR}\"\n   )\n   set_tests_properties(\"CMakeHelper::DiscoverTests\"\n     PROPERTIES\ndiff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -5,7 +5,7 @@ message(STATUS \"Extra tests included\")\n \n add_test(\n   NAME TestShardingIntegration\n-  COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/tests/TestScripts/testSharding.py $<TARGET_FILE:SelfTest>\n+  COMMAND Python3::Interpreter ${CATCH_DIR}/tests/TestScripts/testSharding.py $<TARGET_FILE:SelfTest>\n )\n set_tests_properties(TestShardingIntegration\n   PROPERTIES\n@@ -114,7 +114,7 @@ target_compile_definitions(BazelReporter PRIVATE CATCH_CONFIG_BAZEL_SUPPORT)\n target_link_libraries(BazelReporter Catch2_buildall_interface)\n add_test(NAME CATCH_CONFIG_BAZEL_REPORTER-1\n   COMMAND\n-  \"${PYTHON_EXECUTABLE}\" \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporter> \"${CMAKE_CURRENT_BINARY_DIR}\"\n+  Python3::Interpreter \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporter> \"${CMAKE_CURRENT_BINARY_DIR}\"\n )\n set_tests_properties(CATCH_CONFIG_BAZEL_REPORTER-1\n   PROPERTIES\n@@ -126,7 +126,7 @@ add_executable(BazelReporterNoCatchConfig ${TESTS_DIR}/X30-BazelReporter.cpp)\n target_link_libraries(BazelReporterNoCatchConfig Catch2WithMain)\n add_test(NAME NO_CATCH_CONFIG_BAZEL_REPORTER-1\n   COMMAND\n-  \"${PYTHON_EXECUTABLE}\" \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporterNoCatchConfig> \"${CMAKE_CURRENT_BINARY_DIR}\"\n+  Python3::Interpreter \"${CATCH_DIR}/tests/TestScripts/testBazelReporter.py\" $<TARGET_FILE:BazelReporterNoCatchConfig> \"${CMAKE_CURRENT_BINARY_DIR}\"\n )\n set_tests_properties(NO_CATCH_CONFIG_BAZEL_REPORTER-1\n   PROPERTIES\n@@ -146,7 +146,7 @@ set_tests_properties(BazelEnv::TESTBRIDGE_TEST_ONLY\n \n add_test(NAME BazelEnv::Sharding\n   COMMAND\n-    \"${PYTHON_EXECUTABLE}\" \"${CATCH_DIR}/tests/TestScripts/testBazelSharding.py\"\n+    Python3::Interpreter \"${CATCH_DIR}/tests/TestScripts/testBazelSharding.py\"\n       $<TARGET_FILE:BazelReporterNoCatchConfig>\n       \"${CMAKE_CURRENT_BINARY_DIR}\"\n )\n@@ -222,7 +222,7 @@ add_executable(PartialTestCaseEvents ${TESTS_DIR}/X21-PartialTestCaseEvents.cpp)\n target_link_libraries(PartialTestCaseEvents PRIVATE Catch2WithMain)\n add_test(\n   NAME PartialTestCaseEvents\n-  COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/tests/TestScripts/testPartialTestCaseEvent.py $<TARGET_FILE:PartialTestCaseEvents>\n+  COMMAND Python3::Interpreter ${CATCH_DIR}/tests/TestScripts/testPartialTestCaseEvent.py $<TARGET_FILE:PartialTestCaseEvents>\n )\n set_tests_properties(PartialTestCaseEvents\n   PROPERTIES\n", "problem_statement": "Stop using deprecated FindPythonInterp module\n**Describe the bug**\r\nCMake 3.27 warns about the FindPythonInterp being deprecated and removed in newer releases. \r\n\r\n```\r\nCMake Warning (dev) at CMakeLists.txt:86 (find_package):\r\n  Policy CMP0148 is not set: The FindPythonInterp and FindPythonLibs modules\r\n  are removed.  Run \"cmake --help-policy CMP0148\" for policy details.  Use\r\n  the cmake_policy command to set the policy and suppress this warning.\r\n\r\nThis warning is for project developers.  Use -Wno-dev to suppress it.\r\n```\r\n\r\nhttps://github.com/catchorg/Catch2/actions/runs/6679314592/job/18151308282#step:3:26\r\n\r\nCI shows this warning as well.\r\n\r\n**Expected behavior**\r\nFor there to be no `(dev)` warnings when configuring.\r\n\r\n**Additional context**\r\nI believe the fix is to use the `FindPython` module which has a particular component for the Python interpreter. This was added in CMake 3.12 yet the trunk branch currently only requires CMake 3.10. Raising the minimum CMake version would be reasonable and is unlikely to affect any users other than those still on Ubuntu 18 which by default ships 3.10.\r\n\n", "hints_text": "I don't want to push up the minimum cmake version just yet, instead there should be a version check to pick the right module.", "created_at": "2025-06-09T01:06:18Z", "version": "3.8"}
{"repo": "catchorg/Catch2", "pull_number": 2723, "instance_id": "catchorg__Catch2-2723", "issue_numbers": ["2719"], "base_commit": "4acc51828f7f93f3b2058a63f54d112af4034503", "patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -20,6 +20,7 @@\n #include <catch2/internal/catch_output_redirect.hpp>\n #include <catch2/internal/catch_assertion_handler.hpp>\n #include <catch2/internal/catch_test_failure_exception.hpp>\n+#include <catch2/internal/catch_result_type.hpp>\n \n #include <cassert>\n #include <algorithm>\n@@ -293,13 +294,14 @@ namespace Catch {\n             m_messageScopes.clear();\n         }\n \n-        // Reset working state\n-        resetAssertionInfo();\n+        // Reset working state. assertion info will be reset after\n+        // populateReaction is run if it is needed\n         m_lastResult = CATCH_MOVE( result );\n     }\n     void RunContext::resetAssertionInfo() {\n         m_lastAssertionInfo.macroName = StringRef();\n         m_lastAssertionInfo.capturedExpression = \"{Unknown expression after the reported line}\"_sr;\n+        m_lastAssertionInfo.resultDisposition = ResultDisposition::Normal;\n     }\n \n     void RunContext::notifyAssertionStarted( AssertionInfo const& info ) {\n@@ -447,6 +449,7 @@ namespace Catch {\n         AssertionResult result(m_lastAssertionInfo, CATCH_MOVE(tempResult));\n \n         assertionEnded(CATCH_MOVE(result) );\n+        resetAssertionInfo();\n \n         handleUnfinishedSections();\n \n@@ -583,6 +586,7 @@ namespace Catch {\n             reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\n             populateReaction( reaction );\n         }\n+        resetAssertionInfo();\n     }\n     void RunContext::reportExpr(\n             AssertionInfo const &info,\n@@ -621,6 +625,7 @@ namespace Catch {\n             // considered \"OK\"\n             reaction.shouldSkip = true;\n         }\n+        resetAssertionInfo();\n     }\n     void RunContext::handleUnexpectedExceptionNotThrown(\n             AssertionInfo const& info,\n@@ -641,6 +646,7 @@ namespace Catch {\n         AssertionResult assertionResult{ info, CATCH_MOVE(data) };\n         assertionEnded( CATCH_MOVE(assertionResult) );\n         populateReaction( reaction );\n+        resetAssertionInfo();\n     }\n \n     void RunContext::populateReaction( AssertionReaction& reaction ) {\n@@ -658,6 +664,7 @@ namespace Catch {\n         data.message = \"Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE\"s;\n         AssertionResult assertionResult{ info, CATCH_MOVE( data ) };\n         assertionEnded( CATCH_MOVE(assertionResult) );\n+        resetAssertionInfo();\n     }\n     void RunContext::handleNonExpr(\n             AssertionInfo const &info,\n@@ -672,6 +679,7 @@ namespace Catch {\n         const auto isOk = assertionResult.isOk();\n         assertionEnded( CATCH_MOVE(assertionResult) );\n         if ( !isOk ) { populateReaction( reaction ); }\n+        resetAssertionInfo();\n     }\n \n \n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -78,6 +78,7 @@ endif(MSVC) #Temporary workaround\n set(TEST_SOURCES\n         ${SELF_TEST_DIR}/TestRegistrations.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Algorithms.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/AssertionHandler.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Clara.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLine.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLineHelpers.tests.cpp\ndiff --git a/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp b/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/AssertionHandler.tests.cpp\n@@ -0,0 +1,17 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+TEST_CASE( \"Incomplete AssertionHandler\", \"[assertion-handler][!shouldfail]\" ) {\n+    Catch::AssertionHandler catchAssertionHandler(\n+        \"REQUIRE\"_catch_sr,\n+        CATCH_INTERNAL_LINEINFO,\n+        \"Dummy\",\n+        Catch::ResultDisposition::Normal );\n+}\ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -217,6 +217,18 @@ TEST_CASE(\"Testing checked-if 3\", \"[checked-if][!shouldfail]\") {\n     SUCCEED();\n }\n \n+[[noreturn]]\n+TEST_CASE(\"Testing checked-if 4\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(true) {}\n+    throw std::runtime_error(\"Uncaught exception should fail!\");\n+}\n+\n+[[noreturn]]\n+TEST_CASE(\"Testing checked-if 5\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(false) {}\n+    throw std::runtime_error(\"Uncaught exception should fail!\");\n+}\n+\n TEST_CASE( \"xmlentitycheck\" ) {\n     SECTION( \"embedded xml: <test>it should be possible to embed xml characters, such as <, \\\" or &, or even whole <xml>documents</xml> within an attribute</test>\" ) {\n         SUCCEED(); // We need this here to stop it failing due to no tests\n", "problem_statement": "Exception is treated as passing when used CHECKED_ELSE before in xml reporter\n**Describe the bug**\r\nAfter CHECKED_ELSE(true) {} is being run, any exception being thrown in the tests are suppressed and treated as passing when using xml reporter. Using console reporter reports failure.\r\n\r\nAfter CHECKED_ELSE(false) {} is being run, any exception being thrown are suppressed in both console and xml reporter.\r\n\r\n**Expected behavior**\r\nBoth the console reporter and xml reporter should behave exactly the same, that the exception is reported and test counted as failure in both cases.\r\n\r\n**Reproduction steps**\r\nSteps to reproduce the bug.\r\n<!-- Usually this means a small and self-contained piece of code that uses Catch and specifying compiler flags if relevant. -->\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <exception>\r\n\r\nTEST_CASE(\"Testing\") {\r\n    CHECKED_ELSE(true) {}\r\n    throw std::runtime_error(\"it is an error\");\r\n}\r\n```\r\nRunning it with \r\n./test -r xml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Catch2TestRun name=\"test\" rng-seed=\"3025144594\" xml-format-version=\"2\" catch\r\n  <TestCase name=\"Testing\" filename=\"/home/ross/workspace/catch2-xml/test.cpp\r\n    <OverallResult success=\"true\" skips=\"0\"/>\r\n  </TestCase>\r\n  <OverallResults successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n  <OverallResultsCases successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\r\n</Catch2TestRun>\r\n```\r\nAnd running it directly with\r\n./test\r\n```\r\n...\r\n/home/ross/workspace/catch2-xml/test.cpp:4: FAILED:\r\n  {Unknown expression after the reported line}\r\ndue to unexpected exception with message:\r\n  it is an error\r\n\r\n===============================================================================\r\ntest cases: 1 | 1 failed\r\nassertions: 2 | 1 passed | 1 failed\r\n```\r\nAnd if the argument inside CHECKED_ELSE is false, exception is suppressed for both console and xml reporter. It also looks like a bug.\r\n\r\n```\r\n#include <catch2/catch_test_macros.hpp>\r\n#include <exception>\r\n\r\nTEST_CASE(\"Testing\") {\r\n    CHECKED_ELSE(false) {}\r\n    throw std::runtime_error(\"it is an error\");\r\n}\r\n```\r\nRunning\r\n./test -r xml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Catch2TestRun name=\"test\" rng-seed=\"3270933764\" xml-format-version=\"2\" catch2-version=\"3.3.2\">\r\n  <TestCase name=\"Testing\" filename=\"/home/ross/workspace/catch2-xml/test.cpp\" line=\"4\">\r\n    <OverallResult success=\"true\" skips=\"0\"/>\r\n  </TestCase>\r\n  <OverallResults successes=\"0\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n  <OverallResultsCases successes=\"1\" failures=\"0\" expectedFailures=\"0\" skips=\"0\"/>\r\n</Catch2TestRun>\r\n```\r\nRunning \r\n./test \r\n```\r\nRandomness seeded to: 1751265161\r\n===============================================================================\r\ntest cases: 1 | 1 passed\r\nassertions: - none -\r\n```\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Ubuntu jammy**\r\n - Compiler+version: **clang++-15**\r\n - Catch version: **v3.3.2**\r\n\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n\n", "hints_text": "", "created_at": "2023-07-21T17:31:25Z", "version": "3.4"}
{"repo": "catchorg/Catch2", "pull_number": 2334, "instance_id": "catchorg__Catch2-2334", "issue_numbers": ["898"], "base_commit": "d3199c42c2af0f69e43686c2b47189c8bad04026", "patch": "diff --git a/src/catch2/internal/catch_fatal_condition_handler.cpp b/src/catch2/internal/catch_fatal_condition_handler.cpp\n--- a/src/catch2/internal/catch_fatal_condition_handler.cpp\n+++ b/src/catch2/internal/catch_fatal_condition_handler.cpp\n@@ -84,7 +84,7 @@ namespace Catch {\n         { static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), \"Divide by zero error\" },\n     };\n \n-    static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {\n+    static LONG CALLBACK topLevelExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo) {\n         for (auto const& def : signalDefs) {\n             if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {\n                 reportFatal(def.name);\n@@ -98,7 +98,7 @@ namespace Catch {\n     // Since we do not support multiple instantiations, we put these\n     // into global variables and rely on cleaning them up in outlined\n     // constructors/destructors\n-    static PVOID exceptionHandlerHandle = nullptr;\n+    static LPTOP_LEVEL_EXCEPTION_FILTER previousTopLevelExceptionFilter = nullptr;\n \n \n     // For MSVC, we reserve part of the stack memory for handling\n@@ -120,18 +120,15 @@ namespace Catch {\n \n \n     void FatalConditionHandler::engage_platform() {\n-        // Register as first handler in current chain\n-        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\n-        if (!exceptionHandlerHandle) {\n-            CATCH_RUNTIME_ERROR(\"Could not register vectored exception handler\");\n-        }\n+        // Register as a the top level exception filter.\n+        previousTopLevelExceptionFilter = SetUnhandledExceptionFilter(topLevelExceptionFilter);\n     }\n \n     void FatalConditionHandler::disengage_platform() {\n-        if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {\n-            CATCH_RUNTIME_ERROR(\"Could not unregister vectored exception handler\");\n+        if (SetUnhandledExceptionFilter(reinterpret_cast<LPTOP_LEVEL_EXCEPTION_FILTER>(previousTopLevelExceptionFilter)) != topLevelExceptionFilter) {\n+            CATCH_RUNTIME_ERROR(\"Could not restore previous top level exception filter\");\n         }\n-        exceptionHandlerHandle = nullptr;\n+        previousTopLevelExceptionFilter = nullptr;\n     }\n \n } // end namespace Catch\n", "test_patch": "diff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -6,6 +6,7 @@\n #include <catch2/catch_test_macros.hpp>\n #include <catch2/catch_template_test_macros.hpp>\n #include <catch2/internal/catch_config_wchar.hpp>\n+#include <catch2/internal/catch_windows_h_proxy.hpp>\n \n #ifdef __clang__\n #   pragma clang diagnostic ignored \"-Wc++98-compat\"\n@@ -498,3 +499,34 @@ TEMPLATE_TEST_CASE_SIG(\"#1954 - 7 arg template test case sig compiles\", \"[regres\n \n TEST_CASE(\"Same test name but with different tags is fine\", \"[.approvals][some-tag]\") {}\n TEST_CASE(\"Same test name but with different tags is fine\", \"[.approvals][other-tag]\") {}\n+\n+#if defined(CATCH_PLATFORM_WINDOWS)\n+void throw_and_catch()\n+{\n+    __try {\n+        RaiseException(0xC0000005, 0, 0, NULL);\n+    }\n+    __except (1)\n+    {\n+\n+    }\n+}\n+\n+\n+TEST_CASE(\"Validate SEH behavior - handled\", \"[approvals][FatalConditionHandler][CATCH_PLATFORM_WINDOWS]\")\n+{\n+    // Validate that Catch2 framework correctly handles tests raising and handling SEH exceptions.\n+    throw_and_catch();\n+}\n+\n+void throw_no_catch()\n+{\n+    RaiseException(0xC0000005, 0, 0, NULL);\n+}\n+\n+TEST_CASE(\"Validate SEH behavior - unhandled\", \"[.approvals][FatalConditionHandler][CATCH_PLATFORM_WINDOWS]\")\n+{\n+    // Validate that Catch2 framework correctly handles tests raising and not handling SEH exceptions.\n+    throw_no_catch();\n+}\n+#endif\n", "problem_statement": "[clang] [windows] [address-sanitizer] stack overflow when test is failing\n## Description\r\nCatch enters infinite recursion trying to print error message when compiled with clang -faddress-sanitize under Windows\r\n\r\n### Steps to reproduce\r\n0. Install VS 2015 and [clang](http://llvm.org/pre-releases/win-snapshots/LLVM-5.0.0-r300231-win64.exe)\r\n1. Put `catch.hpp` and `test.bat` from [test.zip](https://github.com/philsquared/Catch/files/964783/test.zip) in one directory, start `test.bat`\r\n2. Resulting executable, instead of reporting an error, will output:\r\n<pre>\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n</pre>\r\nand then it will crash.\r\n\n", "hints_text": "FWIW this works normally under Linux.\r\n\r\nWhat if you use normal Clang:\r\n\r\n```\r\nclang++ -fsanitize=address -o test.exe test.cpp\r\n```\r\n\r\nAlso, you seem to be building a normal, shared executable. What if you change the library name to `clang_rt.asan_dynamic-x86_64.lib`? (The one you're using is for applications using the static CRT.)\nCompiling with \r\n\r\n    clang++ -fsanitize=address -o test.exe test.cpp\r\n\r\ngives me \r\n\r\n<pre>\r\n==748==AddressSanitizer CHECK failed: D:\\src\\llvm_package_300231\\llvm\\projects\\compiler-rt\\lib\\asan\\asan_rtl.cc:505 \"((!asan_init_is_running && \"ASan init calls itself!\")) != (0)\" (0x0, 0x0)\r\n==748==AddressSanitizer CHECK failed: D:\\src\\llvm_package_300231\\llvm\\projects\\compiler-rt\\lib\\asan\\asan_poisoning.cc:37 \"((AddrIsInMem(addr))) != (0)\" (0x0, 0x0)\r\n</pre>\r\n \r\neven if 'test.cpp' is just an empty `main`. This is why I've added `/DEBUG` when linking. This has nothing to do with Catch, must be clang bug.\r\n\r\nWith `clang_rt.asan_dynamic-x86_64.lib` linking fails:\r\n<pre>\r\ntest.obj : error LNK2019: unresolved external symbol __asan_shadow_memory_dynamic_address referenced in function \"struct Catch::IResultCapture & __cdecl Catch::getResultCapture(void)\" (?getResultCapture@Catch@@YAAEAUIResultCapture@1@XZ)\r\ntest.obj : error LNK2019: unresolved external symbol __asan_option_detect_stack_use_after_return referenced in function \"struct Catch::IResultCapture & __cdecl Catch::getResultCapture(void)\" (?getResultCapture@Catch@@YAAEAUIResultCapture@1@XZ)\r\ntest.exe : fatal error LNK1120: 2 unresolved externals\r\n</pre>\r\n\nIs ASan supported under Windows? Last time I checked, it was \"this will very likely work for C, C++ is very much beta\".\nHello. Now that Address Sanitizer is [Generally Available](https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/) for MSVC, I've noticed that I'm unable to run my tests due to this issue--they get stuck and won't complete.\r\n\r\nAfter some digging, I found a relevant open issue on Microsoft's tracker with a [potential workaround](https://developercommunity.visualstudio.com/t/Asan-problems-when-manual-exception-hand/1242524#T-N1295191) that would consist of the following (naive) change to Catch here https://github.com/catchorg/Catch2/blob/b025a007b924cc16da84c07a5d35118695cb9bcc/include/internal/catch_fatal_condition.cpp#L64 and here for the single include header: https://github.com/catchorg/Catch2/blob/b025a007b924cc16da84c07a5d35118695cb9bcc/single_include/catch2/catch.hpp#L10787\r\n\r\n```diff\r\n- exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\r\n+ exceptionHandlerHandle = AddVectoredExceptionHandler(0, handleVectoredException);\r\n```\r\n\r\n\r\nI've tested this change locally with a modified (read: updated) version of the batch script in the OP with a fully updated Visual Studio (v16.9.1) on latest Catch (v2.13.4), and it seems to run to completion! \r\n```bat\r\necho #define CATCH_CONFIG_MAIN > test.cpp\r\necho #include \"catch.hpp\" >> test.cpp\r\necho TEST_CASE( \"t\", \"[t]\" ) { REQUIRE( 2 == 1 ); } >> test.cpp\r\n\r\ncall \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" amd64\r\necho Please wait...\r\ncl /EHsc test.cpp -fsanitize=address -c\r\nlink /DEBUG test.obj\r\n\r\nstart test.exe\r\n```\r\n\r\nHowever, I don't understand the consequences of this change and how it could affect the rest of Catch's logic and exception handling, so hopefully this helps one of the maintainers or someone else more familiar with the code base and C++ in general \ud83d\ude42 \nThis is related to the way asan is implemented on x64 msvc. See here [doc](https://devblogs.microsoft.com/cppblog/asan-for-windows-x64-and-debug-build-support/).\r\nCatch2 is catching tons of 0xc0000005 (FCE - first chance exceptions) and gets confused.\r\nYour fix works but gives up on FCEs.\r\n\r\ncatch2+asan+msvc is working on x86 unmodified (but nobody builds for x86 anymore)\r\n\r\nMaybe catch2 could offer an option to give up on first chance exception or do it automatically on x64 with\r\n```#  if __SANITIZE_ADDRESS__\r\n... ```\r\n\r\nEdit: with catch2 moving as a library, this way to fix depending on asan would not work. \nas a workaround, setting `CATCH_CONFIG_NO_WINDOWS_SEH` fixed this issue for me (tested with 2.13.6).", "created_at": "2021-12-15T17:06:20Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 2163, "instance_id": "catchorg__Catch2-2163", "issue_numbers": ["2061"], "base_commit": "ba8150516800dd5e18f818346a2a12c45b6ec542", "patch": "diff --git a/src/catch2/catch_session.cpp b/src/catch2/catch_session.cpp\n--- a/src/catch2/catch_session.cpp\n+++ b/src/catch2/catch_session.cpp\n@@ -48,7 +48,7 @@ namespace Catch {\n             // doesn't compile without a std::move call. However, this causes\n             // a warning on newer platforms. Thus, we have to work around\n             // it a bit and downcast the pointer manually.\n-            auto ret = Detail::unique_ptr<IStreamingReporter>(new ListeningReporter);\n+            auto ret = Detail::unique_ptr<IStreamingReporter>(new ListeningReporter(config));\n             auto& multi = static_cast<ListeningReporter&>(*ret);\n             auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\n             for (auto const& listener : listeners) {\ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter.cpp b/src/catch2/interfaces/catch_interfaces_reporter.cpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter.cpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter.cpp\n@@ -11,34 +11,15 @@\n #include <catch2/internal/catch_console_width.hpp>\n #include <catch2/catch_message.hpp>\n #include <catch2/internal/catch_list.hpp>\n-#include <catch2/internal/catch_textflow.hpp>\n #include <catch2/internal/catch_string_manip.hpp>\n #include <catch2/catch_test_case_info.hpp>\n-#include <catch2/internal/catch_textflow.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n \n #include <algorithm>\n #include <iomanip>\n \n namespace Catch {\n \n-    namespace {\n-        void listTestNamesOnly( std::vector<TestCaseHandle> const& tests ) {\n-            for ( auto const& test : tests ) {\n-                auto const& testCaseInfo = test.getTestCaseInfo();\n-\n-                if ( startsWith( testCaseInfo.name, '#' ) ) {\n-                    Catch::cout() << '\"' << testCaseInfo.name << '\"';\n-                } else {\n-                    Catch::cout() << testCaseInfo.name;\n-                }\n-\n-                Catch::cout() << '\\n';\n-            }\n-            Catch::cout() << std::flush;\n-        }\n-    } // end unnamed namespace\n-\n-\n     ReporterConfig::ReporterConfig( IConfig const* _fullConfig )\n     :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}\n \n@@ -127,89 +108,4 @@ namespace Catch {\n \n     void IStreamingReporter::fatalErrorEncountered( StringRef ) {}\n \n-    void IStreamingReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) {\n-        Catch::cout() << \"Available reporters:\\n\";\n-        const auto maxNameLen = std::max_element(descriptions.begin(), descriptions.end(),\n-            [](ReporterDescription const& lhs, ReporterDescription const& rhs) { return lhs.name.size() < rhs.name.size(); })\n-            ->name.size();\n-\n-        for (auto const& desc : descriptions) {\n-            if (config.verbosity() == Verbosity::Quiet) {\n-                Catch::cout()\n-                    << TextFlow::Column(desc.name)\n-                    .indent(2)\n-                    .width(5 + maxNameLen) << '\\n';\n-            } else {\n-                Catch::cout()\n-                    << TextFlow::Column(desc.name + \":\")\n-                    .indent(2)\n-                    .width(5 + maxNameLen)\n-                    + TextFlow::Column(desc.description)\n-                    .initialIndent(0)\n-                    .indent(2)\n-                    .width(CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8)\n-                    << '\\n';\n-            }\n-        }\n-        Catch::cout() << std::endl;\n-    }\n-\n-    void IStreamingReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) {\n-        // We special case this to provide the equivalent of old\n-        // `--list-test-names-only`, which could then be used by the\n-        // `--input-file` option.\n-        if (config.verbosity() == Verbosity::Quiet) {\n-            listTestNamesOnly(tests);\n-            return;\n-        }\n-\n-        if (config.hasTestFilters()) {\n-            Catch::cout() << \"Matching test cases:\\n\";\n-        } else {\n-            Catch::cout() << \"All available test cases:\\n\";\n-        }\n-\n-        for (auto const& test : tests) {\n-            auto const& testCaseInfo = test.getTestCaseInfo();\n-            Colour::Code colour = testCaseInfo.isHidden()\n-                ? Colour::SecondaryText\n-                : Colour::None;\n-            Colour colourGuard(colour);\n-\n-            Catch::cout() << TextFlow::Column(testCaseInfo.name).initialIndent(2).indent(4) << '\\n';\n-            if (config.verbosity() >= Verbosity::High) {\n-                Catch::cout() << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << std::endl;\n-            }\n-            if (!testCaseInfo.tags.empty() && config.verbosity() > Verbosity::Quiet) {\n-                Catch::cout() << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << '\\n';\n-            }\n-        }\n-\n-        if (!config.hasTestFilters()) {\n-            Catch::cout() << pluralise(tests.size(), \"test case\") << '\\n' << std::endl;\n-        } else {\n-            Catch::cout() << pluralise(tests.size(), \"matching test case\") << '\\n' << std::endl;\n-        }\n-    }\n-\n-    void IStreamingReporter::listTags(std::vector<TagInfo> const& tags, IConfig const& config) {\n-        if (config.hasTestFilters()) {\n-            Catch::cout() << \"Tags for matching test cases:\\n\";\n-        } else {\n-            Catch::cout() << \"All available tags:\\n\";\n-        }\n-\n-        for (auto const& tagCount : tags) {\n-            ReusableStringStream rss;\n-            rss << \"  \" << std::setw(2) << tagCount.count << \"  \";\n-            auto str = rss.str();\n-            auto wrapper = TextFlow::Column(tagCount.all())\n-                .initialIndent(0)\n-                .indent(str.size())\n-                .width(CATCH_CONFIG_CONSOLE_WIDTH - 10);\n-            Catch::cout() << str << wrapper << '\\n';\n-        }\n-        Catch::cout() << pluralise(tags.size(), \"tag\") << '\\n' << std::endl;\n-    }\n-\n } // end namespace Catch\ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter.hpp b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter.hpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter.hpp\n@@ -176,7 +176,12 @@ namespace Catch {\n     protected:\n         //! Derived classes can set up their preferences here\n         ReporterPreferences m_preferences;\n+        //! The test run's config as filled in from CLI and defaults\n+        IConfig const* m_config;\n+\n     public:\n+        IStreamingReporter( IConfig const* config ): m_config( config ) {}\n+\n         virtual ~IStreamingReporter() = default;\n \n         // Implementing class must also provide the following static methods:\n@@ -217,11 +222,11 @@ namespace Catch {\n         virtual void fatalErrorEncountered( StringRef name );\n \n         //! Writes out information about provided reporters using reporter-specific format\n-        virtual void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config);\n+        virtual void listReporters(std::vector<ReporterDescription> const& descriptions) = 0;\n         //! Writes out information about provided tests using reporter-specific format\n-        virtual void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config);\n+        virtual void listTests(std::vector<TestCaseHandle> const& tests) = 0;\n         //! Writes out information about the provided tags using reporter-specific format\n-        virtual void listTags(std::vector<TagInfo> const& tags, IConfig const& config);\n+        virtual void listTags(std::vector<TagInfo> const& tags) = 0;\n \n     };\n     using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\ndiff --git a/src/catch2/internal/catch_list.cpp b/src/catch2/internal/catch_list.cpp\n--- a/src/catch2/internal/catch_list.cpp\n+++ b/src/catch2/internal/catch_list.cpp\n@@ -24,7 +24,7 @@ namespace Catch {\n         void listTests(IStreamingReporter& reporter, IConfig const& config) {\n             auto const& testSpec = config.testSpec();\n             auto matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);\n-            reporter.listTests(matchedTestCases, config);\n+            reporter.listTests(matchedTestCases);\n         }\n \n         void listTags(IStreamingReporter& reporter, IConfig const& config) {\n@@ -46,10 +46,10 @@ namespace Catch {\n                 infos.push_back(std::move(tagc.second));\n             }\n \n-            reporter.listTags(infos, config);\n+            reporter.listTags(infos);\n         }\n \n-        void listReporters(IStreamingReporter& reporter, IConfig const& config) {\n+        void listReporters(IStreamingReporter& reporter) {\n             std::vector<ReporterDescription> descriptions;\n \n             IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n@@ -58,7 +58,7 @@ namespace Catch {\n                 descriptions.push_back({ fac.first, fac.second->getDescription() });\n             }\n \n-            reporter.listReporters(descriptions, config);\n+            reporter.listReporters(descriptions);\n         }\n \n     } // end anonymous namespace\n@@ -96,7 +96,7 @@ namespace Catch {\n         }\n         if (config.listReporters()) {\n             listed = true;\n-            listReporters(reporter, config);\n+            listReporters(reporter);\n         }\n         return listed;\n     }\ndiff --git a/src/catch2/reporters/catch_reporter_combined_tu.cpp b/src/catch2/reporters/catch_reporter_combined_tu.cpp\n--- a/src/catch2/reporters/catch_reporter_combined_tu.cpp\n+++ b/src/catch2/reporters/catch_reporter_combined_tu.cpp\n@@ -21,13 +21,40 @@\n #include <catch2/interfaces/catch_interfaces_config.hpp>\n #include <catch2/internal/catch_console_width.hpp>\n #include <catch2/internal/catch_errno_guard.hpp>\n-\n+#include <catch2/internal/catch_textflow.hpp>\n+#include <catch2/internal/catch_stream.hpp>\n+#include <catch2/internal/catch_string_manip.hpp>\n+#include <catch2/internal/catch_console_colour.hpp>\n+#include <catch2/catch_tostring.hpp>\n+#include <catch2/catch_test_case_info.hpp>\n+\n+#include <algorithm>\n #include <cfloat>\n #include <cstdio>\n #include <ostream>\n+#include <iomanip>\n \n namespace Catch {\n \n+    namespace {\n+        void listTestNamesOnly(std::ostream& out,\n+                               std::vector<TestCaseHandle> const& tests) {\n+            for (auto const& test : tests) {\n+                auto const& testCaseInfo = test.getTestCaseInfo();\n+\n+                if (startsWith(testCaseInfo.name, '#')) {\n+                    out << '\"' << testCaseInfo.name << '\"';\n+                } else {\n+                    out << testCaseInfo.name;\n+                }\n+\n+                out << '\\n';\n+            }\n+            out << std::flush;\n+        }\n+    } // end unnamed namespace\n+\n+\n     // Because formatting using c++ streams is stateful, drop down to C is\n     // required Alternatively we could use stringstream, but its performance\n     // is... not good.\n@@ -89,6 +116,101 @@ namespace Catch {\n         return out;\n     }\n \n+    void\n+    defaultListReporters( std::ostream& out,\n+                          std::vector<ReporterDescription> const& descriptions,\n+                          Verbosity verbosity ) {\n+        out << \"Available reporters:\\n\";\n+        const auto maxNameLen =\n+            std::max_element( descriptions.begin(),\n+                              descriptions.end(),\n+                              []( ReporterDescription const& lhs,\n+                                  ReporterDescription const& rhs ) {\n+                                  return lhs.name.size() < rhs.name.size();\n+                              } )\n+                ->name.size();\n+\n+        for ( auto const& desc : descriptions ) {\n+            if ( verbosity == Verbosity::Quiet ) {\n+                out << TextFlow::Column( desc.name )\n+                           .indent( 2 )\n+                           .width( 5 + maxNameLen )\n+                    << '\\n';\n+            } else {\n+                out << TextFlow::Column( desc.name + \":\" )\n+                               .indent( 2 )\n+                               .width( 5 + maxNameLen ) +\n+                           TextFlow::Column( desc.description )\n+                               .initialIndent( 0 )\n+                               .indent( 2 )\n+                               .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\n+                    << '\\n';\n+            }\n+        }\n+        out << '\\n' << std::flush;\n+    }\n+\n+    void defaultListTags( std::ostream& out,\n+                          std::vector<TagInfo> const& tags,\n+                          bool isFiltered ) {\n+        if ( isFiltered ) {\n+            out << \"Tags for matching test cases:\\n\";\n+        } else {\n+            out << \"All available tags:\\n\";\n+        }\n+\n+        for ( auto const& tagCount : tags ) {\n+            ReusableStringStream rss;\n+            rss << \"  \" << std::setw( 2 ) << tagCount.count << \"  \";\n+            auto str = rss.str();\n+            auto wrapper = TextFlow::Column( tagCount.all() )\n+                               .initialIndent( 0 )\n+                               .indent( str.size() )\n+                               .width( CATCH_CONFIG_CONSOLE_WIDTH - 10 );\n+            out << str << wrapper << '\\n';\n+        }\n+        out << pluralise( tags.size(), \"tag\" ) << '\\n' << std::endl;\n+    }\n+\n+    void defaultListTests(std::ostream& out, std::vector<TestCaseHandle> const& tests, bool isFiltered, Verbosity verbosity) {\n+        // We special case this to provide the equivalent of old\n+        // `--list-test-names-only`, which could then be used by the\n+        // `--input-file` option.\n+        if (verbosity == Verbosity::Quiet) {\n+            listTestNamesOnly(out, tests);\n+            return;\n+        }\n+\n+        if (isFiltered) {\n+            out << \"Matching test cases:\\n\";\n+        } else {\n+            out << \"All available test cases:\\n\";\n+        }\n+\n+        for (auto const& test : tests) {\n+            auto const& testCaseInfo = test.getTestCaseInfo();\n+            Colour::Code colour = testCaseInfo.isHidden()\n+                ? Colour::SecondaryText\n+                : Colour::None;\n+            Colour colourGuard(colour);\n+\n+            out << TextFlow::Column(testCaseInfo.name).initialIndent(2).indent(4) << '\\n';\n+            if (verbosity >= Verbosity::High) {\n+                out << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << std::endl;\n+            }\n+            if (!testCaseInfo.tags.empty() &&\n+                verbosity > Verbosity::Quiet) {\n+                out << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << '\\n';\n+            }\n+        }\n+\n+        if (isFiltered) {\n+            out << pluralise(tests.size(), \"matching test case\") << '\\n' << std::endl;\n+        } else {\n+            out << pluralise(tests.size(), \"test case\") << '\\n' << std::endl;\n+        }\n+    }\n+\n } // namespace Catch\n \n \n@@ -100,13 +222,10 @@ namespace Catch {\n     bool EventListenerBase::assertionEnded( AssertionStats const& ) {\n         return false;\n     }\n-    void\n-    EventListenerBase::listReporters( std::vector<ReporterDescription> const&,\n-                                      IConfig const& ) {}\n-    void EventListenerBase::listTests( std::vector<TestCaseHandle> const&,\n-                                       IConfig const& ) {}\n-    void EventListenerBase::listTags( std::vector<TagInfo> const&,\n-                                      IConfig const& ) {}\n+    void EventListenerBase::listReporters(\n+        std::vector<ReporterDescription> const& ) {}\n+    void EventListenerBase::listTests( std::vector<TestCaseHandle> const& ) {}\n+    void EventListenerBase::listTags( std::vector<TagInfo> const& ) {}\n     void EventListenerBase::noMatchingTestCases( std::string const& ) {}\n     void EventListenerBase::testRunStarting( TestRunInfo const& ) {}\n     void EventListenerBase::testGroupStarting( GroupInfo const& ) {}\ndiff --git a/src/catch2/reporters/catch_reporter_cumulative_base.cpp b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n--- a/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n+++ b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n@@ -6,6 +6,7 @@\n \n // SPDX-License-Identifier: BSL-1.0\n #include <catch2/reporters/catch_reporter_cumulative_base.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n \n #include <algorithm>\n #include <cassert>\n@@ -110,4 +111,19 @@ namespace Catch {\n         testRunEndedCumulative();\n     }\n \n+    void CumulativeReporterBase::listReporters(std::vector<ReporterDescription> const& descriptions) {\n+        defaultListReporters(stream, descriptions, m_config->verbosity());\n+    }\n+\n+    void CumulativeReporterBase::listTests(std::vector<TestCaseHandle> const& tests) {\n+        defaultListTests(stream,\n+                         tests,\n+                         m_config->hasTestFilters(),\n+                         m_config->verbosity());\n+    }\n+\n+    void CumulativeReporterBase::listTags(std::vector<TagInfo> const& tags) {\n+        defaultListTags( stream, tags, m_config->hasTestFilters() );\n+    }\n+\n } // end namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_cumulative_base.hpp b/src/catch2/reporters/catch_reporter_cumulative_base.hpp\n--- a/src/catch2/reporters/catch_reporter_cumulative_base.hpp\n+++ b/src/catch2/reporters/catch_reporter_cumulative_base.hpp\n@@ -46,7 +46,8 @@ namespace Catch {\n         using TestRunNode = Node<TestRunStats, TestGroupNode>;\n \n         CumulativeReporterBase( ReporterConfig const& _config ):\n-            m_config( _config.fullConfig() ), stream( _config.stream() ) {}\n+            IStreamingReporter( _config.fullConfig() ),\n+            stream( _config.stream() ) {}\n         ~CumulativeReporterBase() override;\n \n         void testRunStarting( TestRunInfo const& ) override {}\n@@ -68,7 +69,11 @@ namespace Catch {\n \n         void skipTest(TestCaseInfo const&) override {}\n \n-        IConfig const* m_config;\n+        void listReporters( std::vector<ReporterDescription> const& descriptions ) override;\n+        void listTests( std::vector<TestCaseHandle> const& tests ) override;\n+        void listTags( std::vector<TagInfo> const& tags ) override;\n+\n+\n         std::ostream& stream;\n         // Note: We rely on pointer identity being stable, which is why\n         //       which is why we store around pointers rather than values.\ndiff --git a/src/catch2/reporters/catch_reporter_event_listener.hpp b/src/catch2/reporters/catch_reporter_event_listener.hpp\n--- a/src/catch2/reporters/catch_reporter_event_listener.hpp\n+++ b/src/catch2/reporters/catch_reporter_event_listener.hpp\n@@ -20,22 +20,17 @@ namespace Catch {\n      * member functions it actually cares about.\n      */\n     class EventListenerBase : public IStreamingReporter {\n-        IConfig const* m_config;\n-\n     public:\n         EventListenerBase( ReporterConfig const& config ):\n-            m_config( config.fullConfig() ) {}\n+            IStreamingReporter( config.fullConfig() ) {}\n \n         void assertionStarting( AssertionInfo const& assertionInfo ) override;\n         bool assertionEnded( AssertionStats const& assertionStats ) override;\n \n-        void\n-        listReporters( std::vector<ReporterDescription> const& descriptions,\n-                       IConfig const& config ) override;\n-        void listTests( std::vector<TestCaseHandle> const& tests,\n-                        IConfig const& config ) override;\n-        void listTags( std::vector<TagInfo> const& tagInfos,\n-                       IConfig const& config ) override;\n+        void listReporters(\n+            std::vector<ReporterDescription> const& descriptions ) override;\n+        void listTests( std::vector<TestCaseHandle> const& tests ) override;\n+        void listTags( std::vector<TagInfo> const& tagInfos ) override;\n \n         void noMatchingTestCases( std::string const& spec ) override;\n         void testRunStarting( TestRunInfo const& testRunInfo ) override;\ndiff --git a/src/catch2/reporters/catch_reporter_helpers.hpp b/src/catch2/reporters/catch_reporter_helpers.hpp\n--- a/src/catch2/reporters/catch_reporter_helpers.hpp\n+++ b/src/catch2/reporters/catch_reporter_helpers.hpp\n@@ -12,9 +12,13 @@\n #include <string>\n #include <vector>\n \n+#include <catch2/internal/catch_list.hpp>\n+#include <catch2/interfaces/catch_interfaces_config.hpp>\n+\n namespace Catch {\n \n     struct IConfig;\n+    class TestCaseHandle;\n \n     // Returns double formatted as %.3f (format expected on output)\n     std::string getFormattedDuration( double duration );\n@@ -31,6 +35,42 @@ namespace Catch {\n         friend std::ostream& operator<<( std::ostream& out, lineOfChars value );\n     };\n \n+    /**\n+     * Lists reporter descriptions to the provided stream in user-friendly\n+     * format\n+     *\n+     * Used as the default listing implementation by the first party reporter\n+     * bases. The output should be backwards compatible with the output of\n+     * Catch2 v2 binaries.\n+     */\n+    void\n+    defaultListReporters( std::ostream& out,\n+                          std::vector<ReporterDescription> const& descriptions,\n+                          Verbosity verbosity );\n+\n+    /**\n+     * Lists tag information to the provided stream in user-friendly format\n+     *\n+     * Used as the default listing implementation by the first party reporter\n+     * bases. The output should be backwards compatible with the output of\n+     * Catch2 v2 binaries.\n+     */\n+    void defaultListTags( std::ostream& out, std::vector<TagInfo> const& tags, bool isFiltered );\n+\n+    /**\n+     * Lists test case information to the provided stream in user-friendly\n+     * format\n+     *\n+     * Used as the default listing implementation by the first party reporter\n+     * bases. The output is backwards compatible with the output of Catch2\n+     * v2 binaries, and also supports the format specific to the old\n+     * `--list-test-names-only` option, for people who used it in integrations.\n+     */\n+    void defaultListTests( std::ostream& out,\n+                           std::vector<TestCaseHandle> const& tests,\n+                           bool isFiltered,\n+                           Verbosity verbosity );\n+\n } // end namespace Catch\n \n #endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED\ndiff --git a/src/catch2/reporters/catch_reporter_listening.cpp b/src/catch2/reporters/catch_reporter_listening.cpp\n--- a/src/catch2/reporters/catch_reporter_listening.cpp\n+++ b/src/catch2/reporters/catch_reporter_listening.cpp\n@@ -11,11 +11,6 @@\n \n namespace Catch {\n \n-    ListeningReporter::ListeningReporter() {\n-        // We will assume that listeners will always want all assertions\n-        m_preferences.shouldReportAllAssertions = true;\n-    }\n-\n     void ListeningReporter::addListener( IStreamingReporterPtr&& listener ) {\n         m_listeners.push_back( std::move( listener ) );\n     }\n@@ -146,25 +141,25 @@ namespace Catch {\n         m_reporter->skipTest( testInfo );\n     }\n \n-    void ListeningReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) {\n+    void ListeningReporter::listReporters(std::vector<ReporterDescription> const& descriptions) {\n         for (auto const& listener : m_listeners) {\n-            listener->listReporters(descriptions, config);\n+            listener->listReporters(descriptions);\n         }\n-        m_reporter->listReporters(descriptions, config);\n+        m_reporter->listReporters(descriptions);\n     }\n \n-    void ListeningReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) {\n+    void ListeningReporter::listTests(std::vector<TestCaseHandle> const& tests) {\n         for (auto const& listener : m_listeners) {\n-            listener->listTests(tests, config);\n+            listener->listTests(tests);\n         }\n-        m_reporter->listTests(tests, config);\n+        m_reporter->listTests(tests);\n     }\n \n-    void ListeningReporter::listTags(std::vector<TagInfo> const& tags, IConfig const& config) {\n+    void ListeningReporter::listTags(std::vector<TagInfo> const& tags) {\n         for (auto const& listener : m_listeners) {\n-            listener->listTags(tags, config);\n+            listener->listTags(tags);\n         }\n-        m_reporter->listTags(tags, config);\n+        m_reporter->listTags(tags);\n     }\n \n } // end namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_listening.hpp b/src/catch2/reporters/catch_reporter_listening.hpp\n--- a/src/catch2/reporters/catch_reporter_listening.hpp\n+++ b/src/catch2/reporters/catch_reporter_listening.hpp\n@@ -18,7 +18,12 @@ namespace Catch {\n         IStreamingReporterPtr m_reporter = nullptr;\n \n     public:\n-        ListeningReporter();\n+        ListeningReporter( IConfig const* config ):\n+            IStreamingReporter( config ) {\n+            // We will assume that listeners will always want all assertions\n+            m_preferences.shouldReportAllAssertions = true;\n+        }\n+\n \n         void addListener( IStreamingReporterPtr&& listener );\n         void addReporter( IStreamingReporterPtr&& reporter );\n@@ -49,9 +54,9 @@ namespace Catch {\n \n         void skipTest( TestCaseInfo const& testInfo ) override;\n \n-        void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) override;\n-        void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) override;\n-        void listTags(std::vector<TagInfo> const& tags, IConfig const& config) override;\n+        void listReporters(std::vector<ReporterDescription> const& descriptions) override;\n+        void listTests(std::vector<TestCaseHandle> const& tests) override;\n+        void listTags(std::vector<TagInfo> const& tags) override;\n \n \n     };\ndiff --git a/src/catch2/reporters/catch_reporter_streaming_base.cpp b/src/catch2/reporters/catch_reporter_streaming_base.cpp\n--- a/src/catch2/reporters/catch_reporter_streaming_base.cpp\n+++ b/src/catch2/reporters/catch_reporter_streaming_base.cpp\n@@ -6,6 +6,7 @@\n \n // SPDX-License-Identifier: BSL-1.0\n #include <catch2/reporters/catch_reporter_streaming_base.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n \n namespace Catch {\n \n@@ -31,4 +32,19 @@ namespace Catch {\n         currentTestRunInfo.reset();\n     }\n \n+    void StreamingReporterBase::listReporters(std::vector<ReporterDescription> const& descriptions) {\n+        defaultListReporters( stream, descriptions, m_config->verbosity() );\n+    }\n+\n+    void StreamingReporterBase::listTests(std::vector<TestCaseHandle> const& tests) {\n+        defaultListTests(stream,\n+                         tests,\n+                         m_config->hasTestFilters(),\n+                         m_config->verbosity());\n+    }\n+\n+    void StreamingReporterBase::listTags(std::vector<TagInfo> const& tags) {\n+        defaultListTags( stream, tags, m_config->hasTestFilters() );\n+    }\n+\n } // end namespace Catch\ndiff --git a/src/catch2/reporters/catch_reporter_streaming_base.hpp b/src/catch2/reporters/catch_reporter_streaming_base.hpp\n--- a/src/catch2/reporters/catch_reporter_streaming_base.hpp\n+++ b/src/catch2/reporters/catch_reporter_streaming_base.hpp\n@@ -36,8 +36,8 @@ namespace Catch {\n     struct StreamingReporterBase : IStreamingReporter {\n \n         StreamingReporterBase( ReporterConfig const& _config ):\n-            m_config( _config.fullConfig() ), stream( _config.stream() ) {\n-        }\n+            IStreamingReporter( _config.fullConfig() ),\n+            stream( _config.stream() ) {}\n \n \n         ~StreamingReporterBase() override;\n@@ -71,7 +71,10 @@ namespace Catch {\n             // It can optionally be overridden in the derived class.\n         }\n \n-        IConfig const* m_config;\n+        void listReporters( std::vector<ReporterDescription> const& descriptions ) override;\n+        void listTests( std::vector<TestCaseHandle> const& tests ) override;\n+        void listTags( std::vector<TagInfo> const& tags ) override;\n+\n         std::ostream& stream;\n \n         LazyStat<TestRunInfo> currentTestRunInfo;\ndiff --git a/src/catch2/reporters/catch_reporter_xml.cpp b/src/catch2/reporters/catch_reporter_xml.cpp\n--- a/src/catch2/reporters/catch_reporter_xml.cpp\n+++ b/src/catch2/reporters/catch_reporter_xml.cpp\n@@ -272,7 +272,7 @@ namespace Catch {\n         m_xml.endElement();\n     }\n \n-    void XmlReporter::listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const&) {\n+    void XmlReporter::listReporters(std::vector<ReporterDescription> const& descriptions) {\n         auto outerTag = m_xml.scopedElement(\"AvailableReporters\");\n         for (auto const& reporter : descriptions) {\n             auto inner = m_xml.scopedElement(\"Reporter\");\n@@ -285,7 +285,7 @@ namespace Catch {\n         }\n     }\n \n-    void XmlReporter::listTests(std::vector<TestCaseHandle> const& tests, IConfig const&) {\n+    void XmlReporter::listTests(std::vector<TestCaseHandle> const& tests) {\n         auto outerTag = m_xml.scopedElement(\"MatchingTests\");\n         for (auto const& test : tests) {\n             auto innerTag = m_xml.scopedElement(\"TestCase\");\n@@ -310,7 +310,7 @@ namespace Catch {\n         }\n     }\n \n-    void XmlReporter::listTags(std::vector<TagInfo> const& tags, IConfig const&) {\n+    void XmlReporter::listTags(std::vector<TagInfo> const& tags) {\n         auto outerTag = m_xml.scopedElement(\"TagsFromMatchingTests\");\n         for (auto const& tag : tags) {\n             auto innerTag = m_xml.scopedElement(\"Tag\");\ndiff --git a/src/catch2/reporters/catch_reporter_xml.hpp b/src/catch2/reporters/catch_reporter_xml.hpp\n--- a/src/catch2/reporters/catch_reporter_xml.hpp\n+++ b/src/catch2/reporters/catch_reporter_xml.hpp\n@@ -56,9 +56,9 @@ namespace Catch {\n         void benchmarkEnded(BenchmarkStats<> const&) override;\n         void benchmarkFailed(std::string const&) override;\n \n-        void listReporters(std::vector<ReporterDescription> const& descriptions, IConfig const& config) override;\n-        void listTests(std::vector<TestCaseHandle> const& tests, IConfig const& config) override;\n-        void listTags(std::vector<TagInfo> const& tags, IConfig const& config) override;\n+        void listReporters(std::vector<ReporterDescription> const& descriptions) override;\n+        void listTests(std::vector<TestCaseHandle> const& tests) override;\n+        void listTags(std::vector<TagInfo> const& tags) override;\n \n     private:\n         Timer m_testCaseTimer;\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -23,6 +23,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/IntrospectiveTests/InternalBenchmark.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/PartTracker.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/RandomNumberGeneration.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/Reporters.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/String.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/StringManip.tests.cpp\ndiff --git a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n@@ -0,0 +1,109 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE_1_0.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/catch_config.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter_registry.hpp>\n+#include <catch2/internal/catch_list.hpp>\n+#include <catch2/matchers/catch_matchers_string.hpp>\n+#include <catch2/reporters/catch_reporter_helpers.hpp>\n+\n+#include <sstream>\n+\n+TEST_CASE( \"The default listing implementation write to provided stream\",\n+           \"[reporters][reporter-helpers]\" ) {\n+    using Catch::Matchers::Contains;\n+    using namespace std::string_literals;\n+\n+    std::stringstream sstream;\n+    SECTION( \"Listing tags\" ) {\n+        std::vector<Catch::TagInfo> tags(1);\n+        tags[0].add(\"fakeTag\"_catch_sr);\n+        Catch::defaultListTags(sstream, tags, false);\n+\n+        auto listingString = sstream.str();\n+        REQUIRE_THAT(listingString, Contains(\"[fakeTag]\"s));\n+    }\n+    SECTION( \"Listing reporters\" ) {\n+        std::vector<Catch::ReporterDescription> reporters(\n+            { { \"fake reporter\", \"fake description\" } } );\n+        Catch::defaultListReporters(sstream, reporters, Catch::Verbosity::Normal);\n+\n+        auto listingString = sstream.str();\n+        REQUIRE_THAT(listingString, Contains(\"fake reporter\"s));\n+    }\n+    SECTION( \"Listing tests\" ) {\n+        Catch::TestCaseInfo fakeInfo{\n+            \"\"s,\n+            { \"fake test name\"_catch_sr, \"[fakeTestTag]\"_catch_sr },\n+            { \"fake-file.cpp\", 123456789 } };\n+        std::vector<Catch::TestCaseHandle> tests({ {&fakeInfo, nullptr} });\n+        Catch::defaultListTests(sstream, tests, false, Catch::Verbosity::Normal);\n+\n+        auto listingString = sstream.str();\n+        REQUIRE_THAT( listingString,\n+                      Contains( \"fake test name\"s ) &&\n+                          Contains( \"fakeTestTag\"s ) );\n+    }\n+}\n+\n+TEST_CASE( \"Reporter's write listings to provided stream\", \"[reporters]\" ) {\n+    using Catch::Matchers::Contains;\n+    using namespace std::string_literals;\n+\n+    auto const& factories = Catch::getRegistryHub().getReporterRegistry().getFactories();\n+    // If there are no reporters, the test would pass falsely\n+    // while there is something obviously broken\n+    REQUIRE_FALSE(factories.empty());\n+\n+    for (auto const& factory : factories) {\n+        INFO(\"Tested reporter: \" << factory.first);\n+        std::stringstream sstream;\n+\n+        Catch::ConfigData config_data;\n+        Catch::Config config( config_data );\n+        Catch::ReporterConfig rep_config( &config, sstream );\n+        auto reporter = factory.second->create( rep_config );\n+\n+        DYNAMIC_SECTION( factory.first << \" reporter lists tags\" ) {\n+            std::vector<Catch::TagInfo> tags(1);\n+            tags[0].add(\"fakeTag\"_catch_sr);\n+            reporter->listTags(tags);\n+\n+            auto listingString = sstream.str();\n+            REQUIRE_THAT(listingString, Contains(\"fakeTag\"s));\n+        }\n+\n+        DYNAMIC_SECTION( factory.first << \" reporter lists reporters\" ) {\n+            std::vector<Catch::ReporterDescription> reporters(\n+                { { \"fake reporter\", \"fake description\" } } );\n+            reporter->listReporters(reporters);\n+\n+            auto listingString = sstream.str();\n+            REQUIRE_THAT(listingString, Contains(\"fake reporter\"s));\n+        }\n+\n+        DYNAMIC_SECTION( factory.first << \" reporter lists tests\" ) {\n+            Catch::TestCaseInfo fakeInfo{\n+                \"\"s,\n+                { \"fake test name\"_catch_sr, \"[fakeTestTag]\"_catch_sr },\n+                { \"fake-file.cpp\", 123456789 } };\n+            std::vector<Catch::TestCaseHandle> tests({ {&fakeInfo, nullptr} });\n+            reporter->listTests(tests);\n+\n+            auto listingString = sstream.str();\n+            REQUIRE_THAT( listingString,\n+                          Contains( \"fake test name\"s ) &&\n+                              Contains( \"fakeTestTag\"s ) );\n+        }\n+    }\n+}\n", "problem_statement": "The output of --list-* options should obey -o flag\n**Description**\r\nCurrently, the output of `--list-*` options writes to stdout through `Catch::cout()`. It should obey the `-o` flag instead.\r\n\r\n**Additional context**\r\nBecause the default implementation of `--list*` flags is done in the `IStreamingReporter`  interface, we need to extend it to contain the stream it should write to, e.g. by giving it a `ReporterConfig` member and initializing it properly.\n", "hints_text": "", "created_at": "2021-01-26T17:45:37Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 2288, "instance_id": "catchorg__Catch2-2288", "issue_numbers": ["2273"], "base_commit": "85c9544fa4c9625b9656d9bd765e54f8e639287f", "patch": "diff --git a/include/internal/catch_approx.h b/include/internal/catch_approx.h\n--- a/include/internal/catch_approx.h\n+++ b/include/internal/catch_approx.h\n@@ -33,7 +33,7 @@ namespace Detail {\n         Approx operator-() const;\n \n         template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>\n-        Approx operator()( T const& value ) {\n+        Approx operator()( T const& value ) const {\n             Approx approx( static_cast<double>(value) );\n             approx.m_epsilon = m_epsilon;\n             approx.m_margin = m_margin;\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Approx.tests.cpp b/projects/SelfTest/UsageTests/Approx.tests.cpp\n--- a/projects/SelfTest/UsageTests/Approx.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Approx.tests.cpp\n@@ -212,4 +212,11 @@ TEST_CASE( \"Comparison with explicitly convertible types\", \"[Approx]\" )\n \n }\n \n+TEST_CASE(\"Approx::operator() is const correct\", \"[Approx][.approvals]\") {\n+  const Approx ap = Approx(0.0).margin(0.01);\n+\n+  // As long as this compiles, the test should be considered passing\n+  REQUIRE(1.0 == ap(1.0));\n+}\n+\n }} // namespace ApproxTests\n", "problem_statement": "Approx::operator() not const-correct\n**Describe the bug**\r\n\r\nThe `Approx` type has an overload of `template <typename T, ...SFINAE...> Approx operator()(T const&)` which (correct me if I'm wrong) is meant to be a factory function for instances that have the same epsilon, margin, and scale, but that use the passed value. \r\n\r\nAFAICT this should be const on the instance, but it's not.\r\n\r\nMinimum failing example:\r\n```C++\r\n#include <catch2/catch.hpp>\r\n\r\nTEST_CASE(\"Approx factory is const-correct\") {\r\n  // Set up a template Approx with problem-specific margin, etc.\r\n  Approx const apprx = Approx(0.0).margin(1e-6);\r\n  double value = 1.0;\r\n  // Use template in assertions\r\n  REQUIRE(value == apprx(1.0));\r\n}\r\n```\r\n\r\n**Expected behavior**\r\nAbove test compiles, runs and passes.\r\n\r\n**Reproduction steps**\r\nSee above.\r\n\r\n**Platform information:**\r\n - OS: RHEL 8\r\n - Compiler+version: GCC 8.2.0\r\n - Catch version: 2.13.6\r\n\r\n\r\n**Additional context**\r\nAdd any other context about the problem here.\r\n\n", "hints_text": "Sorry forgot to add error message:\r\n```\r\n$ g++ -I$Catch2_DIR/include const-approx.cpp \r\nIn file included from const-approx.cpp:1:\r\nconst-approx.cpp: In function \u2018void ____C_A_T_C_H____T_E_S_T____0()\u2019:\r\nconst-approx.cpp:6:29: error: no match for call to \u2018(const Catch::Detail::Approx) (double)\u2019\r\n   REQUIRE(value == apprx(1.0));\r\n                             ^\r\nIn file included from const-approx.cpp:1:\r\n$Catch2_DIR/include/catch2/catch.hpp:3094:16: note: candidate: \u2018Catch::Detail::Approx Catch::Detail::Approx::operator()(const T&) [with T = double; <template-parameter-1-2> = void]\u2019 <near match>\r\n         Approx operator()( T const& value ) {\r\n                ^~~~~~~~\r\n$Catch2_DIR/include/catch2/catch.hpp:3094:16: note:   passing \u2018const Catch::Detail::Approx*\u2019 as \u2018this\u2019 argument discards qualifiers\r\n```\nMakes sense to have it const-qualified.\r\n\r\nIf you want the fix to be in v2, PRs are welcome \ud83d\ude03 ", "created_at": "2021-09-17T10:05:47Z", "version": "2.13"}
{"repo": "catchorg/Catch2", "pull_number": 1815, "instance_id": "catchorg__Catch2-1815", "issue_numbers": ["1809", "1809"], "base_commit": "9a8963133fb7ce9ce31802160d8e351e0ac5527c", "patch": "diff --git a/include/internal/catch_generators.hpp b/include/internal/catch_generators.hpp\n--- a/include/internal/catch_generators.hpp\n+++ b/include/internal/catch_generators.hpp\n@@ -57,7 +57,6 @@ namespace Generators {\n     class SingleValueGenerator final : public IGenerator<T> {\n         T m_value;\n     public:\n-        SingleValueGenerator(T const& value) : m_value( value ) {}\n         SingleValueGenerator(T&& value) : m_value(std::move(value)) {}\n \n         T const& get() const override {\n@@ -120,21 +119,21 @@ namespace Generators {\n             m_generators.emplace_back(std::move(generator));\n         }\n         void populate(T&& val) {\n-            m_generators.emplace_back(value(std::move(val)));\n+            m_generators.emplace_back(value(std::forward<T>(val)));\n         }\n         template<typename U>\n         void populate(U&& val) {\n-            populate(T(std::move(val)));\n+            populate(T(std::forward<U>(val)));\n         }\n         template<typename U, typename... Gs>\n-        void populate(U&& valueOrGenerator, Gs... moreGenerators) {\n+        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {\n             populate(std::forward<U>(valueOrGenerator));\n             populate(std::forward<Gs>(moreGenerators)...);\n         }\n \n     public:\n         template <typename... Gs>\n-        Generators(Gs... moreGenerators) {\n+        Generators(Gs &&... moreGenerators) {\n             m_generators.reserve(sizeof...(Gs));\n             populate(std::forward<Gs>(moreGenerators)...);\n         }\n@@ -166,7 +165,7 @@ namespace Generators {\n     struct as {};\n \n     template<typename T, typename... Gs>\n-    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {\n         return Generators<T>(std::move(generator), std::forward<Gs>(moreGenerators)...);\n     }\n     template<typename T>\n@@ -174,11 +173,11 @@ namespace Generators {\n         return Generators<T>(std::move(generator));\n     }\n     template<typename T, typename... Gs>\n-    auto makeGenerators( T&& val, Gs... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {\n         return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );\n     }\n     template<typename T, typename U, typename... Gs>\n-    auto makeGenerators( as<T>, U&& val, Gs... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {\n         return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );\n     }\n \n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -181,7 +181,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                     const auto step = .1;\n \n                     auto gen = range(rangeStart, rangeEnd, step);\n-                    auto expected = rangeStart; \n+                    auto expected = rangeStart;\n                     while( (rangeEnd - expected) > step ) {\n                         INFO( \"Current expected value is \" << expected )\n                         REQUIRE(gen.get() == Approx(expected));\n@@ -198,7 +198,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                     const auto step = .3;\n \n                     auto gen = range(rangeStart, rangeEnd, step);\n-                    auto expected = rangeStart; \n+                    auto expected = rangeStart;\n                     while( (rangeEnd - expected) > step ) {\n                        INFO( \"Current expected value is \" << expected )\n                        REQUIRE(gen.get() == Approx(expected));\n@@ -214,7 +214,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                     const auto step = .3;\n \n                     auto gen = range(rangeStart, rangeEnd, step);\n-                    auto expected = rangeStart; \n+                    auto expected = rangeStart;\n                     while( (rangeEnd - expected) > step ) {\n                        INFO( \"Current expected value is \" << expected )\n                        REQUIRE(gen.get() == Approx(expected));\n@@ -223,7 +223,7 @@ TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\n                        expected += step;\n                     }\n                     REQUIRE_FALSE(gen.next());\n-                }                \n+                }\n             }\n         }\n         SECTION(\"Negative manual step\") {\n@@ -311,6 +311,21 @@ TEST_CASE(\"GENERATE capture macros\", \"[generators][internals][approvals]\") {\n     REQUIRE(value == value2);\n }\n \n+TEST_CASE(\"#1809 - GENERATE_COPY and SingleValueGenerator does not compile\", \"[generators][compilation][approvals]\") {\n+    // Verify Issue #1809 fix, only needs to compile.\n+    auto a = GENERATE_COPY(1, 2);\n+    (void)a;\n+    auto b = GENERATE_COPY(as<long>{}, 1, 2);\n+    (void)b;\n+    int i = 1;\n+    int j = 2;\n+    auto c = GENERATE_COPY(i, j);\n+    (void)c;\n+    auto d = GENERATE_COPY(as<long>{}, i, j);\n+    (void)d;\n+    SUCCEED();\n+}\n+\n TEST_CASE(\"Multiple random generators in one test case output different values\", \"[generators][internals][approvals]\") {\n     SECTION(\"Integer\") {\n         auto random1 = Catch::Generators::random(0, 1000);\n", "problem_statement": "Can't compile SingleValueGenerator inside GENERATE_COPY\n**Describe the bug**\r\nAttempting to invoke the `SingleValueGenerator` (using external variables) inside `GENERATE_COPY` like so...\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( a,b );\r\n```\r\nresults in a compilation error:\r\n```C++\r\nerror: no matching function for call to 'Catch::Generators::GeneratorWrapper<const int&>::GeneratorWrapper(Catch::Generators::GeneratorWrapper<const int>)'\r\n  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\r\n```\r\n\r\n**Expected behavior**\r\nThe above example code should compile fine, since `GENERATE_COPY` should allow the use of external variables (`a` and `b`) in any generator. For example, the following code compiles totally fine (using `RangeGenerator`):\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( range(a,b) );\r\n```\r\n\r\n**Reproduction steps**\r\nself-contained code **`bugdemo.cpp`:**\r\n```C++\r\n#include \"catch.hpp\"\r\n\r\nTEST_CASE( \"bug \" ) {\r\n    \r\n    int a = 1;\r\n    int b = 2;\r\n    int c = GENERATE_COPY(a, b);\r\n    REQUIRE( true );\r\n}\r\n```\r\nand compiled simply with\r\n```\r\ng++ -std=c++14 -c bugdemo.cpp\r\n```\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **MacOS 10.14** and **Ubuntu 18.04**\r\n - Compiler+version: **GCC v8.2.0** and **GCC v7.4.0** and **clang v10.0.0** (and all other versions on system)\r\n - Catch version: **v2.10.0**\r\n\nCan't compile SingleValueGenerator inside GENERATE_COPY\n**Describe the bug**\r\nAttempting to invoke the `SingleValueGenerator` (using external variables) inside `GENERATE_COPY` like so...\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( a,b );\r\n```\r\nresults in a compilation error:\r\n```C++\r\nerror: no matching function for call to 'Catch::Generators::GeneratorWrapper<const int&>::GeneratorWrapper(Catch::Generators::GeneratorWrapper<const int>)'\r\n  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\r\n```\r\n\r\n**Expected behavior**\r\nThe above example code should compile fine, since `GENERATE_COPY` should allow the use of external variables (`a` and `b`) in any generator. For example, the following code compiles totally fine (using `RangeGenerator`):\r\n```C++\r\nint a = 1;\r\nint b = 2;\r\nint c = GENERATE_COPY( range(a,b) );\r\n```\r\n\r\n**Reproduction steps**\r\nself-contained code **`bugdemo.cpp`:**\r\n```C++\r\n#include \"catch.hpp\"\r\n\r\nTEST_CASE( \"bug \" ) {\r\n    \r\n    int a = 1;\r\n    int b = 2;\r\n    int c = GENERATE_COPY(a, b);\r\n    REQUIRE( true );\r\n}\r\n```\r\nand compiled simply with\r\n```\r\ng++ -std=c++14 -c bugdemo.cpp\r\n```\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **MacOS 10.14** and **Ubuntu 18.04**\r\n - Compiler+version: **GCC v8.2.0** and **GCC v7.4.0** and **clang v10.0.0** (and all other versions on system)\r\n - Catch version: **v2.10.0**\r\n\n", "hints_text": "\n", "created_at": "2019-12-15T06:22:30Z", "version": "2.11"}
{"repo": "catchorg/Catch2", "pull_number": 2394, "instance_id": "catchorg__Catch2-2394", "issue_numbers": ["2304"], "base_commit": "1a8a793178d50b74b0f9a0adb3eec937b61039a9", "patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -157,6 +157,7 @@ set(INTERNAL_HEADERS\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.hpp\n     ${SOURCES_DIR}/internal/catch_windows_h_proxy.hpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.hpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.hpp\n )\n set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_approx.cpp\n@@ -213,6 +214,7 @@ set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_version.cpp\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.cpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.cpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.cpp\n )\n set(INTERNAL_FILES ${IMPL_SOURCES} ${INTERNAL_HEADERS})\n \ndiff --git a/src/catch2/catch_all.hpp b/src/catch2/catch_all.hpp\n--- a/src/catch2/catch_all.hpp\n+++ b/src/catch2/catch_all.hpp\n@@ -95,6 +95,7 @@\n #include <catch2/internal/catch_stringref.hpp>\n #include <catch2/internal/catch_tag_alias_registry.hpp>\n #include <catch2/internal/catch_template_test_registry.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n #include <catch2/internal/catch_test_case_registry_impl.hpp>\n #include <catch2/internal/catch_test_case_tracker.hpp>\n #include <catch2/internal/catch_test_failure_exception.hpp>\n", "test_patch": "diff --git a/src/catch2/internal/catch_test_case_info_hasher.cpp b/src/catch2/internal/catch_test_case_info_hasher.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.cpp\n@@ -0,0 +1,31 @@\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+namespace Catch {\n+    TestCaseInfoHasher::TestCaseInfoHasher( hash_t seed ): m_seed( seed ) {}\n+\n+    uint32_t TestCaseInfoHasher::operator()( TestCaseInfo const& t ) const {\n+        // FNV-1a hash algorithm that is designed for uniqueness:\n+        const hash_t prime = 1099511628211u;\n+        hash_t hash = 14695981039346656037u;\n+        for ( const char c : t.name ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const char c : t.className ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const Tag& tag : t.tags ) {\n+            for ( const char c : tag.original ) {\n+                hash ^= c;\n+                hash *= prime;\n+            }\n+        }\n+        hash ^= m_seed;\n+        hash *= prime;\n+        const uint32_t low{ static_cast<uint32_t>( hash ) };\n+        const uint32_t high{ static_cast<uint32_t>( hash >> 32 ) };\n+        return low * high;\n+    }\n+} // namespace Catch\ndiff --git a/src/catch2/internal/catch_test_case_info_hasher.hpp b/src/catch2/internal/catch_test_case_info_hasher.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.hpp\n@@ -0,0 +1,22 @@\n+#ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+\n+#include <cstdint>\n+\n+namespace Catch {\n+\n+    struct TestCaseInfo;\n+\n+    class TestCaseInfoHasher {\n+    public:\n+        using hash_t = std::uint64_t;\n+        TestCaseInfoHasher( hash_t seed );\n+        uint32_t operator()( TestCaseInfo const& t ) const;\n+\n+    private:\n+        hash_t m_seed;\n+    };\n+\n+} // namespace Catch\n+\n+#endif /* CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED */\ndiff --git a/src/catch2/internal/catch_test_case_registry_impl.cpp b/src/catch2/internal/catch_test_case_registry_impl.cpp\n--- a/src/catch2/internal/catch_test_case_registry_impl.cpp\n+++ b/src/catch2/internal/catch_test_case_registry_impl.cpp\n@@ -16,38 +16,13 @@\n #include <catch2/catch_test_case_info.hpp>\n #include <catch2/catch_test_spec.hpp>\n #include <catch2/internal/catch_move_and_forward.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n \n #include <algorithm>\n #include <set>\n \n namespace Catch {\n \n-namespace {\n-    struct TestHasher {\n-        using hash_t = uint64_t;\n-\n-        explicit TestHasher( hash_t hashSuffix ):\n-            m_hashSuffix( hashSuffix ) {}\n-\n-        uint64_t m_hashSuffix;\n-\n-        uint32_t operator()( TestCaseInfo const& t ) const {\n-            // FNV-1a hash with multiplication fold.\n-            const hash_t prime = 1099511628211u;\n-            hash_t hash = 14695981039346656037u;\n-            for (const char c : t.name) {\n-                hash ^= c;\n-                hash *= prime;\n-            }\n-            hash ^= m_hashSuffix;\n-            hash *= prime;\n-            const uint32_t low{ static_cast<uint32_t>(hash) };\n-            const uint32_t high{ static_cast<uint32_t>(hash >> 32) };\n-            return low * high;\n-        }\n-    };\n-} // end anonymous namespace\n-\n     std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases ) {\n         switch (config.runOrder()) {\n         case TestRunOrder::Declared:\n@@ -66,9 +41,9 @@ namespace {\n         }\n         case TestRunOrder::Randomized: {\n             seedRng(config);\n-            using TestWithHash = std::pair<TestHasher::hash_t, TestCaseHandle>;\n+            using TestWithHash = std::pair<TestCaseInfoHasher::hash_t, TestCaseHandle>;\n \n-            TestHasher h{ config.rngSeed() };\n+            TestCaseInfoHasher h{ config.rngSeed() };\n             std::vector<TestWithHash> indexed_tests;\n             indexed_tests.reserve(unsortedTestCases.size());\n \ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -88,6 +88,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/IntrospectiveTests/RandomNumberGeneration.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Reporters.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TestSpecParser.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TextFlow.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Sharding.tests.cpp\ndiff --git a/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n@@ -0,0 +1,51 @@\n+#include <catch2/catch_test_macros.hpp>\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+static constexpr Catch::SourceLineInfo dummySourceLineInfo = CATCH_INTERNAL_LINEINFO;\n+\n+TEST_CASE( \"TestCaseInfoHasher produces equal hashes.\" ) {\n+    SECTION( \"class names and names and tags are equal.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2));\n+    }\n+}\n+\n+TEST_CASE( \"TestCaseInfoHasher produces different hashes.\" ) {\n+    SECTION( \"class names are equal, names are equal but tags are different.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag2]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names are equal, tags are equal but names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name1\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name2\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"names are equal, tags are equal but class names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"class1\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"class2\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names and names and tags are equal but hashers are seeded differently.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher h1(14695981039346656037u);\n+        Catch::TestCaseInfoHasher h2(14695981039346656038u);\n+\n+        CHECK(h1(testCase1) != h2(testCase2));\n+    }\n+}\n", "problem_statement": "Test case name hashing should consider tags and class name too\n**Describe the bug**\r\nRecently I changed the \"unique test case\" criteria to allow test cases with same name, but different tags, or same names and tags but different class name (when a test case hangs off a type).\r\n\r\nHowever, we also hash test cases when ordering them randomly (to get subset-stable ordering), and the hashing currently only considers test case name, which means that hash collisions are now much more realistic (in fact the collision is guaranteed if two test cases have same name, which is a desired property by some users).\r\n\r\n_Note that this doesn't break the subset invariant, because we use the ordering of test case infos to break ties, which handles tags and class name properly_\r\n\r\n**Expected behavior**\r\nTo fix this, the hasher should also consider tags and class name.\r\n\r\n**Additional context**\r\nThis change also makes the hasher complex enough that it should be promoted to a header and receive direct unit tests.\n", "hints_text": "I am happy to work on this.\n@MohamedAlaa201 Sure, go for it.", "created_at": "2022-03-18T19:32:21Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 2058, "instance_id": "catchorg__Catch2-2058", "issue_numbers": ["2040", "2012"], "base_commit": "4b2bc8757c6d5a95e163b8a54a122d4c95b84310", "patch": "diff --git a/src/catch2/generators/catch_generators.hpp b/src/catch2/generators/catch_generators.hpp\n--- a/src/catch2/generators/catch_generators.hpp\n+++ b/src/catch2/generators/catch_generators.hpp\n@@ -70,8 +70,11 @@ namespace Detail {\n     class SingleValueGenerator final : public IGenerator<T> {\n         T m_value;\n     public:\n+        SingleValueGenerator(T const& value) :\n+            m_value(value)\n+        {}\n         SingleValueGenerator(T&& value):\n-            m_value(std::forward<T>(value))\n+            m_value(std::move(value))\n         {}\n \n         T const& get() const override {\n@@ -101,9 +104,11 @@ namespace Detail {\n         }\n     };\n \n-    template <typename T>\n-    GeneratorWrapper<T> value(T&& value) {\n-        return GeneratorWrapper<T>(Catch::Detail::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));\n+    template <typename T, typename DecayedT = std::decay_t<T>>\n+    GeneratorWrapper<DecayedT> value( T&& value ) {\n+        return GeneratorWrapper<DecayedT>(\n+            Catch::Detail::make_unique<SingleValueGenerator<DecayedT>>(\n+                std::forward<T>( value ) ) );\n     }\n     template <typename T>\n     GeneratorWrapper<T> values(std::initializer_list<T> values) {\n@@ -115,27 +120,36 @@ namespace Detail {\n         std::vector<GeneratorWrapper<T>> m_generators;\n         size_t m_current = 0;\n \n-        void populate(GeneratorWrapper<T>&& generator) {\n-            m_generators.emplace_back(std::move(generator));\n+        void add_generator( GeneratorWrapper<T>&& generator ) {\n+            m_generators.emplace_back( std::move( generator ) );\n+        }\n+        void add_generator( T const& val ) {\n+            m_generators.emplace_back( value( val ) );\n         }\n-        void populate(T&& val) {\n-            m_generators.emplace_back(value(std::forward<T>(val)));\n+        void add_generator( T&& val ) {\n+            m_generators.emplace_back( value( std::move( val ) ) );\n         }\n-        template<typename U>\n-        void populate(U&& val) {\n-            populate(T(std::forward<U>(val)));\n+        template <typename U>\n+        std::enable_if_t<!std::is_same<std::decay_t<U>, T>::value>\n+        add_generator( U&& val ) {\n+            add_generator( T( std::forward<U>( val ) ) );\n         }\n-        template<typename U, typename... Gs>\n-        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {\n-            populate(std::forward<U>(valueOrGenerator));\n-            populate(std::forward<Gs>(moreGenerators)...);\n+\n+        template <typename U> void add_generators( U&& valueOrGenerator ) {\n+            add_generator( std::forward<U>( valueOrGenerator ) );\n+        }\n+\n+        template <typename U, typename... Gs>\n+        void add_generators( U&& valueOrGenerator, Gs&&... moreGenerators ) {\n+            add_generator( std::forward<U>( valueOrGenerator ) );\n+            add_generators( std::forward<Gs>( moreGenerators )... );\n         }\n \n     public:\n         template <typename... Gs>\n         Generators(Gs &&... moreGenerators) {\n             m_generators.reserve(sizeof...(Gs));\n-            populate(std::forward<Gs>(moreGenerators)...);\n+            add_generators(std::forward<Gs>(moreGenerators)...);\n         }\n \n         T const& get() const override {\n@@ -155,8 +169,9 @@ namespace Detail {\n     };\n \n \n-    template<typename... Ts>\n-    GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {\n+    template <typename... Ts>\n+    GeneratorWrapper<std::tuple<std::decay_t<Ts>...>>\n+    table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {\n         return values<std::tuple<Ts...>>( tuples );\n     }\n \n@@ -173,7 +188,7 @@ namespace Detail {\n         return Generators<T>(std::move(generator));\n     }\n     template<typename T, typename... Gs>\n-    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<std::decay_t<T>> {\n         return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );\n     }\n     template<typename T, typename U, typename... Gs>\n", "test_patch": "diff --git a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -358,3 +358,33 @@ TEST_CASE(\"Multiple random generators in one test case output different values\",\n         REQUIRE(same < 200);\n     }\n }\n+\n+TEST_CASE(\"#2040 - infinite compilation recursion in GENERATE with MSVC\", \"[generators][compilation][approvals]\") {\n+    int x = 42;\n+    auto test = GENERATE_COPY(1, x, 2 * x);\n+    CHECK(test < 100);\n+}\n+\n+namespace {\n+    static bool always_true(int) {\n+        return true;\n+    }\n+\n+    static bool is_even(int n) {\n+        return n % 2 == 0;\n+    }\n+\n+    static bool is_multiple_of_3(int n) {\n+        return n % 3 == 0;\n+    }\n+}\n+\n+TEST_CASE(\"GENERATE handles function (pointers)\", \"[generators][compilation][approvals]\") {\n+    auto f = GENERATE(always_true, is_even, is_multiple_of_3);\n+    REQUIRE(f(6));\n+}\n+\n+TEST_CASE(\"GENERATE decays arrays\", \"[generators][compilation][approvals]\") {\n+    auto str = GENERATE(\"abc\", \"def\", \"gh\");\n+    STATIC_REQUIRE(std::is_same<decltype(str), const char*>::value);\n+}\n", "problem_statement": "Infinite recursion in Generators::populate with MSVC\n```\r\nCATCH_TEST_CASE(\"Recursion Bug\")\r\n{\r\n    int x = 42;\r\n    auto test = GENERATE_COPY(1, x, 2 * x);\r\n    CATCH_CHECK(test < 50);\r\n}\r\n```\r\nThis worked in `2.9.2` but now I get \r\n`single_include\\catch2\\catch.hpp(4027):warning C4717: 'Catch::Generators::Generators<int>::populate<int &>': recursive on all control paths, function will cause runtime stack overflow` with MSVC 2017 `Microsoft (R) C/C++ Optimizing Compiler Version 19.16.27042 for x64`.\r\nIt matches the wrong template.\r\n\r\nA possible work-around is `GENERATE_COPY(values<int>({1, x, 2 * x}));`, but the above should work, right?\nGENERATE() changes compile time length of arrays\n**Description**\r\nGENERATE macro takes type of first argument and cast all other args to it. It is ok for most cases but for string literals it is bad. It takes length of first literal and force it for all.\r\n`TEST_CASE(\"t\", \"[t]\") {\r\n    auto& str = GENERATE(\"123\", \"1\");\r\n    WARN(typeid(str).name());\r\n}`\r\nOutput\r\n`warning:\r\n  A4_c`\r\nUsually you don't see it. If you use std::string to store the result of GENERATE then everything works fine, all lengths are correct. But some string implementations use length from type of array. E.g., https://stackoverflow.com/questions/2384107/magic-arguments-in-function-templates\r\nThis template magic works wrong with GENERATE. I cann't say this is a bug, because I have no idea how to fix it. May be detect arrays and generate compilation error if lengths are different?\r\n\r\nIt is very bad rule in C++ that references to arrays with different lengths can be cast to each other. \n", "hints_text": "I can reproduce this with an up-to-date MSVC.\r\n\r\nHowever, it doesn't reproduce with Clang/GCC, so I suspect the code runs into some MSVC bug, which is going to be hard to debug.\nDoes not reproduce with `/permissive-`...\nSo, this was almost definitely introduced in 6c9a255dc2973e97b2d6a155d36f47e145382d32.\r\n\r\n\nRight, so, there are two parts to this.\r\n\r\n1) single `GENERATE` \"call\" can have only one return type. (even though for e.g. `TEMPLATE_TEST_CASE`, the type can differ across different input types...)\r\n2) deducing string literals as char arrays with specific size _can_ be a problem.\r\n\r\nI cannot change 1), and fixing 2) by forcing a pointer decay would break people who already use it with all literals having the same size.\r\n\r\nI will have to think about whether there is an use case for having different size string literals deduce as the same size, and if not, `static_assert` that they share length is indeed the best option.\r\n\r\n\r\nIn the meantime, if you have this issue in your code, consider passing `as<char const*>{}` as the first element in `GENERATE`. Doing so forces the type to be deduced as `char const*`.\nThank you for answer.\r\nYes, casting to string is how I solved this problem in my case.\r\n\r\nFor general case there is the only solution - detect reference to array. It is a question what to do with it. One option is static assert for length, but it is code breakage. If somebody used `std::string a = GENERATE(\"a\", \"ab\");` it worked well and, imho, should continue working. But static_assert breaks it. \r\nAnother option is cast to `const char*`. Correct code with std::string continues to compile and incorrect depends on situation. If it could not work without length then it wouldn't compile. And it is good because it was wrong code that worked with wrong length. If it can work with `const char*` instead of `char&[N]` then everything is OK like std::string.\r\n\r\nDetection itself can be implemented with function overload, e.g., `template<typename T,size_t N> \r\n void generate(T (&a)[N])`\nUpdate: I've decided that for v3 I am going to make arrays decay. Not sure if I will port this to v2 as well.", "created_at": "2020-10-20T09:04:14Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 2855, "instance_id": "catchorg__Catch2-2855", "issue_numbers": ["1210"], "base_commit": "2bce3e276b5f859ac45c43f011ffed98d0325115", "patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -450,6 +450,13 @@ namespace Catch {\n         assertionEnded(CATCH_MOVE(result) );\n         resetAssertionInfo();\n \n+        // Best effort cleanup for sections that have not been destructed yet\n+        // Since this is a fatal error, we have not had and won't have the opportunity to destruct them properly\n+        while (!m_activeSections.empty()) {\n+            auto nl = m_activeSections.back()->nameAndLocation();\n+            SectionEndInfo endInfo{ SectionInfo(CATCH_MOVE(nl.location), CATCH_MOVE(nl.name)), {}, 0.0 };\n+            sectionEndedEarly(CATCH_MOVE(endInfo));\n+        }\n         handleUnfinishedSections();\n \n         // Recreate section for test case (as we will lose the one that was in scope)\n", "test_patch": "diff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -467,6 +467,18 @@ set_tests_properties(\n     PASS_REGULAR_EXPRESSION \"Errors occurred during startup!\"\n )\n \n+add_executable(ReportingCrashWithJunitReporter ${TESTS_DIR}/X36-ReportingCrashWithJunitReporter.cpp)\n+target_link_libraries(ReportingCrashWithJunitReporter PRIVATE Catch2::Catch2WithMain)\n+add_test(\n+  NAME Reporters::CrashInJunitReporter\n+  COMMAND ${CMAKE_COMMAND} -E env $<TARGET_FILE:ReportingCrashWithJunitReporter> --reporter JUnit\n+)\n+set_tests_properties(\n+    Reporters::CrashInJunitReporter\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"</testsuites>\"\n+    LABELS \"uses-signals\"\n+)\n \n add_executable(AssertionStartingEventGoesBeforeAssertionIsEvaluated\n   X20-AssertionStartingEventGoesBeforeAssertionIsEvaluated.cpp\ndiff --git a/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp b/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp\n@@ -0,0 +1,32 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+/**\\file\n+ * Checks that signals/SEH within open section does not hard crash JUnit\n+ * (or similar reporter) while we are trying to report fatal error.\n+ */\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+#include <csignal>\n+\n+// On Windows we need to send SEH and not signal to test the\n+// RunContext::handleFatalErrorCondition code path\n+#if defined( _MSC_VER )\n+#    include <windows.h>\n+#endif\n+\n+TEST_CASE( \"raises signal\" ) {\n+    SECTION( \"section\" ) {\n+#if defined( _MSC_VER )\n+        RaiseException( 0xC0000005, 0, 0, NULL );\n+#else\n+        std::raise( SIGILL );\n+#endif\n+    }\n+}\ndiff --git a/tools/misc/appveyorTestRunScript.bat b/tools/misc/appveyorTestRunScript.bat\n--- a/tools/misc/appveyorTestRunScript.bat\n+++ b/tools/misc/appveyorTestRunScript.bat\n@@ -5,7 +5,7 @@ reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug\\AutoExclusion\n cd Build\n if \"%CONFIGURATION%\"==\"Debug\" (\n   if \"%coverage%\"==\"1\" (\n-    ctest -j 2 -C %CONFIGURATION% -D ExperimentalMemCheck || exit /b !ERRORLEVEL!\n+    ctest -j 2 -C %CONFIGURATION% -D ExperimentalMemCheck -LE uses-signals || exit /b !ERRORLEVEL!\n     python ..\\tools\\misc\\appveyorMergeCoverageScript.py || exit /b !ERRORLEVEL!\n     codecov --root .. --no-color --disable gcov -f cobertura.xml -t %CODECOV_TOKEN% || exit /b !ERRORLEVEL!\n   ) else (\n", "problem_statement": "virtual void Catch::CumulativeReporterBase::testCaseEnded(const Catch::TestCaseStats&):  Assertion `m_sectionStack.size() == 0' failed\n## Description\r\nI am getting this error sometimes in CI.\r\n```\r\ntestd: /build/agent-2/FAL-BS-JOB1/third-party/catch-1.9.3/catch.hpp:9611: \r\nvirtual void Catch::CumulativeReporterBase::testCaseEnded(const Catch::TestCaseStats&): \r\nAssertion `m_sectionStack.size() == 0' failed.\r\n```\r\nRerunning the job fixes the problem.  \r\n\r\nThis was mentioned in a comment to #663.\r\n\r\n### Extra information\r\n* Catch command line options: **-r junit -o testresults.xml**\r\n* Catch version: **v1.9.3**\r\n* Operating System: **RHEL 4.9**\r\n* Compiler+version: **g++ 5.3**\r\n\n", "hints_text": "This is happening almost all the time now\nDo you have a reliable repro, or is it still an intermittent thing? The JUnit reporter is ran multiple times on each commit and it doesn't reproduce with our tests, so it's hard to tell what is going on.\nI will work on a repro\nI'm using `-fno-exceptions` and see the same problem; this reproduces the problem for me:\r\na.cpp:\r\n```C++\r\n#define CATCH_CONFIG_MAIN\r\n#include \"catch2/catch.hpp\"\r\n\r\nTEST_CASE(\"doomed\", \"[tag]\") {\r\n\r\n  SECTION(\"only section\") {\r\n    REQUIRE(false);\r\n  }\r\n}\r\n```\r\n    > g++ --version\r\n    g++ (GCC) 7.3.0\r\n    Copyright (C) 2017 Free Software Foundation, Inc.\r\n    This is free software; see the source for copying conditions.  There is NO\r\n    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n    > g++ -fno-exceptions -I../Catch2/single_include a.cpp\r\n    > ./a.out -r junit\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    terminate called without an active exception\r\n    <testsuitesa.out: ../Catch2/single_include/catch2/catch.hpp:4463: void Catch::CumulativeReporterBase<DerivedT>::testCaseEnded(const Catch::TestCaseStats&) [with DerivedT = Catch::JunitReporter]: Assertion `m_sectionStack.size() == 0' failed.\r\n    Aborted (core dumped)\r\n\n@sd-x That's actually quite useful, thanks.\nSeeing this also in my CI sometimes.\r\n\nI'm seeing this pretty regularly, but not 100% consistently, on our windows builds. We don't have exceptions disabled or anything. Is the recommended workaround to stop using SECTIONs?\r\n\r\nfor reference, also using junit. seems to be a common factor in these reports.\nOur GitLab CI just ran into the same or a very similar issue, the exact assertion error in our case is\r\n```\r\nAssertion failed: m_sectionStack.size() == 0, file catch.hpp, line 5859\r\n```\r\n\r\nWe are also running on Windows and using the JUnit reporter. Catch version v2.11.1, MSVC 16.5. The issue disappeared after rerunning.\nProbably I found one possible scenario, why it could happen #1967 \r\n\nMy problem was that I was dividing by zero which crashed on my Linux CI but did not crash on my macOS dev machine. A working stacktrace from Catch would have saved me 30 minutes of printf debugging!\nI am not too familiar with catch internals but here is what I assume is happening\r\n\r\nIn `RunContext::handleFatalErrorCondition`, `handleUnfinishedSections()`  is called:\r\nhttps://github.com/catchorg/Catch2/blob/029fe3b4609dd84cd939b73357f37bbb75bcf82f/src/catch2/internal/catch_run_context.cpp#L453\r\n\r\nIf I understand it correctly, running Sections are in `m_activeSections`, and when a Section's destructor is called with an active exception, that Section is moved to `m_unfinishedSections`. `handleUnfinishedSections()` then handles those Sections in `m_unfinishedSections`. However, if a signal is being handled, we have not and will not call the destructors for the Sections, which means, all those Sections are in `m_activeSections` and not `m_unfinishedSections`.\r\n\r\nMy (potentially very dirty) fix is the following before the call to `handleUnfinishedSections()`:\r\n```c++\r\nwhile (!m_activeSections.empty()) {\r\n    auto nl = m_activeSections.back()->nameAndLocation();\r\n    SectionEndInfo endInfo{ SectionInfo(nl.location, nl.name), {}, 0.0 };\r\n    sectionEndedEarly(CATCH_MOVE(endInfo));\r\n}\r\nhandleUnfinishedSections();\r\n```\r\n\r\nI move the Sections from `m_activeSections` to `m_unfinishedSections` in a best effort way as to not trigger the assertion later.\r\n\r\nBtw, here is a test case that reproduces the issue for me (with `--reporter JUnit`):\r\n```c++\r\nTEST_CASE(\"broken\") {\r\n   SECTION(\"section\") {\r\n      /// Use illegal cpu instruction\r\n      __asm__ __volatile__(\"ud2\" : : : \"memory\");\r\n   }\r\n}\r\n```\r\n\r\n", "created_at": "2024-04-15T11:26:37Z", "version": "3.5"}
{"repo": "catchorg/Catch2", "pull_number": 1642, "instance_id": "catchorg__Catch2-1642", "issue_numbers": ["1627"], "base_commit": "b468d7cbff70291200294732c3795c53b5c502f6", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -259,6 +259,8 @@\n #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)\n+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n@@ -268,6 +270,8 @@\n #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -31,4 +31,8 @@ struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args..\n \n } // namespace Catch\n \n+namespace mpl_{\n+    struct na;\n+}\n+\n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -107,6 +107,8 @@\n     constexpr auto append(L1<E1...>, L2<E2...>) noexcept -> L1<E1...,E2...> { return {}; }\\\n     template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\\n     constexpr auto append(L1<E1...>, L2<E2...>, Rest...) noexcept -> decltype(append(L1<E1...,E2...>{}, Rest{}...)) { return {}; }\\\n+    template< template<typename...> class L1, typename...E1, typename...Rest>\\\n+    constexpr auto append(L1<E1...>, TypeList<mpl_::na>, Rest...) noexcept -> L1<E1...> { return {}; }\\\n     \\\n     template< template<typename...> class Container, template<typename...> class List, typename...elems>\\\n     constexpr auto rewrap(List<elems...>) noexcept -> TypeList<Container<elems...>> { return {}; }\\\n@@ -114,7 +116,9 @@\n     constexpr auto rewrap(List<Elems...>,Elements...) noexcept -> decltype(append(TypeList<Container<Elems...>>{}, rewrap<Container>(Elements{}...))) { return {}; }\\\n     \\\n     template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\\n-    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\\\n+    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\\\n+    constexpr auto convert(List<Ts...>) noexcept -> decltype(append(Final<>{},TypeList<Ts>{}...)) { return {}; }\n \n #define INTERNAL_CATCH_NTTP_1(signature, ...)\\\n     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\\\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -96,8 +96,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by types, in the form of `TEMPLATE_TEST_CASE` and\n-`TEMPLATE_PRODUCT_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE`,\n+`TEMPLATE_PRODUCT_TEST_CASE` and `TEMPLATE_LIST_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -192,6 +192,23 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+* **TEMPLATE_LIST_TEST_CASE(** _test name_, _tags_, _type list_ **)**\n+\n+_type list_ is a generic list of types on which test case should be instantiated.\n+List can be `std::tuple`, `boost::mpl::list`, `boost::mp11::mp_list` or anything with\n+`template <typename...>` signature.\n+\n+This allows you to reuse the _type list_ in multiple test cases.\n+\n+Example:\n+```cpp\n+using MyTypes = std::tuple<int, char, float>;\n+TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n+{\n+    REQUIRE(sizeof(TestType) > 0);\n+}\n+```\n+\n \n ## Signature based parametrised test cases\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -111,6 +111,19 @@ TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TE\n }\n ```\n \n+Catch2 also provides `TEMPLATE_LIST_TEST_CASE_METHOD` to support template fixtures with types specified in\n+template type lists like `std::tuple`, `boost::mpl::list` or `boost::mp11::mp_list`. This test case works the same as `TEMPLATE_TEST_CASE_METHOD`,\n+only difference is the source of types. This allows you to reuse the template type list in multiple test cases.\n+\n+Example:\n+```cpp\n+using MyTypes = std::tuple<int, char, double>;\n+TEMPLATE_LIST_TEST_CASE_METHOD(Template_Fixture, \"Template test case method with test types specified inside std::tuple\", \"[class][template][list]\", MyTypes)\n+{\n+    REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -232,6 +232,35 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> static void TestFunc();       \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+        INTERNAL_CATCH_TYPE_GEN\\\n+        template<typename... Types>                               \\\n+        struct TestName {                                         \\\n+            void reg_tests() {                                          \\\n+                int index = 0;                                    \\\n+                using expander = int[];                           \\\n+                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + \" - \" + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */\\\n+            }                                                     \\\n+        };\\\n+        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = decltype(convert<TestName>(TmplList {})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n+                return 0;                                             \\\n+            }();                                                        \\\n+        }}\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFunc()\n+\n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \\\n+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )\n+\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n@@ -327,5 +356,36 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+            void test();\\\n+        };\\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                void reg_tests(){\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + \" - \" + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = decltype(convert<TestNameClass>(TmplList {}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n+                return 0;\\\n+            }(); \\\n+        }}\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \\\n+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )\n+\n \n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -98,6 +98,12 @@ TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TE\n     REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n }\n \n+using MyTypes = std::tuple<int, char, double>;\n+TEMPLATE_LIST_TEST_CASE_METHOD(Template_Fixture, \"Template test case method with test types specified inside std::tuple\", \"[class][template][list]\", MyTypes)\n+{\n+    REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -365,6 +365,12 @@ TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\n \n+using MyTypes = std::tuple<int, char, float>;\n+TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n+{\n+    REQUIRE(sizeof(TestType) > 0);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\n", "problem_statement": "Support for generic typelists in TEMPLATE_TEST_CASE\n**Description**\r\nOften I already have a typelist of some kind (std::tuple, boost::mpl::list (Boost.MPL), mp_list (Boost.mp11)) and I want to execute a test for each of the types contained in the typelist. I have not yet found a good way to do this with catch2. In my case the types in those lists depend on the current platform and other settings so it is hard if not impossible to write them into the test case header.\r\n\r\nCurrently I am working around this by iterating over the type list in the test body and calling a separate template test method for each type. However, with this approach the type is not part of the test name and it is not easily possible to see which type triggered the error.\r\n\r\nTo enable this use-case, a new macro called `TEMPLATE_LIST_TEST_CASE` or similar would have to be added which internally adds a test case for each of the contained types.\r\nThis is supported by [Boost.Test](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/boost_test/tests_organization/test_cases/test_organization_templates.html) as well as [gtest](https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#typed-tests).\r\n\r\n**Additional context**\r\nExample pseudo code usage:\r\n```\r\nusing Types = std::tuple<int, double, float>;\r\nTEMPLATE_LIST_TEST_CASE(\"test\", \"[test]\", Types)\r\n{\r\n    // Do something with the TestType here which would be `int`, `double` or `float`\r\n}\r\nTEMPLATE_LIST_TEST_CASE(\"test2\", \"[test]\", Types)\r\n{\r\n    // This allows to reuse the typelist for multiple tests\r\n}\r\n```\r\n\n", "hints_text": "", "created_at": "2019-05-27T18:46:18Z", "version": "2.8"}
{"repo": "catchorg/Catch2", "pull_number": 1672, "instance_id": "catchorg__Catch2-1672", "issue_numbers": ["1671"], "base_commit": "6f32c67ea763ff189b55eeb24980ddc2522a80fb", "patch": "diff --git a/include/internal/catch_generators_generic.hpp b/include/internal/catch_generators_generic.hpp\n--- a/include/internal/catch_generators_generic.hpp\n+++ b/include/internal/catch_generators_generic.hpp\n@@ -205,12 +205,14 @@ namespace Generators {\n             m_chunk_size(size), m_generator(std::move(generator))\n         {\n             m_chunk.reserve(m_chunk_size);\n-            m_chunk.push_back(m_generator.get());\n-            for (size_t i = 1; i < m_chunk_size; ++i) {\n-                if (!m_generator.next()) {\n-                    Catch::throw_exception(GeneratorException(\"Not enough values to initialize the first chunk\"));\n-                }\n+            if (m_chunk_size != 0) {\n                 m_chunk.push_back(m_generator.get());\n+                for (size_t i = 1; i < m_chunk_size; ++i) {\n+                    if (!m_generator.next()) {\n+                        Catch::throw_exception(GeneratorException(\"Not enough values to initialize the first chunk\"));\n+                    }\n+                    m_chunk.push_back(m_generator.get());\n+                }\n             }\n         }\n         std::vector<T> const& get() const override {\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Generators.tests.cpp b/projects/SelfTest/UsageTests/Generators.tests.cpp\n--- a/projects/SelfTest/UsageTests/Generators.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Generators.tests.cpp\n@@ -167,6 +167,10 @@ TEST_CASE(\"Generators -- adapters\", \"[generators][generic]\") {\n             REQUIRE(chunk2.front() == chunk2.back());\n             REQUIRE(chunk2.front() < 3);\n         }\n+        SECTION(\"Chunk size of zero\") {\n+            auto chunk2 = GENERATE(take(3, chunk(0, value(1))));\n+            REQUIRE(chunk2.size() == 0);\n+        }\n         SECTION(\"Throws on too small generators\") {\n             using namespace Catch::Generators;\n             REQUIRE_THROWS_AS(chunk(2, value(1)), Catch::GeneratorException);\n", "problem_statement": "The first vector returned by ChunkGenerator is size 1 when chunk-size is 0\n**Describe the bug**\r\nWhen using `ChunkGenerator` with a chunk-size of 0, the first vector returned is size 1. Following vectors are size 0.\r\n\r\n**Expected behavior**\r\nThe first (and all following) vectors should be size 0.\r\n\r\n**Reproduction steps**\r\n```c++\r\nTEST_CASE(\"chunks\") {\r\n  auto vector = GENERATE(take(5, chunk(0, value(1))));\r\n  REQUIRE(vector.size() == 0);\r\n}\r\n```\r\n\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Linux 5.1.15-arch1-1-ARCH**\r\n - Compiler+version: **g++ (GCC) 9.1.0**\r\n - Catch version: **Catch v2.7.2** ([it looks like the bug still exists though](https://github.com/catchorg/Catch2/blob/54089c4c8c657ffb13d8f3a1425403335af5ba4d/include/internal/catch_generators_generic.hpp#L208-L209))\r\n\r\n\r\n**Additional context**\r\nMy specific use-case in which I ran into this is a test like this:\r\n\r\n```c++\r\nTEST_CASE(\"my function\") {\r\n  auto size = GENERATE(0, 1, 2, 3);\r\n  auto vector = GENERATE_COPY(take(1, chunk(size, random(-100, 100))));\r\n\r\n  auto list = VectorToList(vector);\r\n  \r\n  REQUIRE(list.size() == size);\r\n}\r\n```\r\n\r\nIt's possible that the intended behaviour was to return a minimum chunk-size of 1 for all chunks, but I think it would make much more sense to return empty vectors, otherwise the use-case above would be more annoying to write.\r\n\n", "hints_text": "", "created_at": "2019-06-29T13:50:00Z", "version": "2.9"}
{"repo": "catchorg/Catch2", "pull_number": 1684, "instance_id": "catchorg__Catch2-1684", "issue_numbers": ["1449", "1683"], "base_commit": "fb74bb133ccc8b1bbf932071f3db039861dea73a", "patch": "diff --git a/include/internal/catch_session.cpp b/include/internal/catch_session.cpp\n--- a/include/internal/catch_session.cpp\n+++ b/include/internal/catch_session.cpp\n@@ -25,6 +25,8 @@\n \n #include <cstdlib>\n #include <iomanip>\n+#include <set>\n+#include <iterator>\n \n namespace Catch {\n \n@@ -58,46 +60,53 @@ namespace Catch {\n             return ret;\n         }\n \n-\n-        Catch::Totals runTests(std::shared_ptr<Config> const& config) {\n-            auto reporter = makeReporter(config);\n-\n-            RunContext context(config, std::move(reporter));\n-\n-            Totals totals;\n-\n-            context.testGroupStarting(config->name(), 1, 1);\n-\n-            TestSpec testSpec = config->testSpec();\n-\n-            auto const& allTestCases = getAllTestCasesSorted(*config);\n-            for (auto const& testCase : allTestCases) {\n-                bool matching = (!testSpec.hasFilters() && !testCase.isHidden()) ||\n-                                 (testSpec.hasFilters() && matchTest(testCase, testSpec, *config));\n-\n-                if (!context.aborting() && matching)\n-                    totals += context.runTest(testCase);\n-                else\n-                    context.reporter().skipTest(testCase);\n+        class TestGroup {\n+        public:\n+            explicit TestGroup(std::shared_ptr<Config> const& config)\n+            : m_config{config}\n+            , m_context{config, makeReporter(config)}\n+            {\n+                auto const& allTestCases = getAllTestCasesSorted(*m_config);\n+                m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);\n+\n+                if (m_matches.empty()) {\n+                    for (auto const& test : allTestCases)\n+                        if (!test.isHidden())\n+                            m_tests.emplace(&test);\n+                } else {\n+                    for (auto const& match : m_matches)\n+                        m_tests.insert(match.tests.begin(), match.tests.end());\n+                }\n             }\n \n-            if (config->warnAboutNoTests() && totals.testCases.total() == 0) {\n-                ReusableStringStream testConfig;\n-\n-                bool first = true;\n-                for (const auto& input : config->getTestsOrTags()) {\n-                    if (!first) { testConfig << ' '; }\n-                    first = false;\n-                    testConfig << input;\n+            Totals execute() {\n+                Totals totals;\n+                m_context.testGroupStarting(m_config->name(), 1, 1);\n+                for (auto const& testCase : m_tests) {\n+                    if (!m_context.aborting())\n+                        totals += m_context.runTest(*testCase);\n+                    else\n+                        m_context.reporter().skipTest(*testCase);\n                 }\n \n-                context.reporter().noMatchingTestCases(testConfig.str());\n-                totals.error = -1;\n+                for (auto const& match : m_matches) {\n+                    if (match.tests.empty()) {\n+                        m_context.reporter().noMatchingTestCases(match.name);\n+                        totals.error = -1;\n+                    }\n+                }\n+                m_context.testGroupEnded(m_config->name(), totals, 1, 1);\n+                return totals;\n             }\n \n-            context.testGroupEnded(config->name(), totals, 1, 1);\n-            return totals;\n-        }\n+        private:\n+            using Tests = std::set<TestCase const*>;\n+\n+            std::shared_ptr<Config> m_config;\n+            RunContext m_context;\n+            Tests m_tests;\n+            TestSpec::Matches m_matches;\n+        };\n \n         void applyFilenamesAsTags(Catch::IConfig const& config) {\n             auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\n@@ -274,7 +283,12 @@ namespace Catch {\n             if( Option<std::size_t> listed = list( m_config ) )\n                 return static_cast<int>( *listed );\n \n-            auto totals = runTests( m_config );\n+            TestGroup tests { m_config };\n+            auto const totals = tests.execute();\n+\n+            if( m_config->warnAboutNoTests() && totals.error == -1 )\n+                return 2;\n+\n             // Note that on unices only the lower 8 bits are usually used, clamping\n             // the return value to 255 prevents false negative when some multiple\n             // of 256 tests has failed\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -393,8 +393,19 @@ set_tests_properties(ListTestNamesOnly PROPERTIES\n add_test(NAME NoAssertions COMMAND $<TARGET_FILE:SelfTest> -w NoAssertions)\n set_tests_properties(NoAssertions PROPERTIES PASS_REGULAR_EXPRESSION \"No assertions in test case\")\n \n-add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> -w NoTests \"___nonexistent_test___\")\n-set_tests_properties(NoTest PROPERTIES PASS_REGULAR_EXPRESSION \"No test cases matched\")\n+add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> Tracker, \"___nonexistent_test___\")\n+set_tests_properties(NoTest PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"No test cases matched '___nonexistent_test___'\"\n+    FAIL_REGULAR_EXPRESSION \"No tests ran\"\n+)\n+\n+add_test(NAME WarnAboutNoTests COMMAND ${CMAKE_COMMAND} -P ${CATCH_DIR}/projects/SelfTest/WarnAboutNoTests.cmake $<TARGET_FILE:SelfTest>)\n+\n+add_test(NAME UnmatchedOutputFilter COMMAND $<TARGET_FILE:SelfTest> [this-tag-does-not-exist] -w NoTests)\n+set_tests_properties(UnmatchedOutputFilter\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"No test cases matched '\\\\[this-tag-does-not-exist\\\\]'\"\n+)\n \n add_test(NAME FilteredSection-1 COMMAND $<TARGET_FILE:SelfTest> \\#1394 -c RunSection)\n set_tests_properties(FilteredSection-1 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n", "test_patch": "diff --git a/include/internal/catch_interfaces_testcase.h b/include/internal/catch_interfaces_testcase.h\n--- a/include/internal/catch_interfaces_testcase.h\n+++ b/include/internal/catch_interfaces_testcase.h\n@@ -28,6 +28,7 @@ namespace Catch {\n         virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;\n     };\n \n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n     std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );\n     std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );\ndiff --git a/include/internal/catch_test_case_registry_impl.cpp b/include/internal/catch_test_case_registry_impl.cpp\n--- a/include/internal/catch_test_case_registry_impl.cpp\n+++ b/include/internal/catch_test_case_registry_impl.cpp\n@@ -36,8 +36,13 @@ namespace Catch {\n         }\n         return sorted;\n     }\n+\n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config ) {\n+        return !testCase.throws() || config.allowThrows();\n+    }\n+\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {\n-        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );\n+        return testSpec.matches( testCase ) && isThrowSafe( testCase, config );\n     }\n \n     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {\ndiff --git a/include/internal/catch_test_case_registry_impl.h b/include/internal/catch_test_case_registry_impl.h\n--- a/include/internal/catch_test_case_registry_impl.h\n+++ b/include/internal/catch_test_case_registry_impl.h\n@@ -23,6 +23,8 @@ namespace Catch {\n     struct IConfig;\n \n     std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );\n+\n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n \n     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );\ndiff --git a/include/internal/catch_test_spec.cpp b/include/internal/catch_test_spec.cpp\n--- a/include/internal/catch_test_spec.cpp\n+++ b/include/internal/catch_test_spec.cpp\n@@ -7,6 +7,7 @@\n \n #include \"catch_test_spec.h\"\n #include \"catch_string_manip.h\"\n+#include \"catch_interfaces_config.h\"\n \n #include <algorithm>\n #include <string>\n@@ -15,45 +16,80 @@\n \n namespace Catch {\n \n+    TestSpec::Pattern::Pattern( std::string const& name )\n+    : m_name( name )\n+    {}\n+\n     TestSpec::Pattern::~Pattern() = default;\n-    TestSpec::NamePattern::~NamePattern() = default;\n-    TestSpec::TagPattern::~TagPattern() = default;\n-    TestSpec::ExcludedPattern::~ExcludedPattern() = default;\n \n-    TestSpec::NamePattern::NamePattern( std::string const& name )\n-    : m_wildcardPattern( toLower( name ), CaseSensitive::No )\n+    std::string const& TestSpec::Pattern::name() const {\n+        return m_name;\n+    }\n+\n+\n+    TestSpec::NamePattern::NamePattern( std::string const& name, std::string const& filterString )\n+    : Pattern( filterString )\n+    , m_wildcardPattern( toLower( name ), CaseSensitive::No )\n     {}\n+\n     bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {\n         return m_wildcardPattern.matches( toLower( testCase.name ) );\n     }\n \n-    TestSpec::TagPattern::TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}\n+\n+    TestSpec::TagPattern::TagPattern( std::string const& tag, std::string const& filterString )\n+    : Pattern( filterString )\n+    , m_tag( toLower( tag ) )\n+    {}\n+\n     bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {\n         return std::find(begin(testCase.lcaseTags),\n                          end(testCase.lcaseTags),\n                          m_tag) != end(testCase.lcaseTags);\n     }\n \n-    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}\n-    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }\n+\n+    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern )\n+    : Pattern( underlyingPattern->name() )\n+    , m_underlyingPattern( underlyingPattern )\n+    {}\n+\n+    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const {\n+        return !m_underlyingPattern->matches( testCase );\n+    }\n+\n \n     bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {\n-        // All patterns in a filter must match for the filter to be a match\n-        for( auto const& pattern : m_patterns ) {\n-            if( !pattern->matches( testCase ) )\n-                return false;\n-        }\n-        return true;\n+        return std::all_of( m_patterns.begin(), m_patterns.end(), [&]( PatternPtr const& p ){ return p->matches( testCase ); } );\n+    }\n+\n+    std::string TestSpec::Filter::name() const {\n+        std::string name;\n+        for( auto const& p : m_patterns )\n+            name += p->name();\n+        return name;\n     }\n \n+\n     bool TestSpec::hasFilters() const {\n         return !m_filters.empty();\n     }\n+\n     bool TestSpec::matches( TestCaseInfo const& testCase ) const {\n-        // A TestSpec matches if any filter matches\n-        for( auto const& filter : m_filters )\n-            if( filter.matches( testCase ) )\n-                return true;\n-        return false;\n+        return std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter const& f ){ return f.matches( testCase ); } );\n     }\n+\n+    TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const\n+    {\n+        Matches matches( m_filters.size() );\n+        std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&]( Filter const& filter ){\n+            std::vector<TestCase const*> currentMatches;\n+            for( auto const& test : testCases )\n+                if( isThrowSafe( test, config ) && filter.matches( test ) )\n+                    currentMatches.emplace_back( &test );\n+            return FilterMatch{ filter.name(), currentMatches };\n+        } );\n+        return matches;\n+    }\n+\n }\ndiff --git a/include/internal/catch_test_spec.h b/include/internal/catch_test_spec.h\n--- a/include/internal/catch_test_spec.h\n+++ b/include/internal/catch_test_spec.h\n@@ -22,17 +22,23 @@\n \n namespace Catch {\n \n+    struct IConfig;\n+\n     class TestSpec {\n-        struct Pattern {\n+        class Pattern {\n+        public:\n+            explicit Pattern( std::string const& name );\n             virtual ~Pattern();\n             virtual bool matches( TestCaseInfo const& testCase ) const = 0;\n+            std::string const& name() const;\n+        private:\n+            std::string const m_name;\n         };\n         using PatternPtr = std::shared_ptr<Pattern>;\n \n         class NamePattern : public Pattern {\n         public:\n-            NamePattern( std::string const& name );\n-            virtual ~NamePattern();\n+            explicit NamePattern( std::string const& name, std::string const& filterString );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             WildcardPattern m_wildcardPattern;\n@@ -40,8 +46,7 @@ namespace Catch {\n \n         class TagPattern : public Pattern {\n         public:\n-            TagPattern( std::string const& tag );\n-            virtual ~TagPattern();\n+            explicit TagPattern( std::string const& tag, std::string const& filterString );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             std::string m_tag;\n@@ -49,8 +54,7 @@ namespace Catch {\n \n         class ExcludedPattern : public Pattern {\n         public:\n-            ExcludedPattern( PatternPtr const& underlyingPattern );\n-            virtual ~ExcludedPattern();\n+            explicit ExcludedPattern( PatternPtr const& underlyingPattern );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             PatternPtr m_underlyingPattern;\n@@ -60,11 +64,19 @@ namespace Catch {\n             std::vector<PatternPtr> m_patterns;\n \n             bool matches( TestCaseInfo const& testCase ) const;\n+            std::string name() const;\n         };\n \n     public:\n+        struct FilterMatch {\n+            std::string name;\n+            std::vector<TestCase const*> tests;\n+        };\n+        using Matches = std::vector<FilterMatch>;\n+\n         bool hasFilters() const;\n         bool matches( TestCaseInfo const& testCase ) const;\n+        Matches matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const;\n \n     private:\n         std::vector<Filter> m_filters;\ndiff --git a/include/internal/catch_test_spec_parser.cpp b/include/internal/catch_test_spec_parser.cpp\n--- a/include/internal/catch_test_spec_parser.cpp\n+++ b/include/internal/catch_test_spec_parser.cpp\n@@ -14,64 +14,125 @@ namespace Catch {\n     TestSpecParser& TestSpecParser::parse( std::string const& arg ) {\n         m_mode = None;\n         m_exclusion = false;\n-        m_start = std::string::npos;\n         m_arg = m_tagAliases->expandAliases( arg );\n         m_escapeChars.clear();\n+        m_substring.reserve(m_arg.size());\n+        m_patternName.reserve(m_arg.size());\n         for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n             visitChar( m_arg[m_pos] );\n-        if( m_mode == Name )\n-            addPattern<TestSpec::NamePattern>();\n+        endMode();\n         return *this;\n     }\n     TestSpec TestSpecParser::testSpec() {\n         addFilter();\n         return m_testSpec;\n     }\n-\n     void TestSpecParser::visitChar( char c ) {\n-        if( m_mode == None ) {\n-            switch( c ) {\n-            case ' ': return;\n-            case '~': m_exclusion = true; return;\n-            case '[': return startNewMode( Tag, ++m_pos );\n-            case '\"': return startNewMode( QuotedName, ++m_pos );\n-            case '\\\\': return escape();\n-            default: startNewMode( Name, m_pos ); break;\n-            }\n+        if( c == ',' ) {\n+            endMode();\n+            addFilter();\n+            return;\n+        }\n+\n+        switch( m_mode ) {\n+        case None:\n+            if( processNoneChar( c ) )\n+                return;\n+            break;\n+        case Name:\n+            processNameChar( c );\n+            break;\n+        case EscapedName:\n+            endMode();\n+            break;\n+        default:\n+        case Tag:\n+        case QuotedName:\n+            if( processOtherChar( c ) )\n+                return;\n+            break;\n+        }\n+\n+        m_substring += c;\n+        if( !isControlChar( c ) )\n+            m_patternName += c;\n+    }\n+    // Two of the processing methods return true to signal the caller to return\n+    // without adding the given character to the current pattern strings\n+    bool TestSpecParser::processNoneChar( char c ) {\n+        switch( c ) {\n+        case ' ':\n+            return true;\n+        case '~':\n+            m_exclusion = true;\n+            return false;\n+        case '[':\n+            startNewMode( Tag );\n+            return false;\n+        case '\"':\n+            startNewMode( QuotedName );\n+            return false;\n+        case '\\\\':\n+            escape();\n+            return true;\n+        default:\n+            startNewMode( Name );\n+            return false;\n         }\n-        if( m_mode == Name ) {\n-            if( c == ',' ) {\n-                addPattern<TestSpec::NamePattern>();\n-                addFilter();\n-            }\n-            else if( c == '[' ) {\n-                if( subString() == \"exclude:\" )\n-                    m_exclusion = true;\n-                else\n-                    addPattern<TestSpec::NamePattern>();\n-                startNewMode( Tag, ++m_pos );\n-            }\n-            else if( c == '\\\\' )\n-                escape();\n+    }\n+    void TestSpecParser::processNameChar( char c ) {\n+        if( c == '[' ) {\n+            if( m_substring == \"exclude:\" )\n+                m_exclusion = true;\n+            else\n+                endMode();\n+            startNewMode( Tag );\n         }\n-        else if( m_mode == EscapedName )\n-            m_mode = Name;\n-        else if( m_mode == QuotedName && c == '\"' )\n-            addPattern<TestSpec::NamePattern>();\n-        else if( m_mode == Tag && c == ']' )\n-            addPattern<TestSpec::TagPattern>();\n     }\n-    void TestSpecParser::startNewMode( Mode mode, std::size_t start ) {\n+    bool TestSpecParser::processOtherChar( char c ) {\n+        if( !isControlChar( c ) )\n+            return false;\n+        m_substring += c;\n+        endMode();\n+        return true;\n+    }\n+    void TestSpecParser::startNewMode( Mode mode ) {\n         m_mode = mode;\n-        m_start = start;\n+    }\n+    void TestSpecParser::endMode() {\n+        switch( m_mode ) {\n+        case Name:\n+        case QuotedName:\n+            return addPattern<TestSpec::NamePattern>();\n+        case Tag:\n+            return addPattern<TestSpec::TagPattern>();\n+        case EscapedName:\n+            return startNewMode( Name );\n+        case None:\n+        default:\n+            return startNewMode( None );\n+        }\n     }\n     void TestSpecParser::escape() {\n-        if( m_mode == None )\n-            m_start = m_pos;\n         m_mode = EscapedName;\n         m_escapeChars.push_back( m_pos );\n     }\n-    std::string TestSpecParser::subString() const { return m_arg.substr( m_start, m_pos - m_start ); }\n+    bool TestSpecParser::isControlChar( char c ) const {\n+        switch( m_mode ) {\n+            default:\n+                return false;\n+            case None:\n+                return c == '~';\n+            case Name:\n+                return c == '[';\n+            case EscapedName:\n+                return true;\n+            case QuotedName:\n+                return c == '\"';\n+            case Tag:\n+                return c == '[' || c == ']';\n+        }\n+    }\n \n     void TestSpecParser::addFilter() {\n         if( !m_currentFilter.m_patterns.empty() ) {\ndiff --git a/include/internal/catch_test_spec_parser.h b/include/internal/catch_test_spec_parser.h\n--- a/include/internal/catch_test_spec_parser.h\n+++ b/include/internal/catch_test_spec_parser.h\n@@ -23,8 +23,10 @@ namespace Catch {\n         enum Mode{ None, Name, QuotedName, Tag, EscapedName };\n         Mode m_mode = None;\n         bool m_exclusion = false;\n-        std::size_t m_start = std::string::npos, m_pos = 0;\n+        std::size_t m_pos = 0;\n         std::string m_arg;\n+        std::string m_substring;\n+        std::string m_patternName;\n         std::vector<std::size_t> m_escapeChars;\n         TestSpec::Filter m_currentFilter;\n         TestSpec m_testSpec;\n@@ -38,26 +40,32 @@ namespace Catch {\n \n     private:\n         void visitChar( char c );\n-        void startNewMode( Mode mode, std::size_t start );\n+        void startNewMode( Mode mode );\n+        bool processNoneChar( char c );\n+        void processNameChar( char c );\n+        bool processOtherChar( char c );\n+        void endMode();\n         void escape();\n-        std::string subString() const;\n+        bool isControlChar( char c ) const;\n \n         template<typename T>\n         void addPattern() {\n-            std::string token = subString();\n+            std::string token = m_patternName;\n             for( std::size_t i = 0; i < m_escapeChars.size(); ++i )\n-                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\n+                token = token.substr( 0, m_escapeChars[i] - i ) + token.substr( m_escapeChars[i] -i +1 );\n             m_escapeChars.clear();\n             if( startsWith( token, \"exclude:\" ) ) {\n                 m_exclusion = true;\n                 token = token.substr( 8 );\n             }\n             if( !token.empty() ) {\n-                TestSpec::PatternPtr pattern = std::make_shared<T>( token );\n+                TestSpec::PatternPtr pattern = std::make_shared<T>( token, m_substring );\n                 if( m_exclusion )\n                     pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );\n                 m_currentFilter.m_patterns.push_back( pattern );\n             }\n+            m_substring.clear();\n+            m_patternName.clear();\n             m_exclusion = false;\n             m_mode = None;\n         }\ndiff --git a/projects/SelfTest/WarnAboutNoTests.cmake b/projects/SelfTest/WarnAboutNoTests.cmake\nnew file mode 100644\n--- /dev/null\n+++ b/projects/SelfTest/WarnAboutNoTests.cmake\n@@ -0,0 +1,19 @@\n+# Workaround for a peculiarity where CTest disregards the return code from a\n+# test command if a PASS_REGULAR_EXPRESSION is also set\n+execute_process(\n+    COMMAND ${CMAKE_ARGV3} -w NoTests \"___nonexistent_test___\"\n+    RESULT_VARIABLE ret\n+    OUTPUT_VARIABLE out\n+)\n+\n+message(\"${out}\")\n+\n+if(NOT ${ret} MATCHES \"^[0-9]+$\")\n+    message(FATAL_ERROR \"${ret}\")\n+endif()\n+\n+if(${ret} EQUAL 0)\n+    message(FATAL_ERROR \"Expected nonzero return code\")\n+elseif(${out} MATCHES \"Helper failed with\")\n+    message(FATAL_ERROR \"Helper failed\")\n+endif()\n", "problem_statement": "Catch2 does not report unmatched parts of a partially-matched test spec\n## Description\r\nCatch2's runTests function calls the reporter's noMatchingTestCases if *no* tests match the spec, but if some test matches some part of the spec, nothing reports that the rest of the spec matched nothing. In other words, if I pass \"Test1 Test2\" as command-line args, and \"Test1\" matches some test, nothing complains about the fact that \"Test2\" matched nothing. This can lead the user to believe that they're running all the tests in the spec when they are not.\r\n\r\n### Steps to reproduce\r\nCreate a test file with one test. Run it with command-line args that specify two tests: the existing test and\r\nsome other, non-existent test. Everything will be green and happy, with no indication that the second test was not found.\r\n\r\n### Extra information\r\n* Catch version: **v2.4.1**\r\n* Operating System: **Windows 10**\r\n* Compiler+version: **MS VS 2015**\r\n\n-w NoTests should give non-zero status\ndocs/command-line.md says \"NoTests        // Return non-zero exit code when no test cases were run\" but I see a status of zero being returned instead of non-zero\r\n\r\nmy_bug.cpp:\r\n```#define CATCH_CONFIG_MAIN\r\n#include \"catch2/catch.hpp\"\r\n\r\nTEST_CASE(\"my case\", \"[foo]\") {\r\n  SECTION(\"my section\") {\r\n    CHECK(1);\r\n  }\r\n}\r\n```\r\n```\r\n> g++ -o my_bug my_bug.cpp -I ...\r\n> ./my_bug -w NoTests '[x]'\r\nFilters: [x]\r\nNo test cases matched '[x]'\r\n===============================================================================\r\nNo tests ran\r\n\r\nstatus=0\r\n```\r\n\r\nI expected a non-zero status.\r\n\r\n**Platform information:**\r\n - OS: **Linux CentOS 6**\r\n - Compiler+version: **GCC v7.3.0**\r\n - Catch version: **v2.9.1**\r\n\n", "hints_text": "This is actually true even if you run with just \"test2\". That is, you are told _\"No tests ran\"_, but the test calls `exit(0)`. So to my script it looks like everything ran as expected.\r\n\r\nI think that:\r\n\r\n1. It should report errors for any spec. which does not have a match; and\r\n2. If any such error is found, the test should return 1 (i.e. `exit(1)`) so my scripts break as expected on errors.\nYou're right. The main issue can be fixed with some changes to the test case filtering mechanism. As for the exit code issue, going by the documentation, the command-line option `-w NoTests` *should* do what @AlexisWilke wants, but the code does not seem to respect it. This is also easy to fix. I'll have a go at it soon.\n", "created_at": "2019-07-09T21:09:26Z", "version": "2.9"}
{"repo": "catchorg/Catch2", "pull_number": 2849, "instance_id": "catchorg__Catch2-2849", "issue_numbers": ["2833"], "base_commit": "7ce35799767de7b9c6ba836c72e479c5f70219a3", "patch": "diff --git a/src/catch2/internal/catch_textflow.cpp b/src/catch2/internal/catch_textflow.cpp\n--- a/src/catch2/internal/catch_textflow.cpp\n+++ b/src/catch2/internal/catch_textflow.cpp\n@@ -26,117 +26,228 @@ namespace {\n         return std::memchr( chars, c, sizeof( chars ) - 1 ) != nullptr;\n     }\n \n-    bool isBoundary( std::string const& line, size_t at ) {\n-        assert( at > 0 );\n-        assert( at <= line.size() );\n-\n-        return at == line.size() ||\n-               ( isWhitespace( line[at] ) && !isWhitespace( line[at - 1] ) ) ||\n-               isBreakableBefore( line[at] ) ||\n-               isBreakableAfter( line[at - 1] );\n-    }\n-\n } // namespace\n \n namespace Catch {\n     namespace TextFlow {\n+        void AnsiSkippingString::preprocessString() {\n+            for ( auto it = m_string.begin(); it != m_string.end(); ) {\n+                // try to read through an ansi sequence\n+                while ( it != m_string.end() && *it == '\\033' &&\n+                        it + 1 != m_string.end() && *( it + 1 ) == '[' ) {\n+                    auto cursor = it + 2;\n+                    while ( cursor != m_string.end() &&\n+                            ( isdigit( *cursor ) || *cursor == ';' ) ) {\n+                        ++cursor;\n+                    }\n+                    if ( cursor == m_string.end() || *cursor != 'm' ) {\n+                        break;\n+                    }\n+                    // 'm' -> 0xff\n+                    *cursor = AnsiSkippingString::sentinel;\n+                    // if we've read an ansi sequence, set the iterator and\n+                    // return to the top of the loop\n+                    it = cursor + 1;\n+                }\n+                if ( it != m_string.end() ) {\n+                    ++m_size;\n+                    ++it;\n+                }\n+            }\n+        }\n+\n+        AnsiSkippingString::AnsiSkippingString( std::string const& text ):\n+            m_string( text ) {\n+            preprocessString();\n+        }\n+\n+        AnsiSkippingString::AnsiSkippingString( std::string&& text ):\n+            m_string( CATCH_MOVE( text ) ) {\n+            preprocessString();\n+        }\n+\n+        AnsiSkippingString::const_iterator AnsiSkippingString::begin() const {\n+            return const_iterator( m_string );\n+        }\n+\n+        AnsiSkippingString::const_iterator AnsiSkippingString::end() const {\n+            return const_iterator( m_string, const_iterator::EndTag{} );\n+        }\n+\n+        std::string AnsiSkippingString::substring( const_iterator begin,\n+                                                   const_iterator end ) const {\n+            // There's one caveat here to an otherwise simple substring: when\n+            // making a begin iterator we might have skipped ansi sequences at\n+            // the start. If `begin` here is a begin iterator, skipped over\n+            // initial ansi sequences, we'll use the true beginning of the\n+            // string. Lastly: We need to transform any chars we replaced with\n+            // 0xff back to 'm'\n+            auto str = std::string( begin == this->begin() ? m_string.begin()\n+                                                           : begin.m_it,\n+                                    end.m_it );\n+            std::transform( str.begin(), str.end(), str.begin(), []( char c ) {\n+                return c == AnsiSkippingString::sentinel ? 'm' : c;\n+            } );\n+            return str;\n+        }\n+\n+        void AnsiSkippingString::const_iterator::tryParseAnsiEscapes() {\n+            // check if we've landed on an ansi sequence, and if so read through\n+            // it\n+            while ( m_it != m_string->end() && *m_it == '\\033' &&\n+                    m_it + 1 != m_string->end() &&  *( m_it + 1 ) == '[' ) {\n+                auto cursor = m_it + 2;\n+                while ( cursor != m_string->end() &&\n+                        ( isdigit( *cursor ) || *cursor == ';' ) ) {\n+                    ++cursor;\n+                }\n+                if ( cursor == m_string->end() ||\n+                     *cursor != AnsiSkippingString::sentinel ) {\n+                    break;\n+                }\n+                // if we've read an ansi sequence, set the iterator and\n+                // return to the top of the loop\n+                m_it = cursor + 1;\n+            }\n+        }\n+\n+        void AnsiSkippingString::const_iterator::advance() {\n+            assert( m_it != m_string->end() );\n+            m_it++;\n+            tryParseAnsiEscapes();\n+        }\n+\n+        void AnsiSkippingString::const_iterator::unadvance() {\n+            assert( m_it != m_string->begin() );\n+            m_it--;\n+            // if *m_it is 0xff, scan back to the \\033 and then m_it-- once more\n+            // (and repeat check)\n+            while ( *m_it == AnsiSkippingString::sentinel ) {\n+                while ( *m_it != '\\033' ) {\n+                    assert( m_it != m_string->begin() );\n+                    m_it--;\n+                }\n+                // if this happens, we must have been a begin iterator that had\n+                // skipped over ansi sequences at the start of a string\n+                assert( m_it != m_string->begin() );\n+                assert( *m_it == '\\033' );\n+                m_it--;\n+            }\n+        }\n+\n+        static bool isBoundary( AnsiSkippingString const& line,\n+                                AnsiSkippingString::const_iterator it ) {\n+            return it == line.end() ||\n+                   ( isWhitespace( *it ) &&\n+                     !isWhitespace( *it.oneBefore() ) ) ||\n+                   isBreakableBefore( *it ) ||\n+                   isBreakableAfter( *it.oneBefore() );\n+        }\n \n         void Column::const_iterator::calcLength() {\n             m_addHyphen = false;\n             m_parsedTo = m_lineStart;\n+            AnsiSkippingString const& current_line = m_column.m_string;\n \n-            std::string const& current_line = m_column.m_string;\n-            if ( current_line[m_lineStart] == '\\n' ) {\n-                ++m_parsedTo;\n+            if ( m_parsedTo == current_line.end() ) {\n+                m_lineEnd = m_parsedTo;\n+                return;\n             }\n \n+            assert( m_lineStart != current_line.end() );\n+            if ( *m_lineStart == '\\n' ) { ++m_parsedTo; }\n+\n             const auto maxLineLength = m_column.m_width - indentSize();\n-            const auto maxParseTo = std::min(current_line.size(), m_lineStart + maxLineLength);\n-            while ( m_parsedTo < maxParseTo &&\n-                    current_line[m_parsedTo] != '\\n' ) {\n+            std::size_t lineLength = 0;\n+            while ( m_parsedTo != current_line.end() &&\n+                    lineLength < maxLineLength && *m_parsedTo != '\\n' ) {\n                 ++m_parsedTo;\n+                ++lineLength;\n             }\n \n             // If we encountered a newline before the column is filled,\n             // then we linebreak at the newline and consider this line\n             // finished.\n-            if ( m_parsedTo < m_lineStart + maxLineLength ) {\n-                m_lineLength = m_parsedTo - m_lineStart;\n+            if ( lineLength < maxLineLength ) {\n+                m_lineEnd = m_parsedTo;\n             } else {\n                 // Look for a natural linebreak boundary in the column\n                 // (We look from the end, so that the first found boundary is\n                 // the right one)\n-                size_t newLineLength = maxLineLength;\n-                while ( newLineLength > 0 && !isBoundary( current_line, m_lineStart + newLineLength ) ) {\n-                    --newLineLength;\n+                m_lineEnd = m_parsedTo;\n+                while ( lineLength > 0 &&\n+                        !isBoundary( current_line, m_lineEnd ) ) {\n+                    --lineLength;\n+                    --m_lineEnd;\n                 }\n-                while ( newLineLength > 0 &&\n-                        isWhitespace( current_line[m_lineStart + newLineLength - 1] ) ) {\n-                    --newLineLength;\n+                while ( lineLength > 0 &&\n+                        isWhitespace( *m_lineEnd.oneBefore() ) ) {\n+                    --lineLength;\n+                    --m_lineEnd;\n                 }\n \n-                // If we found one, then that is where we linebreak\n-                if ( newLineLength > 0 ) {\n-                    m_lineLength = newLineLength;\n-                } else {\n-                    // Otherwise we have to split text with a hyphen\n+                // If we found one, then that is where we linebreak, otherwise\n+                // we have to split text with a hyphen\n+                if ( lineLength == 0 ) {\n                     m_addHyphen = true;\n-                    m_lineLength = maxLineLength - 1;\n+                    m_lineEnd = m_parsedTo.oneBefore();\n                 }\n             }\n         }\n \n         size_t Column::const_iterator::indentSize() const {\n-            auto initial =\n-                m_lineStart == 0 ? m_column.m_initialIndent : std::string::npos;\n+            auto initial = m_lineStart == m_column.m_string.begin()\n+                               ? m_column.m_initialIndent\n+                               : std::string::npos;\n             return initial == std::string::npos ? m_column.m_indent : initial;\n         }\n \n-        std::string\n-        Column::const_iterator::addIndentAndSuffix( size_t position,\n-                                              size_t length ) const {\n+        std::string Column::const_iterator::addIndentAndSuffix(\n+            AnsiSkippingString::const_iterator start,\n+            AnsiSkippingString::const_iterator end ) const {\n             std::string ret;\n             const auto desired_indent = indentSize();\n-            ret.reserve( desired_indent + length + m_addHyphen );\n+            // ret.reserve( desired_indent + (end - start) + m_addHyphen );\n             ret.append( desired_indent, ' ' );\n-            ret.append( m_column.m_string, position, length );\n-            if ( m_addHyphen ) {\n-                ret.push_back( '-' );\n-            }\n+            // ret.append( start, end );\n+            ret += m_column.m_string.substring( start, end );\n+            if ( m_addHyphen ) { ret.push_back( '-' ); }\n \n             return ret;\n         }\n \n-        Column::const_iterator::const_iterator( Column const& column ): m_column( column ) {\n+        Column::const_iterator::const_iterator( Column const& column ):\n+            m_column( column ),\n+            m_lineStart( column.m_string.begin() ),\n+            m_lineEnd( column.m_string.begin() ),\n+            m_parsedTo( column.m_string.begin() ) {\n             assert( m_column.m_width > m_column.m_indent );\n             assert( m_column.m_initialIndent == std::string::npos ||\n                     m_column.m_width > m_column.m_initialIndent );\n             calcLength();\n-            if ( m_lineLength == 0 ) {\n-                m_lineStart = m_column.m_string.size();\n+            if ( m_lineStart == m_lineEnd ) {\n+                m_lineStart = m_column.m_string.end();\n             }\n         }\n \n         std::string Column::const_iterator::operator*() const {\n             assert( m_lineStart <= m_parsedTo );\n-            return addIndentAndSuffix( m_lineStart, m_lineLength );\n+            return addIndentAndSuffix( m_lineStart, m_lineEnd );\n         }\n \n         Column::const_iterator& Column::const_iterator::operator++() {\n-            m_lineStart += m_lineLength;\n-            std::string const& current_line = m_column.m_string;\n-            if ( m_lineStart < current_line.size() && current_line[m_lineStart] == '\\n' ) {\n-                m_lineStart += 1;\n+            m_lineStart = m_lineEnd;\n+            AnsiSkippingString const& current_line = m_column.m_string;\n+            if ( m_lineStart != current_line.end() && *m_lineStart == '\\n' ) {\n+                m_lineStart++;\n             } else {\n-                while ( m_lineStart < current_line.size() &&\n-                        isWhitespace( current_line[m_lineStart] ) ) {\n+                while ( m_lineStart != current_line.end() &&\n+                        isWhitespace( *m_lineStart ) ) {\n                     ++m_lineStart;\n                 }\n             }\n \n-            if ( m_lineStart != current_line.size() ) {\n-                calcLength();\n-            }\n+            if ( m_lineStart != current_line.end() ) { calcLength(); }\n             return *this;\n         }\n \n@@ -233,25 +344,25 @@ namespace Catch {\n             return os;\n         }\n \n-        Columns operator+(Column const& lhs, Column const& rhs) {\n+        Columns operator+( Column const& lhs, Column const& rhs ) {\n             Columns cols;\n             cols += lhs;\n             cols += rhs;\n             return cols;\n         }\n-        Columns operator+(Column&& lhs, Column&& rhs) {\n+        Columns operator+( Column&& lhs, Column&& rhs ) {\n             Columns cols;\n             cols += CATCH_MOVE( lhs );\n             cols += CATCH_MOVE( rhs );\n             return cols;\n         }\n \n-        Columns& operator+=(Columns& lhs, Column const& rhs) {\n+        Columns& operator+=( Columns& lhs, Column const& rhs ) {\n             lhs.m_columns.push_back( rhs );\n             return lhs;\n         }\n-        Columns& operator+=(Columns& lhs, Column&& rhs) {\n-            lhs.m_columns.push_back( CATCH_MOVE(rhs) );\n+        Columns& operator+=( Columns& lhs, Column&& rhs ) {\n+            lhs.m_columns.push_back( CATCH_MOVE( rhs ) );\n             return lhs;\n         }\n         Columns operator+( Columns const& lhs, Column const& rhs ) {\ndiff --git a/src/catch2/internal/catch_textflow.hpp b/src/catch2/internal/catch_textflow.hpp\n--- a/src/catch2/internal/catch_textflow.hpp\n+++ b/src/catch2/internal/catch_textflow.hpp\n@@ -20,6 +20,107 @@ namespace Catch {\n \n         class Columns;\n \n+        /**\n+         * Abstraction for a string with ansi escape sequences that\n+         * automatically skips over escapes when iterating. Only graphical\n+         * escape sequences are considered.\n+         *\n+         * Internal representation:\n+         * An escape sequence looks like \\033[39;49m\n+         * We need bidirectional iteration and the unbound length of escape\n+         * sequences poses a problem for operator-- To make this work we'll\n+         * replace the last `m` with a 0xff (this is a codepoint that won't have\n+         * any utf-8 meaning).\n+         */\n+        class AnsiSkippingString {\n+            std::string m_string;\n+            std::size_t m_size = 0;\n+\n+            // perform 0xff replacement and calculate m_size\n+            void preprocessString();\n+\n+        public:\n+            class const_iterator;\n+            using iterator = const_iterator;\n+            // note: must be u-suffixed or this will cause a \"truncation of\n+            // constant value\" warning on MSVC\n+            static constexpr char sentinel = static_cast<char>( 0xffu );\n+\n+            explicit AnsiSkippingString( std::string const& text );\n+            explicit AnsiSkippingString( std::string&& text );\n+\n+            const_iterator begin() const;\n+            const_iterator end() const;\n+\n+            size_t size() const { return m_size; }\n+\n+            std::string substring( const_iterator begin,\n+                                   const_iterator end ) const;\n+        };\n+\n+        class AnsiSkippingString::const_iterator {\n+            friend AnsiSkippingString;\n+            struct EndTag {};\n+\n+            const std::string* m_string;\n+            std::string::const_iterator m_it;\n+\n+            explicit const_iterator( const std::string& string, EndTag ):\n+                m_string( &string ), m_it( string.end() ) {}\n+\n+            void tryParseAnsiEscapes();\n+            void advance();\n+            void unadvance();\n+\n+        public:\n+            using difference_type = std::ptrdiff_t;\n+            using value_type = char;\n+            using pointer = value_type*;\n+            using reference = value_type&;\n+            using iterator_category = std::bidirectional_iterator_tag;\n+\n+            explicit const_iterator( const std::string& string ):\n+                m_string( &string ), m_it( string.begin() ) {\n+                tryParseAnsiEscapes();\n+            }\n+\n+            char operator*() const { return *m_it; }\n+\n+            const_iterator& operator++() {\n+                advance();\n+                return *this;\n+            }\n+            const_iterator operator++( int ) {\n+                iterator prev( *this );\n+                operator++();\n+                return prev;\n+            }\n+            const_iterator& operator--() {\n+                unadvance();\n+                return *this;\n+            }\n+            const_iterator operator--( int ) {\n+                iterator prev( *this );\n+                operator--();\n+                return prev;\n+            }\n+\n+            bool operator==( const_iterator const& other ) const {\n+                return m_it == other.m_it;\n+            }\n+            bool operator!=( const_iterator const& other ) const {\n+                return !operator==( other );\n+            }\n+            bool operator<=( const_iterator const& other ) const {\n+                return m_it <= other.m_it;\n+            }\n+\n+            const_iterator oneBefore() const {\n+                auto it = *this;\n+                return --it;\n+            }\n+        };\n+\n         /**\n          * Represents a column of text with specific width and indentation\n          *\n@@ -29,10 +130,11 @@ namespace Catch {\n          */\n         class Column {\n             // String to be written out\n-            std::string m_string;\n+            AnsiSkippingString m_string;\n             // Width of the column for linebreaking\n             size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;\n-            // Indentation of other lines (including first if initial indent is unset)\n+            // Indentation of other lines (including first if initial indent is\n+            // unset)\n             size_t m_indent = 0;\n             // Indentation of the first line\n             size_t m_initialIndent = std::string::npos;\n@@ -47,16 +149,19 @@ namespace Catch {\n \n                 Column const& m_column;\n                 // Where does the current line start?\n-                size_t m_lineStart = 0;\n+                AnsiSkippingString::const_iterator m_lineStart;\n                 // How long should the current line be?\n-                size_t m_lineLength = 0;\n+                AnsiSkippingString::const_iterator m_lineEnd;\n                 // How far have we checked the string to iterate?\n-                size_t m_parsedTo = 0;\n+                AnsiSkippingString::const_iterator m_parsedTo;\n                 // Should a '-' be appended to the line?\n                 bool m_addHyphen = false;\n \n                 const_iterator( Column const& column, EndTag ):\n-                    m_column( column ), m_lineStart( m_column.m_string.size() ) {}\n+                    m_column( column ),\n+                    m_lineStart( m_column.m_string.end() ),\n+                    m_lineEnd( column.m_string.end() ),\n+                    m_parsedTo( column.m_string.end() ) {}\n \n                 // Calculates the length of the current line\n                 void calcLength();\n@@ -66,8 +171,9 @@ namespace Catch {\n \n                 // Creates an indented and (optionally) suffixed string from\n                 // current iterator position, indentation and length.\n-                std::string addIndentAndSuffix( size_t position,\n-                                                size_t length ) const;\n+                std::string addIndentAndSuffix(\n+                    AnsiSkippingString::const_iterator start,\n+                    AnsiSkippingString::const_iterator end ) const;\n \n             public:\n                 using difference_type = std::ptrdiff_t;\n@@ -84,7 +190,8 @@ namespace Catch {\n                 const_iterator operator++( int );\n \n                 bool operator==( const_iterator const& other ) const {\n-                    return m_lineStart == other.m_lineStart && &m_column == &other.m_column;\n+                    return m_lineStart == other.m_lineStart &&\n+                           &m_column == &other.m_column;\n                 }\n                 bool operator!=( const_iterator const& other ) const {\n                     return !operator==( other );\n@@ -94,7 +201,7 @@ namespace Catch {\n \n             explicit Column( std::string const& text ): m_string( text ) {}\n             explicit Column( std::string&& text ):\n-                m_string( CATCH_MOVE(text)) {}\n+                m_string( CATCH_MOVE( text ) ) {}\n \n             Column& width( size_t newWidth ) & {\n                 assert( newWidth > 0 );\n@@ -125,7 +232,9 @@ namespace Catch {\n \n             size_t width() const { return m_width; }\n             const_iterator begin() const { return const_iterator( *this ); }\n-            const_iterator end() const { return { *this, const_iterator::EndTag{} }; }\n+            const_iterator end() const {\n+                return { *this, const_iterator::EndTag{} };\n+            }\n \n             friend std::ostream& operator<<( std::ostream& os,\n                                              Column const& col );\n", "test_patch": "diff --git a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n@@ -12,6 +12,7 @@\n #include <sstream>\n \n using Catch::TextFlow::Column;\n+using Catch::TextFlow::AnsiSkippingString;\n \n namespace {\n     static std::string as_written(Column const& c) {\n@@ -198,3 +199,202 @@ TEST_CASE( \"#1400 - TextFlow::Column wrapping would sometimes duplicate words\",\n             \"  in \\n\"\n             \"  convallis posuere, libero nisi ultricies orci, nec lobortis.\");\n }\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString skips ansi sequences\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+\n+    SECTION(\"basic string\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+\n+        SECTION( \"iterates forward\" ) {\n+            auto it = str.begin();\n+            CHECK(*it == 'a');\n+            ++it;\n+            CHECK(*it == 'b');\n+            ++it;\n+            CHECK(*it == 'c');\n+            ++it;\n+            CHECK(*it == 'd');\n+            ++it;\n+            CHECK(*it == 'e');\n+            ++it;\n+            CHECK(it == str.end());\n+        }\n+        SECTION( \"iterates backwards\" ) {\n+            auto it = str.end();\n+            --it;\n+            CHECK(*it == 'e');\n+            --it;\n+            CHECK(*it == 'd');\n+            --it;\n+            CHECK(*it == 'c');\n+            --it;\n+            CHECK(*it == 'b');\n+            --it;\n+            CHECK(*it == 'a');\n+            CHECK(it == str.begin());\n+        }\n+    }\n+\n+    SECTION( \"ansi escape sequences at the start\" ) {\n+        std::string text = \"\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"ansi escape sequences at the end\" ) {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\\033[38;2;98;174;239m\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"skips consecutive escapes\" ) {\n+        std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto it = str.begin();\n+        CHECK(*it == 'a');\n+        ++it;\n+        CHECK(*it == 'b');\n+        ++it;\n+        CHECK(*it == 'c');\n+        ++it;\n+        CHECK(*it == 'd');\n+        ++it;\n+        CHECK(*it == 'e');\n+        ++it;\n+        CHECK(it == str.end());\n+        --it;\n+        CHECK(*it == 'e');\n+        --it;\n+        CHECK(*it == 'd');\n+        --it;\n+        CHECK(*it == 'c');\n+        --it;\n+        CHECK(*it == 'b');\n+        --it;\n+        CHECK(*it == 'a');\n+        CHECK(it == str.begin());\n+    }\n+\n+    SECTION( \"handles incomplete ansi sequences\" ) {\n+        std::string text = \"a\\033[b\\033[30c\\033[30;d\\033[30;2e\";\n+        AnsiSkippingString str(text);\n+        CHECK(std::string(str.begin(), str.end()) == text);\n+    }\n+}\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString computes the size properly\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+    std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+    AnsiSkippingString str(text);\n+    CHECK(str.size() == 5);\n+}\n+\n+TEST_CASE( \"TextFlow::AnsiSkippingString substrings properly\",\n+           \"[TextFlow][ansiskippingstring][approvals]\" ) {\n+    SECTION(\"basic test\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"a\\033[38;2;98;174;239mb\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38mc\\033[0md\\033[me\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+    SECTION(\"escapes at the start\") {\n+        std::string text = \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"\\033[38;2;98;174;239m\\033[38;2;98;174;239ma\\033[38;2;98;174;239mb\\033[38m\\033[38m\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38m\\033[38m\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38m\\033[38m\\033[38mc\\033[0md\\033[me\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+    SECTION(\"escapes at the end\") {\n+        std::string text = \"a\\033[38;2;98;174;239mb\\033[38mc\\033[0md\\033[me\\033[38m\";\n+        AnsiSkippingString str(text);\n+        auto a = str.begin();\n+        auto b = str.begin();\n+        ++b;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"a\\033[38;2;98;174;239mb\\033[38m\");\n+        ++a;\n+        ++b;\n+        CHECK(str.substring(a, b) == \"b\\033[38mc\\033[0m\");\n+        CHECK(str.substring(a, str.end()) == \"b\\033[38mc\\033[0md\\033[me\\033[38m\");\n+        CHECK(str.substring(str.begin(), str.end()) == text);\n+    }\n+}\n+\n+TEST_CASE( \"TextFlow::Column skips ansi escape sequences\",\n+           \"[TextFlow][column][approvals]\" ) {\n+    std::string text = \"\\033[38;2;98;174;239m\\033[38;2;198;120;221mThe quick brown \\033[38;2;198;120;221mfox jumped over the lazy dog\\033[0m\";\n+    Column col(text);\n+\n+    SECTION( \"width=20\" ) {\n+        col.width( 20 );\n+        REQUIRE( as_written( col ) == \"\\033[38;2;98;174;239m\\033[38;2;198;120;221mThe quick brown \\033[38;2;198;120;221mfox\\n\"\n+                                      \"jumped over the lazy\\n\"\n+                                      \"dog\\033[0m\" );\n+    }\n+\n+    SECTION( \"width=80\" ) {\n+        col.width( 80 );\n+        REQUIRE( as_written( col ) == text );\n+    }\n+}\n", "problem_statement": "Handle ANSI escape sequences during text wrapping\n**Description**\r\n\r\nI'd like to provide diagnostic messages from a `Catch::Matchers::MatcherBase::describe` function that are colored with ANSI sequences, however Catch2's line wrapping interferes with this.\r\n\r\nWould a PR to update the line wrapping logic be welcomed?\r\n\r\n**Additional context**\r\n\r\nI have an assertion library that I'd like to provide a catch2 integration for. Without color codes, with my current attempt to make it work in Catch2, it looks like this:\r\n\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/4f410b0c-a0c4-472d-935a-37e0068770ba)\r\n\r\nHowever with color codes the lines are messed up and escape sequences are split in the middle:\r\n\r\n![image](https://github.com/catchorg/Catch2/assets/51220084/a600caf7-f047-4c66-90cf-dd41f9eef258)\n", "hints_text": "", "created_at": "2024-03-29T20:16:51Z", "version": "3.5"}
{"repo": "catchorg/Catch2", "pull_number": 1673, "instance_id": "catchorg__Catch2-1673", "issue_numbers": ["1670"], "base_commit": "6f32c67ea763ff189b55eeb24980ddc2522a80fb", "patch": "diff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -378,6 +378,8 @@ set_tests_properties(FilteredSection-2 PROPERTIES FAIL_REGULAR_EXPRESSION \"No te\n add_test(NAME ApprovalTests COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/scripts/approvalTests.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(ApprovalTests PROPERTIES FAIL_REGULAR_EXPRESSION \"Results differed\")\n \n+add_test(NAME RegressionCheck-1670 COMMAND $<TARGET_FILE:SelfTest> \"#1670 regression check\" -c A -r compact)\n+set_tests_properties(RegressionCheck-1670 PROPERTIES PASS_REGULAR_EXPRESSION \"Passed 1 test case with 2 assertions.\")\n \n if (CATCH_USE_VALGRIND)\n     add_test(NAME ValgrindRunTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest>)\n", "test_patch": "diff --git a/include/internal/catch_test_case_tracker.cpp b/include/internal/catch_test_case_tracker.cpp\n--- a/include/internal/catch_test_case_tracker.cpp\n+++ b/include/internal/catch_test_case_tracker.cpp\n@@ -139,7 +139,7 @@ namespace TestCaseTracking {\n                 m_runState = CompletedSuccessfully;\n                 break;\n             case ExecutingChildren:\n-                if( m_children.empty() || m_children.back()->isComplete() )\n+                if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const& t){ return t->isComplete(); }) )\n                     m_runState = CompletedSuccessfully;\n                 break;\n \ndiff --git a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n@@ -189,3 +189,18 @@ TEST_CASE( \"#1394 nested\", \"[.][approvals][tracker]\" ) {\n         REQUIRE(1 == 0);\n     }\n }\n+\n+// Selecting a \"not last\" section inside a test case via -c \"section\" would\n+// previously only run the first subsection, instead of running all of them.\n+// This allows us to check that `\"#1670 regression check\" -c A` leads to\n+// 2 successful assertions.\n+TEST_CASE(\"#1670 regression check\", \"[.approvals][tracker]\") {\n+    SECTION(\"A\") {\n+        SECTION(\"1\") SUCCEED();\n+        SECTION(\"2\") SUCCEED();\n+    }\n+    SECTION(\"B\") {\n+        SECTION(\"1\") SUCCEED();\n+        SECTION(\"2\") SUCCEED();\n+    }\n+}\n", "problem_statement": "Inconsistent behaviour of nested sections\n**Describe the bug**\r\nSuppose I have a test case with a structure like the following:\r\n```\r\nTEST_CASE(\"Nesting\")\r\n{\r\n    SECTION(\"A\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n    SECTION(\"B\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n}\r\n```\r\n\r\nUpon selecting the test case and section on the command line, I get the following results:\r\n* `./test Nesting`: All four assertions are executed;\r\n* `./test Nesting -c A`: *Only A1 is executed*;\r\n* `./test Nesting -c B`: B1 and B2 are executed.\r\n\r\n**Expected behavior**\r\n`./test Nesting -c A` should execute all subsections of section A.\r\n\r\n**Reproduction steps**\r\nSee description.\r\n\r\n**Platform information:**\r\n - Compiler+version: **GCC v9.1.1**\r\n - Catch version: **v2.8.0**, **v2.9.1**\r\n\n", "hints_text": "Thanks for the report.\r\n\r\nUpon further investigation, this was introduced by #1492 and affects all sections that are not the last section, in other words, in this\r\n\r\n```cpp\r\nTEST_CASE(\"Nesting\")\r\n{\r\n    SECTION(\"A\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n    SECTION(\"B\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n    SECTION(\"C\") {\r\n        SECTION(\"1\") SUCCEED();\r\n        SECTION(\"2\") SUCCEED();\r\n    }\r\n}\r\n```\r\nOnly \"C\" is unaffected.", "created_at": "2019-06-29T16:12:17Z", "version": "2.9"}
{"repo": "catchorg/Catch2", "pull_number": 2177, "instance_id": "catchorg__Catch2-2177", "issue_numbers": ["2166"], "base_commit": "c12170ff69ddc9a0a25ec2025783b815354c6d26", "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -17,6 +17,8 @@ cmake_dependent_option(CATCH_BUILD_EXTRA_TESTS \"Build extra tests\" OFF \"CATCH_DE\n cmake_dependent_option(CATCH_BUILD_FUZZERS \"Build fuzzers\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n cmake_dependent_option(CATCH_ENABLE_COVERAGE \"Generate coverage for codecov.io\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n cmake_dependent_option(CATCH_ENABLE_WERROR \"Enables Werror during build\" ON \"CATCH_DEVELOPMENT_BUILD\" OFF)\n+cmake_dependent_option(CATCH_BUILD_SURROGATES \"Enable generating and building surrogate TUs for the main headers\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n+\n \n # Catch2's build breaks if done in-tree. You probably should not build\n # things in tree anyway, but we can allow projects that include Catch2\ndiff --git a/src/catch2/benchmark/catch_constructor.hpp b/src/catch2/benchmark/catch_constructor.hpp\n--- a/src/catch2/benchmark/catch_constructor.hpp\n+++ b/src/catch2/benchmark/catch_constructor.hpp\n@@ -11,6 +11,7 @@\n #define CATCH_CONSTRUCTOR_HPP_INCLUDED\n \n #include <type_traits>\n+#include <utility>\n \n namespace Catch {\n     namespace Benchmark {\ndiff --git a/src/catch2/benchmark/detail/catch_analyse.hpp b/src/catch2/benchmark/detail/catch_analyse.hpp\n--- a/src/catch2/benchmark/detail/catch_analyse.hpp\n+++ b/src/catch2/benchmark/detail/catch_analyse.hpp\n@@ -11,8 +11,10 @@\n #define CATCH_ANALYSE_HPP_INCLUDED\n \n #include <catch2/benchmark/catch_clock.hpp>\n+#include <catch2/benchmark/catch_environment.hpp>\n #include <catch2/benchmark/catch_sample_analysis.hpp>\n #include <catch2/benchmark/detail/catch_stats.hpp>\n+#include <catch2/interfaces/catch_interfaces_config.hpp>\n \n #include <algorithm>\n #include <iterator>\ndiff --git a/src/catch2/catch_reporter_registrars.hpp b/src/catch2/catch_reporter_registrars.hpp\n--- a/src/catch2/catch_reporter_registrars.hpp\n+++ b/src/catch2/catch_reporter_registrars.hpp\n@@ -9,11 +9,15 @@\n #define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED\n \n #include <catch2/interfaces/catch_interfaces_registry_hub.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter.hpp>\n #include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n #include <catch2/internal/catch_unique_ptr.hpp>\n \n namespace Catch {\n \n+    struct IStreamingReporter;\n+    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\n+\n     template <typename T>\n     class ReporterFactory : public IReporterFactory {\n \ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp b/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n@@ -8,9 +8,16 @@\n #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED\n #define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED\n \n+#include <catch2/internal/catch_unique_ptr.hpp>\n+\n+#include <string>\n+\n namespace Catch {\n \n     struct ReporterConfig;\n+    struct IStreamingReporter;\n+    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\n+\n \n     struct IReporterFactory {\n         virtual ~IReporterFactory(); // = default\ndiff --git a/src/catch2/internal/catch_container_nonmembers.hpp b/src/catch2/internal/catch_container_nonmembers.hpp\n--- a/src/catch2/internal/catch_container_nonmembers.hpp\n+++ b/src/catch2/internal/catch_container_nonmembers.hpp\n@@ -10,6 +10,8 @@\n \n #include <catch2/internal/catch_compiler_capabilities.hpp>\n \n+#include <cstddef>\n+#include <initializer_list>\n \n // We want a simple polyfill over `std::empty`, `std::size` and so on\n // for C++14 or C++ libraries with incomplete support.\n", "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -1,5 +1,66 @@\n include(MiscFunctions)\n \n+if (CATCH_BUILD_SURROGATES)\n+  message(STATUS \"Configuring targets for surrogate TUs\")\n+\n+  # If the folder does not exist before we ask for output redirect to\n+  # a file, it won't work.\n+  file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/surrogates)\n+\n+  # Creates target to generate the surrogate TU for provided header.\n+  # Returns the path to the generated file.\n+  function(createSurrogateFileTarget sourceHeader pathToFile)\n+    set(pathPrefix ${PROJECT_SOURCE_DIR}/src)\n+\n+    file(RELATIVE_PATH includePath ${pathPrefix} ${sourceHeader})\n+\n+    get_filename_component(basicFileName \"${sourceHeader}\" NAME_WE)\n+\n+    set(surrogateFilePath ${CMAKE_CURRENT_BINARY_DIR}/surrogates/surrogate_${basicFileName}.cpp)\n+\n+    add_custom_command(\n+      OUTPUT ${surrogateFilePath}\n+      COMMAND cmake -E echo \"\\#include <${includePath}>\" > \"${surrogateFilePath}\"\n+      VERBATIM\n+    )\n+\n+    set(${pathToFile} ${surrogateFilePath} PARENT_SCOPE)\n+  endfunction()\n+\n+  # Extracts all non-helper (e.g. catch_all.hpp) headers from the\n+  # Catch2 target, and returns them through the argument.\n+  function(ExtractCatch2Headers OutArg)\n+    get_target_property(targetSources Catch2 SOURCES)\n+    foreach(Source ${targetSources})\n+      string(REGEX MATCH \"^.*\\\\.hpp$\" isHeader ${Source})\n+      string(REGEX MATCH \"_all.hpp\" isAllHeader ${Source})\n+      if(isHeader AND NOT isAllHeader)\n+        list(APPEND AllHeaders ${Source})\n+      endif()\n+    endforeach()\n+    set(${OutArg} ${AllHeaders} PARENT_SCOPE)\n+  endfunction()\n+\n+\n+  ExtractCatch2Headers(mainHeaders)\n+\n+  if (NOT mainHeaders)\n+    message(FATAL_ERROR \"No headers in the main target were detected. Something is broken.\")\n+  endif()\n+\n+  foreach(header ${mainHeaders})\n+    createSurrogateFileTarget(${header} pathToGeneratedFile)\n+    list(APPEND surrogateFiles ${pathToGeneratedFile})\n+  endforeach()\n+\n+\n+  add_executable(Catch2SurrogateTarget\n+    ${surrogateFiles}\n+  )\n+  target_link_libraries(Catch2SurrogateTarget PRIVATE Catch2WithMain)\n+\n+endif(CATCH_BUILD_SURROGATES)\n+\n ####\n # Temporary workaround for VS toolset changes in 2017\n # We need to disable <UseFullPaths> property, but CMake doesn't support it\n", "problem_statement": "Add surrogate TUs for header files\n## Description\r\n\r\nThis PR adds surrogate TUs to test that each header file in the project can be included without depending on other files.\r\n\r\nIn order for the PR to be complete I have to clean the commit history.\r\nAlso 5 files are commented in the CMakeLists.txt of SurrogateCpps since they need to be fixed.\r\n\r\n## GitHub Issues\r\n\r\nCloses #2106\r\n\n", "hints_text": "# [Codecov](https://codecov.io/gh/catchorg/Catch2/pull/2166?src=pr&el=h1) Report\n> Merging [#2166](https://codecov.io/gh/catchorg/Catch2/pull/2166?src=pr&el=desc) (4fad45c) into [devel](https://codecov.io/gh/catchorg/Catch2/commit/ba8150516800dd5e18f818346a2a12c45b6ec542?el=desc) (ba81505) will **increase** coverage by `0.04%`.\n> The diff coverage is `n/a`.\n\n```diff\n@@            Coverage Diff             @@\n##            devel    #2166      +/-   ##\n==========================================\n+ Coverage   90.03%   90.07%   +0.04%     \n==========================================\n  Files         146      146              \n  Lines        7089     7110      +21     \n==========================================\n+ Hits         6382     6404      +22     \n+ Misses        707      706       -1     \n```\n\nCleared commit history.\nActually don't do a thing now, this might be an entirely wrong approach \ud83d\ude03 \r\n\r\nI realized that this approach where the surrogate cpp files actually exist on disk add a lot of mechanical overhead to creating new headers, and that we could replace it with generating the surrogate cpp files on-demand. This would move the mechanical work from the developer to a machine, which is much better.\nAt some point, I got bored copy-pasting headers, and I wrote a script to autogenerate the surrogate files. Should I make it generic to autogenerate them based on what exists in the src directory of catch2?", "created_at": "2021-02-16T15:26:54Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 2427, "instance_id": "catchorg__Catch2-2427", "issue_numbers": ["2306"], "base_commit": "231c58a048039fc09d399bdccdfb7c65a1a6ed4a", "patch": "diff --git a/src/catch2/internal/catch_compiler_capabilities.hpp b/src/catch2/internal/catch_compiler_capabilities.hpp\n--- a/src/catch2/internal/catch_compiler_capabilities.hpp\n+++ b/src/catch2/internal/catch_compiler_capabilities.hpp\n@@ -57,6 +57,12 @@\n \n #endif\n \n+#if defined(__CUDACC__) && !defined(__clang__)\n+#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( \"nv_diagnostic push\" )\n+#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( \"nv_diagnostic pop\" )\n+#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( \"nv_diag_suppress 177\" )\n+#endif\n+\n #if defined(__clang__) && !defined(_MSC_VER)\n \n #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( \"clang diagnostic push\" )\n", "test_patch": "diff --git a/src/catch2/internal/catch_test_registry.hpp b/src/catch2/internal/catch_test_registry.hpp\n--- a/src/catch2/internal/catch_test_registry.hpp\n+++ b/src/catch2/internal/catch_test_registry.hpp\n@@ -77,6 +77,7 @@ struct AutoReg : Detail::NonCopyable {\n         static void TestName(); \\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n         static void TestName()\n@@ -87,6 +88,7 @@ struct AutoReg : Detail::NonCopyable {\n     #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n         namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, \"&\" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \n@@ -94,6 +96,7 @@ struct AutoReg : Detail::NonCopyable {\n     #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n         namespace{ \\\n             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \\\n                 void test(); \\\n@@ -110,6 +113,7 @@ struct AutoReg : Detail::NonCopyable {\n         do { \\\n             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\n             CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+            CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\n             Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \\\n             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\n         } while(false)\n", "problem_statement": "Unused variable warnings when compiling with nvcc + gcc\nWhen compiling CUDA files with nvcc (CUDA 11.3 and GCC 9.4), when including catch2 and declaring a simple test case, I'm getting warnings such as `variable \"[...]autoRegistrar1\" was declared but never referenced`.\r\nIs there a way to get rid of these warnings?\r\n\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Linux x86_64**\r\n - Compiler+version: **NVCC 11.3 / GCC 9.4.0**\r\n - Catch version: **v2.13.0** [included as part of CMake build, with cmake 3.17.0]\r\n\n", "hints_text": "Other issues similar to this have been opened (#2132,  #1552) but I believe they're not using a fairly recent GCC.", "created_at": "2022-05-18T13:48:47Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 2817, "instance_id": "catchorg__Catch2-2817", "issue_numbers": ["2816"], "base_commit": "c3fd4eb17e28ace4d3d9df1fb0656f3975879709", "patch": "diff --git a/examples/210-Evt-EventListeners.cpp b/examples/210-Evt-EventListeners.cpp\n--- a/examples/210-Evt-EventListeners.cpp\n+++ b/examples/210-Evt-EventListeners.cpp\n@@ -385,8 +385,7 @@ struct MyListener : Catch::EventListenerBase {\n CATCH_REGISTER_LISTENER( MyListener )\n \n // Get rid of Wweak-tables\n-MyListener::~MyListener() {}\n-\n+MyListener::~MyListener() = default;\n \n // -----------------------------------------------------------------------\n // 3. Test cases:\ndiff --git a/examples/231-Cfg-OutputStreams.cpp b/examples/231-Cfg-OutputStreams.cpp\n--- a/examples/231-Cfg-OutputStreams.cpp\n+++ b/examples/231-Cfg-OutputStreams.cpp\n@@ -22,7 +22,7 @@ class out_buff : public std::stringbuf {\n     std::FILE* m_stream;\n public:\n     out_buff(std::FILE* stream):m_stream(stream) {}\n-    ~out_buff();\n+    ~out_buff() override;\n     int sync() override {\n         int ret = 0;\n         for (unsigned char c : str()) {\ndiff --git a/examples/232-Cfg-CustomMain.cpp b/examples/232-Cfg-CustomMain.cpp\n--- a/examples/232-Cfg-CustomMain.cpp\n+++ b/examples/232-Cfg-CustomMain.cpp\n@@ -35,7 +35,7 @@ int main(int argc, char** argv) {\n       return returnCode;\n \n   // if set on the command line then 'height' is now set at this point\n-  std::cout << \"height: \" << height << std::endl;\n+  std::cout << \"height: \" << height << '\\n';\n \n   return session.run();\n }\ndiff --git a/examples/300-Gen-OwnGenerator.cpp b/examples/300-Gen-OwnGenerator.cpp\n--- a/examples/300-Gen-OwnGenerator.cpp\n+++ b/examples/300-Gen-OwnGenerator.cpp\n@@ -21,7 +21,7 @@\n namespace {\n \n // This class shows how to implement a simple generator for Catch tests\n-class RandomIntGenerator : public Catch::Generators::IGenerator<int> {\n+class RandomIntGenerator final : public Catch::Generators::IGenerator<int> {\n     std::minstd_rand m_rand;\n     std::uniform_int_distribution<> m_dist;\n     int current_number;\ndiff --git a/examples/301-Gen-MapTypeConversion.cpp b/examples/301-Gen-MapTypeConversion.cpp\n--- a/examples/301-Gen-MapTypeConversion.cpp\n+++ b/examples/301-Gen-MapTypeConversion.cpp\n@@ -24,12 +24,12 @@ namespace {\n // Returns a line from a stream. You could have it e.g. read lines from\n // a file, but to avoid problems with paths in examples, we will use\n // a fixed stringstream.\n-class LineGenerator : public Catch::Generators::IGenerator<std::string> {\n+class LineGenerator final : public Catch::Generators::IGenerator<std::string> {\n     std::string m_line;\n     std::stringstream m_stream;\n public:\n-    LineGenerator() {\n-        m_stream.str(\"1\\n2\\n3\\n4\\n\");\n+    explicit LineGenerator( std::string const& lines ) {\n+        m_stream.str( lines );\n         if (!next()) {\n             Catch::Generators::Detail::throw_generator_exception(\"Couldn't read a single line\");\n         }\n@@ -49,18 +49,19 @@ std::string const& LineGenerator::get() const {\n // This helper function provides a nicer UX when instantiating the generator\n // Notice that it returns an instance of GeneratorWrapper<std::string>, which\n // is a value-wrapper around std::unique_ptr<IGenerator<std::string>>.\n-Catch::Generators::GeneratorWrapper<std::string> lines(std::string /* ignored for example */) {\n+Catch::Generators::GeneratorWrapper<std::string>\n+lines( std::string const& lines ) {\n     return Catch::Generators::GeneratorWrapper<std::string>(\n-        new LineGenerator()\n-    );\n+        new LineGenerator( lines ) );\n }\n \n } // end anonymous namespace\n \n \n TEST_CASE(\"filter can convert types inside the generator expression\", \"[example][generator]\") {\n-    auto num = GENERATE(map<int>([](std::string const& line) { return std::stoi(line); },\n-                                 lines(\"fake-file\")));\n+    auto num = GENERATE(\n+        map<int>( []( std::string const& line ) { return std::stoi( line ); },\n+                  lines( \"1\\n2\\n3\\n4\\n\" ) ) );\n \n     REQUIRE(num > 0);\n }\ndiff --git a/src/catch2/catch_message.cpp b/src/catch2/catch_message.cpp\n--- a/src/catch2/catch_message.cpp\n+++ b/src/catch2/catch_message.cpp\n@@ -91,6 +91,7 @@ namespace Catch {\n                     m_messages.back().message += \" := \";\n                     start = pos;\n                 }\n+            default:; // noop\n             }\n         }\n         assert(openings.empty() && \"Mismatched openings\");\ndiff --git a/src/catch2/catch_registry_hub.cpp b/src/catch2/catch_registry_hub.cpp\n--- a/src/catch2/catch_registry_hub.cpp\n+++ b/src/catch2/catch_registry_hub.cpp\n@@ -20,7 +20,6 @@\n #include <catch2/internal/catch_noncopyable.hpp>\n #include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n #include <catch2/internal/catch_move_and_forward.hpp>\n-#include <catch2/internal/catch_reporter_registry.hpp>\n \n #include <exception>\n \ndiff --git a/src/catch2/catch_tostring.cpp b/src/catch2/catch_tostring.cpp\n--- a/src/catch2/catch_tostring.cpp\n+++ b/src/catch2/catch_tostring.cpp\n@@ -54,13 +54,13 @@ namespace Detail {\n         }\n     } // end unnamed namespace\n \n-    std::string convertIntoString(StringRef string, bool escape_invisibles) {\n+    std::string convertIntoString(StringRef string, bool escapeInvisibles) {\n         std::string ret;\n         // This is enough for the \"don't escape invisibles\" case, and a good\n         // lower bound on the \"escape invisibles\" case.\n         ret.reserve(string.size() + 2);\n \n-        if (!escape_invisibles) {\n+        if (!escapeInvisibles) {\n             ret += '\"';\n             ret += string;\n             ret += '\"';\n@@ -138,7 +138,7 @@ std::string StringMaker<char const*>::convert(char const* str) {\n         return{ \"{null string}\" };\n     }\n }\n-std::string StringMaker<char*>::convert(char* str) {\n+std::string StringMaker<char*>::convert(char* str) { // NOLINT(readability-non-const-parameter)\n     if (str) {\n         return Detail::convertIntoString( str );\n     } else {\n@@ -235,8 +235,8 @@ std::string StringMaker<signed char>::convert(signed char value) {\n std::string StringMaker<char>::convert(char c) {\n     return ::Catch::Detail::stringify(static_cast<signed char>(c));\n }\n-std::string StringMaker<unsigned char>::convert(unsigned char c) {\n-    return ::Catch::Detail::stringify(static_cast<char>(c));\n+std::string StringMaker<unsigned char>::convert(unsigned char value) {\n+    return ::Catch::Detail::stringify(static_cast<char>(value));\n }\n \n int StringMaker<float>::precision = 5;\ndiff --git a/src/catch2/catch_tostring.hpp b/src/catch2/catch_tostring.hpp\n--- a/src/catch2/catch_tostring.hpp\n+++ b/src/catch2/catch_tostring.hpp\n@@ -279,11 +279,11 @@ namespace Catch {\n     };\n     template<>\n     struct StringMaker<signed char> {\n-        static std::string convert(signed char c);\n+        static std::string convert(signed char value);\n     };\n     template<>\n     struct StringMaker<unsigned char> {\n-        static std::string convert(unsigned char c);\n+        static std::string convert(unsigned char value);\n     };\n \n     template<>\ndiff --git a/src/catch2/internal/catch_commandline.cpp b/src/catch2/internal/catch_commandline.cpp\n--- a/src/catch2/internal/catch_commandline.cpp\n+++ b/src/catch2/internal/catch_commandline.cpp\n@@ -47,7 +47,7 @@ namespace Catch {\n                     line = trim(line);\n                     if( !line.empty() && !startsWith( line, '#' ) ) {\n                         if( !startsWith( line, '\"' ) )\n-                            line = '\"' + line + '\"';\n+                            line = '\"' + CATCH_MOVE(line) + '\"';\n                         config.testsOrTags.push_back( line );\n                         config.testsOrTags.emplace_back( \",\" );\n                     }\ndiff --git a/src/catch2/internal/catch_console_colour.cpp b/src/catch2/internal/catch_console_colour.cpp\n--- a/src/catch2/internal/catch_console_colour.cpp\n+++ b/src/catch2/internal/catch_console_colour.cpp\n@@ -230,21 +230,21 @@ namespace {\n \n namespace Catch {\n \n-    Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode implSelection,\n+    Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,\n                                                    IStream* stream ) {\n #if defined( CATCH_CONFIG_COLOUR_WIN32 )\n-        if ( implSelection == ColourMode::Win32 ) {\n+        if ( colourSelection == ColourMode::Win32 ) {\n             return Detail::make_unique<Win32ColourImpl>( stream );\n         }\n #endif\n-        if ( implSelection == ColourMode::ANSI ) {\n+        if ( colourSelection == ColourMode::ANSI ) {\n             return Detail::make_unique<ANSIColourImpl>( stream );\n         }\n-        if ( implSelection == ColourMode::None ) {\n+        if ( colourSelection == ColourMode::None ) {\n             return Detail::make_unique<NoColourImpl>( stream );\n         }\n \n-        if ( implSelection == ColourMode::PlatformDefault) {\n+        if ( colourSelection == ColourMode::PlatformDefault) {\n #if defined( CATCH_CONFIG_COLOUR_WIN32 )\n             if ( Win32ColourImpl::useImplementationForStream( *stream ) ) {\n                 return Detail::make_unique<Win32ColourImpl>( stream );\n@@ -256,7 +256,7 @@ namespace Catch {\n             return Detail::make_unique<NoColourImpl>( stream );\n         }\n \n-        CATCH_ERROR( \"Could not create colour impl for selection \" << static_cast<int>(implSelection) );\n+        CATCH_ERROR( \"Could not create colour impl for selection \" << static_cast<int>(colourSelection) );\n     }\n \n     bool isColourImplAvailable( ColourMode colourSelection ) {\ndiff --git a/src/catch2/internal/catch_enum_values_registry.hpp b/src/catch2/internal/catch_enum_values_registry.hpp\n--- a/src/catch2/internal/catch_enum_values_registry.hpp\n+++ b/src/catch2/internal/catch_enum_values_registry.hpp\n@@ -24,7 +24,7 @@ namespace Catch {\n \n             std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;\n \n-            EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values) override;\n+            EnumInfo const& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values) override;\n         };\n \n         std::vector<StringRef> parseEnums( StringRef enums );\ndiff --git a/src/catch2/internal/catch_jsonwriter.cpp b/src/catch2/internal/catch_jsonwriter.cpp\n--- a/src/catch2/internal/catch_jsonwriter.cpp\n+++ b/src/catch2/internal/catch_jsonwriter.cpp\n@@ -31,7 +31,7 @@ namespace Catch {\n         m_os{ os }, m_indent_level{ indent_level } {\n         m_os << '{';\n     }\n-    JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ):\n+    JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ) noexcept:\n         m_os{ source.m_os },\n         m_indent_level{ source.m_indent_level },\n         m_should_comma{ source.m_should_comma },\n@@ -62,7 +62,7 @@ namespace Catch {\n         m_os{ os }, m_indent_level{ indent_level } {\n         m_os << '[';\n     }\n-    JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ):\n+    JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ) noexcept:\n         m_os{ source.m_os },\n         m_indent_level{ source.m_indent_level },\n         m_should_comma{ source.m_should_comma },\ndiff --git a/src/catch2/internal/catch_jsonwriter.hpp b/src/catch2/internal/catch_jsonwriter.hpp\n--- a/src/catch2/internal/catch_jsonwriter.hpp\n+++ b/src/catch2/internal/catch_jsonwriter.hpp\n@@ -65,7 +65,7 @@ namespace Catch {\n         JsonObjectWriter( std::ostream& os );\n         JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );\n \n-        JsonObjectWriter( JsonObjectWriter&& source );\n+        JsonObjectWriter( JsonObjectWriter&& source ) noexcept;\n         JsonObjectWriter& operator=( JsonObjectWriter&& source ) = delete;\n \n         ~JsonObjectWriter();\n@@ -84,7 +84,7 @@ namespace Catch {\n         JsonArrayWriter( std::ostream& os );\n         JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );\n \n-        JsonArrayWriter( JsonArrayWriter&& source );\n+        JsonArrayWriter( JsonArrayWriter&& source ) noexcept;\n         JsonArrayWriter& operator=( JsonArrayWriter&& source ) = delete;\n \n         ~JsonArrayWriter();\ndiff --git a/src/catch2/internal/catch_reporter_spec_parser.cpp b/src/catch2/internal/catch_reporter_spec_parser.cpp\n--- a/src/catch2/internal/catch_reporter_spec_parser.cpp\n+++ b/src/catch2/internal/catch_reporter_spec_parser.cpp\n@@ -117,7 +117,7 @@ namespace Catch {\n             auto kv = splitKVPair( parts[i] );\n             auto key = kv.key, value = kv.value;\n \n-            if ( key.empty() || value.empty() ) {\n+            if ( key.empty() || value.empty() ) { // NOLINT(bugprone-branch-clone)\n                 return {};\n             } else if ( key[0] == 'X' ) {\n                 // This is a reporter-specific option, we don't check these\ndiff --git a/src/catch2/internal/catch_section.hpp b/src/catch2/internal/catch_section.hpp\n--- a/src/catch2/internal/catch_section.hpp\n+++ b/src/catch2/internal/catch_section.hpp\n@@ -69,7 +69,9 @@ namespace Catch {\n     namespace Detail {\n         // Intentionally without linkage, as it should only be used as a dummy\n         // symbol for static analysis.\n-        int GetNewSectionHint();\n+        // The arguments are used as a dummy for checking warnings in the passed\n+        // expressions.\n+        int GetNewSectionHint( StringRef, const char* const = nullptr );\n     } // namespace Detail\n } // namespace Catch\n \n@@ -80,7 +82,8 @@ namespace Catch {\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\\n         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\\n                  catchInternalSectionHint,                                  \\\n-             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(); \\\n+             catchInternalSectionHint =                                     \\\n+                 Catch::Detail::GetNewSectionHint(__VA_ARGS__);             \\\n              catchInternalPreviousSectionHint == __LINE__ )                 \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \n@@ -90,7 +93,8 @@ namespace Catch {\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\\n         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\\n                  catchInternalSectionHint,                                  \\\n-             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(); \\\n+             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(   \\\n+                ( Catch::ReusableStringStream() << __VA_ARGS__ ).str());    \\\n              catchInternalPreviousSectionHint == __LINE__ )                 \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \ndiff --git a/src/catch2/internal/catch_string_manip.cpp b/src/catch2/internal/catch_string_manip.cpp\n--- a/src/catch2/internal/catch_string_manip.cpp\n+++ b/src/catch2/internal/catch_string_manip.cpp\n@@ -5,6 +5,7 @@\n //        https://www.boost.org/LICENSE_1_0.txt)\n \n // SPDX-License-Identifier: BSL-1.0\n+#include <catch2/internal/catch_move_and_forward.hpp>\n #include <catch2/internal/catch_string_manip.hpp>\n #include <catch2/internal/catch_stringref.hpp>\n \n@@ -65,17 +66,29 @@ namespace Catch {\n     }\n \n     bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {\n-        bool replaced = false;\n         std::size_t i = str.find( replaceThis );\n-        while( i != std::string::npos ) {\n-            replaced = true;\n-            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\n-            if( i < str.size()-withThis.size() )\n-                i = str.find( replaceThis, i+withThis.size() );\n+        if (i == std::string::npos) {\n+            return false;\n+        }\n+        std::size_t copyBegin = 0;\n+        std::string origStr = CATCH_MOVE(str);\n+        str.clear();\n+        // There is at least one replacement, so reserve with the best guess\n+        // we can make without actually counting the number of occurences.\n+        str.reserve(origStr.size() - replaceThis.size() + withThis.size());\n+        do {\n+            str.append(origStr, copyBegin, i-copyBegin );\n+            str += withThis;\n+            copyBegin = i + replaceThis.size();\n+            if( copyBegin < origStr.size() )\n+                i = origStr.find( replaceThis, copyBegin );\n             else\n                 i = std::string::npos;\n+        } while( i != std::string::npos );\n+        if ( copyBegin < origStr.size() ) {\n+            str.append(origStr, copyBegin, origStr.size() );\n         }\n-        return replaced;\n+        return true;\n     }\n \n     std::vector<StringRef> splitStringRef( StringRef str, char delimiter ) {\ndiff --git a/src/catch2/internal/catch_stringref.hpp b/src/catch2/internal/catch_stringref.hpp\n--- a/src/catch2/internal/catch_stringref.hpp\n+++ b/src/catch2/internal/catch_stringref.hpp\n@@ -97,8 +97,8 @@ namespace Catch {\n         constexpr const_iterator end() const { return m_start + m_size; }\n \n \n-        friend std::string& operator += (std::string& lhs, StringRef sr);\n-        friend std::ostream& operator << (std::ostream& os, StringRef sr);\n+        friend std::string& operator += (std::string& lhs, StringRef rhs);\n+        friend std::ostream& operator << (std::ostream& os, StringRef str);\n         friend std::string operator+(StringRef lhs, StringRef rhs);\n \n         /**\ndiff --git a/src/catch2/reporters/catch_reporter_console.cpp b/src/catch2/reporters/catch_reporter_console.cpp\n--- a/src/catch2/reporters/catch_reporter_console.cpp\n+++ b/src/catch2/reporters/catch_reporter_console.cpp\n@@ -520,8 +520,8 @@ void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {\n     m_stream << '\\n' << std::flush;\n     StreamingReporterBase::testRunEnded(_testRunStats);\n }\n-void ConsoleReporter::testRunStarting(TestRunInfo const& _testInfo) {\n-    StreamingReporterBase::testRunStarting(_testInfo);\n+void ConsoleReporter::testRunStarting(TestRunInfo const& _testRunInfo) {\n+    StreamingReporterBase::testRunStarting(_testRunInfo);\n     if ( m_config->testSpec().hasFilters() ) {\n         m_stream << m_colour->guardColour( Colour::BrightYellow ) << \"Filters: \"\n                  << m_config->testSpec() << '\\n';\ndiff --git a/src/catch2/reporters/catch_reporter_cumulative_base.cpp b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n--- a/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n+++ b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n@@ -16,8 +16,7 @@ namespace Catch {\n     namespace {\n         struct BySectionInfo {\n             BySectionInfo( SectionInfo const& other ): m_other( other ) {}\n-            BySectionInfo( BySectionInfo const& other ):\n-                m_other( other.m_other ) {}\n+            BySectionInfo( BySectionInfo const& other ) = default;\n             bool operator()(\n                 Detail::unique_ptr<CumulativeReporterBase::SectionNode> const&\n                     node ) const {\ndiff --git a/src/catch2/reporters/catch_reporter_json.cpp b/src/catch2/reporters/catch_reporter_json.cpp\n--- a/src/catch2/reporters/catch_reporter_json.cpp\n+++ b/src/catch2/reporters/catch_reporter_json.cpp\n@@ -133,8 +133,8 @@ namespace Catch {\n         return \"Outputs listings as JSON. Test listing is Work-in-Progress!\";\n     }\n \n-    void JsonReporter::testRunStarting( TestRunInfo const& testInfo ) {\n-        StreamingReporterBase::testRunStarting( testInfo );\n+    void JsonReporter::testRunStarting( TestRunInfo const& runInfo ) {\n+        StreamingReporterBase::testRunStarting( runInfo );\n         endListing();\n \n         assert( isInside( Writer::Object ) );\ndiff --git a/src/catch2/reporters/catch_reporter_junit.cpp b/src/catch2/reporters/catch_reporter_junit.cpp\n--- a/src/catch2/reporters/catch_reporter_junit.cpp\n+++ b/src/catch2/reporters/catch_reporter_junit.cpp\n@@ -74,7 +74,7 @@ namespace Catch {\n \n         static void normalizeNamespaceMarkers(std::string& str) {\n             std::size_t pos = str.find( \"::\" );\n-            while ( pos != str.npos ) {\n+            while ( pos != std::string::npos ) {\n                 str.replace( pos, 2, \".\" );\n                 pos += 1;\n                 pos = str.find( \"::\", pos );\ndiff --git a/src/catch2/reporters/catch_reporter_multi.hpp b/src/catch2/reporters/catch_reporter_multi.hpp\n--- a/src/catch2/reporters/catch_reporter_multi.hpp\n+++ b/src/catch2/reporters/catch_reporter_multi.hpp\n@@ -53,7 +53,7 @@ namespace Catch {\n \n         void assertionEnded( AssertionStats const& assertionStats ) override;\n         void sectionEnded( SectionStats const& sectionStats ) override;\n-        void testCasePartialEnded(TestCaseStats const& testInfo, uint64_t partNumber) override;\n+        void testCasePartialEnded(TestCaseStats const& testStats, uint64_t partNumber) override;\n         void testCaseEnded( TestCaseStats const& testCaseStats ) override;\n         void testRunEnded( TestRunStats const& testRunStats ) override;\n \ndiff --git a/src/catch2/reporters/catch_reporter_sonarqube.hpp b/src/catch2/reporters/catch_reporter_sonarqube.hpp\n--- a/src/catch2/reporters/catch_reporter_sonarqube.hpp\n+++ b/src/catch2/reporters/catch_reporter_sonarqube.hpp\n@@ -37,7 +37,7 @@ namespace Catch {\n             xml.endElement();\n         }\n \n-        void writeRun( TestRunNode const& groupNode );\n+        void writeRun( TestRunNode const& runNode );\n \n         void writeTestFile(StringRef filename, std::vector<TestCaseNode const*> const& testCaseNodes);\n \ndiff --git a/src/catch2/reporters/catch_reporter_teamcity.hpp b/src/catch2/reporters/catch_reporter_teamcity.hpp\n--- a/src/catch2/reporters/catch_reporter_teamcity.hpp\n+++ b/src/catch2/reporters/catch_reporter_teamcity.hpp\n@@ -35,8 +35,8 @@ namespace Catch {\n             return \"Reports test results as TeamCity service messages\"s;\n         }\n \n-        void testRunStarting( TestRunInfo const& groupInfo ) override;\n-        void testRunEnded( TestRunStats const& testGroupStats ) override;\n+        void testRunStarting( TestRunInfo const& runInfo ) override;\n+        void testRunEnded( TestRunStats const& runStats ) override;\n \n \n         void assertionEnded(AssertionStats const& assertionStats) override;\n", "test_patch": "diff --git a/src/catch2/catch_test_case_info.hpp b/src/catch2/catch_test_case_info.hpp\n--- a/src/catch2/catch_test_case_info.hpp\n+++ b/src/catch2/catch_test_case_info.hpp\n@@ -68,7 +68,7 @@ namespace Catch {\n     struct TestCaseInfo : Detail::NonCopyable {\n \n         TestCaseInfo(StringRef _className,\n-                     NameAndTags const& _tags,\n+                     NameAndTags const& _nameAndTags,\n                      SourceLineInfo const& _lineInfo);\n \n         bool isHidden() const;\ndiff --git a/src/catch2/internal/catch_test_registry.hpp b/src/catch2/internal/catch_test_registry.hpp\n--- a/src/catch2/internal/catch_test_registry.hpp\n+++ b/src/catch2/internal/catch_test_registry.hpp\n@@ -95,7 +95,7 @@ struct AutoReg : Detail::NonCopyable {\n namespace Catch {\n     namespace Detail {\n         struct DummyUse {\n-            DummyUse( void ( * )( int ) );\n+            DummyUse( void ( * )( int ), Catch::NameAndTags const& );\n         };\n     } // namespace Detail\n } // namespace Catch\n@@ -107,18 +107,18 @@ namespace Catch {\n // tests can compile. The redefined `TEST_CASE` shadows this with param.\n static int catchInternalSectionHint = 0;\n \n-#    define INTERNAL_CATCH_TESTCASE2( fname )                              \\\n+#    define INTERNAL_CATCH_TESTCASE2( fname, ... )                         \\\n         static void fname( int );                                          \\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \\\n         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                   \\\n         static const Catch::Detail::DummyUse INTERNAL_CATCH_UNIQUE_NAME(   \\\n-            dummyUser )( &(fname) );                                       \\\n+            dummyUser )( &(fname), Catch::NameAndTags{ __VA_ARGS__ } );    \\\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                            \\\n         static void fname( [[maybe_unused]] int catchInternalSectionHint ) \\\n             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n #    define INTERNAL_CATCH_TESTCASE( ... ) \\\n-        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ) )\n+        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ), __VA_ARGS__ )\n \n \n #endif // CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT\ndiff --git a/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp b/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n--- a/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n+++ b/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n@@ -34,7 +34,7 @@ class CumulativeBenchmarkReporter final : public Catch::CumulativeReporterBase {\n         return \"Custom reporter for testing cumulative reporter base\";\n     }\n \n-    virtual void testRunEndedCumulative() override;\n+    void testRunEndedCumulative() override;\n };\n \n CATCH_REGISTER_REPORTER(\"testReporter\", CumulativeBenchmarkReporter)\ndiff --git a/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp b/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n--- a/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n+++ b/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n@@ -36,6 +36,7 @@ class TestReporter : public Catch::StreamingReporterBase {\n \n     void testRunStarting( Catch::TestRunInfo const& ) override {\n         std::vector<std::pair<std::string, std::string>> options;\n+        options.reserve( m_customOptions.size() );\n         for ( auto const& kv : m_customOptions ) {\n             options.push_back( kv );\n         }\ndiff --git a/tests/ExtraTests/X91-AmalgamatedCatch.cpp b/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n--- a/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n+++ b/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n@@ -16,10 +16,10 @@\n TEST_CASE(\"Just a dummy test\") {\n     auto i = GENERATE(1, 2, 3);\n     SECTION(\"a\") {\n-        REQUIRE(1 != 4);\n+        REQUIRE(i != 4);\n     }\n     SECTION(\"b\") {\n-        CHECK(1 != 5);\n+        CHECK(i != 5);\n     }\n     REQUIRE_THAT(1,\n                  Catch::Matchers::Predicate<int>([](int i) {\ndiff --git a/tests/SelfTest/IntrospectiveTests/Details.tests.cpp b/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n@@ -120,13 +120,13 @@ TEST_CASE( \"Optional supports move ops\", \"[optional][approvals]\" ) {\n     }\n     SECTION( \"Move construction from optional\" ) {\n         Optional<MoveChecker> opt_B( CATCH_MOVE( opt_A ) );\n-        REQUIRE( opt_A->has_moved );\n+        REQUIRE( opt_A->has_moved ); // NOLINT(clang-analyzer-cplusplus.Move)\n     }\n     SECTION( \"Move assignment from optional\" ) {\n         Optional<MoveChecker> opt_B( opt_A );\n         REQUIRE_FALSE( opt_A->has_moved );\n         opt_B = CATCH_MOVE( opt_A );\n-        REQUIRE( opt_A->has_moved );\n+        REQUIRE( opt_A->has_moved ); // NOLINT(clang-analyzer-cplusplus.Move)\n     }\n }\n \ndiff --git a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -18,7 +18,6 @@\n #include <catch2/generators/catch_generators_adapters.hpp>\n #include <catch2/generators/catch_generators_random.hpp>\n #include <catch2/generators/catch_generators_range.hpp>\n-#include <catch2/generators/catch_generator_exception.hpp>\n \n // Tests of generator implementation details\n TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\ndiff --git a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n@@ -107,7 +107,7 @@ TEST_CASE( \"Reporter's write listings to provided stream\", \"[reporters]\" ) {\n     for (auto const& factory : factories) {\n         INFO(\"Tested reporter: \" << factory.first);\n         auto sstream = Catch::Detail::make_unique<StringIStream>();\n-        auto& sstreamRef = *sstream.get();\n+        auto& sstreamRef = *sstream;\n \n         Catch::ConfigData cfg_data;\n         cfg_data.rngSeed = 1234;\ndiff --git a/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp b/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n@@ -57,6 +57,17 @@ TEST_CASE(\"replaceInPlace\", \"[string-manip]\") {\n         CHECK_FALSE(Catch::replaceInPlace(letters, \"x\", \"z\"));\n         CHECK(letters == letters);\n     }\n+    SECTION(\"no replace in already-replaced string\") {\n+        SECTION(\"lengthening\") {\n+            CHECK(Catch::replaceInPlace(letters, \"c\", \"cc\"));\n+            CHECK(letters == \"abccdefccg\");\n+        }\n+        SECTION(\"shortening\") {\n+            std::string s = \"----\";\n+            CHECK(Catch::replaceInPlace(s, \"--\", \"-\"));\n+            CHECK(s == \"--\");\n+        }\n+    }\n     SECTION(\"escape '\") {\n         std::string s = \"didn't\";\n         CHECK(Catch::replaceInPlace(s, \"'\", \"|'\"));\ndiff --git a/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp b/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n@@ -236,7 +236,7 @@ TEST_CASE( \"Parse test names and tags\", \"[command-line][test-spec][approvals]\" )\n         CHECK( spec.matches( *tcD ) == false );\n     }\n     SECTION( \"two wildcarded names\" ) {\n-        TestSpec spec = parseTestSpec( \"\\\"longer*\\\"\\\"*spaces\\\"\" );\n+        TestSpec spec = parseTestSpec( R\"(\"longer*\"\"*spaces\")\" );\n         CHECK( spec.hasFilters() == true );\n         CHECK( spec.matches( *tcA ) == false );\n         CHECK( spec.matches( *tcB ) == false );\ndiff --git a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n@@ -152,7 +152,7 @@ TEST_CASE( \"TextFlow::Column respects indentation for empty lines\",\n \n     std::string written = as_written(col);\n \n-    REQUIRE(as_written(col) == \"  \\n  \\n  third line\");\n+    REQUIRE(written == \"  \\n  \\n  third line\");\n }\n \n TEST_CASE( \"TextFlow::Column leading/trailing whitespace\",\ndiff --git a/tests/SelfTest/UsageTests/Benchmark.tests.cpp b/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n--- a/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n@@ -90,14 +90,14 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n         };\n         REQUIRE(v.size() == size);\n \n-        int array[size];\n+        int array[size] {};\n         BENCHMARK(\"A fixed size array that should require no allocations\") {\n             for (int i = 0; i < size; ++i)\n                 array[i] = i;\n         };\n         int sum = 0;\n-        for (int i = 0; i < size; ++i)\n-            sum += array[i];\n+        for (int val : array)\n+            sum += val;\n         REQUIRE(sum > size);\n \n         SECTION(\"XYZ\") {\n@@ -121,8 +121,8 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n                 runs = benchmarkIndex;\n             };\n \n-            for (size_t i = 0; i < v.size(); ++i) {\n-                REQUIRE(v[i] == runs);\n+            for (int val : v) {\n+                REQUIRE(val == runs);\n             }\n         }\n     }\n@@ -135,8 +135,8 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n             for (int i = 0; i < size; ++i)\n                 v[i] = generated;\n         };\n-        for (size_t i = 0; i < v.size(); ++i) {\n-            REQUIRE(v[i] == generated);\n+        for (int val : v) {\n+            REQUIRE(val == generated);\n         }\n     }\n \ndiff --git a/tests/SelfTest/UsageTests/Class.tests.cpp b/tests/SelfTest/UsageTests/Class.tests.cpp\n--- a/tests/SelfTest/UsageTests/Class.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Class.tests.cpp\n@@ -39,7 +39,7 @@ namespace {\n     };\n \n     template <typename T> struct Template_Fixture_2 {\n-        Template_Fixture_2() {}\n+        Template_Fixture_2() = default;\n \n         T m_a;\n     };\ndiff --git a/tests/SelfTest/UsageTests/Exception.tests.cpp b/tests/SelfTest/UsageTests/Exception.tests.cpp\n--- a/tests/SelfTest/UsageTests/Exception.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Exception.tests.cpp\n@@ -119,7 +119,7 @@ TEST_CASE( \"When unchecked exceptions are thrown, but caught, they do not affect\n     try {\n         throw std::domain_error( \"unexpected exception\" );\n     }\n-    catch(...) {}\n+    catch(...) {} // NOLINT(bugprone-empty-catch)\n }\n \n \n@@ -152,7 +152,7 @@ TEST_CASE( \"Custom exceptions can be translated when testing for throwing as som\n }\n \n TEST_CASE( \"Unexpected exceptions can be translated\", \"[.][failing][!throws]\"  ) {\n-    throw double( 3.14 );\n+    throw double( 3.14 ); // NOLINT(readability-redundant-casting): the type is important here, so we want to be explicit\n }\n \n TEST_CASE(\"Thrown string literals are translated\", \"[.][failing][!throws]\") {\ndiff --git a/tests/SelfTest/UsageTests/Matchers.tests.cpp b/tests/SelfTest/UsageTests/Matchers.tests.cpp\n--- a/tests/SelfTest/UsageTests/Matchers.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Matchers.tests.cpp\n@@ -1027,7 +1027,6 @@ TEST_CASE( \"Combining MatchNotOfGeneric does not nest\",\n }\n \n struct EvilAddressOfOperatorUsed : std::exception {\n-    EvilAddressOfOperatorUsed() {}\n     const char* what() const noexcept override {\n         return \"overloaded address-of operator of matcher was used instead of \"\n                \"std::addressof\";\n@@ -1035,7 +1034,6 @@ struct EvilAddressOfOperatorUsed : std::exception {\n };\n \n struct EvilCommaOperatorUsed : std::exception {\n-    EvilCommaOperatorUsed() {}\n     const char* what() const noexcept override {\n         return \"overloaded comma operator of matcher was used\";\n     }\n@@ -1073,7 +1071,6 @@ struct ImmovableMatcher : Catch::Matchers::MatcherGenericBase {\n };\n \n struct MatcherWasMovedOrCopied : std::exception {\n-    MatcherWasMovedOrCopied() {}\n     const char* what() const noexcept override {\n         return \"attempted to copy or move a matcher\";\n     }\n@@ -1081,17 +1078,20 @@ struct MatcherWasMovedOrCopied : std::exception {\n \n struct ThrowOnCopyOrMoveMatcher : Catch::Matchers::MatcherGenericBase {\n     ThrowOnCopyOrMoveMatcher() = default;\n-    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher const& ):\n-        Catch::Matchers::MatcherGenericBase() {\n+\n+    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher const& other ):\n+        Catch::Matchers::MatcherGenericBase( other ) {\n         throw MatcherWasMovedOrCopied();\n     }\n-    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher&& ):\n-        Catch::Matchers::MatcherGenericBase() {\n+    // NOLINTNEXTLINE(performance-noexcept-move-constructor)\n+    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher&& other ):\n+        Catch::Matchers::MatcherGenericBase( CATCH_MOVE(other) ) {\n         throw MatcherWasMovedOrCopied();\n     }\n     ThrowOnCopyOrMoveMatcher& operator=( ThrowOnCopyOrMoveMatcher const& ) {\n         throw MatcherWasMovedOrCopied();\n     }\n+    // NOLINTNEXTLINE(performance-noexcept-move-constructor)\n     ThrowOnCopyOrMoveMatcher& operator=( ThrowOnCopyOrMoveMatcher&& ) {\n         throw MatcherWasMovedOrCopied();\n     }\ndiff --git a/tests/SelfTest/UsageTests/Message.tests.cpp b/tests/SelfTest/UsageTests/Message.tests.cpp\n--- a/tests/SelfTest/UsageTests/Message.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Message.tests.cpp\n@@ -80,20 +80,20 @@ TEST_CASE( \"Output from all sections is reported\", \"[failing][messages][.]\" ) {\n \n TEST_CASE( \"Standard output from all sections is reported\", \"[messages][.]\" ) {\n     SECTION( \"one\" ) {\n-        std::cout << \"Message from section one\" << std::endl;\n+        std::cout << \"Message from section one\\n\";\n     }\n \n     SECTION( \"two\" ) {\n-        std::cout << \"Message from section two\" << std::endl;\n+        std::cout << \"Message from section two\\n\";\n     }\n }\n \n TEST_CASE( \"Standard error is reported and redirected\", \"[messages][.][approvals]\" ) {\n     SECTION( \"std::cerr\" ) {\n-        std::cerr << \"Write to std::cerr\" << std::endl;\n+        std::cerr << \"Write to std::cerr\\n\";\n     }\n     SECTION( \"std::clog\" ) {\n-        std::clog << \"Write to std::clog\" << std::endl;\n+        std::clog << \"Write to std::clog\\n\";\n     }\n     SECTION( \"Interleaved writes to cerr and clog\" ) {\n         std::cerr << \"Inter\";\n@@ -101,7 +101,7 @@ TEST_CASE( \"Standard error is reported and redirected\", \"[messages][.][approvals\n         std::cerr << ' ';\n         std::clog << \"writes\";\n         std::cerr << \" to error\";\n-        std::clog << \" streams\" << std::endl;\n+        std::clog << \" streams\\n\" << std::flush;\n     }\n }\n \ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -158,9 +158,9 @@ TEST_CASE( \"looped tests\", \"[.][failing]\" ) {\n }\n \n TEST_CASE( \"Sends stuff to stdout and stderr\", \"[.]\" ) {\n-    std::cout << \"A string sent directly to stdout\" << std::endl;\n-    std::cerr << \"A string sent directly to stderr\" << std::endl;\n-    std::clog << \"A string sent to stderr via clog\" << std::endl;\n+    std::cout << \"A string sent directly to stdout\\n\" << std::flush;\n+    std::cerr << \"A string sent directly to stderr\\n\" << std::flush;\n+    std::clog << \"A string sent to stderr via clog\\n\" << std::flush;\n }\n \n TEST_CASE( \"null strings\" ) {\n@@ -396,7 +396,7 @@ TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product\n using MyTypes = std::tuple<int, char, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_arithmetic<TestType>::value);\n }\n \n struct NonDefaultConstructibleType {\n@@ -406,7 +406,7 @@ struct NonDefaultConstructibleType {\n using MyNonDefaultConstructibleTypes = std::tuple<NonDefaultConstructibleType, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside non-default-constructible std::tuple\", \"[template][list]\", MyNonDefaultConstructibleTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_trivially_copyable<TestType>::value);\n }\n \n struct NonCopyableAndNonMovableType {\n@@ -421,7 +421,7 @@ struct NonCopyableAndNonMovableType {\n using NonCopyableAndNonMovableTypes = std::tuple<NonCopyableAndNonMovableType, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside non-copyable and non-movable std::tuple\", \"[template][list]\", NonCopyableAndNonMovableTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_default_constructible<TestType>::value);\n }\n \n // https://github.com/philsquared/Catch/issues/166\ndiff --git a/tests/SelfTest/UsageTests/Tricky.tests.cpp b/tests/SelfTest/UsageTests/Tricky.tests.cpp\n--- a/tests/SelfTest/UsageTests/Tricky.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Tricky.tests.cpp\n@@ -261,7 +261,7 @@ TEST_CASE( \"non streamable - with conv. op\", \"[Tricky]\" )\n \n inline void foo() {}\n \n-typedef void (*fooptr_t)();\n+using fooptr_t = void (*)();\n \n TEST_CASE( \"Comparing function pointers\", \"[Tricky][function pointer]\" )\n {\n@@ -281,7 +281,7 @@ struct S\n \n TEST_CASE( \"Comparing member function pointers\", \"[Tricky][member function pointer][approvals]\" )\n {\n-    typedef void (S::*MF)();\n+    using MF = void (S::*)();\n     MF m = &S::f;\n \n     CHECK( m == &S::f );\n", "problem_statement": "Wunused-variable in (DYNAMIC_)SECTION when CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT is enabled\n**Describe the bug**\r\n\r\nIn static analysis mode, the argument of `SECTION`/`DYNAMIC_SECTION` is not evaluated. If it contains\r\na variable that is used only there, it'll lead to `Wunused-variable` warning.\r\n\r\n\r\n**Expected behavior**\r\nNo warning\r\n\r\n**Reproduction steps**\r\n\r\nhttps://compiler-explorer.com/z/K9fxKGaz4\r\n\r\n**Platform information:**\r\n - Compiler+version: clang (clang-tidy)\r\n - Catch version: devel\r\n\n", "hints_text": "", "created_at": "2024-02-19T17:20:35Z", "version": "3.5"}
{"repo": "catchorg/Catch2", "pull_number": 1616, "instance_id": "catchorg__Catch2-1616", "issue_numbers": ["1186"], "base_commit": "00347f1e79260e76d5072cca5b3636868397dda5", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -53,7 +53,6 @@\n #include \"internal/catch_test_registry.h\"\n #include \"internal/catch_capture.hpp\"\n #include \"internal/catch_section.h\"\n-#include \"internal/catch_benchmark.h\"\n #include \"internal/catch_interfaces_exception.h\"\n #include \"internal/catch_approx.h\"\n #include \"internal/catch_compiler_capabilities.h\"\n@@ -79,6 +78,10 @@\n #include \"internal/catch_external_interfaces.h\"\n #endif\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#include \"internal/benchmark/catch_benchmark.hpp\"\n+#endif\n+\n #endif // ! CATCH_CONFIG_IMPL_ONLY\n \n #ifdef CATCH_IMPL\n@@ -89,6 +92,7 @@\n #include \"internal/catch_default_main.hpp\"\n #endif\n \n+\n #if !defined(CATCH_CONFIG_IMPL_ONLY)\n \n #ifdef CLARA_CONFIG_MAIN_NOT_DEFINED\n@@ -188,6 +192,13 @@\n #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#define CATCH_BENCHMARK(...) \\\n+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))\n+#define CATCH_BENCHMARK_ADVANCED(name) \\\n+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required\n #else\n \n@@ -283,6 +294,13 @@\n #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#define BENCHMARK(...) \\\n+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))\n+#define BENCHMARK_ADVANCED(name) \\\n+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n using Catch::Detail::Approx;\n \n #else // CATCH_CONFIG_DISABLE\ndiff --git a/include/internal/benchmark/catch_benchmark.hpp b/include/internal/benchmark/catch_benchmark.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_benchmark.hpp\n@@ -0,0 +1,122 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Benchmark\n+#ifndef TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\n+\n+#include \"../catch_config.hpp\"\n+#include \"../catch_context.h\"\n+#include \"../catch_interfaces_reporter.h\"\n+#include \"../catch_test_registry.h\"\n+\n+#include \"catch_chronometer.hpp\"\n+#include \"catch_clock.hpp\"\n+#include \"catch_environment.hpp\"\n+#include \"catch_execution_plan.hpp\"\n+#include \"detail/catch_estimate_clock.hpp\"\n+#include \"detail/catch_complete_invoke.hpp\"\n+#include \"detail/catch_analyse.hpp\"\n+#include \"detail/catch_benchmark_function.hpp\"\n+#include \"detail/catch_run_for_at_least.hpp\"\n+\n+#include <algorithm>\n+#include <functional>\n+#include <string>\n+#include <vector>\n+#include <cmath>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        struct Benchmark {\n+            Benchmark(std::string &&name)\n+                : name(std::move(name)) {}\n+\n+            template <class FUN>\n+            Benchmark(std::string &&name, FUN &&func)\n+                : fun(std::move(func)), name(std::move(name)) {}\n+\n+            template <typename Clock>\n+            ExecutionPlan<FloatDuration<Clock>> prepare(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {\n+                auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;\n+                auto run_time = std::max(min_time, std::chrono::duration_cast<decltype(min_time)>(Detail::warmup_time));\n+                auto&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(run_time), 1, fun);\n+                int new_iters = static_cast<int>(std::ceil(min_time * test.iterations / test.elapsed));\n+                return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FloatDuration<Clock>>(Detail::warmup_time), Detail::warmup_iterations };\n+            }\n+\n+            template <typename Clock = default_clock>\n+            void run() {\n+                IConfigPtr cfg = getCurrentContext().getConfig();\n+\n+                auto env = Detail::measure_environment<Clock>();\n+\n+                getResultCapture().benchmarkPreparing(name);\n+                CATCH_TRY{\n+                    auto plan = user_code([&] {\n+                        return prepare<Clock>(*cfg, env);\n+                    });\n+\n+                    BenchmarkInfo info {\n+                        name,\n+                        plan.estimated_duration.count(),\n+                        plan.iterations_per_sample,\n+                        cfg->benchmarkSamples(),\n+                        cfg->benchmarkResamples(),\n+                        env.clock_resolution.mean.count(),\n+                        env.clock_cost.mean.count()\n+                    };\n+\n+                    getResultCapture().benchmarkStarting(info);\n+\n+                    auto samples = user_code([&] {\n+                        return plan.template run<Clock>(*cfg, env);\n+                    });\n+\n+                    auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());\n+                    BenchmarkStats<std::chrono::duration<double, std::nano>> stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };\n+                    getResultCapture().benchmarkEnded(stats);\n+\n+                } CATCH_CATCH_ALL{\n+                    if (translateActiveException() != Detail::benchmarkErrorMsg) // benchmark errors have been reported, otherwise rethrow.\n+                        std::rethrow_exception(std::current_exception());\n+                }\n+            }\n+\n+            // sets lambda to be used in fun *and* executes benchmark!\n+            template <typename Fun,\n+                typename std::enable_if<!Detail::is_related<Fun, Benchmark>::value, int>::type = 0>\n+                Benchmark & operator=(Fun func) {\n+                fun = Detail::BenchmarkFunction(func);\n+                run();\n+                return *this;\n+            }\n+\n+            explicit operator bool() {\n+                return true;\n+            }\n+\n+        private:\n+            Detail::BenchmarkFunction fun;\n+            std::string name;\n+        };\n+    }\n+} // namespace Catch\n+\n+#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1\n+#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2\n+\n+#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\\\n+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \\\n+        BenchmarkName = [&](int benchmarkIndex)\n+\n+#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\\\n+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \\\n+        BenchmarkName = [&]\n+\n+#endif // TWOBLUECUBES_CATCH_BENCHMARK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_chronometer.hpp b/include/internal/benchmark/catch_chronometer.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_chronometer.hpp\n@@ -0,0 +1,71 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// User-facing chronometer\n+\n+#ifndef TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_optimizer.hpp\"\n+#include \"detail/catch_complete_invoke.hpp\"\n+#include \"../catch_meta.hpp\"\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            struct ChronometerConcept {\n+                virtual void start() = 0;\n+                virtual void finish() = 0;\n+                virtual ~ChronometerConcept() = default;\n+            };\n+            template <typename Clock>\n+            struct ChronometerModel final : public ChronometerConcept {\n+                void start() override { started = Clock::now(); }\n+                void finish() override { finished = Clock::now(); }\n+\n+                ClockDuration<Clock> elapsed() const { return finished - started; }\n+\n+                TimePoint<Clock> started;\n+                TimePoint<Clock> finished;\n+            };\n+        } // namespace Detail\n+\n+        struct Chronometer {\n+        public:\n+            template <typename Fun>\n+            void measure(Fun&& fun) { measure(std::forward<Fun>(fun), is_callable<Fun(int)>()); }\n+\n+            int runs() const { return k; }\n+\n+            Chronometer(Detail::ChronometerConcept& meter, int k)\n+                : impl(&meter)\n+                , k(k) {}\n+\n+        private:\n+            template <typename Fun>\n+            void measure(Fun&& fun, std::false_type) {\n+                measure([&fun](int) { return fun(); }, std::true_type());\n+            }\n+\n+            template <typename Fun>\n+            void measure(Fun&& fun, std::true_type) {\n+                Detail::optimizer_barrier();\n+                impl->start();\n+                for (int i = 0; i < k; ++i) invoke_deoptimized(fun, i);\n+                impl->finish();\n+                Detail::optimizer_barrier();\n+            }\n+\n+            Detail::ChronometerConcept* impl;\n+            int k;\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_CHRONOMETER_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_clock.hpp b/include/internal/benchmark/catch_clock.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_clock.hpp\n@@ -0,0 +1,40 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Clocks\n+\n+#ifndef TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\n+\n+#include <chrono>\n+#include <ratio>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Clock>\n+        using ClockDuration = typename Clock::duration;\n+        template <typename Clock>\n+        using FloatDuration = std::chrono::duration<double, typename Clock::period>;\n+\n+        template <typename Clock>\n+        using TimePoint = typename Clock::time_point;\n+\n+        using default_clock = std::chrono::steady_clock;\n+\n+        template <typename Clock>\n+        struct now {\n+            TimePoint<Clock> operator()() const {\n+                return Clock::now();\n+            }\n+        };\n+\n+        using fp_seconds = std::chrono::duration<double, std::ratio<1>>;\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_CLOCK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_constructor.hpp b/include/internal/benchmark/catch_constructor.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_constructor.hpp\n@@ -0,0 +1,73 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Constructor and destructor helpers\n+\n+#ifndef TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\n+\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Detail {\n+        template <typename T, bool Destruct>\n+        struct ObjectStorage\n+        {\n+            using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;\n+\n+            ObjectStorage() : data() {}\n+\n+            ObjectStorage(const ObjectStorage& other)\n+            {\n+                new(&data) T(other.stored_object());\n+            }\n+\n+            ObjectStorage(ObjectStorage&& other)\n+            {\n+                new(&data) T(std::move(other.stored_object()));\n+            }\n+\n+            ~ObjectStorage() { destruct_on_exit<T>(); }\n+\n+            template <typename... Args>\n+            void construct(Args&&... args)\n+            {\n+                new (&data) T(std::forward<Args>(args)...);\n+            }\n+\n+            template <bool AllowManualDestruction = !Destruct>\n+            typename std::enable_if<AllowManualDestruction>::type destruct()\n+            {\n+                stored_object().~T();\n+            }\n+\n+        private:\n+            // If this is a constructor benchmark, destruct the underlying object\n+            template <typename U>\n+            void destruct_on_exit(typename std::enable_if<Destruct, U>::type* = 0) { destruct<true>(); }\n+            // Otherwise, don't\n+            template <typename U>\n+            void destruct_on_exit(typename std::enable_if<!Destruct, U>::type* = 0) { }\n+\n+            T& stored_object()\n+            {\n+                return *static_cast<T*>(static_cast<void*>(&data));\n+            }\n+\n+            TStorage data;\n+        };\n+    }\n+\n+    template <typename T>\n+    using storage_for = Detail::ObjectStorage<T, true>;\n+\n+    template <typename T>\n+    using destructable_object = Detail::ObjectStorage<T, false>;\n+}\n+\n+#endif // TWOBLUECUBES_CATCH_CONSTRUCTOR_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_environment.hpp b/include/internal/benchmark/catch_environment.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_environment.hpp\n@@ -0,0 +1,38 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Environment information\n+\n+#ifndef TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_outlier_classification.hpp\"\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct EnvironmentEstimate {\n+            Duration mean;\n+            OutlierClassification outliers;\n+\n+            template <typename Duration2>\n+            operator EnvironmentEstimate<Duration2>() const {\n+                return { mean, outliers };\n+            }\n+        };\n+        template <typename Clock>\n+        struct Environment {\n+            using clock_type = Clock;\n+            EnvironmentEstimate<FloatDuration<Clock>> clock_resolution;\n+            EnvironmentEstimate<FloatDuration<Clock>> clock_cost;\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_ENVIRONMENT_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_estimate.hpp b/include/internal/benchmark/catch_estimate.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_estimate.hpp\n@@ -0,0 +1,31 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Statistics estimates\n+\n+#ifndef TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct Estimate {\n+            Duration point;\n+            Duration lower_bound;\n+            Duration upper_bound;\n+            double confidence_interval;\n+\n+            template <typename Duration2>\n+            operator Estimate<Duration2>() const {\n+                return { point, lower_bound, upper_bound, confidence_interval };\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_ESTIMATE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_execution_plan.hpp b/include/internal/benchmark/catch_execution_plan.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_execution_plan.hpp\n@@ -0,0 +1,58 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Execution plan\n+\n+#ifndef TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\n+\n+#include \"../catch_config.hpp\"\n+#include \"catch_clock.hpp\"\n+#include \"catch_environment.hpp\"\n+#include \"detail/catch_benchmark_function.hpp\"\n+#include \"detail/catch_repeat.hpp\"\n+#include \"detail/catch_run_for_at_least.hpp\"\n+\n+#include <algorithm>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct ExecutionPlan {\n+            int iterations_per_sample;\n+            Duration estimated_duration;\n+            Detail::BenchmarkFunction benchmark;\n+            Duration warmup_time;\n+            int warmup_iterations;\n+\n+            template <typename Duration2>\n+            operator ExecutionPlan<Duration2>() const {\n+                return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };\n+            }\n+\n+            template <typename Clock>\n+            std::vector<FloatDuration<Clock>> run(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {\n+                // warmup a bit\n+                Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_iterations, Detail::repeat(now<Clock>{}));\n+\n+                std::vector<FloatDuration<Clock>> times;\n+                times.reserve(cfg.benchmarkSamples());\n+                std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {\n+                    Detail::ChronometerModel<Clock> model;\n+                    this->benchmark(Chronometer(model, iterations_per_sample));\n+                    auto sample_time = model.elapsed() - env.clock_cost.mean;\n+                    if (sample_time < FloatDuration<Clock>::zero()) sample_time = FloatDuration<Clock>::zero();\n+                    return sample_time / iterations_per_sample;\n+                });\n+                return times;\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_EXECUTION_PLAN_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_optimizer.hpp b/include/internal/benchmark/catch_optimizer.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_optimizer.hpp\n@@ -0,0 +1,68 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Hinting the optimizer\n+\n+#ifndef TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\n+\n+#if defined(_MSC_VER)\n+#   include <atomic> // atomic_thread_fence\n+#endif\n+\n+namespace Catch {\n+    namespace Benchmark {\n+#if defined(__GNUC__) || defined(__clang__)\n+        template <typename T>\n+        inline void keep_memory(T* p) {\n+            asm volatile(\"\" : : \"g\"(p) : \"memory\");\n+        }\n+        inline void keep_memory() {\n+            asm volatile(\"\" : : : \"memory\");\n+        }\n+\n+        namespace Detail {\n+            inline void optimizer_barrier() { keep_memory(); }\n+        } // namespace Detail\n+#elif defined(_MSC_VER)\n+\n+#pragma optimize(\"\", off)\n+        template <typename T>\n+        inline void keep_memory(T* p) {\n+            // thanks @milleniumbug\n+            *reinterpret_cast<char volatile*>(p) = *reinterpret_cast<char const volatile*>(p);\n+        }\n+        // TODO equivalent keep_memory()\n+#pragma optimize(\"\", on)\n+\n+        namespace Detail {\n+            inline void optimizer_barrier() {\n+                std::atomic_thread_fence(std::memory_order_seq_cst);\n+            }\n+        } // namespace Detail\n+\n+#endif\n+\n+        template <typename T>\n+        inline void deoptimize_value(T&& x) {\n+            keep_memory(&x);\n+        }\n+\n+        template <typename Fn, typename... Args>\n+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<!std::is_same<void, decltype(fn(args...))>::value>::type {\n+            deoptimize_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));\n+        }\n+\n+        template <typename Fn, typename... Args>\n+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<std::is_same<void, decltype(fn(args...))>::value>::type {\n+            std::forward<Fn>(fn) (std::forward<Args...>(args...));\n+        }\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_OPTIMIZER_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_outlier_classification.hpp b/include/internal/benchmark/catch_outlier_classification.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_outlier_classification.hpp\n@@ -0,0 +1,29 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Outlier information\n+#ifndef TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        struct OutlierClassification {\n+            int samples_seen = 0;\n+            int low_severe = 0;     // more than 3 times IQR below Q1\n+            int low_mild = 0;       // 1.5 to 3 times IQR below Q1\n+            int high_mild = 0;      // 1.5 to 3 times IQR above Q3\n+            int high_severe = 0;    // more than 3 times IQR above Q3\n+\n+            int total() const {\n+                return low_severe + low_mild + high_mild + high_severe;\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_OUTLIERS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/catch_sample_analysis.hpp b/include/internal/benchmark/catch_sample_analysis.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/catch_sample_analysis.hpp\n@@ -0,0 +1,50 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Benchmark results\n+\n+#ifndef TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\n+\n+#include \"catch_clock.hpp\"\n+#include \"catch_estimate.hpp\"\n+#include \"catch_outlier_classification.hpp\"\n+\n+#include <algorithm>\n+#include <vector>\n+#include <string>\n+#include <iterator>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration>\n+        struct SampleAnalysis {\n+            std::vector<Duration> samples;\n+            Estimate<Duration> mean;\n+            Estimate<Duration> standard_deviation;\n+            OutlierClassification outliers;\n+            double outlier_variance;\n+\n+            template <typename Duration2>\n+            operator SampleAnalysis<Duration2>() const {\n+                std::vector<Duration2> samples2;\n+                samples2.reserve(samples.size());\n+                std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });\n+                return {\n+                    std::move(samples2),\n+                    mean,\n+                    standard_deviation,\n+                    outliers,\n+                    outlier_variance,\n+                };\n+            }\n+        };\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_BENCHMARK_RESULTS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_analyse.hpp b/include/internal/benchmark/detail/catch_analyse.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_analyse.hpp\n@@ -0,0 +1,78 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Run and analyse one benchmark\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_sample_analysis.hpp\"\n+#include \"catch_stats.hpp\"\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <vector>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Duration, typename Iterator>\n+            SampleAnalysis<Duration> analyse(const IConfig &cfg, Environment<Duration>, Iterator first, Iterator last) {\n+                if (!cfg.benchmarkNoAnalysis()) {\n+                    std::vector<double> samples;\n+                    samples.reserve(last - first);\n+                    std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });\n+\n+                    auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());\n+                    auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());\n+\n+                    auto wrap_estimate = [](Estimate<double> e) {\n+                        return Estimate<Duration> {\n+                            Duration(e.point),\n+                                Duration(e.lower_bound),\n+                                Duration(e.upper_bound),\n+                                e.confidence_interval,\n+                        };\n+                    };\n+                    std::vector<Duration> samples2;\n+                    samples2.reserve(samples.size());\n+                    std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });\n+                    return {\n+                        std::move(samples2),\n+                        wrap_estimate(analysis.mean),\n+                        wrap_estimate(analysis.standard_deviation),\n+                        outliers,\n+                        analysis.outlier_variance,\n+                    };\n+                } else {\n+                    std::vector<Duration> samples; \n+                    samples.reserve(last - first);\n+\n+                    Duration mean = Duration(0);\n+                    int i = 0;\n+                    for (auto it = first; it < last; ++it, ++i) {\n+                        samples.push_back(Duration(*it));\n+                        mean += Duration(*it);\n+                    }\n+                    mean /= i;\n+\n+                    return {\n+                        std::move(samples),\n+                        Estimate<Duration>{mean, mean, mean, 0.0},\n+                        Estimate<Duration>{Duration(0), Duration(0), Duration(0), 0.0},\n+                        OutlierClassification{},\n+                        0.0\n+                    };\n+                }\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ANALYSE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_benchmark_function.hpp b/include/internal/benchmark/detail/catch_benchmark_function.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_benchmark_function.hpp\n@@ -0,0 +1,105 @@\n+    /*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Dumb std::function implementation for consistent call overhead\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\n+\n+#include \"../catch_chronometer.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"../../catch_meta.hpp\"\n+\n+#include <cassert>\n+#include <type_traits>\n+#include <utility>\n+#include <memory>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename T>\n+            using Decay = typename std::decay<T>::type;\n+            template <typename T, typename U>\n+            struct is_related\n+                : std::is_same<Decay<T>, Decay<U>> {};\n+\n+            /// We need to reinvent std::function because every piece of code that might add overhead\n+            /// in a measurement context needs to have consistent performance characteristics so that we\n+            /// can account for it in the measurement.\n+            /// Implementations of std::function with optimizations that aren't always applicable, like\n+            /// small buffer optimizations, are not uncommon.\n+            /// This is effectively an implementation of std::function without any such optimizations;\n+            /// it may be slow, but it is consistently slow.\n+            struct BenchmarkFunction {\n+            private:\n+                struct callable {\n+                    virtual void call(Chronometer meter) const = 0;\n+                    virtual callable* clone() const = 0;\n+                    virtual ~callable() = default;\n+                };\n+                template <typename Fun>\n+                struct model : public callable {\n+                    model(Fun&& fun) : fun(std::move(fun)) {}\n+                    model(Fun const& fun) : fun(fun) {}\n+\n+                    model<Fun>* clone() const override { return new model<Fun>(*this); }\n+\n+                    void call(Chronometer meter) const override {\n+                        call(meter, is_callable<Fun(Chronometer)>());\n+                    }\n+                    void call(Chronometer meter, std::true_type) const {\n+                        fun(meter);\n+                    }\n+                    void call(Chronometer meter, std::false_type) const {\n+                        meter.measure(fun);\n+                    }\n+\n+                    Fun fun;\n+                };\n+\n+                struct do_nothing { void operator()() const {} };\n+\n+                template <typename T>\n+                BenchmarkFunction(model<T>* c) : f(c) {}\n+\n+            public:\n+                BenchmarkFunction()\n+                    : f(new model<do_nothing>{ {} }) {}\n+\n+                template <typename Fun,\n+                    typename std::enable_if<!is_related<Fun, BenchmarkFunction>::value, int>::type = 0>\n+                    BenchmarkFunction(Fun&& fun)\n+                    : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) {}\n+\n+                BenchmarkFunction(BenchmarkFunction&& that)\n+                    : f(std::move(that.f)) {}\n+\n+                BenchmarkFunction(BenchmarkFunction const& that)\n+                    : f(that.f->clone()) {}\n+\n+                BenchmarkFunction& operator=(BenchmarkFunction&& that) {\n+                    f = std::move(that.f);\n+                    return *this;\n+                }\n+\n+                BenchmarkFunction& operator=(BenchmarkFunction const& that) {\n+                    f.reset(that.f->clone());\n+                    return *this;\n+                }\n+\n+                void operator()(Chronometer meter) const { f->call(meter); }\n+\n+            private:\n+                std::unique_ptr<callable> f;\n+            };\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_BENCHMARK_FUNCTION_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_complete_invoke.hpp b/include/internal/benchmark/detail/catch_complete_invoke.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_complete_invoke.hpp\n@@ -0,0 +1,69 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Invoke with a special case for void\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\n+\n+#include \"../../catch_enforce.h\"\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename T>\n+            struct CompleteType { using type = T; };\n+            template <>\n+            struct CompleteType<void> { struct type {}; };\n+\n+            template <typename T>\n+            using CompleteType_t = typename CompleteType<T>::type;\n+\n+            template <typename Result>\n+            struct CompleteInvoker {\n+                template <typename Fun, typename... Args>\n+                static Result invoke(Fun&& fun, Args&&... args) {\n+                    return std::forward<Fun>(fun)(std::forward<Args>(args)...);\n+                }\n+            };\n+            template <>\n+            struct CompleteInvoker<void> {\n+                template <typename Fun, typename... Args>\n+                static CompleteType_t<void> invoke(Fun&& fun, Args&&... args) {\n+                    std::forward<Fun>(fun)(std::forward<Args>(args)...);\n+                    return {};\n+                }\n+            };\n+            template <typename Sig>\n+            using ResultOf_t = typename std::result_of<Sig>::type;\n+\n+            // invoke and not return void :(\n+            template <typename Fun, typename... Args>\n+            CompleteType_t<ResultOf_t<Fun(Args...)>> complete_invoke(Fun&& fun, Args&&... args) {\n+                return CompleteInvoker<ResultOf_t<Fun(Args...)>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);\n+            }\n+\n+            const std::string benchmarkErrorMsg = \"a benchmark failed to run successfully\";\n+        } // namespace Detail\n+\n+        template <typename Fun>\n+        Detail::CompleteType_t<Detail::ResultOf_t<Fun()>> user_code(Fun&& fun) {\n+            CATCH_TRY{\n+                return Detail::complete_invoke(std::forward<Fun>(fun));\n+            } CATCH_CATCH_ALL{\n+                getResultCapture().benchmarkFailed(translateActiveException());\n+                CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);\n+            }\n+        }\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_COMPLETE_INVOKE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_estimate_clock.hpp b/include/internal/benchmark/detail/catch_estimate_clock.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_estimate_clock.hpp\n@@ -0,0 +1,113 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+ // Environment measurement\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_environment.hpp\"\n+#include \"catch_stats.hpp\"\n+#include \"catch_measure.hpp\"\n+#include \"catch_run_for_at_least.hpp\"\n+#include \"../catch_clock.hpp\"\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <tuple>\n+#include <vector>\n+#include <cmath>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock>\n+            std::vector<double> resolution(int k) {\n+                std::vector<TimePoint<Clock>> times;\n+                times.reserve(k + 1);\n+                std::generate_n(std::back_inserter(times), k + 1, now<Clock>{});\n+\n+                std::vector<double> deltas;\n+                deltas.reserve(k);\n+                std::transform(std::next(times.begin()), times.end(), times.begin(),\n+                    std::back_inserter(deltas),\n+                    [](TimePoint<Clock> a, TimePoint<Clock> b) { return static_cast<double>((a - b).count()); });\n+\n+                return deltas;\n+            }\n+\n+            const auto warmup_iterations = 10000;\n+            const auto warmup_time = std::chrono::milliseconds(100);\n+            const auto minimum_ticks = 1000;\n+            const auto warmup_seed = 10000;\n+            const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);\n+            const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);\n+            const auto clock_cost_estimation_tick_limit = 100000;\n+            const auto clock_cost_estimation_time = std::chrono::milliseconds(10);\n+            const auto clock_cost_estimation_iterations = 10000;\n+\n+            template <typename Clock>\n+            int warmup() {\n+                return run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_seed, &resolution<Clock>)\n+                    .iterations;\n+            }\n+            template <typename Clock>\n+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_resolution(int iterations) {\n+                auto r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_resolution_estimation_time), iterations, &resolution<Clock>)\n+                    .result;\n+                return {\n+                    FloatDuration<Clock>(mean(r.begin(), r.end())),\n+                    classify_outliers(r.begin(), r.end()),\n+                };\n+            }\n+            template <typename Clock>\n+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {\n+                auto time_limit = std::min(resolution * clock_cost_estimation_tick_limit, FloatDuration<Clock>(clock_cost_estimation_time_limit));\n+                auto time_clock = [](int k) {\n+                    return Detail::measure<Clock>([k] {\n+                        for (int i = 0; i < k; ++i) {\n+                            volatile auto ignored = Clock::now();\n+                            (void)ignored;\n+                        }\n+                    }).elapsed;\n+                };\n+                time_clock(1);\n+                int iters = clock_cost_estimation_iterations;\n+                auto&& r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_cost_estimation_time), iters, time_clock);\n+                std::vector<double> times;\n+                int nsamples = static_cast<int>(std::ceil(time_limit / r.elapsed));\n+                times.reserve(nsamples);\n+                std::generate_n(std::back_inserter(times), nsamples, [time_clock, &r] {\n+                    return static_cast<double>((time_clock(r.iterations) / r.iterations).count());\n+                });\n+                return {\n+                    FloatDuration<Clock>(mean(times.begin(), times.end())),\n+                    classify_outliers(times.begin(), times.end()),\n+                };\n+            }\n+\n+            template <typename Clock>\n+            Environment<FloatDuration<Clock>> measure_environment() {\n+                static Environment<FloatDuration<Clock>>* env = nullptr;\n+                if (env) {\n+                    return *env;\n+                }\n+\n+                auto iters = Detail::warmup<Clock>();\n+                auto resolution = Detail::estimate_clock_resolution<Clock>(iters);\n+                auto cost = Detail::estimate_clock_cost<Clock>(resolution.mean);\n+\n+                env = new Environment<FloatDuration<Clock>>{ resolution, cost };\n+                return *env;\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ESTIMATE_CLOCK_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_measure.hpp b/include/internal/benchmark/detail/catch_measure.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_measure.hpp\n@@ -0,0 +1,35 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Measure\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"catch_timing.hpp\"\n+\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock, typename Fun, typename... Args>\n+            TimingOf<Clock, Fun(Args...)> measure(Fun&& fun, Args&&... args) {\n+                auto start = Clock::now();\n+                auto&& r = Detail::complete_invoke(fun, std::forward<Args>(args)...);\n+                auto end = Clock::now();\n+                auto delta = end - start;\n+                return { delta, std::forward<decltype(r)>(r), 1 };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_MEASURE_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_repeat.hpp b/include/internal/benchmark/detail/catch_repeat.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_repeat.hpp\n@@ -0,0 +1,37 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// repeat algorithm\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\n+\n+#include <type_traits>\n+#include <utility>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Fun>\n+            struct repeater {\n+                void operator()(int k) const {\n+                    for (int i = 0; i < k; ++i) {\n+                        fun();\n+                    }\n+                }\n+                Fun fun;\n+            };\n+            template <typename Fun>\n+            repeater<typename std::decay<Fun>::type> repeat(Fun&& fun) {\n+                return { std::forward<Fun>(fun) };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_REPEAT_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_run_for_at_least.hpp b/include/internal/benchmark/detail/catch_run_for_at_least.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_run_for_at_least.hpp\n@@ -0,0 +1,65 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Run a function for a minimum amount of time\n+\n+#ifndef TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_chronometer.hpp\"\n+#include \"catch_measure.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+#include \"catch_timing.hpp\"\n+#include \"../../catch_meta.hpp\"\n+\n+#include <utility>\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(int)> measure_one(Fun&& fun, int iters, std::false_type) {\n+                return Detail::measure<Clock>(fun, iters);\n+            }\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(Chronometer)> measure_one(Fun&& fun, int iters, std::true_type) {\n+                Detail::ChronometerModel<Clock> meter;\n+                auto&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));\n+\n+                return { meter.elapsed(), std::move(result), iters };\n+            }\n+\n+            template <typename Clock, typename Fun>\n+            using run_for_at_least_argument_t = typename std::conditional<is_callable<Fun(Chronometer)>::value, Chronometer, int>::type;\n+\n+            struct optimized_away_error : std::exception {\n+                const char* what() const noexcept override {\n+                    return \"could not measure benchmark, maybe it was optimized away\";\n+                }\n+            };\n+\n+            template <typename Clock, typename Fun>\n+            TimingOf<Clock, Fun(run_for_at_least_argument_t<Clock, Fun>)> run_for_at_least(ClockDuration<Clock> how_long, int seed, Fun&& fun) {\n+                auto iters = seed;\n+                while (iters < (1 << 30)) {\n+                    auto&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());\n+\n+                    if (Timing.elapsed >= how_long) {\n+                        return { Timing.elapsed, std::move(Timing.result), iters };\n+                    }\n+                    iters *= 2;\n+                }\n+                throw optimized_away_error{};\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_stats.hpp b/include/internal/benchmark/detail/catch_stats.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_stats.hpp\n@@ -0,0 +1,342 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Statistical analysis tools\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"../catch_estimate.hpp\"\n+#include \"../catch_outlier_classification.hpp\"\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <functional>\n+#include <iterator>\n+#include <vector>\n+#include <array>\n+#include <random>\n+#include <numeric>\n+#include <tuple>\n+#include <cmath>\n+#include <utility>\n+#include <cstddef>\n+\n+#ifdef CATCH_USE_ASYNC\n+#include <future>\n+#endif\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        namespace Detail {\n+            using sample = std::vector<double>;\n+\n+            template <typename Iterator>\n+            double weighted_average_quantile(int k, int q, Iterator first, Iterator last) {\n+                auto count = last - first;\n+                double idx = (count - 1) * k / static_cast<double>(q);\n+                int j = static_cast<int>(idx);\n+                double g = idx - j;\n+                std::nth_element(first, first + j, last);\n+                auto xj = first[j];\n+                if (g == 0) return xj;\n+\n+                auto xj1 = *std::min_element(first + (j + 1), last);\n+                return xj + g * (xj1 - xj);\n+            }\n+\n+            template <typename Iterator>\n+            OutlierClassification classify_outliers(Iterator first, Iterator last) {\n+                std::vector<double> copy(first, last);\n+\n+                auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());\n+                auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());\n+                auto iqr = q3 - q1;\n+                auto los = q1 - (iqr * 3.);\n+                auto lom = q1 - (iqr * 1.5);\n+                auto him = q3 + (iqr * 1.5);\n+                auto his = q3 + (iqr * 3.);\n+\n+                OutlierClassification o;\n+                for (; first != last; ++first) {\n+                    auto&& t = *first;\n+                    if (t < los) ++o.low_severe;\n+                    else if (t < lom) ++o.low_mild;\n+                    else if (t > his) ++o.high_severe;\n+                    else if (t > him) ++o.high_mild;\n+                    ++o.samples_seen;\n+                }\n+                return o;\n+            }\n+\n+            template <typename Iterator>\n+            double mean(Iterator first, Iterator last) {\n+                auto count = last - first;\n+                double sum = std::accumulate(first, last, 0.);\n+                return sum / count;\n+            }\n+\n+            template <typename Iterator>\n+            double standard_deviation(Iterator first, Iterator last) {\n+                auto m = mean(first, last);\n+                double variance = std::accumulate(first, last, 0., [m](double a, double b) {\n+                    double diff = b - m;\n+                    return a + diff * diff;\n+                }) / (last - first);\n+                return std::sqrt(variance);\n+            }\n+\n+            template <typename URng, typename Iterator, typename Estimator>\n+            sample resample(URng& rng, int resamples, Iterator first, Iterator last, Estimator& estimator) {\n+                auto n = last - first;\n+                std::uniform_int_distribution<decltype(n)> dist(0, n - 1);\n+\n+                sample out;\n+                out.reserve(resamples);\n+                std::generate_n(std::back_inserter(out), resamples, [n, first, &estimator, &dist, &rng] {\n+                    std::vector<double> resampled;\n+                    resampled.reserve(n);\n+                    std::generate_n(std::back_inserter(resampled), n, [first, &dist, &rng] { return first[dist(rng)]; });\n+                    return estimator(resampled.begin(), resampled.end());\n+                });\n+                std::sort(out.begin(), out.end());\n+                return out;\n+            }\n+\n+            template <typename Estimator, typename Iterator>\n+            sample jackknife(Estimator&& estimator, Iterator first, Iterator last) {\n+                auto n = last - first;\n+                auto second = std::next(first);\n+                sample results;\n+                results.reserve(n);\n+\n+                for (auto it = first; it != last; ++it) {\n+                    std::iter_swap(it, first);\n+                    results.push_back(estimator(second, last));\n+                }\n+\n+                return results;\n+            }\n+\n+            inline double normal_cdf(double x) {\n+                return std::erfc(-x / std::sqrt(2.0)) / 2.0;\n+            }\n+\n+            inline double erf_inv(double x) {\n+                // Code accompanying the article \"Approximating the erfinv function\" in GPU Computing Gems, Volume 2\n+                double w, p;\n+\n+                w = -log((1.0 - x)*(1.0 + x));\n+\n+                if (w < 6.250000) {\n+                    w = w - 3.125000;\n+                    p = -3.6444120640178196996e-21;\n+                    p = -1.685059138182016589e-19 + p * w;\n+                    p = 1.2858480715256400167e-18 + p * w;\n+                    p = 1.115787767802518096e-17 + p * w;\n+                    p = -1.333171662854620906e-16 + p * w;\n+                    p = 2.0972767875968561637e-17 + p * w;\n+                    p = 6.6376381343583238325e-15 + p * w;\n+                    p = -4.0545662729752068639e-14 + p * w;\n+                    p = -8.1519341976054721522e-14 + p * w;\n+                    p = 2.6335093153082322977e-12 + p * w;\n+                    p = -1.2975133253453532498e-11 + p * w;\n+                    p = -5.4154120542946279317e-11 + p * w;\n+                    p = 1.051212273321532285e-09 + p * w;\n+                    p = -4.1126339803469836976e-09 + p * w;\n+                    p = -2.9070369957882005086e-08 + p * w;\n+                    p = 4.2347877827932403518e-07 + p * w;\n+                    p = -1.3654692000834678645e-06 + p * w;\n+                    p = -1.3882523362786468719e-05 + p * w;\n+                    p = 0.0001867342080340571352 + p * w;\n+                    p = -0.00074070253416626697512 + p * w;\n+                    p = -0.0060336708714301490533 + p * w;\n+                    p = 0.24015818242558961693 + p * w;\n+                    p = 1.6536545626831027356 + p * w;\n+                } else if (w < 16.000000) {\n+                    w = sqrt(w) - 3.250000;\n+                    p = 2.2137376921775787049e-09;\n+                    p = 9.0756561938885390979e-08 + p * w;\n+                    p = -2.7517406297064545428e-07 + p * w;\n+                    p = 1.8239629214389227755e-08 + p * w;\n+                    p = 1.5027403968909827627e-06 + p * w;\n+                    p = -4.013867526981545969e-06 + p * w;\n+                    p = 2.9234449089955446044e-06 + p * w;\n+                    p = 1.2475304481671778723e-05 + p * w;\n+                    p = -4.7318229009055733981e-05 + p * w;\n+                    p = 6.8284851459573175448e-05 + p * w;\n+                    p = 2.4031110387097893999e-05 + p * w;\n+                    p = -0.0003550375203628474796 + p * w;\n+                    p = 0.00095328937973738049703 + p * w;\n+                    p = -0.0016882755560235047313 + p * w;\n+                    p = 0.0024914420961078508066 + p * w;\n+                    p = -0.0037512085075692412107 + p * w;\n+                    p = 0.005370914553590063617 + p * w;\n+                    p = 1.0052589676941592334 + p * w;\n+                    p = 3.0838856104922207635 + p * w;\n+                } else {\n+                    w = sqrt(w) - 5.000000;\n+                    p = -2.7109920616438573243e-11;\n+                    p = -2.5556418169965252055e-10 + p * w;\n+                    p = 1.5076572693500548083e-09 + p * w;\n+                    p = -3.7894654401267369937e-09 + p * w;\n+                    p = 7.6157012080783393804e-09 + p * w;\n+                    p = -1.4960026627149240478e-08 + p * w;\n+                    p = 2.9147953450901080826e-08 + p * w;\n+                    p = -6.7711997758452339498e-08 + p * w;\n+                    p = 2.2900482228026654717e-07 + p * w;\n+                    p = -9.9298272942317002539e-07 + p * w;\n+                    p = 4.5260625972231537039e-06 + p * w;\n+                    p = -1.9681778105531670567e-05 + p * w;\n+                    p = 7.5995277030017761139e-05 + p * w;\n+                    p = -0.00021503011930044477347 + p * w;\n+                    p = -0.00013871931833623122026 + p * w;\n+                    p = 1.0103004648645343977 + p * w;\n+                    p = 4.8499064014085844221 + p * w;\n+                }\n+                return p * x;\n+            }\n+\n+            inline double erfc_inv(double x) {\n+                return erf_inv(1.0 - x);\n+            }\n+\n+            inline double normal_quantile(double p) {\n+                static const double ROOT_TWO = std::sqrt(2.0);\n+\n+                double result = 0.0;\n+                assert(p >= 0 && p <= 1);\n+                if (p < 0 || p > 1) {\n+                    return result;\n+                }\n+\n+                result = -erfc_inv(2.0 * p);\n+                // result *= normal distribution standard deviation (1.0) * sqrt(2)\n+                result *= /*sd * */ ROOT_TWO;\n+                // result += normal disttribution mean (0)\n+                return result;\n+            }\n+\n+            template <typename Iterator, typename Estimator>\n+            Estimate<double> bootstrap(double confidence_level, Iterator first, Iterator last, sample const& resample, Estimator&& estimator) {\n+                auto n_samples = last - first;\n+\n+                double point = estimator(first, last);\n+                // Degenerate case with a single sample\n+                if (n_samples == 1) return { point, point, point, confidence_level };\n+\n+                sample jack = jackknife(estimator, first, last);\n+                double jack_mean = mean(jack.begin(), jack.end());\n+                double sum_squares, sum_cubes;\n+                std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair<double, double> sqcb, double x) -> std::pair<double, double> {\n+                    auto d = jack_mean - x;\n+                    auto d2 = d * d;\n+                    auto d3 = d2 * d;\n+                    return { sqcb.first + d2, sqcb.second + d3 };\n+                });\n+\n+                double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));\n+                int n = static_cast<int>(resample.size());\n+                double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x < point; }) / (double)n;\n+                // degenerate case with uniform samples\n+                if (prob_n == 0) return { point, point, point, confidence_level };\n+\n+                double bias = normal_quantile(prob_n);\n+                double z1 = normal_quantile((1. - confidence_level) / 2.);\n+\n+                auto cumn = [n](double x) -> int {\n+                    return std::lround(normal_cdf(x) * n); };\n+                auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };\n+                double b1 = bias + z1;\n+                double b2 = bias - z1;\n+                double a1 = a(b1);\n+                double a2 = a(b2);\n+                auto lo = std::max(cumn(a1), 0);\n+                auto hi = std::min(cumn(a2), n - 1);\n+\n+                return { point, resample[lo], resample[hi], confidence_level };\n+            }\n+\n+            inline double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n) {\n+                double sb = stddev.point;\n+                double mn = mean.point / n;\n+                double mg_min = mn / 2.;\n+                double sg = std::min(mg_min / 4., sb / std::sqrt(n));\n+                double sg2 = sg * sg;\n+                double sb2 = sb * sb;\n+\n+                auto c_max = [n, mn, sb2, sg2](double x) -> double {\n+                    double k = mn - x;\n+                    double d = k * k;\n+                    double nd = n * d;\n+                    double k0 = -n * nd;\n+                    double k1 = sb2 - n * sg2 + nd;\n+                    double det = k1 * k1 - 4 * sg2 * k0;\n+                    return (int)(-2. * k0 / (k1 + std::sqrt(det)));\n+                };\n+\n+                auto var_out = [n, sb2, sg2](double c) {\n+                    double nc = n - c;\n+                    return (nc / n) * (sb2 - nc * sg2);\n+                };\n+\n+                return std::min(var_out(1), var_out(std::min(c_max(0.), c_max(mg_min)))) / sb2;\n+            }\n+\n+            struct bootstrap_analysis {\n+                Estimate<double> mean;\n+                Estimate<double> standard_deviation;\n+                double outlier_variance;\n+            };\n+\n+            template <typename Iterator>\n+            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, Iterator first, Iterator last) {\n+                static std::random_device entropy;\n+\n+                auto n = static_cast<int>(last - first); // seriously, one can't use integral types without hell in C++\n+\n+                auto mean = &Detail::mean<Iterator>;\n+                auto stddev = &Detail::standard_deviation<Iterator>;\n+\n+#ifdef CATCH_USE_ASYNC\n+                auto Estimate = [=](double(*f)(Iterator, Iterator)) {\n+                    auto seed = entropy();\n+                    return std::async(std::launch::async, [=] {\n+                        std::mt19937 rng(seed);\n+                        auto resampled = resample(rng, n_resamples, first, last, f);\n+                        return bootstrap(confidence_level, first, last, resampled, f);\n+                    });\n+                };\n+\n+                auto mean_future = Estimate(mean);\n+                auto stddev_future = Estimate(stddev);\n+\n+                auto mean_estimate = mean_future.get();\n+                auto stddev_estimate = stddev_future.get();\n+#else\n+                auto Estimate = [=](double(*f)(Iterator, Iterator)) {\n+                    auto seed = entropy();\n+                    std::mt19937 rng(seed);\n+                    auto resampled = resample(rng, n_resamples, first, last, f);\n+                    return bootstrap(confidence_level, first, last, resampled, f);\n+                };\n+\n+                auto mean_estimate = Estimate(mean);\n+                auto stddev_estimate = Estimate(stddev);\n+#endif // CATCH_USE_ASYNC\n+\n+                double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);\n+\n+                return { mean_estimate, stddev_estimate, outlier_variance };\n+            }\n+        } // namespace Detail\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_ANALYSIS_HPP_INCLUDED\ndiff --git a/include/internal/benchmark/detail/catch_timing.hpp b/include/internal/benchmark/detail/catch_timing.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/benchmark/detail/catch_timing.hpp\n@@ -0,0 +1,33 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+// Timing\n+\n+#ifndef TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\n+\n+#include \"../catch_clock.hpp\"\n+#include \"catch_complete_invoke.hpp\"\n+\n+#include <tuple>\n+#include <type_traits>\n+\n+namespace Catch {\n+    namespace Benchmark {\n+        template <typename Duration, typename Result>\n+        struct Timing {\n+            Duration elapsed;\n+            Result result;\n+            int iterations;\n+        };\n+        template <typename Clock, typename Sig>\n+        using TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType_t<Detail::ResultOf_t<Sig>>>;\n+    } // namespace Benchmark\n+} // namespace Catch\n+\n+#endif // TWOBLUECUBES_CATCH_DETAIL_TIMING_HPP_INCLUDED\ndiff --git a/include/internal/catch_benchmark.cpp b/include/internal/catch_benchmark.cpp\ndeleted file mode 100644\n--- a/include/internal/catch_benchmark.cpp\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-/*\n- *  Created by Phil on 04/07/2017.\n- *  Copyright 2017 Two Blue Cubes Ltd. All rights reserved.\n- *\n- *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n- *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n- */\n-\n-#include \"catch_benchmark.h\"\n-#include \"catch_capture.hpp\"\n-#include \"catch_interfaces_reporter.h\"\n-#include \"catch_context.h\"\n-\n-namespace Catch {\n-\n-    auto BenchmarkLooper::getResolution() -> uint64_t {\n-        return getEstimatedClockResolution() * getCurrentContext().getConfig()->benchmarkResolutionMultiple();\n-    }\n-\n-    void BenchmarkLooper::reportStart() {\n-        getResultCapture().benchmarkStarting( { m_name } );\n-    }\n-    auto BenchmarkLooper::needsMoreIterations() -> bool {\n-        auto elapsed = m_timer.getElapsedNanoseconds();\n-\n-        // Exponentially increasing iterations until we're confident in our timer resolution\n-        if( elapsed < m_resolution ) {\n-            m_iterationsToRun *= 10;\n-            return true;\n-        }\n-\n-        getResultCapture().benchmarkEnded( { { m_name }, m_count, elapsed } );\n-        return false;\n-    }\n-\n-} // end namespace Catch\ndiff --git a/include/internal/catch_benchmark.h b/include/internal/catch_benchmark.h\ndeleted file mode 100644\n--- a/include/internal/catch_benchmark.h\n+++ /dev/null\n@@ -1,57 +0,0 @@\n-/*\n- *  Created by Phil on 04/07/2017.\n- *  Copyright 2017 Two Blue Cubes Ltd. All rights reserved.\n- *\n- *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n- *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n- */\n-#ifndef TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\n-#define TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\n-\n-#include \"catch_stringref.h\"\n-#include \"catch_timer.h\"\n-\n-#include <cstdint>\n-#include <string>\n-\n-namespace Catch {\n-\n-    class BenchmarkLooper {\n-\n-        std::string m_name;\n-        std::size_t m_count = 0;\n-        std::size_t m_iterationsToRun = 1;\n-        uint64_t m_resolution;\n-        Timer m_timer;\n-\n-        static auto getResolution() -> uint64_t;\n-    public:\n-        // Keep most of this inline as it's on the code path that is being timed\n-        BenchmarkLooper( StringRef name )\n-        :   m_name( name ),\n-            m_resolution( getResolution() )\n-        {\n-            reportStart();\n-            m_timer.start();\n-        }\n-\n-        explicit operator bool() {\n-            if( m_count < m_iterationsToRun )\n-                return true;\n-            return needsMoreIterations();\n-        }\n-\n-        void increment() {\n-            ++m_count;\n-        }\n-\n-        void reportStart();\n-        auto needsMoreIterations() -> bool;\n-    };\n-\n-} // end namespace Catch\n-\n-#define BENCHMARK( name ) \\\n-    for( Catch::BenchmarkLooper looper( name ); looper; looper.increment() )\n-\n-#endif // TWOBLUECUBES_CATCH_BENCHMARK_H_INCLUDED\ndiff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -196,11 +196,19 @@ namespace Catch {\n             | Opt( setWaitForKeypress, \"start|exit|both\" )\n                 [\"--wait-for-keypress\"]\n                 ( \"waits for a keypress before exiting\" )\n-            | Opt( config.benchmarkResolutionMultiple, \"multiplier\" )\n-                [\"--benchmark-resolution-multiple\"]\n-                ( \"multiple of clock resolution to run benchmarks\" )\n-\n-            | Arg( config.testsOrTags, \"test name|pattern|tags\" )\n+            | Opt( config.benchmarkSamples, \"samples\" )\n+                [\"--benchmark-samples\"]\n+                ( \"number of samples to collect (default: 100)\" )\n+            | Opt( config.benchmarkResamples, \"resamples\" )\n+                [\"--benchmark-resamples\"]\n+                ( \"number of resamples for the bootstrap (default: 100000)\" )\n+            | Opt( config.benchmarkConfidenceInterval, \"confidence interval\" )\n+                [\"--benchmark-confidence-interval\"]\n+                ( \"confidence interval for the bootstrap (between 0 and 1, default: 0.95)\" )\n+            | Opt( config.benchmarkNoAnalysis )\n+                [\"--benchmark-no-analysis\"]\n+                ( \"perform only measurements; do not perform any analysis\" )\n+\t\t\t| Arg( config.testsOrTags, \"test name|pattern|tags\" )\n                 ( \"which test or tests to use\" );\n \n         return cli;\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -118,9 +118,9 @@\n // some versions of cygwin (most) do not support std::to_string. Use the libstd check. \n // https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813\n # if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \\\n-\t       && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\n+           && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))\n \n-#\tdefine CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING\n+#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING\n \n # endif\n #endif // __CYGWIN__\n@@ -148,7 +148,11 @@\n #  if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)\n #    define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #  endif\n+#endif // _MSC_VER\n \n+#if defined(_REENTRANT) || defined(_MSC_VER)\n+// Enable async processing, as -pthread is specified or no additional linking is required\n+# define CATCH_USE_ASYNC\n #endif // _MSC_VER\n \n ////////////////////////////////////////////////////////////////////////////////\ndiff --git a/include/internal/catch_config.cpp b/include/internal/catch_config.cpp\n--- a/include/internal/catch_config.cpp\n+++ b/include/internal/catch_config.cpp\n@@ -32,7 +32,7 @@ namespace Catch {\n     bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }\n     bool Config::listTags() const           { return m_data.listTags; }\n     bool Config::listReporters() const      { return m_data.listReporters; }\n-\n+\t\n     std::string Config::getProcessName() const { return m_data.processName; }\n     std::string const& Config::getReporterName() const { return m_data.reporterName; }\n \n@@ -54,13 +54,17 @@ namespace Catch {\n     ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }\n     RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }\n     unsigned int Config::rngSeed() const               { return m_data.rngSeed; }\n-    int Config::benchmarkResolutionMultiple() const    { return m_data.benchmarkResolutionMultiple; }\n     UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }\n     bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }\n     int Config::abortAfter() const                     { return m_data.abortAfter; }\n     bool Config::showInvisibles() const                { return m_data.showInvisibles; }\n     Verbosity Config::verbosity() const                { return m_data.verbosity; }\n \n+    bool Config::benchmarkNoAnalysis() const           { return m_data.benchmarkNoAnalysis; }\n+    int Config::benchmarkSamples() const               { return m_data.benchmarkSamples; }\n+    double Config::benchmarkConfidenceInterval() const { return m_data.benchmarkConfidenceInterval; }\n+    unsigned int Config::benchmarkResamples() const    { return m_data.benchmarkResamples; }\n+\n     IStream const* Config::openStream() {\n         return Catch::makeStream(m_data.outputFilename);\n     }\ndiff --git a/include/internal/catch_config.hpp b/include/internal/catch_config.hpp\n--- a/include/internal/catch_config.hpp\n+++ b/include/internal/catch_config.hpp\n@@ -42,7 +42,11 @@ namespace Catch {\n \n         int abortAfter = -1;\n         unsigned int rngSeed = 0;\n-        int benchmarkResolutionMultiple = 100;\n+\n+        bool benchmarkNoAnalysis = false;\n+        unsigned int benchmarkSamples = 100;\n+        double benchmarkConfidenceInterval = 0.95;\n+        unsigned int benchmarkResamples = 100000;\n \n         Verbosity verbosity = Verbosity::Normal;\n         WarnAbout::What warnings = WarnAbout::Nothing;\n@@ -100,12 +104,15 @@ namespace Catch {\n         ShowDurations::OrNot showDurations() const override;\n         RunTests::InWhatOrder runOrder() const override;\n         unsigned int rngSeed() const override;\n-        int benchmarkResolutionMultiple() const override;\n         UseColour::YesOrNo useColour() const override;\n         bool shouldDebugBreak() const override;\n         int abortAfter() const override;\n         bool showInvisibles() const override;\n         Verbosity verbosity() const override;\n+        bool benchmarkNoAnalysis() const override;\n+        int benchmarkSamples() const override;\n+        double benchmarkConfidenceInterval() const override;\n+        unsigned int benchmarkResamples() const override;\n \n     private:\n \ndiff --git a/include/internal/catch_interfaces_capture.h b/include/internal/catch_interfaces_capture.h\n--- a/include/internal/catch_interfaces_capture.h\n+++ b/include/internal/catch_interfaces_capture.h\n@@ -9,6 +9,7 @@\n #define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED\n \n #include <string>\n+#include <chrono>\n \n #include \"catch_stringref.h\"\n #include \"catch_result_type.h\"\n@@ -22,14 +23,18 @@ namespace Catch {\n     struct MessageInfo;\n     struct MessageBuilder;\n     struct Counts;\n-    struct BenchmarkInfo;\n-    struct BenchmarkStats;\n     struct AssertionReaction;\n     struct SourceLineInfo;\n \n     struct ITransientExpression;\n     struct IGeneratorTracker;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    struct BenchmarkInfo;\n+    template <typename Duration = std::chrono::duration<double, std::nano>>\n+    struct BenchmarkStats;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     struct IResultCapture {\n \n         virtual ~IResultCapture();\n@@ -41,8 +46,12 @@ namespace Catch {\n \n         virtual auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        virtual void benchmarkPreparing( std::string const& name ) = 0;\n         virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;\n-        virtual void benchmarkEnded( BenchmarkStats const& stats ) = 0;\n+        virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;\n+        virtual void benchmarkFailed( std::string const& error ) = 0;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         virtual void pushScopedMessage( MessageInfo const& message ) = 0;\n         virtual void popScopedMessage( MessageInfo const& message ) = 0;\ndiff --git a/include/internal/catch_interfaces_config.h b/include/internal/catch_interfaces_config.h\n--- a/include/internal/catch_interfaces_config.h\n+++ b/include/internal/catch_interfaces_config.h\n@@ -9,6 +9,7 @@\n #define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED\n \n #include \"catch_common.h\"\n+#include \"catch_option.hpp\"\n \n #include <iosfwd>\n #include <string>\n@@ -50,7 +51,7 @@ namespace Catch {\n         BeforeExit = 2,\n         BeforeStartAndExit = BeforeStart | BeforeExit\n     }; };\n-\n+    \n     class TestSpec;\n \n     struct IConfig : NonCopyable {\n@@ -72,10 +73,14 @@ namespace Catch {\n         virtual std::vector<std::string> const& getTestsOrTags() const = 0;\n         virtual RunTests::InWhatOrder runOrder() const = 0;\n         virtual unsigned int rngSeed() const = 0;\n-        virtual int benchmarkResolutionMultiple() const = 0;\n         virtual UseColour::YesOrNo useColour() const = 0;\n         virtual std::vector<std::string> const& getSectionsToRun() const = 0;\n         virtual Verbosity verbosity() const = 0;\n+\n+        virtual bool benchmarkNoAnalysis() const = 0;\n+        virtual int benchmarkSamples() const = 0;\n+        virtual double benchmarkConfidenceInterval() const = 0;\n+        virtual unsigned int benchmarkResamples() const = 0;\n     };\n \n     using IConfigPtr = std::shared_ptr<IConfig const>;\ndiff --git a/include/internal/catch_interfaces_reporter.h b/include/internal/catch_interfaces_reporter.h\n--- a/include/internal/catch_interfaces_reporter.h\n+++ b/include/internal/catch_interfaces_reporter.h\n@@ -18,12 +18,18 @@\n #include \"catch_option.hpp\"\n #include \"catch_stringref.h\"\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+#include \"benchmark/catch_estimate.hpp\"\n+#include \"benchmark/catch_outlier_classification.hpp\"\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n \n #include <string>\n #include <iosfwd>\n #include <map>\n #include <set>\n #include <memory>\n+#include <algorithm>\n \n namespace Catch {\n \n@@ -159,14 +165,43 @@ namespace Catch {\n         bool aborting;\n     };\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n     struct BenchmarkInfo {\n         std::string name;\n+        double estimatedDuration;\n+        int iterations;\n+        int samples;\n+        unsigned int resamples;\n+        double clockResolution;\n+        double clockCost;\n     };\n+\n+    template <class Duration>\n     struct BenchmarkStats {\n         BenchmarkInfo info;\n-        std::size_t iterations;\n-        uint64_t elapsedTimeInNanoseconds;\n+\n+        std::vector<Duration> samples;\n+        Benchmark::Estimate<Duration> mean;\n+        Benchmark::Estimate<Duration> standardDeviation;\n+        Benchmark::OutlierClassification outliers;\n+        double outlierVariance;\n+\n+        template <typename Duration2>\n+        operator BenchmarkStats<Duration2>() const {\n+            std::vector<Duration2> samples2;\n+            samples2.reserve(samples.size());\n+            std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });\n+            return {\n+                info,\n+                std::move(samples2),\n+                mean,\n+                standardDeviation,\n+                outliers,\n+                outlierVariance,\n+            };\n+        }\n     };\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n     struct IStreamingReporter {\n         virtual ~IStreamingReporter() = default;\n@@ -185,17 +220,18 @@ namespace Catch {\n         virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;\n         virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;\n \n-        // *** experimental ***\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        virtual void benchmarkPreparing( std::string const& ) {}\n         virtual void benchmarkStarting( BenchmarkInfo const& ) {}\n+        virtual void benchmarkEnded( BenchmarkStats<> const& ) {}\n+        virtual void benchmarkFailed( std::string const& ) {}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;\n \n         // The return value indicates if the messages buffer should be cleared:\n         virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;\n \n-        // *** experimental ***\n-        virtual void benchmarkEnded( BenchmarkStats const& ) {}\n-\n         virtual void sectionEnded( SectionStats const& sectionStats ) = 0;\n         virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;\n         virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -12,8 +12,23 @@\n #include <type_traits>\n \n namespace Catch {\n-    template<typename T>\n-    struct always_false : std::false_type {};\n+template<typename T>\n+struct always_false : std::false_type {};\n+\n+template <typename> struct true_given : std::true_type {};\n+struct is_callable_tester {\n+    template <typename Fun, typename... Args>\n+    true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);\n+    template <typename...>\n+    std::false_type static test(...);\n+};\n+\n+template <typename T>\n+struct is_callable;\n+\n+template <typename Fun, typename... Args>\n+struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};\n+\n } // namespace Catch\n \n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_run_context.cpp b/include/internal/catch_run_context.cpp\n--- a/include/internal/catch_run_context.cpp\n+++ b/include/internal/catch_run_context.cpp\n@@ -230,12 +230,21 @@ namespace Catch {\n \n         m_unfinishedSections.push_back(endInfo);\n     }\n+\t\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void RunContext::benchmarkPreparing(std::string const& name) {\n+\t\tm_reporter->benchmarkPreparing(name);\n+\t}\n     void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {\n         m_reporter->benchmarkStarting( info );\n     }\n-    void RunContext::benchmarkEnded( BenchmarkStats const& stats ) {\n+    void RunContext::benchmarkEnded( BenchmarkStats<> const& stats ) {\n         m_reporter->benchmarkEnded( stats );\n     }\n+\tvoid RunContext::benchmarkFailed(std::string const & error) {\n+\t\tm_reporter->benchmarkFailed(error);\n+\t}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n     void RunContext::pushScopedMessage(MessageInfo const & message) {\n         m_messages.push_back(message);\ndiff --git a/include/internal/catch_run_context.h b/include/internal/catch_run_context.h\n--- a/include/internal/catch_run_context.h\n+++ b/include/internal/catch_run_context.h\n@@ -82,8 +82,12 @@ namespace Catch {\n \n         auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& override;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing( std::string const& name ) override;\n         void benchmarkStarting( BenchmarkInfo const& info ) override;\n-        void benchmarkEnded( BenchmarkStats const& stats ) override;\n+        void benchmarkEnded( BenchmarkStats<> const& stats ) override;\n+        void benchmarkFailed( std::string const& error ) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void pushScopedMessage( MessageInfo const& message ) override;\n         void popScopedMessage( MessageInfo const& message ) override;\ndiff --git a/include/internal/catch_stream.cpp b/include/internal/catch_stream.cpp\n--- a/include/internal/catch_stream.cpp\n+++ b/include/internal/catch_stream.cpp\n@@ -25,7 +25,7 @@ namespace Catch {\n \n     Catch::IStream::~IStream() = default;\n \n-    namespace detail { namespace {\n+    namespace Detail { namespace {\n         template<typename WriterF, std::size_t bufferSize=256>\n         class StreamBufImpl : public std::streambuf {\n             char data[bufferSize];\n@@ -124,15 +124,15 @@ namespace Catch {\n \n     auto makeStream( StringRef const &filename ) -> IStream const* {\n         if( filename.empty() )\n-            return new detail::CoutStream();\n+            return new Detail::CoutStream();\n         else if( filename[0] == '%' ) {\n             if( filename == \"%debug\" )\n-                return new detail::DebugOutStream();\n+                return new Detail::DebugOutStream();\n             else\n                 CATCH_ERROR( \"Unrecognised stream: '\" << filename << \"'\" );\n         }\n         else\n-            return new detail::FileStream( filename );\n+            return new Detail::FileStream( filename );\n     }\n \n \ndiff --git a/include/reporters/catch_reporter_console.cpp b/include/reporters/catch_reporter_console.cpp\n--- a/include/reporters/catch_reporter_console.cpp\n+++ b/include/reporters/catch_reporter_console.cpp\n@@ -20,10 +20,16 @@\n #if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch\n- // Note that 4062 (not all labels are handled\n- // and default is missing) is enabled\n+ // Note that 4062 (not all labels are handled and default is missing) is enabled\n #endif\n \n+#if defined(__clang__)\n+#  pragma clang diagnostic push\n+// For simplicity, benchmarking-only helpers are always enabled\n+#  pragma clang diagnostic ignored \"-Wunused-function\"\n+#endif\n+\n+\n \n namespace Catch {\n \n@@ -208,6 +214,10 @@ class Duration {\n     Unit m_units;\n \n public:\n+\texplicit Duration(double inNanoseconds, Unit units = Unit::Auto)\n+        : Duration(static_cast<uint64_t>(inNanoseconds), units) {\n+    }\n+\n     explicit Duration(uint64_t inNanoseconds, Unit units = Unit::Auto)\n         : m_inNanoseconds(inNanoseconds),\n         m_units(units) {\n@@ -283,9 +293,15 @@ class TablePrinter {\n         if (!m_isOpen) {\n             m_isOpen = true;\n             *this << RowBreak();\n-            for (auto const& info : m_columnInfos)\n-                *this << info.name << ColumnBreak();\n-            *this << RowBreak();\n+\n+\t\t\tColumns headerCols;\n+\t\t\tSpacer spacer(2);\n+\t\t\tfor (auto const& info : m_columnInfos) {\n+\t\t\t\theaderCols += Column(info.name).width(static_cast<std::size_t>(info.width - 2));\n+\t\t\t\theaderCols += spacer;\n+\t\t\t}\n+\t\t\tm_os << headerCols << \"\\n\";\n+\n             m_os << Catch::getLineOfChars<'-'>() << \"\\n\";\n         }\n     }\n@@ -340,9 +356,9 @@ ConsoleReporter::ConsoleReporter(ReporterConfig const& config)\n     m_tablePrinter(new TablePrinter(config.stream(),\n     {\n         { \"benchmark name\", CATCH_CONFIG_CONSOLE_WIDTH - 32, ColumnInfo::Left },\n-        { \"iters\", 8, ColumnInfo::Right },\n-        { \"elapsed ns\", 14, ColumnInfo::Right },\n-        { \"average\", 14, ColumnInfo::Right }\n+        { \"samples      mean       std dev\", 14, ColumnInfo::Right },\n+        { \"iterations   low mean   low std dev\", 14, ColumnInfo::Right },\n+        { \"estimated    high mean  high std dev\", 14, ColumnInfo::Right }\n     })) {}\n ConsoleReporter::~ConsoleReporter() = default;\n \n@@ -374,6 +390,7 @@ bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {\n }\n \n void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {\n+    m_tablePrinter->close();\n     m_headerPrinted = false;\n     StreamingReporterBase::sectionStarting(_sectionInfo);\n }\n@@ -397,29 +414,45 @@ void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {\n     StreamingReporterBase::sectionEnded(_sectionStats);\n }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+void ConsoleReporter::benchmarkPreparing(std::string const& name) {\n+\tlazyPrintWithoutClosingBenchmarkTable();\n \n-void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n-    lazyPrintWithoutClosingBenchmarkTable();\n+\tauto nameCol = Column(name).width(static_cast<std::size_t>(m_tablePrinter->columnInfos()[0].width - 2));\n \n-    auto nameCol = Column( info.name ).width( static_cast<std::size_t>( m_tablePrinter->columnInfos()[0].width - 2 ) );\n+\tbool firstLine = true;\n+\tfor (auto line : nameCol) {\n+\t\tif (!firstLine)\n+\t\t\t(*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n+\t\telse\n+\t\t\tfirstLine = false;\n \n-    bool firstLine = true;\n-    for (auto line : nameCol) {\n-        if (!firstLine)\n-            (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\n-        else\n-            firstLine = false;\n+\t\t(*m_tablePrinter) << line << ColumnBreak();\n+\t}\n+}\n \n-        (*m_tablePrinter) << line << ColumnBreak();\n-    }\n+void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {\n+\t(*m_tablePrinter) << info.samples << ColumnBreak()\n+\t\t<< info.iterations << ColumnBreak()\n+\t\t<< Duration(info.estimatedDuration) << ColumnBreak();\n }\n-void ConsoleReporter::benchmarkEnded(BenchmarkStats const& stats) {\n-    Duration average(stats.elapsedTimeInNanoseconds / stats.iterations);\n+void ConsoleReporter::benchmarkEnded(BenchmarkStats<> const& stats) {\n+\t(*m_tablePrinter) << ColumnBreak()\n+\t\t<< Duration(stats.mean.point.count()) << ColumnBreak()\n+\t\t<< Duration(stats.mean.lower_bound.count()) << ColumnBreak()\n+\t\t<< Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.point.count()) << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()\n+\t\t<< Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();\n+}\n+\n+void ConsoleReporter::benchmarkFailed(std::string const& error) {\n+\tColour colour(Colour::Red);\n     (*m_tablePrinter)\n-        << stats.iterations << ColumnBreak()\n-        << stats.elapsedTimeInNanoseconds << ColumnBreak()\n-        << average << ColumnBreak();\n+        << \"Benchmark failed (\" << error << \")\"\n+        << ColumnBreak() << RowBreak();\n }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {\n     m_tablePrinter->close();\n@@ -638,3 +671,7 @@ CATCH_REGISTER_REPORTER(\"console\", ConsoleReporter)\n #if defined(_MSC_VER)\n #pragma warning(pop)\n #endif\n+\n+#if defined(__clang__)\n+#  pragma clang diagnostic pop\n+#endif\ndiff --git a/include/reporters/catch_reporter_console.h b/include/reporters/catch_reporter_console.h\n--- a/include/reporters/catch_reporter_console.h\n+++ b/include/reporters/catch_reporter_console.h\n@@ -39,9 +39,12 @@ namespace Catch {\n         void sectionStarting(SectionInfo const& _sectionInfo) override;\n         void sectionEnded(SectionStats const& _sectionStats) override;\n \n-\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing(std::string const& name) override;\n         void benchmarkStarting(BenchmarkInfo const& info) override;\n-        void benchmarkEnded(BenchmarkStats const& stats) override;\n+        void benchmarkEnded(BenchmarkStats<> const& stats) override;\n+        void benchmarkFailed(std::string const& error) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void testCaseEnded(TestCaseStats const& _testCaseStats) override;\n         void testGroupEnded(TestGroupStats const& _testGroupStats) override;\ndiff --git a/include/reporters/catch_reporter_listening.cpp b/include/reporters/catch_reporter_listening.cpp\n--- a/include/reporters/catch_reporter_listening.cpp\n+++ b/include/reporters/catch_reporter_listening.cpp\n@@ -42,19 +42,34 @@ namespace Catch {\n         m_reporter->noMatchingTestCases( spec );\n     }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void ListeningReporter::benchmarkPreparing( std::string const& name ) {\n+\t\tfor (auto const& listener : m_listeners) {\n+\t\t\tlistener->benchmarkPreparing(name);\n+\t\t}\n+\t\tm_reporter->benchmarkPreparing(name);\n+\t}\n     void ListeningReporter::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->benchmarkStarting( benchmarkInfo );\n         }\n         m_reporter->benchmarkStarting( benchmarkInfo );\n     }\n-    void ListeningReporter::benchmarkEnded( BenchmarkStats const& benchmarkStats ) {\n+    void ListeningReporter::benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->benchmarkEnded( benchmarkStats );\n         }\n         m_reporter->benchmarkEnded( benchmarkStats );\n     }\n \n+\tvoid ListeningReporter::benchmarkFailed( std::string const& error ) {\n+\t\tfor (auto const& listener : m_listeners) {\n+\t\t\tlistener->benchmarkFailed(error);\n+\t\t}\n+\t\tm_reporter->benchmarkFailed(error);\n+\t}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     void ListeningReporter::testRunStarting( TestRunInfo const& testRunInfo ) {\n         for ( auto const& listener : m_listeners ) {\n             listener->testRunStarting( testRunInfo );\ndiff --git a/include/reporters/catch_reporter_listening.h b/include/reporters/catch_reporter_listening.h\n--- a/include/reporters/catch_reporter_listening.h\n+++ b/include/reporters/catch_reporter_listening.h\n@@ -31,8 +31,12 @@ namespace Catch {\n \n         static std::set<Verbosity> getSupportedVerbosities();\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkPreparing(std::string const& name) override;\n         void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;\n-        void benchmarkEnded( BenchmarkStats const& benchmarkStats ) override;\n+        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;\n+        void benchmarkFailed(std::string const&) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n \n         void testRunStarting( TestRunInfo const& testRunInfo ) override;\n         void testGroupStarting( GroupInfo const& groupInfo ) override;\ndiff --git a/include/reporters/catch_reporter_xml.cpp b/include/reporters/catch_reporter_xml.cpp\n--- a/include/reporters/catch_reporter_xml.cpp\n+++ b/include/reporters/catch_reporter_xml.cpp\n@@ -219,6 +219,48 @@ namespace Catch {\n         m_xml.endElement();\n     }\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+    void XmlReporter::benchmarkStarting(BenchmarkInfo const &info) {\n+        m_xml.startElement(\"BenchmarkResults\")\n+            .writeAttribute(\"name\", info.name)\n+            .writeAttribute(\"samples\", info.samples)\n+            .writeAttribute(\"resamples\", info.resamples)\n+            .writeAttribute(\"iterations\", info.iterations)\n+            .writeAttribute(\"clockResolution\", static_cast<uint64_t>(info.clockResolution))\n+            .writeAttribute(\"estimatedDuration\", static_cast<uint64_t>(info.estimatedDuration))\n+            .writeComment(\"All values in nano seconds\");\n+    }\n+\n+    void XmlReporter::benchmarkEnded(BenchmarkStats<> const& benchmarkStats) {\n+        m_xml.startElement(\"mean\")\n+            .writeAttribute(\"value\", static_cast<uint64_t>(benchmarkStats.mean.point.count()))\n+            .writeAttribute(\"lowerBound\", static_cast<uint64_t>(benchmarkStats.mean.lower_bound.count()))\n+            .writeAttribute(\"upperBound\", static_cast<uint64_t>(benchmarkStats.mean.upper_bound.count()))\n+            .writeAttribute(\"ci\", benchmarkStats.mean.confidence_interval);\n+        m_xml.endElement();\n+        m_xml.startElement(\"standardDeviation\")\n+            .writeAttribute(\"value\", benchmarkStats.standardDeviation.point.count())\n+            .writeAttribute(\"lowerBound\", benchmarkStats.standardDeviation.lower_bound.count())\n+            .writeAttribute(\"upperBound\", benchmarkStats.standardDeviation.upper_bound.count())\n+            .writeAttribute(\"ci\", benchmarkStats.standardDeviation.confidence_interval);\n+        m_xml.endElement();\n+        m_xml.startElement(\"outliers\")\n+            .writeAttribute(\"variance\", benchmarkStats.outlierVariance)\n+            .writeAttribute(\"lowMild\", benchmarkStats.outliers.low_mild)\n+            .writeAttribute(\"lowSevere\", benchmarkStats.outliers.low_severe)\n+            .writeAttribute(\"highMild\", benchmarkStats.outliers.high_mild)\n+            .writeAttribute(\"highSevere\", benchmarkStats.outliers.high_severe);\n+        m_xml.endElement();\n+        m_xml.endElement();\n+    }\n+\n+    void XmlReporter::benchmarkFailed(std::string const &error) {\n+        m_xml.scopedElement(\"failed\").\n+            writeAttribute(\"message\", error);\n+        m_xml.endElement();\n+    }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     CATCH_REGISTER_REPORTER( \"xml\", XmlReporter )\n \n } // end namespace Catch\ndiff --git a/include/reporters/catch_reporter_xml.h b/include/reporters/catch_reporter_xml.h\n--- a/include/reporters/catch_reporter_xml.h\n+++ b/include/reporters/catch_reporter_xml.h\n@@ -50,6 +50,12 @@ namespace Catch {\n \n         void testRunEnded(TestRunStats const& testRunStats) override;\n \n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+        void benchmarkStarting(BenchmarkInfo const&) override;\n+        void benchmarkEnded(BenchmarkStats<> const&) override;\n+        void benchmarkFailed(std::string const&) override;\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n+\n     private:\n         Timer m_testCaseTimer;\n         XmlWriter m_xml;\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -18,6 +18,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/TestMain.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/CmdLine.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/InternalBenchmark.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/PartTracker.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/String.tests.cpp\n@@ -79,6 +80,28 @@ CheckFileList(EXTERNAL_HEADERS ${HEADER_DIR}/external)\n \n \n # Please keep these ordered alphabetically\n+set(BENCHMARK_HEADERS\n+\t\t${HEADER_DIR}/internal/benchmark/catch_benchmark.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_chronometer.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_clock.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_constructor.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_environment.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_estimate.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_execution_plan.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_optimizer.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_outlier_classification.hpp\n+        ${HEADER_DIR}/internal/benchmark/catch_sample_analysis.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_analyse.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_benchmark_function.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_complete_invoke.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_estimate_clock.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_measure.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_repeat.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_run_for_at_least.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_stats.hpp\n+        ${HEADER_DIR}/internal/benchmark/detail/catch_timing.hpp\n+)\n+SOURCE_GROUP(\"benchmark\" FILES ${BENCHMARK_HEADERS})\n set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_approx.h\n         ${HEADER_DIR}/internal/catch_assertionhandler.h\n@@ -138,7 +161,6 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_reporter_registry.h\n         ${HEADER_DIR}/internal/catch_result_type.h\n         ${HEADER_DIR}/internal/catch_run_context.h\n-        ${HEADER_DIR}/internal/catch_benchmark.h\n         ${HEADER_DIR}/internal/catch_section.h\n         ${HEADER_DIR}/internal/catch_section_info.h\n         ${HEADER_DIR}/internal/catch_session.h\n@@ -174,7 +196,6 @@ set(IMPL_SOURCES\n         ${HEADER_DIR}/internal/catch_approx.cpp\n         ${HEADER_DIR}/internal/catch_assertionhandler.cpp\n         ${HEADER_DIR}/internal/catch_assertionresult.cpp\n-        ${HEADER_DIR}/internal/catch_benchmark.cpp\n         ${HEADER_DIR}/internal/catch_capture_matchers.cpp\n         ${HEADER_DIR}/internal/catch_commandline.cpp\n         ${HEADER_DIR}/internal/catch_common.cpp\n@@ -269,6 +290,7 @@ set(HEADERS\n         ${EXTERNAL_HEADERS}\n         ${INTERNAL_HEADERS}\n         ${REPORTER_HEADERS}\n+\t\t${BENCHMARK_HEADERS}\n         )\n \n # Provide some groupings for IDEs\ndiff --git a/projects/ExtraTests/CMakeLists.txt b/projects/ExtraTests/CMakeLists.txt\n--- a/projects/ExtraTests/CMakeLists.txt\n+++ b/projects/ExtraTests/CMakeLists.txt\n@@ -116,6 +116,17 @@ set_tests_properties(\n )\n \n \n+add_executable(BenchmarkingMacros ${TESTS_DIR}/X20-BenchmarkingMacros.cpp)\n+target_compile_definitions( BenchmarkingMacros PRIVATE CATCH_CONFIG_ENABLE_BENCHMARKING )\n+\n+add_test(NAME BenchmarkingMacros COMMAND BenchmarkingMacros -r console -s)\n+set_tests_properties(\n+    BenchmarkingMacros\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"benchmark name                                  samples       iterations    estimated\"\n+)\n+\n+\n set( EXTRA_TEST_BINARIES\n     PrefixedMacros\n     DisabledMacros\n@@ -123,6 +134,7 @@ set( EXTRA_TEST_BINARIES\n     DisabledExceptions-CustomHandler\n     FallbackStringifier\n     DisableStringification\n+    BenchmarkingMacros\n )\n \n # Shared config\ndiff --git a/projects/ExtraTests/X20-BenchmarkingMacros.cpp b/projects/ExtraTests/X20-BenchmarkingMacros.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/projects/ExtraTests/X20-BenchmarkingMacros.cpp\n@@ -0,0 +1,133 @@\n+// X20-BenchmarkingMacros.cpp\n+// Test that the benchmarking support macros compile properly with the single header\n+\n+#define CATCH_CONFIG_MAIN\n+#include <catch2/catch.hpp>\n+\n+namespace {\n+std::uint64_t factorial(std::uint64_t number) {\n+    if (number < 2) {\n+        return 1;\n+    }\n+    return number * factorial(number - 1);\n+}\n+}\n+\n+TEST_CASE(\"Benchmark factorial\", \"[benchmark]\") {\n+    CHECK(factorial(0) == 1);\n+    // some more asserts..\n+    CHECK(factorial(10) == 3628800);\n+\n+    BENCHMARK(\"factorial 10\") {\n+        return factorial(10);\n+    };\n+\n+    CHECK(factorial(14) == 87178291200ull);\n+    BENCHMARK(\"factorial 14\") {\n+        return factorial(14);\n+    };\n+//\n+//    BENCHMARK(\"factorial 20\") {\n+//        return factorial(20);\n+//    };\n+//\n+//    BENCHMARK(\"factorial 35\") {\n+//        return factorial(35);\n+//    };\n+}\n+\n+TEST_CASE(\"Benchmark containers\", \"[.][benchmark]\") {\n+    static const int size = 100;\n+\n+    std::vector<int> v;\n+    std::map<int, int> m;\n+\n+    SECTION(\"without generator\") {\n+        BENCHMARK(\"Load up a vector\") {\n+            v = std::vector<int>();\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        // test optimizer control\n+        BENCHMARK(\"Add up a vector's content\") {\n+            uint64_t add = 0;\n+            for (int i = 0; i < size; ++i)\n+                add += v[i];\n+            return add;\n+        };\n+\n+        BENCHMARK(\"Load up a map\") {\n+            m = std::map<int, int>();\n+            for (int i = 0; i < size; ++i)\n+                m.insert({ i, i + 1 });\n+        };\n+        REQUIRE(m.size() == size);\n+\n+        BENCHMARK(\"Reserved vector\") {\n+            v = std::vector<int>();\n+            v.reserve(size);\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        BENCHMARK(\"Resized vector\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = i;\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        int array[size];\n+        BENCHMARK(\"A fixed size array that should require no allocations\") {\n+            for (int i = 0; i < size; ++i)\n+                array[i] = i;\n+        };\n+        int sum = 0;\n+        for (int i = 0; i < size; ++i)\n+            sum += array[i];\n+        REQUIRE(sum > size);\n+\n+        SECTION(\"XYZ\") {\n+\n+            BENCHMARK_ADVANCED(\"Load up vector with chronometer\")(Catch::Benchmark::Chronometer meter) {\n+                std::vector<int> k;\n+                meter.measure([&](int idx) {\n+                    k = std::vector<int>();\n+                    for (int i = 0; i < size; ++i)\n+                        k.push_back(idx);\n+                });\n+                REQUIRE(k.size() == size);\n+            };\n+\n+            int runs = 0;\n+            BENCHMARK(\"Fill vector indexed\", benchmarkIndex) {\n+                v = std::vector<int>();\n+                v.resize(size);\n+                for (int i = 0; i < size; ++i)\n+                    v[i] = benchmarkIndex;\n+                runs = benchmarkIndex;\n+            };\n+\n+            for (size_t i = 0; i < v.size(); ++i) {\n+                REQUIRE(v[i] == runs);\n+            }\n+        }\n+    }\n+\n+    SECTION(\"with generator\") {\n+        auto generated = GENERATE(range(0, 10));\n+        BENCHMARK(\"Fill vector generated\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = generated;\n+        };\n+        for (size_t i = 0; i < v.size(); ++i) {\n+            REQUIRE(v[i] == generated);\n+        }\n+    }\n+}\n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n@@ -462,4 +462,30 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n #endif\n         }\n     }\n+\n+    SECTION(\"Benchmark options\") {\n+        SECTION(\"samples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-samples=200\" }));\n+\n+            REQUIRE(config.benchmarkSamples == 200);\n+        }\n+        \n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-resamples=20000\" }));\n+\n+            REQUIRE(config.benchmarkResamples == 20000);\n+        }\n+\n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-confidence-interval=0.99\" }));\n+\n+            REQUIRE(config.benchmarkConfidenceInterval == Catch::Detail::Approx(0.99));\n+        }\n+\n+        SECTION(\"resamples\") {\n+            CHECK(cli.parse({ \"test\", \"--benchmark-no-analysis\" }));\n+\n+            REQUIRE(config.benchmarkNoAnalysis);\n+        }\n+    }\n }\ndiff --git a/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp b/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/projects/SelfTest/IntrospectiveTests/InternalBenchmark.tests.cpp\n@@ -0,0 +1,405 @@\n+/*\n+ *  Created by Joachim on 16/04/2019.\n+ *  Adapted from donated nonius code.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#include \"catch.hpp\"\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+namespace {\n+    struct manual_clock {\n+    public:\n+        using duration = std::chrono::nanoseconds;\n+        using time_point = std::chrono::time_point<manual_clock, duration>;\n+        using rep = duration::rep;\n+        using period = duration::period;\n+        enum { is_steady = true };\n+\n+        static time_point now() {\n+            return time_point(duration(tick()));\n+        }\n+\n+        static void advance(int ticks = 1) {\n+            tick() += ticks;\n+        }\n+\n+    private:\n+        static rep& tick() {\n+            static rep the_tick = 0;\n+            return the_tick;\n+        }\n+    };\n+\n+    struct counting_clock {\n+    public:\n+        using duration = std::chrono::nanoseconds;\n+        using time_point = std::chrono::time_point<counting_clock, duration>;\n+        using rep = duration::rep;\n+        using period = duration::period;\n+        enum { is_steady = true };\n+\n+        static time_point now() {\n+            static rep ticks = 0;\n+            return time_point(duration(ticks += rate()));\n+        }\n+\n+        static void set_rate(rep new_rate) { rate() = new_rate; }\n+\n+    private:\n+        static rep& rate() {\n+            static rep the_rate = 1;\n+            return the_rate;\n+        }\n+    };\n+\n+    struct TestChronometerModel : Catch::Benchmark::Detail::ChronometerConcept {\n+        int started = 0;\n+        int finished = 0;\n+\n+        void start() override { ++started; }\n+        void finish() override { ++finished; }\n+    };\n+} // namespace\n+\n+TEST_CASE(\"warmup\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    auto start = counting_clock::now();\n+    auto iterations = Catch::Benchmark::Detail::warmup<counting_clock>();\n+    auto end = counting_clock::now();\n+\n+    REQUIRE((iterations * rate) > Catch::Benchmark::Detail::warmup_time.count());\n+    REQUIRE((end - start) > Catch::Benchmark::Detail::warmup_time);\n+}\n+\n+TEST_CASE(\"resolution\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    size_t count = 10;\n+    auto res = Catch::Benchmark::Detail::resolution<counting_clock>(static_cast<int>(count));\n+\n+    REQUIRE(res.size() == count);\n+\n+    for (size_t i = 1; i < count; ++i) {\n+        REQUIRE(res[i] == rate);\n+    }\n+}\n+\n+TEST_CASE(\"estimate_clock_resolution\", \"[benchmark]\") {\n+    auto rate = 1000;\n+    counting_clock::set_rate(rate);\n+\n+    int iters = 160000;\n+    auto res = Catch::Benchmark::Detail::estimate_clock_resolution<counting_clock>(iters);\n+\n+    REQUIRE(res.mean.count() == rate);\n+    REQUIRE(res.outliers.total() == 0);\n+}\n+\n+TEST_CASE(\"benchmark function call\", \"[benchmark]\") {\n+    SECTION(\"without chronometer\") {\n+        auto called = 0;\n+        auto model = TestChronometerModel{};\n+        auto meter = Catch::Benchmark::Chronometer{ model, 1 };\n+        auto fn = Catch::Benchmark::Detail::BenchmarkFunction{ [&] {\n+                CHECK(model.started == 1);\n+                CHECK(model.finished == 0);\n+                ++called;\n+            } };\n+\n+        fn(meter);\n+\n+        CHECK(model.started == 1);\n+        CHECK(model.finished == 1);\n+        CHECK(called == 1);\n+    }\n+\n+    SECTION(\"with chronometer\") {\n+        auto called = 0;\n+        auto model = TestChronometerModel{};\n+        auto meter = Catch::Benchmark::Chronometer{ model, 1 };\n+        auto fn = Catch::Benchmark::Detail::BenchmarkFunction{ [&](Catch::Benchmark::Chronometer) {\n+                CHECK(model.started == 0);\n+                CHECK(model.finished == 0);\n+                ++called;\n+            } };\n+\n+        fn(meter);\n+\n+        CHECK(model.started == 0);\n+        CHECK(model.finished == 0);\n+        CHECK(called == 1);\n+    }\n+}\n+\n+TEST_CASE(\"uniform samples\", \"[benchmark]\") {\n+    std::vector<double> samples(100);\n+    std::fill(samples.begin(), samples.end(), 23);\n+\n+    using it = std::vector<double>::iterator;\n+    auto e = Catch::Benchmark::Detail::bootstrap(0.95, samples.begin(), samples.end(), samples, [](it a, it b) {\n+        auto sum = std::accumulate(a, b, 0.);\n+        return sum / (b - a);\n+    });\n+    CHECK(e.point == 23);\n+    CHECK(e.upper_bound == 23);\n+    CHECK(e.lower_bound == 23);\n+    CHECK(e.confidence_interval == 0.95);\n+}\n+\n+\n+TEST_CASE(\"normal_cdf\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::normal_cdf;\n+    CHECK(normal_cdf(0.000000) == Approx(0.50000000000000000));\n+    CHECK(normal_cdf(1.000000) == Approx(0.84134474606854293));\n+    CHECK(normal_cdf(-1.000000) == Approx(0.15865525393145705));\n+    CHECK(normal_cdf(2.809729) == Approx(0.99752083845315409));\n+    CHECK(normal_cdf(-1.352570) == Approx(0.08809652095066035));\n+}\n+\n+TEST_CASE(\"erfc_inv\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::erfc_inv;\n+    CHECK(erfc_inv(1.103560) == Approx(-0.09203687623843015));\n+    CHECK(erfc_inv(1.067400) == Approx(-0.05980291115763361));\n+    CHECK(erfc_inv(0.050000) == Approx(1.38590382434967796));\n+}\n+\n+TEST_CASE(\"normal_quantile\", \"[benchmark]\") {\n+    using Catch::Benchmark::Detail::normal_quantile;\n+    CHECK(normal_quantile(0.551780) == Approx(0.13015979861484198));\n+    CHECK(normal_quantile(0.533700) == Approx(0.08457408802851875));\n+    CHECK(normal_quantile(0.025000) == Approx(-1.95996398454005449));\n+}\n+\n+\n+TEST_CASE(\"mean\", \"[benchmark]\") {\n+    std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+    auto m = Catch::Benchmark::Detail::mean(x.begin(), x.end());\n+\n+    REQUIRE(m == 19.);\n+}\n+\n+TEST_CASE(\"weighted_average_quantile\", \"[benchmark]\") {\n+    std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+    auto q1 = Catch::Benchmark::Detail::weighted_average_quantile(1, 4, x.begin(), x.end());\n+    auto med = Catch::Benchmark::Detail::weighted_average_quantile(1, 2, x.begin(), x.end());\n+    auto q3 = Catch::Benchmark::Detail::weighted_average_quantile(3, 4, x.begin(), x.end());\n+\n+    REQUIRE(q1 == 14.5);\n+    REQUIRE(med == 18.);\n+    REQUIRE(q3 == 23.);\n+}\n+\n+TEST_CASE(\"classify_outliers\", \"[benchmark]\") {\n+    auto require_outliers = [](Catch::Benchmark::OutlierClassification o, int los, int lom, int him, int his) {\n+        REQUIRE(o.low_severe == los);\n+        REQUIRE(o.low_mild == lom);\n+        REQUIRE(o.high_mild == him);\n+        REQUIRE(o.high_severe == his);\n+        REQUIRE(o.total() == los + lom + him + his);\n+    };\n+\n+    SECTION(\"none\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 0, 0);\n+    }\n+    SECTION(\"low severe\") {\n+        std::vector<double> x{ -12., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 1, 0, 0, 0);\n+    }\n+    SECTION(\"low mild\") {\n+        std::vector<double> x{ 1., 20., 14., 16., 30., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 1, 0, 0);\n+    }\n+    SECTION(\"high mild\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 36., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 1, 0);\n+    }\n+    SECTION(\"high severe\") {\n+        std::vector<double> x{ 10., 20., 14., 16., 49., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 0, 0, 0, 1);\n+    }\n+    SECTION(\"mixed\") {\n+        std::vector<double> x{ -20., 20., 14., 16., 39., 24. };\n+\n+        auto o = Catch::Benchmark::Detail::classify_outliers(x.begin(), x.end());\n+\n+        REQUIRE(o.samples_seen == static_cast<int>(x.size()));\n+        require_outliers(o, 1, 0, 1, 0);\n+    }\n+}\n+\n+TEST_CASE(\"analyse\", \"[benchmark]\") {\n+    Catch::ConfigData data{};\n+    data.benchmarkConfidenceInterval = 0.95;\n+    data.benchmarkNoAnalysis = false;\n+    data.benchmarkResamples = 1000;\n+    data.benchmarkSamples = 99;\n+    Catch::Config config{data};\n+\n+    using Duration = Catch::Benchmark::FloatDuration<Catch::Benchmark::default_clock>;\n+\n+    Catch::Benchmark::Environment<Duration> env;\n+    std::vector<Duration> samples(99);\n+    for (size_t i = 0; i < samples.size(); ++i) {\n+        samples[i] = Duration(23 + (i % 3 - 1));\n+    }\n+\n+    auto analysis = Catch::Benchmark::Detail::analyse(config, env, samples.begin(), samples.end());\n+    CHECK(analysis.mean.point.count() == 23);\n+    CHECK(analysis.mean.lower_bound.count() < 23);\n+    CHECK(analysis.mean.lower_bound.count() > 22);\n+    CHECK(analysis.mean.upper_bound.count() > 23);\n+    CHECK(analysis.mean.upper_bound.count() < 24);\n+\n+    CHECK(analysis.standard_deviation.point.count() > 0.5);\n+    CHECK(analysis.standard_deviation.point.count() < 1);\n+    CHECK(analysis.standard_deviation.lower_bound.count() > 0.5);\n+    CHECK(analysis.standard_deviation.lower_bound.count() < 1);\n+    CHECK(analysis.standard_deviation.upper_bound.count() > 0.5);\n+    CHECK(analysis.standard_deviation.upper_bound.count() < 1);\n+\n+    CHECK(analysis.outliers.total() == 0);\n+    CHECK(analysis.outliers.low_mild == 0);\n+    CHECK(analysis.outliers.low_severe == 0);\n+    CHECK(analysis.outliers.high_mild == 0);\n+    CHECK(analysis.outliers.high_severe == 0);\n+    CHECK(analysis.outliers.samples_seen == samples.size());\n+\n+    CHECK(analysis.outlier_variance < 0.5);\n+    CHECK(analysis.outlier_variance > 0);\n+}\n+\n+TEST_CASE(\"analyse no analysis\", \"[benchmark]\") {\n+    Catch::ConfigData data{};\n+    data.benchmarkConfidenceInterval = 0.95;\n+    data.benchmarkNoAnalysis = true;\n+    data.benchmarkResamples = 1000;\n+    data.benchmarkSamples = 99;\n+    Catch::Config config{ data };\n+\n+    using Duration = Catch::Benchmark::FloatDuration<Catch::Benchmark::default_clock>;\n+\n+    Catch::Benchmark::Environment<Duration> env;\n+    std::vector<Duration> samples(99);\n+    for (size_t i = 0; i < samples.size(); ++i) {\n+        samples[i] = Duration(23 + (i % 3 - 1));\n+    }\n+\n+    auto analysis = Catch::Benchmark::Detail::analyse(config, env, samples.begin(), samples.end());\n+    CHECK(analysis.mean.point.count() == 23);\n+    CHECK(analysis.mean.lower_bound.count() == 23);\n+    CHECK(analysis.mean.upper_bound.count() == 23);\n+\n+    CHECK(analysis.standard_deviation.point.count() == 0);\n+    CHECK(analysis.standard_deviation.lower_bound.count() == 0);\n+    CHECK(analysis.standard_deviation.upper_bound.count() == 0);\n+\n+    CHECK(analysis.outliers.total() == 0);\n+    CHECK(analysis.outliers.low_mild == 0);\n+    CHECK(analysis.outliers.low_severe == 0);\n+    CHECK(analysis.outliers.high_mild == 0);\n+    CHECK(analysis.outliers.high_severe == 0);\n+    CHECK(analysis.outliers.samples_seen == 0);\n+\n+    CHECK(analysis.outlier_variance == 0);\n+}\n+\n+TEST_CASE(\"run_for_at_least, int\", \"[benchmark]\") {\n+    manual_clock::duration time(100);\n+\n+    int old_x = 1;\n+    auto Timing = Catch::Benchmark::Detail::run_for_at_least<manual_clock>(time, 1, [&old_x](int x) -> int {\n+        CHECK(x >= old_x);\n+        manual_clock::advance(x);\n+        old_x = x;\n+        return x + 17;\n+    });\n+\n+    REQUIRE(Timing.elapsed >= time);\n+    REQUIRE(Timing.result == Timing.iterations + 17);\n+    REQUIRE(Timing.iterations >= time.count());\n+}\n+\n+TEST_CASE(\"run_for_at_least, chronometer\", \"[benchmark]\") {\n+    manual_clock::duration time(100);\n+\n+    int old_runs = 1;\n+    auto Timing = Catch::Benchmark::Detail::run_for_at_least<manual_clock>(time, 1, [&old_runs](Catch::Benchmark::Chronometer meter) -> int {\n+        CHECK(meter.runs() >= old_runs);\n+        manual_clock::advance(100);\n+        meter.measure([] {\n+            manual_clock::advance(1);\n+        });\n+        old_runs = meter.runs();\n+        return meter.runs() + 17;\n+    });\n+\n+    REQUIRE(Timing.elapsed >= time);\n+    REQUIRE(Timing.result == Timing.iterations + 17);\n+    REQUIRE(Timing.iterations >= time.count());\n+}\n+\n+\n+TEST_CASE(\"measure\", \"[benchmark]\") {\n+    auto r = Catch::Benchmark::Detail::measure<manual_clock>([](int x) -> int {\n+        CHECK(x == 17);\n+        manual_clock::advance(42);\n+        return 23;\n+    }, 17);\n+    auto s = Catch::Benchmark::Detail::measure<manual_clock>([](int x) -> int {\n+        CHECK(x == 23);\n+        manual_clock::advance(69);\n+        return 17;\n+    }, 23);\n+\n+    CHECK(r.elapsed.count() == 42);\n+    CHECK(r.result == 23);\n+    CHECK(r.iterations == 1);\n+\n+    CHECK(s.elapsed.count() == 69);\n+    CHECK(s.result == 17);\n+    CHECK(s.iterations == 1);\n+}\n+\n+TEST_CASE(\"run benchmark\", \"[benchmark]\") {\n+    counting_clock::set_rate(1000);\n+    auto start = counting_clock::now();\n+    \n+    Catch::Benchmark::Benchmark bench{ \"Test Benchmark\", [](Catch::Benchmark::Chronometer meter) {\n+        counting_clock::set_rate(100000);\n+        meter.measure([] { return counting_clock::now(); });\n+    } };\n+\n+    bench.run<counting_clock>();\n+    auto end = counting_clock::now();\n+\n+    CHECK((end - start).count() == 2867251000);\n+}\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\ndiff --git a/projects/SelfTest/UsageTests/Benchmark.tests.cpp b/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n--- a/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Benchmark.tests.cpp\n@@ -2,42 +2,129 @@\n \n #include <map>\n \n-TEST_CASE( \"benchmarked\", \"[!benchmark]\" ) {\n+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)\n+namespace {\n+    std::uint64_t Fibonacci(std::uint64_t number) {\n+        return number < 2 ? 1 : Fibonacci(number - 1) + Fibonacci(number - 2);\n+    }\n+}\n+\n+TEST_CASE(\"Benchmark Fibonacci\", \"[!benchmark]\") {\n+    CHECK(Fibonacci(0) == 1);\n+    // some more asserts..\n+    CHECK(Fibonacci(5) == 8);\n+    // some more asserts..\n+\n+    BENCHMARK(\"Fibonacci 20\") {\n+        return Fibonacci(20);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 25\") {\n+        return Fibonacci(25);\n+    };\n \n+    BENCHMARK(\"Fibonacci 30\") {\n+        return Fibonacci(30);\n+    };\n+\n+    BENCHMARK(\"Fibonacci 35\") {\n+        return Fibonacci(35);\n+    };\n+}\n+\n+TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n     static const int size = 100;\n \n     std::vector<int> v;\n     std::map<int, int> m;\n \n-    BENCHMARK( \"Load up a vector\" ) {\n-        v = std::vector<int>();\n-        for(int i =0; i < size; ++i )\n-            v.push_back( i );\n-    }\n-    REQUIRE( v.size() == size );\n+    SECTION(\"without generator\") {\n+        BENCHMARK(\"Load up a vector\") {\n+            v = std::vector<int>();\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n \n-    BENCHMARK( \"Load up a map\" ) {\n-        m = std::map<int, int>();\n-        for(int i =0; i < size; ++i )\n-            m.insert( { i, i+1 } );\n-    }\n-    REQUIRE( m.size() == size );\n+        // test optimizer control\n+        BENCHMARK(\"Add up a vector's content\") {\n+            uint64_t add = 0;\n+            for (int i = 0; i < size; ++i)\n+                add += v[i];\n+            return add;\n+        };\n+\n+        BENCHMARK(\"Load up a map\") {\n+            m = std::map<int, int>();\n+            for (int i = 0; i < size; ++i)\n+                m.insert({ i, i + 1 });\n+        };\n+        REQUIRE(m.size() == size);\n+\n+        BENCHMARK(\"Reserved vector\") {\n+            v = std::vector<int>();\n+            v.reserve(size);\n+            for (int i = 0; i < size; ++i)\n+                v.push_back(i);\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        BENCHMARK(\"Resized vector\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = i;\n+        };\n+        REQUIRE(v.size() == size);\n+\n+        int array[size];\n+        BENCHMARK(\"A fixed size array that should require no allocations\") {\n+            for (int i = 0; i < size; ++i)\n+                array[i] = i;\n+        };\n+        int sum = 0;\n+        for (int i = 0; i < size; ++i)\n+            sum += array[i];\n+        REQUIRE(sum > size);\n+\n+        SECTION(\"XYZ\") {\n+\n+            BENCHMARK_ADVANCED(\"Load up vector with chronometer\")(Catch::Benchmark::Chronometer meter) {\n+                std::vector<int> k;\n+                meter.measure([&](int idx) {\n+                    k = std::vector<int>();\n+                    for (int i = 0; i < size; ++i)\n+                        k.push_back(idx);\n+                });\n+                REQUIRE(k.size() == size);\n+            };\n+\n+            int runs = 0;\n+            BENCHMARK(\"Fill vector indexed\", benchmarkIndex) {\n+                v = std::vector<int>();\n+                v.resize(size);\n+                for (int i = 0; i < size; ++i)\n+                    v[i] = benchmarkIndex;\n+                runs = benchmarkIndex;\n+            };\n \n-    BENCHMARK( \"Reserved vector\" ) {\n-        v = std::vector<int>();\n-        v.reserve(size);\n-        for(int i =0; i < size; ++i )\n-            v.push_back( i );\n+            for (size_t i = 0; i < v.size(); ++i) {\n+                REQUIRE(v[i] == runs);\n+            }\n+        }\n     }\n-    REQUIRE( v.size() == size );\n \n-    int array[size];\n-    BENCHMARK( \"A fixed size array that should require no allocations\" ) {\n-        for(int i =0; i < size; ++i )\n-            array[i] = i;\n+    SECTION(\"with generator\") {\n+        auto generated = GENERATE(range(0, 10));\n+        BENCHMARK(\"Fill vector generated\") {\n+            v = std::vector<int>();\n+            v.resize(size);\n+            for (int i = 0; i < size; ++i)\n+                v[i] = generated;\n+        };\n+        for (size_t i = 0; i < v.size(); ++i) {\n+            REQUIRE(v[i] == generated);\n+        }\n     }\n-    int sum = 0;\n-    for(int i =0; i < size; ++i )\n-        sum += array[i];\n-    REQUIRE( sum > size );\n }\n+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING\n", "problem_statement": "Rename #define BENCHMARK or allow disabling benchmark feature\n## Description\r\n\r\nThe `#define BENCHMARK` in https://github.com/catchorg/Catch2/commit/a9b6813ad9e423ddcd6559f52b503a68fe0f624c#diff-c06d59fb4f39c13fb9a355b49d321fcfR52 is an unfortunate name, with high potential of clashes.\r\n\r\nFor example, it clashes with (older) benchmarking framework, see https://github.com/DigitalInBlue/Celero/commit/dc6853478aece4da17e177f285896648b23dc2fd#diff-f1b66ca763828028068774e33319efb4R137 The generic `BENCHMARK` name issue also reported to Celero https://github.com/DigitalInBlue/Celero/issues/114\r\n\r\nIt would be extremely helpful Catch offers a `#define` to allow disabling the whole benchmarking feature all the way.\r\n\r\n\n", "hints_text": "I may be missing something obvious, but is there a good reason why you have both Catch2 and Celero in the same translation unit?\nIt happens, there are/were some files which included both (eg. shared fixtures for both, benchmark and test, so benchmark is actually tested for correctness - in non-optimised builds)", "created_at": "2019-04-27T17:04:30Z", "version": "2.8"}
{"repo": "catchorg/Catch2", "pull_number": 1614, "instance_id": "catchorg__Catch2-1614", "issue_numbers": ["1612"], "base_commit": "9c741fe96073ed620ffc032afbed1f3c789d2b68", "patch": "diff --git a/include/internal/catch_tostring.cpp b/include/internal/catch_tostring.cpp\n--- a/include/internal/catch_tostring.cpp\n+++ b/include/internal/catch_tostring.cpp\n@@ -234,11 +234,16 @@ std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {\n     return \"nullptr\";\n }\n \n+int StringMaker<float>::precision = 5;\n+   \n std::string StringMaker<float>::convert(float value) {\n-    return fpToString(value, 5) + 'f';\n+    return fpToString(value, precision) + 'f';\n }\n+\n+int StringMaker<double>::precision = 10;\n+    \n std::string StringMaker<double>::convert(double value) {\n-    return fpToString(value, 10);\n+    return fpToString(value, precision);\n }\n \n std::string ratio_string<std::atto>::symbol() { return \"a\"; }\ndiff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -261,10 +261,13 @@ namespace Catch {\n     template<>\n     struct StringMaker<float> {\n         static std::string convert(float value);\n+        static int precision;\n     };\n+\n     template<>\n     struct StringMaker<double> {\n         static std::string convert(double value);\n+        static int precision;\n     };\n \n     template <typename T>\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n@@ -128,6 +128,40 @@ TEST_CASE(\"String views are stringified like other strings\", \"[toString][approva\n \n #endif\n \n+TEST_CASE(\"Precision of floating point stringification can be set\", \"[toString][floatingPoint]\") {\n+    SECTION(\"Floats\") {\n+        using sm = Catch::StringMaker<float>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const float testFloat = 1.12345678901234567899f;\n+        auto str1 = sm::convert(testFloat);\n+        sm::precision = 5;\n+        // \"1.\" prefix = 2 chars, f suffix is another char\n+        CHECK(str1.size() == 3 + 5);\n+\n+        sm::precision = 10;\n+        auto str2 = sm::convert(testFloat);\n+        REQUIRE(str2.size() == 3 + 10);\n+        sm::precision = oldPrecision;\n+    }\n+    SECTION(\"Double\") {\n+        using sm = Catch::StringMaker<double>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const double testDouble = 1.123456789012345678901234567899;\n+        sm::precision = 5;\n+        auto str1 = sm::convert(testDouble);\n+        // \"1.\" prefix = 2 chars\n+        CHECK(str1.size() == 2 + 5);\n+\n+        sm::precision = 15;\n+        auto str2 = sm::convert(testDouble);\n+        REQUIRE(str2.size() == 2 + 15);\n+\n+        sm::precision = oldPrecision;\n+    }\n+}\n+\n namespace {\n \n struct WhatException : std::exception {\n", "problem_statement": "Allow custom precision in error reports for floating-point numbers\n**Description**\r\nAs in [this SO Q&A](https://stackoverflow.com/q/55867570/201787), it would be nice to allow customization of the precision of floating-point values that fail. At present, the precision for float and double are hard-coded within Catch2 to 5 and 10, respectively:\r\n```cpp\r\nstd::string StringMaker<float>::convert(float value) {\r\n    return fpToString(value, 5) + 'f';\r\n}\r\nstd::string StringMaker<double>::convert(double value) {\r\n    return fpToString(value, 10);\r\n}\r\n```\r\nSometimes things will fail (even with `Approx()`), but the precision of the failure message doesn't show enough precision to be meaningful.\r\n```\r\nprog.cc:22: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.0f\r\n```\r\nThe proposal here is to add a `setPrecision()` function to allow the user to control this. I have prototyped this, which you can see running [live on Wandbox](https://wandbox.org/permlink/mZXPLEuET5ZeTg1t). Here's the test:\r\n```cpp\r\nTEMPLATE_TEST_CASE( \"Double, double, toil and trouble\", \"[double]\", float, double ) \r\n{\r\n    const auto precision = GENERATE( -1, 0, 3, std::numeric_limits<TestType>::max_digits10 );\r\n\r\n    if( precision >= 0 )\r\n    {\r\n        Catch::StringMaker<TestType>::setPrecision( precision );\r\n    }\r\n    \r\n    // Expected to fail to demonstrate the problem\r\n    REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() ); \r\n}\r\n```\r\nThe output shows as expected for floats and doubles. For instance:\r\n```\r\nprog.cc:15: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.000000119f\r\n```\r\nMaking a unit test for this is a little iffy since the actual string values are dependent on the usual floating-point fuzziness. I guess it could compare string length without looking too closely at the value.\n", "hints_text": "", "created_at": "2019-04-26T18:37:28Z", "version": "2.7"}
{"repo": "catchorg/Catch2", "pull_number": 1609, "instance_id": "catchorg__Catch2-1609", "issue_numbers": ["1531"], "base_commit": "bd703dd74be7fd2413eb0c01662a491bcebea430", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -150,14 +150,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -233,14 +241,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -324,15 +340,23 @@ using Catch::Detail::Approx;\n #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -400,15 +424,23 @@ using Catch::Detail::Approx;\n #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -64,6 +64,12 @@\n #       define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS \\\n             _Pragma( \"clang diagnostic pop\" )\n \n+#       define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic push\" ) \\\n+            _Pragma( \"clang diagnostic ignored \\\"-Wgnu-zero-variadic-macro-arguments\\\"\" )\n+#       define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic pop\" )\n+\n #endif // __clang__\n \n \n@@ -274,6 +280,10 @@\n #   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS\n #   define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS\n #endif\n+#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)\n+#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS\n+#   define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\n+#endif\n \n #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)\n #define CATCH_TRY if ((true))\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -12,66 +12,8 @@\n #include <type_traits>\n \n namespace Catch {\n-template< typename... >\n-struct TypeList {};\n-\n-template< typename... >\n-struct append;\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n->\n-struct append< L1<E1...>, L2<E2...> > {\n-    using type = L1<E1..., E2...>;\n-};\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n-    , typename...Rest\n->\n-struct append< L1<E1...>, L2<E2...>, Rest...> {\n-    using type = typename append< L1<E1..., E2...>, Rest... >::type;\n-};\n-\n-template< template<typename...> class\n-    , typename...\n->\n-struct rewrap;\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , typename...elems\n->\n-struct rewrap<Container, List<elems...>> {\n-    using type = TypeList< Container< elems... > >;\n-};\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , class...Elems\n-    , typename...Elements>\n-    struct rewrap<Container, List<Elems...>, Elements...> {\n-    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n-};\n-\n-template< template<typename...> class...Containers >\n-struct combine {\n-    template< typename...Types >\n-    struct with_types {\n-        template< template <typename...> class Final >\n-        struct into {\n-            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n-        };\n-    };\n-};\n-\n-template<typename T>\n-struct always_false : std::false_type {};\n-\n+    template<typename T>\n+    struct always_false : std::false_type {};\n } // namespace Catch\n \n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -68,22 +68,151 @@\n #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)\n #endif\n \n+#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__\n+#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)\n+\n #define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)\n \n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name, __VA_ARGS__)\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" - \" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name,...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n #else\n-// MSVC is adding extra space and needs more calls to properly remove ()\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" -\" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, __VA_ARGS__)\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) Catch::TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)\n+\n+#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)\n+#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)\n+#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)\n+#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)\n+#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)\n+#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)\n+#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _4, _5, _6)\n+#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)\n+#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)\n+#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)\n+#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)\n+\n+#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n+\n+#define INTERNAL_CATCH_TYPE_GEN\\\n+    template<typename...> struct TypeList {};\\\n+    template<typename...Ts>\\\n+    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\\\n+    \\\n+    template<template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2> \\\n+    constexpr auto append(L1<E1...>, L2<E2...>) noexcept -> L1<E1...,E2...> { return {}; }\\\n+    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\\n+    constexpr auto append(L1<E1...>, L2<E2...>, Rest...) noexcept -> decltype(append(L1<E1...,E2...>{}, Rest{}...)) { return {}; }\\\n+    \\\n+    template< template<typename...> class Container, template<typename...> class List, typename...elems>\\\n+    constexpr auto rewrap(List<elems...>) noexcept -> TypeList<Container<elems...>> { return {}; }\\\n+    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\\\n+    constexpr auto rewrap(List<Elems...>,Elements...) noexcept -> decltype(append(TypeList<Container<Elems...>>{}, rewrap<Container>(Elements{}...))) { return {}; }\\\n+    \\\n+    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_NTTP_1(signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \\\n+    \\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>) noexcept -> TypeList<Container<__VA_ARGS__>> { return {}; }\\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>,Elements...elems) noexcept -> decltype(append(TypeList<Container<__VA_ARGS__>>{}, rewrap<Container>(elems...))) { return {}; }\\\n+    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\\\n+    template<typename TestType> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\\\n+    template<typename TestType> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n-    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+#define INTERNAL_CATCH_NTTP_0\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)\n+#else\n+#define INTERNAL_CATCH_NTTP_0(signature)\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))\n+#endif\n \n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -6,6 +6,7 @@\n [Tag aliases](#tag-aliases)<br>\n [BDD-style test cases](#bdd-style-test-cases)<br>\n [Type parametrised test cases](#type-parametrised-test-cases)<br>\n+[Signature based parametrised test cases](#signature-based-parametrised-test-cases)<br>\n \n While Catch fully supports the traditional, xUnit, style of class-based fixtures containing test case methods this is not the preferred style.\n \n@@ -191,6 +192,56 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+\n+## Signature based parametrised test cases\n+\n+In addition to [type parametrised test cases](#type-parametrised-test-cases) Catch2 also supports\n+signature base parametrised test cases, in form of `TEMPLATE_TEST_CASE_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_SIG`.\n+These test cases have similar syntax like [type parametrised test cases](#type-parametrised-test-cases), with one\n+additional positional argument which specifies the signature.\n+\n+### Signature\n+Signature has some strict rules for these tests cases to work properly:\n+* signature with multiple template parameters e.g. `typename T, size_t S` must have this format in test case declaration\n+  `((typename T, size_t S), T, S)`\n+* signature with variadic template arguments e.g. `typename T, size_t S, typename...Ts` must have this format in test case declaration\n+  `((typename T, size_t S, typename...Ts), T, S, Ts...)`\n+* signature with single non type template parameter e.g. `int V` must have this format in test case declaration `((int V), V)`\n+* signature with single type template parameter e.g. `typename T` should not be used as it is in fact `TEMPLATE_TEST_CASE`\n+\n+Currently Catch2 support up to 11 template parameters in signature\n+\n+### Examples\n+\n+* **TEMPLATE_TEST_CASE_SIG(** _test name_ , _tags_,  _signature_, _type1_, _type2_, ..., _typen_ **)**\n+\n+Inside `TEMPLATE_TEST_CASE_SIG` test case you can use the names of template parameters as defined in _signature_. \n+\n+```cpp\n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: arrays can be created from NTTP arguments\", \"[vector][template][nttp]\",\n+  ((typename T, int V), T, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::array<T, V> v;\n+    REQUIRE(v.size() > 1);\n+}\n+```\n+\n+* **TEMPLATE_PRODUCT_TEST_CASE_SIG(** _test name_ , _tags_, _signature_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+```cpp\n+\n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+```\n+\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -84,6 +84,33 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n the limit is very high and should not be encountered in practice._\n \n+\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG` to support\n+fixtures using non-type template parameters. These test cases work similar to `TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+with additional positional argument for [signature](test-cases-and-sections.md#signature-based-parametrised-test-cases).\n+\n+Example:\n+```cpp\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n+\n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -60,18 +60,47 @@ struct AutoReg : NonCopyable {\n             };                            \\\n         }                                 \\\n         void TestName::test()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION( TestName, ... )  \\\n-        template<typename TestType>                                             \\\n-        static void TestName()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... )    \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \\\n         namespace{                                                                                  \\\n-            template<typename TestType>                                                             \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) {     \\\n-                void test();                                                                        \\\n-            };                                                                                      \\\n+            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         }                                                                                           \\\n-        template<typename TestType>                                                                 \\\n-        void TestName::test()\n+        }                                                                                           \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+    #endif  \n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n #endif\n \n     ///////////////////////////////////////////////////////////////////////////////\n@@ -111,46 +140,61 @@ struct AutoReg : NonCopyable {\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n     ///////////////////////////////////////////////////////////////////////////////\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, ... )\\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc();\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestName{\\\n-                template<typename...Ts> \\\n-                TestName(Ts...names){\\\n+                TestName(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, __VA_ARGS__) \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+            return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n-#endif\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+#endif  \n \n-    #define INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, ...)\\\n-        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-            TestName<CATCH_REC_LIST(INTERNAL_CATCH_REMOVE_PARENS, __VA_ARGS__)>(CATCH_REC_LIST_UD(INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME,Name, __VA_ARGS__));\\\n-            return 0;\\\n-        }();\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\\n         template<typename TestType> static void TestFuncName();       \\\n-        namespace {                                                   \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \\\n+            INTERNAL_CATCH_TYPE_GEN                                                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\\n             template<typename... Types>                               \\\n             struct TestName {                                         \\\n-                TestName() {                                          \\\n+                void reg_tests() {                                          \\\n                     int index = 0;                                    \\\n                     using expander = int[];                           \\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -160,63 +204,92 @@ struct AutoReg : NonCopyable {\n                 }                                                     \\\n             };                                                        \\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n-                TestInit();                                           \\\n+                using TestInit = decltype(create<TestName, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n                 return 0;                                             \\\n             }();                                                      \\\n         }                                                             \\\n+        }                                                             \\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS              \\\n         template<typename TestType>                                   \\\n         static void TestFuncName()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )\n+#endif\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        namespace{ \\\n-            template<typename TestType> \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n-                void test();\\\n-            };\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n+            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestNameClass{\\\n-                template<typename...Ts> \\\n-                TestNameClass(Ts...names){\\\n+                TestNameClass(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestNameClass, Name, __VA_ARGS__)\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+                return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\\\n-        template<typename TestType> \\\n-        void TestName<TestType>::test()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n+\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n                 void test();\\\n             };\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\\\n+            INTERNAL_CATCH_TYPE_GEN                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types>\\\n             struct TestNameClass{\\\n-                TestNameClass(){\\\n+                void reg_tests(){\\\n                     int index = 0;\\\n                     using expander = int[];\\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -226,22 +299,33 @@ struct AutoReg : NonCopyable {\n                 }\\\n             };\\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n-                TestInit();\\\n+                using TestInit = decltype(create<TestNameClass, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n                 return 0;\\\n             }(); \\\n         }\\\n+        }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n         void TestName<TestType>::test()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )\n #endif\n \n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n+#endif\n+\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -7,6 +7,7 @@\n  */\n \n #include \"catch.hpp\"\n+#include <array>\n \n namespace{ namespace ClassTests {\n \n@@ -58,6 +59,15 @@ struct Template_Foo {\n     size_t size() { return 0; }\n };\n \n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n #endif\n \n \n@@ -74,11 +84,20 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n {\n     REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -92,10 +111,19 @@ namespace Inner\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n \n+    TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][nttp][failing]\", ((int V), V), 1, 3, 6) {\n+        REQUIRE(Nttp_Fixture<V>::value == 0);\n+    }\n+\n     TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n     {\n         REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][product][nttp][failing]\", ((typename T, size_t S), T, S), (std::array, Template_Foo_2), ((int, 2), (float, 6)))\n+    {\n+        REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() < 2);\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -18,6 +18,7 @@\n #include <cerrno>\n #include <limits>\n #include <sstream>\n+#include <array>\n \n namespace { namespace MiscTests {\n \n@@ -66,6 +67,10 @@ struct Foo {\n     size_t size() { return 0; }\n };\n \n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -306,11 +311,56 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: vectors can be sized and resized\", \"[vector][template][nttp]\", ((typename TestType, int V), TestType, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::vector<TestType> v(V);\n+\n+    REQUIRE(v.size() == V);\n+    REQUIRE(v.capacity() >= V);\n+\n+    SECTION(\"resizing bigger changes size and capacity\") {\n+        v.resize(2 * V);\n+\n+        REQUIRE(v.size() == 2 * V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"resizing smaller changes size but not capacity\") {\n+        v.resize(0);\n+\n+        REQUIRE(v.size() == 0);\n+        REQUIRE(v.capacity() >= V);\n+\n+        SECTION(\"We can use the 'swap trick' to reset the capacity\") {\n+            std::vector<TestType> empty;\n+            empty.swap(v);\n+\n+            REQUIRE(v.capacity() == 0);\n+        }\n+    }\n+    SECTION(\"reserving bigger changes capacity but not size\") {\n+        v.reserve(2 * V);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"reserving smaller does not change size or capacity\") {\n+        v.reserve(0);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= V);\n+    }\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n     TestType x;\n     REQUIRE(x.size() == 0);\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\n", "problem_statement": "Type parametrised test case: support for non-type template parameters\nRight now, TEMPLATE_TEST_CASE and friends only seem to support type template parameters. Would be nice if we can also do something like this:\r\n\r\n    template<std::size_t,typename> struct Type;\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", 1, 2, 3, 4) {\r\n       Type<TestType, float> test;\r\n    }\r\n\r\n or even\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (1, int), (2, float), (3, int), (4, float)) {\r\n       Type<TestType> test;\r\n    }\r\n  \r\nP.S. Right now I am circumventing it like this:\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (Type<1, float), (Type<2, float), (Type<3, float), (Type<4, float)) {\r\n       TestType test;\r\n    }\r\n\r\nwhich does work\n", "hints_text": "@tzakharko actually we thought about NTTP support for `TEMPLATE_PRODUCT_TEST_CASE`.\r\nWe decided that it would not be so trivial since the whole generation of the final `TestType` depends on the template signature for that type.\r\nEither way I think that I will take a deeper look on this feature.", "created_at": "2019-04-24T18:06:50Z", "version": "2.7"}
{"repo": "catchorg/Catch2", "pull_number": 2187, "instance_id": "catchorg__Catch2-2187", "issue_numbers": ["1390"], "base_commit": "2cb5210caf35bf8fc29ade2e5570cc0f37537951", "patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -230,9 +230,11 @@ namespace Catch {\n         if (result.getResultType() == ResultWas::Ok) {\n             m_totals.assertions.passed++;\n             m_lastAssertionPassed = true;\n-        } else if (!result.isOk()) {\n+        } else if (!result.succeeded()) {\n             m_lastAssertionPassed = false;\n-            if( m_activeTestCase->getTestCaseInfo().okToFail() )\n+            if (result.isOk()) {\n+            }\n+            else if( m_activeTestCase->getTestCaseInfo().okToFail() )\n                 m_totals.assertions.failedButOk++;\n             else\n                 m_totals.assertions.failed++;\n", "test_patch": "diff --git a/src/catch2/catch_test_macros.hpp b/src/catch2/catch_test_macros.hpp\n--- a/src/catch2/catch_test_macros.hpp\n+++ b/src/catch2/catch_test_macros.hpp\n@@ -32,8 +32,8 @@\n \n   #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n-  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n-  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CATCH_CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n+  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CATCH_CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n   #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CATCH_CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n \n   #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CATCH_CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n@@ -123,8 +123,8 @@\n \n   #define CHECK( ... ) INTERNAL_CATCH_TEST( \"CHECK\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n   #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( \"CHECK_FALSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\n-  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n-  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\n+  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( \"CHECKED_IF\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n+  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( \"CHECKED_ELSE\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n   #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( \"CHECK_NOFAIL\", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\n \n   #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( \"CHECK_THROWS\", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -182,6 +182,39 @@ TEST_CASE( \"checkedElse, failing\", \"[failing][.]\" ) {\n     REQUIRE( testCheckedElse( false ) );\n }\n \n+TEST_CASE(\"Testing checked-if\", \"[checked-if]\") {\n+    CHECKED_IF(true) {\n+        SUCCEED();\n+    }\n+    CHECKED_IF(false) {\n+        FAIL();\n+    }\n+    CHECKED_ELSE(true) {\n+        FAIL();\n+    }\n+    CHECKED_ELSE(false) {\n+        SUCCEED();\n+    }\n+}\n+\n+TEST_CASE(\"Testing checked-if 2\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_IF(true) {\n+        FAIL();\n+    }\n+    // If the checked if is not entered, this passes and the test\n+    // fails, because of the [!shouldfail] tag.\n+    SUCCEED();\n+}\n+\n+TEST_CASE(\"Testing checked-if 3\", \"[checked-if][!shouldfail]\") {\n+    CHECKED_ELSE(false) {\n+        FAIL();\n+    }\n+    // If the checked false is not entered, this passes and the test\n+    // fails, because of the [!shouldfail] tag.\n+    SUCCEED();\n+}\n+\n TEST_CASE( \"xmlentitycheck\" ) {\n     SECTION( \"embedded xml: <test>it should be possible to embed xml characters, such as <, \\\" or &, or even whole <xml>documents</xml> within an attribute</test>\" ) {\n         SUCCEED(); // We need this here to stop it failing due to no tests\n", "problem_statement": "Make CHECKED_IF and CHECKED_ELSE \"ok to fail\"\n## Description\r\nBoth `CHECKED_IF` and `CHECKED_ELSE` are currently fairly obscure macros that simplify using `if`/`else` in tests.\r\n\r\nHowever, entering the `else` branch fails the test in which it occurs, because they are not marked as being ok to fail (tagged with `Catch::ResultDisposition::SuppressFail` to be exact). This behaviour makes them less than useful, but with a change they should be actually usable.\r\n\r\nMilestone 3.0, because it is a theoretically breaking change.\r\n\n", "hints_text": "First of all, awesome work with Catch2, THE best testing framework out there. This thread is particularly useful as currently I'm testing with MPI communication whose number of processors is known only at runtime. By adding CHECKED_IF( num_of_procs > 4 ) I can prevent MPI failure on small core machines without having to comment out these tests. Really looking forward to this tweak.", "created_at": "2021-03-12T19:19:22Z", "version": "3.0"}
{"repo": "catchorg/Catch2", "pull_number": 1608, "instance_id": "catchorg__Catch2-1608", "issue_numbers": ["1607"], "base_commit": "979bbf03bb00bc55ca09783791b5091a2247df68", "patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -9,6 +9,7 @@\n #include \"catch_message.h\"\n #include \"catch_interfaces_capture.h\"\n #include \"catch_uncaught_exceptions.h\"\n+#include \"catch_enforce.h\"\n \n #include <cassert>\n #include <stack>\n@@ -76,6 +77,15 @@ namespace Catch {\n             }\n             return names.substr(start, end - start + 1);\n         };\n+        auto skipq = [&] (size_t start, char quote) {\n+            for (auto i = start + 1; i < names.size() ; ++i) {\n+                if (names[i] == quote)\n+                    return i;\n+                if (names[i] == '\\\\')\n+                    ++i;\n+            }\n+            CATCH_INTERNAL_ERROR(\"CAPTURE parsing encountered unmatched parentheses\");\n+        };\n \n         size_t start = 0;\n         std::stack<char> openings;\n@@ -96,6 +106,10 @@ namespace Catch {\n //           case '>':\n                 openings.pop();\n                 break;\n+            case '\"':\n+            case '\\'':\n+                pos = skipq(pos, c);\n+                break;\n             case ',':\n                 if (start != pos && openings.size() == 0) {\n                     m_messages.emplace_back(macroName, lineInfo, resultType);\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -251,6 +251,13 @@ TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messag\n     SUCCEED();\n }\n \n+TEST_CASE(\"CAPTURE parses string and character constants\", \"[messages][capture]\") {\n+    CAPTURE((\"comma, in string\", \"escaped, \\\", \"), \"single quote in string,',\", \"some escapes, \\\\,\\\\\\\\\");\n+    CAPTURE(\"some, ), unmatched, } prenheses {[<\");\n+    CAPTURE('\"', '\\'', ',', '}', ')', '(', '{');\n+    SUCCEED();\n+}\n+\n #ifdef __clang__\n #pragma clang diagnostic pop\n #endif\n", "problem_statement": "CAPTURE(\"text, with comma\") fails\n**Describe the bug**\r\nWhen string containing comma is passed to CAPTURE and test succeeds, the program will fail assertion \r\n`Capturer::~Capturer() : assert( m_captured == m_messages.size() );`\r\n\r\n**Expected behavior**\r\nDocumenting this behavior is probably enough. CAPTURE((\"test, with comma\")) works as expected. \r\n\r\n**Reproduction steps**\r\n```\r\nTEST_CASE(\"catch\") {\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(false);\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(true);\r\n}\r\n```\r\nproduces:\r\n```\r\ntest/test_suite.cpp:35: FAILED:\r\n  CHECK( false )\r\nwith message:\r\n  \"test := \"test, with comma\"\r\n\r\ntest_suite: test/catch.hpp:9638: Catch::Capturer::~Capturer(): Assertion `m_captured == m_messages.size()' failed.\r\n```\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Debian stretch**\r\n - Compiler+version: **gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516**\r\n - Catch version: **Catch v2.7.0**\r\n\r\n\r\n**Additional context**\r\nCapturer::Capturer() does not expect quotation in names. It should be quite easy to fix (just add `bool isquoted` into parsing algorithm.\r\n\r\nBTW: Capturing string is quite useful when capturing __VA_ARGS__ in macro ... \r\n\n", "hints_text": "", "created_at": "2019-04-24T14:13:38Z", "version": "2.7"}
{"repo": "catchorg/Catch2", "pull_number": 1422, "instance_id": "catchorg__Catch2-1422", "issue_numbers": ["1351"], "base_commit": "1faccd601d904a951142d8fba82914a8325b764e", "patch": "diff --git a/include/internal/catch_commandline.cpp b/include/internal/catch_commandline.cpp\n--- a/include/internal/catch_commandline.cpp\n+++ b/include/internal/catch_commandline.cpp\n@@ -10,6 +10,9 @@\n \n #include \"catch_string_manip.h\"\n \n+#include \"catch_interfaces_registry_hub.h\"\n+#include \"catch_interfaces_reporter.h\"\n+\n #include <fstream>\n #include <ctime>\n \n@@ -105,6 +108,18 @@ namespace Catch {\n                 return ParserResult::runtimeError( \"Unrecognised verbosity, '\" + verbosity + \"'\" );\n             return ParserResult::ok( ParseResultType::Matched );\n         };\n+        auto const setReporter = [&]( std::string const& reporter ) {\n+            IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n+\n+            auto lcReporter = toLower( reporter );\n+            auto result = factories.find( lcReporter );\n+\n+            if( factories.end() != result )\n+                config.reporterName = lcReporter;\n+            else\n+                return ParserResult::runtimeError( \"Unrecognized reporter, '\" + reporter + \"'. Check available with --list-reporters\" );\n+            return ParserResult::ok( ParseResultType::Matched );\n+        };\n \n         auto cli\n             = ExeName( config.processName )\n@@ -130,7 +145,7 @@ namespace Catch {\n             | Opt( config.outputFilename, \"filename\" )\n                 [\"-o\"][\"--out\"]\n                 ( \"output filename\" )\n-            | Opt( config.reporterName, \"name\" )\n+            | Opt( setReporter, \"name\" )\n                 [\"-r\"][\"--reporter\"]\n                 ( \"reporter to use (defaults to console)\" )\n             | Opt( config.name, \"name\" )\ndiff --git a/include/internal/catch_list.cpp b/include/internal/catch_list.cpp\n--- a/include/internal/catch_list.cpp\n+++ b/include/internal/catch_list.cpp\n@@ -124,7 +124,7 @@ namespace Catch {\n         return tagCounts.size();\n     }\n \n-    std::size_t listReporters( Config const& /*config*/ ) {\n+    std::size_t listReporters() {\n         Catch::cout() << \"Available reporters:\\n\";\n         IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();\n         std::size_t maxNameLen = 0;\n@@ -155,7 +155,7 @@ namespace Catch {\n         if( config.listTags() )\n             listedCount = listedCount.valueOr(0) + listTags( config );\n         if( config.listReporters() )\n-            listedCount = listedCount.valueOr(0) + listReporters( config );\n+            listedCount = listedCount.valueOr(0) + listReporters();\n         return listedCount;\n     }\n \ndiff --git a/include/internal/catch_list.h b/include/internal/catch_list.h\n--- a/include/internal/catch_list.h\n+++ b/include/internal/catch_list.h\n@@ -29,7 +29,7 @@ namespace Catch {\n \n     std::size_t listTags( Config const& config );\n \n-    std::size_t listReporters( Config const& /*config*/ );\n+    std::size_t listReporters();\n     \n     Option<std::size_t> list( Config const& config );\n \n", "test_patch": "diff --git a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/CmdLine.tests.cpp\n@@ -280,7 +280,6 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n         CHECK(config.processName == \"\");\n     }\n \n-\n     SECTION(\"default - no arguments\") {\n         auto result = cli.parse({\"test\"});\n         CHECK(result);\n@@ -345,8 +344,15 @@ TEST_CASE( \"Process can be configured on command line\", \"[config][command-line]\"\n         SECTION(\"Only one reporter is accepted\") {\n             REQUIRE_FALSE(cli.parse({ \"test\", \"-r\", \"xml\", \"-r\", \"junit\" }));\n         }\n-    }\n+        SECTION(\"must match one of the available ones\") {\n+            auto result = cli.parse({\"test\", \"--reporter\", \"unsupported\"});\n+            CHECK(!result);\n \n+#ifndef CATCH_CONFIG_DISABLE_MATCHERS\n+            REQUIRE_THAT(result.errorMessage(), Contains(\"Unrecognized reporter\"));\n+#endif\n+        }\n+    }\n \n     SECTION(\"debugger\") {\n         SECTION(\"-b\") {\n", "problem_statement": "unregistered reporter is not considered a command line error\n## Description\r\nwhen `session.applyCommandLine()` is called with an unregistered reporter, the function simply returns 0 and the later call to `session.run()` just outputs a text: `No reporter registered with name: 'foo'`\r\n\r\n### Steps to reproduce\r\n    int main()\r\n    {\r\n      const char* argv[] = { \"runner\", \"-r foo\" };\r\n\r\n      Catch::Session session;\r\n\r\n      const int command_line_errors = session.applyCommandLine( std::size( argv ), const_cast< char** >( argv ) );\r\n\r\n      if ( command_line_errors == 0 )\r\n      {\r\n        session.run();\r\n      }\r\n      else\r\n      {\r\n        Catch::cerr() << \"Error parsing following command line: \" << *std::prev( std::end( argv ) ) << std::endl;\r\n      }\r\n    }\r\n\r\nI would expect the parser to recognize this as command line argument error.\r\n\r\n* Catch version: v2.3\r\n* Operating System: No Operation System; bare metal\r\n* Compiler+version: gcc version 7.3.1 20180622 (release) [ARM/embedded-7-branch revision 261907] (GNU Tools for Arm Embedded Processors 7-2018-q2-update) \n", "hints_text": "", "created_at": "2018-10-22T14:08:24Z", "version": "2.4"}
{"repo": "catchorg/Catch2", "pull_number": 1448, "instance_id": "catchorg__Catch2-1448", "issue_numbers": ["1436"], "base_commit": "62460fafe6b54c3173bc5cbc46d05a5f071017ff", "patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -11,6 +11,7 @@\n #include \"catch_uncaught_exceptions.h\"\n \n #include <cassert>\n+#include <stack>\n \n namespace Catch {\n \n@@ -60,19 +61,48 @@ namespace Catch {\n \n \n     Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {\n-        auto start = std::string::npos;\n-        for( size_t pos = 0; pos <= names.size(); ++pos ) {\n+        auto trimmed = [&] (size_t start, size_t end) {\n+            while (names[start] == ',' || isspace(names[start])) {\n+                ++start;\n+            }\n+            while (names[end] == ',' || isspace(names[end])) {\n+                --end;\n+            }\n+            return names.substr(start, end - start + 1);\n+        };\n+\n+        size_t start = 0;\n+        std::stack<char> openings;\n+        for (size_t pos = 0; pos < names.size(); ++pos) {\n             char c = names[pos];\n-            if( pos == names.size() || c == ' ' || c == '\\t' || c == ',' || c == ']' ) {\n-                if( start != std::string::npos ) {\n-                    m_messages.push_back( MessageInfo( macroName, lineInfo, resultType ) );\n-                    m_messages.back().message = names.substr( start, pos-start) + \" := \";\n-                    start = std::string::npos;\n+            switch (c) {\n+            case '[':\n+            case '{':\n+            case '(':\n+            // It is basically impossible to disambiguate between\n+            // comparison and start of template args in this context\n+//            case '<':\n+                openings.push(c);\n+                break;\n+            case ']':\n+            case '}':\n+            case ')':\n+//           case '>':\n+                openings.pop();\n+                break;\n+            case ',':\n+                if (start != pos && openings.size() == 0) {\n+                    m_messages.emplace_back(macroName, lineInfo, resultType);\n+                    m_messages.back().message = trimmed(start, pos);\n+                    m_messages.back().message += \" := \";\n+                    start = pos;\n                 }\n             }\n-            else if( c != '[' && c != ']' && start == std::string::npos )\n-                start = pos;\n         }\n+        assert(openings.size() == 0 && \"Mismatched openings\");\n+        m_messages.emplace_back(macroName, lineInfo, resultType);\n+        m_messages.back().message = trimmed(start, names.size() - 1);\n+        m_messages.back().message += \" := \";\n     }\n     Capturer::~Capturer() {\n         if ( !uncaught_exceptions() ){\n@@ -82,7 +112,7 @@ namespace Catch {\n         }\n     }\n \n-    void Capturer::captureValue( size_t index, StringRef value ) {\n+    void Capturer::captureValue( size_t index, std::string const& value ) {\n         assert( index < m_messages.size() );\n         m_messages[index].message += value;\n         m_resultCapture.pushScopedMessage( m_messages[index] );\ndiff --git a/include/internal/catch_message.h b/include/internal/catch_message.h\n--- a/include/internal/catch_message.h\n+++ b/include/internal/catch_message.h\n@@ -77,16 +77,16 @@ namespace Catch {\n         Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );\n         ~Capturer();\n \n-        void captureValue( size_t index, StringRef value );\n+        void captureValue( size_t index, std::string const& value );\n \n         template<typename T>\n-        void captureValues( size_t index, T&& value ) {\n+        void captureValues( size_t index, T const& value ) {\n             captureValue( index, Catch::Detail::stringify( value ) );\n         }\n \n         template<typename T, typename... Ts>\n-        void captureValues( size_t index, T&& value, Ts&&... values ) {\n-            captureValues( index, value );\n+        void captureValues( size_t index, T const& value, Ts const&... values ) {\n+            captureValue( index, Catch::Detail::stringify(value) );\n             captureValues( index+1, values... );\n         }\n     };\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -9,10 +9,6 @@\n #include \"catch.hpp\"\n #include <iostream>\n \n-#ifdef __clang__\n-#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n-#endif\n-\n TEST_CASE( \"INFO and WARN do not abort tests\", \"[messages][.]\" ) {\n     INFO( \"this is a \" << \"message\" );    // This should output the message if a failure occurs\n     WARN( \"this is a \" << \"warning\" );    // This should always output the message but then continue\n@@ -135,3 +131,60 @@ TEST_CASE( \"Pointers can be converted to strings\", \"[messages][.][approvals]\" )\n     WARN( \"actual address of p: \" << &p );\n     WARN( \"toString(p): \" << ::Catch::Detail::stringify( &p ) );\n }\n+\n+TEST_CASE( \"CAPTURE can deal with complex expressions\", \"[messages][capture]\" ) {\n+    int a = 1;\n+    int b = 2;\n+    int c = 3;\n+    CAPTURE( a, b, c, a + b, a+b, c > b, a == 1 );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wunused-value\" // In (1, 2), the \"1\" is unused ...\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-value\" // All the comma operators are side-effect free\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(push)\n+#pragma warning(disable:4709) // comma in indexing operator\n+#endif\n+\n+template <typename T1, typename T2>\n+struct helper_1436 {\n+    helper_1436(T1 t1, T2 t2):\n+        t1{ t1 },\n+        t2{ t2 }\n+    {}\n+    T1 t1;\n+    T2 t2;\n+};\n+\n+template <typename T1, typename T2>\n+std::ostream& operator<<(std::ostream& out, helper_1436<T1, T2> const& helper) {\n+    out << \"{ \" << helper.t1 << \", \" << helper.t2 << \" }\";\n+    return out;\n+}\n+\n+TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messages][capture]\") {\n+    CAPTURE(std::vector<int>{1, 2, 3}[0, 1, 2],\n+            std::vector<int>{1, 2, 3}[(0, 1)],\n+            std::vector<int>{1, 2, 3}[0]);\n+    CAPTURE((helper_1436<int, int>{12, -12}),\n+            (helper_1436<int, int>(-12, 12)));\n+    CAPTURE( (1, 2), (2, 3) );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic pop\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(pop)\n+#endif\n", "problem_statement": "Capturer destructor asserts due to bad expression parsing\nThe following asserts:\r\n\r\n```\r\nTEST_CASE(\"Explodes\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a + b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe following does not:\r\n```\r\nTEST_CASE(\"Works\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a+b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe assertion that fires:\r\nhttps://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L79\r\n\r\nThe issue appears to have been caused here: https://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L66\r\n\r\n\n", "hints_text": "Looks like you'd want to only count `,` instead of all whitespace as an argument delimiter, and also only when `,` appears at the top level (not nested within `[]`, `{}`, or `()`). You can count the nesting depth of each bracket type in one variable since mismatching brackets would cause the compilation to fail anyway.", "created_at": "2018-11-19T22:15:46Z", "version": "2.4"}
{"repo": "catchorg/Catch2", "pull_number": 1363, "instance_id": "catchorg__Catch2-1363", "issue_numbers": ["1360"], "base_commit": "c9de7dd12d2971c63f9d32ce5459eb98f2fec13d", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -147,11 +147,12 @@\n // \"BDD-style\" convenience wrappers\n #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n-#define CATCH_GIVEN( desc )    INTERNAL_CATCH_DYNAMIC_SECTION( \"   Given: \" << desc )\n-#define CATCH_WHEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    When: \" << desc )\n-#define CATCH_AND_WHEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And when: \" << desc )\n-#define CATCH_THEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Then: \" << desc )\n-#define CATCH_AND_THEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"     And: \" << desc )\n+#define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Given: \" << desc )\n+#define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And given: \" << desc )\n+#define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     When: \" << desc )\n+#define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \" And when: \" << desc )\n+#define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n+#define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required\n #else\n@@ -211,11 +212,12 @@\n #define SCENARIO( ... ) TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n \n-#define GIVEN( desc )    INTERNAL_CATCH_DYNAMIC_SECTION( \"   Given: \" << desc )\n-#define WHEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    When: \" << desc )\n-#define AND_WHEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And when: \" << desc )\n-#define THEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Then: \" << desc )\n-#define AND_THEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"     And: \" << desc )\n+#define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Given: \" << desc )\n+#define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And given: \" << desc )\n+#define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     When: \" << desc )\n+#define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \" And when: \" << desc )\n+#define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n+#define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n using Catch::Detail::Approx;\n \n@@ -276,6 +278,7 @@ using Catch::Detail::Approx;\n #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n #define CATCH_GIVEN( desc )\n+#define CATCH_AND_GIVEN( desc )\n #define CATCH_WHEN( desc )\n #define CATCH_AND_WHEN( desc )\n #define CATCH_THEN( desc )\n@@ -340,6 +343,7 @@ using Catch::Detail::Approx;\n #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n \n #define GIVEN( desc )\n+#define AND_GIVEN( desc )\n #define WHEN( desc )\n #define AND_WHEN( desc )\n #define THEN( desc )\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/BDD.tests.cpp b/projects/SelfTest/UsageTests/BDD.tests.cpp\n--- a/projects/SelfTest/UsageTests/BDD.tests.cpp\n+++ b/projects/SelfTest/UsageTests/BDD.tests.cpp\n@@ -38,11 +38,14 @@ namespace { namespace BDDTests {\n     SCENARIO(\"Do that thing with the thing\", \"[Tags]\") {\n         GIVEN(\"This stuff exists\") {\n             // make stuff exist\n-            WHEN(\"I do this\") {\n-                // do this\n-                THEN(\"it should do this\") {\n-                    REQUIRE(itDoesThis());\n-                    AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+            AND_GIVEN(\"And some assumption\") {\n+                // Validate assumption\n+                WHEN(\"I do this\") {\n+                    // do this\n+                    THEN(\"it should do this\") {\n+                        REQUIRE(itDoesThis());\n+                        AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+                    }\n                 }\n             }\n         }\n", "problem_statement": "Feature Request: AND_GIVEN\n\r\nTo be consistent with the `AND_WHEN` and `AND_THEN`; \r\n\r\nWith BDD:\r\n\r\nthere are times when you require to expand the context, if you feel a need to type *'and'* in the context of a `GIVEN`, `WHEN`, and/or `THEN`, you should use `AND`.\r\n\r\nwe don't have an `AND`, because that just doesn't work in this abstraction; thus we have `AND_WHEN` and `AND_THEN`; thus we should also have `AND_GIVEN`.\n", "hints_text": "", "created_at": "2018-08-14T10:25:40Z", "version": "2.3"}
{"repo": "catchorg/Catch2", "pull_number": 1376, "instance_id": "catchorg__Catch2-1376", "issue_numbers": ["1375"], "base_commit": "1eb42eed974f944401091325bbe8e61b38fd0678", "patch": "diff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -29,11 +29,11 @@\n \n #ifdef __cplusplus\n \n-#  if __cplusplus >= 201402L\n+#  if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)\n #    define CATCH_CPP14_OR_GREATER\n #  endif\n \n-#  if __cplusplus >= 201703L\n+#  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)\n #    define CATCH_CPP17_OR_GREATER\n #  endif\n \n@@ -154,6 +154,16 @@\n     #define CATCH_INTERNAL_CONFIG_COUNTER\n #endif\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Check if string_view is available and usable\n+// The check is split apart to work around v140 (VS2015) preprocessor issue...\n+#if defined(__has_include)\n+#if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)\n+#    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW\n+#endif\n+#endif\n+\n+\n #if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)\n #   define CATCH_CONFIG_COUNTER\n #endif\n@@ -177,6 +187,10 @@\n #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS\n #endif\n \n+#if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)\n+#  define CATCH_CONFIG_CPP17_STRING_VIEW\n+#endif\n+\n #if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)\n #  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE\n #endif\ndiff --git a/include/internal/catch_tostring.cpp b/include/internal/catch_tostring.cpp\n--- a/include/internal/catch_tostring.cpp\n+++ b/include/internal/catch_tostring.cpp\n@@ -116,14 +116,9 @@ std::string StringMaker<std::string>::convert(const std::string& str) {\n     return s;\n }\n \n-#ifdef CATCH_CONFIG_WCHAR\n-std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {\n-    std::string s;\n-    s.reserve(wstr.size());\n-    for (auto c : wstr) {\n-        s += (c <= 0xff) ? static_cast<char>(c) : '?';\n-    }\n-    return ::Catch::Detail::stringify(s);\n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+std::string StringMaker<std::string_view>::convert(std::string_view str) {\n+    return ::Catch::Detail::stringify(std::string{ str });\n }\n #endif\n \n@@ -141,7 +136,23 @@ std::string StringMaker<char*>::convert(char* str) {\n         return{ \"{null string}\" };\n     }\n }\n+\n #ifdef CATCH_CONFIG_WCHAR\n+std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {\n+    std::string s;\n+    s.reserve(wstr.size());\n+    for (auto c : wstr) {\n+        s += (c <= 0xff) ? static_cast<char>(c) : '?';\n+    }\n+    return ::Catch::Detail::stringify(s);\n+}\n+\n+# ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+std::string StringMaker<std::wstring_view>::convert(std::wstring_view str) {\n+    return StringMaker<std::wstring>::convert(std::wstring(str));\n+}\n+# endif\n+\n std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {\n     if (str) {\n         return ::Catch::Detail::stringify(std::wstring{ str });\ndiff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -16,6 +16,10 @@\n #include \"catch_compiler_capabilities.h\"\n #include \"catch_stream.h\"\n \n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+#include <string_view>\n+#endif\n+\n #ifdef __OBJC__\n #include \"catch_objc_arc.hpp\"\n #endif\n@@ -152,10 +156,11 @@ namespace Catch {\n     struct StringMaker<std::string> {\n         static std::string convert(const std::string& str);\n     };\n-#ifdef CATCH_CONFIG_WCHAR\n+\n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n     template<>\n-    struct StringMaker<std::wstring> {\n-        static std::string convert(const std::wstring& wstr);\n+    struct StringMaker<std::string_view> {\n+        static std::string convert(std::string_view str);\n     };\n #endif\n \n@@ -169,6 +174,18 @@ namespace Catch {\n     };\n \n #ifdef CATCH_CONFIG_WCHAR\n+    template<>\n+    struct StringMaker<std::wstring> {\n+        static std::string convert(const std::wstring& wstr);\n+    };\n+\n+# ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+    template<>\n+    struct StringMaker<std::wstring_view> {\n+        static std::string convert(std::wstring_view str);\n+    };\n+# endif\n+\n     template<>\n     struct StringMaker<wchar_t const *> {\n         static std::string convert(wchar_t const * str);\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n@@ -116,6 +116,18 @@ TEST_CASE(\"Static arrays are convertible to string\", \"[toString]\") {\n     }\n }\n \n+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW\n+\n+TEST_CASE(\"String views are stringified like other strings\", \"[toString][approvals]\") {\n+    std::string_view view{\"abc\"};\n+    CHECK(Catch::Detail::stringify(view) == R\"(\"abc\")\");\n+\n+    std::string_view arr[] { view };\n+    CHECK(Catch::Detail::stringify(arr) == R\"({ \"abc\" })\");\n+}\n+\n+#endif\n+\n namespace {\n \n struct WhatException : std::exception {\n", "problem_statement": "std::string_view is stringified without quotes\n## Description\r\n`std::string_view` probably uses some fallback stringification, and is expanded without quotes (and also bypasses pretty printing of invisibles).\r\n\r\n\r\n### Steps to reproduce\r\n```cpp\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch2/catch.hpp>\r\n\r\n#include <string>\r\n#include <string_view>\r\n\r\nTEST_CASE(\"string_view == string\") {\r\n    std::string s = \"foo\";\r\n    std::string_view v = s;\r\n\r\n    CHECK(s == v);\r\n}\r\n```\r\nrun with `-s`:\r\n```\r\nPASSED:\r\n  CHECK( s == v )\r\nwith expansion:\r\n  \"foo\" == foo\r\n```\r\n\r\n\r\n### Extra information\r\nCatch version: **v2.4.0**\r\n\n", "hints_text": "", "created_at": "2018-09-04T18:46:47Z", "version": "2.4"}
{"repo": "catchorg/Catch2", "pull_number": 1492, "instance_id": "catchorg__Catch2-1492", "issue_numbers": ["1394", "1394", "1394"], "base_commit": "0387fb64ced7c3626b3164207c2d29aadb9ceaf2", "patch": "diff --git a/misc/coverage-helper.cpp b/misc/coverage-helper.cpp\n--- a/misc/coverage-helper.cpp\n+++ b/misc/coverage-helper.cpp\n@@ -9,6 +9,38 @@\n #include <string>\n #include <vector>\n \n+std::string escape_arg(const std::string& arg) {\n+    if (arg.empty() == false &&\n+        arg.find_first_of(\" \\t\\n\\v\\\"\") == arg.npos) {\n+        return arg;\n+    }\n+\n+    std::string escaped;\n+    escaped.push_back('\"');\n+    for (auto it = arg.begin(); ; ++it) {\n+        int num_backslashes = 0;\n+\n+        while (it != arg.end() && *it == '\\\\') {\n+            ++it;\n+            ++num_backslashes;\n+        }\n+\n+        if (it == arg.end()) {\n+            escaped.append(num_backslashes * 2, '\\\\');\n+            break;\n+        } else if (*it == '\"') {\n+            escaped.append(num_backslashes * 2 + 1, '\\\\');\n+            escaped.push_back(*it);\n+        } else {\n+            escaped.append(num_backslashes, '\\\\');\n+            escaped.push_back(*it);\n+        }\n+    }\n+    escaped.push_back('\"');\n+\n+    return escaped;\n+}\n+\n \n void create_empty_file(std::string const& path) {\n     std::ofstream ofs(path);\n@@ -60,8 +92,9 @@ std::string windowsify_path(std::string path) {\n void exec_cmd(std::string const& cmd, int log_num, std::string const& path) {\n     std::array<char, 128> buffer;\n #if defined(_WIN32)\n+    // cmd has already been escaped outside this function.\n     auto real_cmd = \"OpenCppCoverage --export_type binary:cov-report\" + std::to_string(log_num)\n-        + \".bin --quiet \" + \"--sources \" + path + \" --cover_children -- \" + cmd;\n+        + \".bin --quiet \" + \"--sources \" + escape_arg(path) + \" --cover_children -- \" + cmd;\n     std::cout << \"=== Marker ===: Cmd: \" << real_cmd << '\\n';\n     std::shared_ptr<FILE> pipe(_popen(real_cmd.c_str(), \"r\"), _pclose);\n #else // Just for testing, in the real world we will always work under WIN32\n@@ -91,9 +124,9 @@ int main(int argc, char** argv) {\n     assert(sep - begin(args) == 2 && \"Structure differs from expected!\");\n \n     auto num = parse_log_file_arg(args[1]);\n-\n+    \n     auto cmdline = std::accumulate(++sep, end(args), std::string{}, [] (const std::string& lhs, const std::string& rhs) {\n-        return lhs + ' ' + rhs;\n+        return lhs + ' ' + escape_arg(rhs);\n     });\n \n     try {\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -345,10 +345,16 @@ set_tests_properties(NoAssertions PROPERTIES PASS_REGULAR_EXPRESSION \"No asserti\n add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> -w NoTests \"___nonexistent_test___\")\n set_tests_properties(NoTest PROPERTIES PASS_REGULAR_EXPRESSION \"No test cases matched\")\n \n+add_test(NAME FilteredSection-1 COMMAND $<TARGET_FILE:SelfTest> \\#1394 -c RunSection)\n+set_tests_properties(FilteredSection-1 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+add_test(NAME FilteredSection-2 COMMAND $<TARGET_FILE:SelfTest> \\#1394\\ nested -c NestedRunSection -c s1)\n+set_tests_properties(FilteredSection-2 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+\n # AppVeyor has a Python 2.7 in path, but doesn't have .py files as autorunnable\n add_test(NAME ApprovalTests COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/scripts/approvalTests.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(ApprovalTests PROPERTIES FAIL_REGULAR_EXPRESSION \"Results differed\")\n \n+\n if (CATCH_USE_VALGRIND)\n     add_test(NAME ValgrindRunTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest>)\n     add_test(NAME ValgrindListTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest> --list-tests --verbosity high)\n", "test_patch": "diff --git a/include/internal/catch_test_case_tracker.cpp b/include/internal/catch_test_case_tracker.cpp\n--- a/include/internal/catch_test_case_tracker.cpp\n+++ b/include/internal/catch_test_case_tracker.cpp\n@@ -190,6 +190,17 @@ namespace TestCaseTracking {\n         }\n     }\n \n+    bool SectionTracker::isComplete() const {\n+        bool complete = true;\n+\n+        if ((m_filters.empty() || m_filters[0] == \"\") ||\n+             std::find(m_filters.begin(), m_filters.end(),\n+                       m_nameAndLocation.name) != m_filters.end())\n+            complete = TrackerBase::isComplete();\n+        return complete;\n+\n+    }\n+\n     bool SectionTracker::isSectionTracker() const { return true; }\n \n     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\ndiff --git a/include/internal/catch_test_case_tracker.h b/include/internal/catch_test_case_tracker.h\n--- a/include/internal/catch_test_case_tracker.h\n+++ b/include/internal/catch_test_case_tracker.h\n@@ -140,6 +140,8 @@ namespace TestCaseTracking {\n \n         bool isSectionTracker() const override;\n \n+        bool isComplete() const override;\n+\n         static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n \n         void tryOpen();\ndiff --git a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n@@ -324,3 +324,33 @@ TEST_CASE( \"Tracker\" ) {\n         //   two sections within a generator\n     }\n }\n+\n+static bool previouslyRun = false;\n+static bool previouslyRunNested = false;\n+\n+TEST_CASE( \"#1394\", \"[.][approvals][tracker]\" ) {\n+    // -- Don't re-run after specified section is done\n+    REQUIRE(previouslyRun == false);\n+\n+    SECTION( \"RunSection\" ) {\n+        previouslyRun = true;\n+    }\n+    SECTION( \"SkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n+\n+TEST_CASE( \"#1394 nested\", \"[.][approvals][tracker]\" ) {\n+    REQUIRE(previouslyRunNested == false);\n+\n+    SECTION( \"NestedRunSection\" ) {\n+        SECTION( \"s1\" ) {\n+            previouslyRunNested = true;\n+        }\n+    }\n+    SECTION( \"NestedSkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n", "problem_statement": "If a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\n", "hints_text": "I agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.", "created_at": "2019-01-08T13:45:01Z", "version": "2.5"}
{"repo": "catchorg/Catch2", "pull_number": 1306, "instance_id": "catchorg__Catch2-1306", "issue_numbers": ["1285", "1285"], "base_commit": "021fcee63667e346c619e04bbae932bcea562334", "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -105,7 +105,9 @@ namespace Catch {\n         typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\n             convert(const Fake& value) {\n                 ReusableStringStream rss;\n-                rss << value;\n+                // NB: call using the function-like syntax to avoid ambiguity with\n+                // user-defined templated operator<< under clang.\n+                rss.operator<<(value);\n                 return rss.str();\n         }\n \n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp b/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n@@ -20,6 +20,7 @@ struct has_operator { };\n struct has_maker {};\n struct has_maker_and_operator {};\n struct has_neither {};\n+struct has_template_operator {};\n \n std::ostream& operator<<(std::ostream& os, const has_operator&) {\n     os << \"operator<<( has_operator )\";\n@@ -31,6 +32,12 @@ std::ostream& operator<<(std::ostream& os, const has_maker_and_operator&) {\n     return os;\n }\n \n+template <typename StreamT>\n+StreamT& operator<<(StreamT& os, const has_template_operator&) {\n+    os << \"operator<<( has_template_operator )\";\n+    return os;\n+}\n+\n namespace Catch {\n     template<>\n     struct StringMaker<has_maker> {\n@@ -69,6 +76,12 @@ TEST_CASE(\"stringify( has_neither )\", \"[toString]\") {\n     REQUIRE( ::Catch::Detail::stringify(item) == \"{ !!! }\" );\n }\n \n+// Call the templated operator\n+TEST_CASE( \"stringify( has_template_operator )\", \"[toString]\" ) {\n+    has_template_operator item;\n+    REQUIRE( ::Catch::Detail::stringify( item ) == \"operator<<( has_template_operator )\" );\n+}\n+\n \n // Vectors...\n \n", "problem_statement": "Clang compilation fails when using REQUIRE with custom string classes that overload the << operator\n## Description\r\n\r\nWe have our own custom string class that overloads the << operator, and it's causing issues when using the REQUIRE macro and compiling under Clang in Linux.\r\n\r\nThe REQUIRE line looks like this:\r\n\r\nREQUIRE(str1 == \"Item1\");\r\n\r\nThe error we get is the following:\r\n\r\n19>project_path\\catch.hpp(810,21): error : use of overloaded operator '<<' is ambiguous (with operand types 'Catch::ReusableStringStream' and 'const MyCustomStringClass<char>')\r\n19>                rss << value;\r\n19>                ~~~ ^  ~~~~~\r\n19>project_path\\catch.hpp(829,114): note: in instantiation of function template specialization 'Catch::StringMaker<type, void>::convert<MyCustomStringClass<char> >' requested here\r\n19>            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\r\n19>                                                                                                                 ^\r\n19>project_path\\catch.hpp(1325,42): note: in instantiation of function template specialization 'Catch::Detail::stringify<MyCustomStringClass<char> >' requested here\r\n19>                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\r\n19>                                         ^\r\n19>project_path\\MyCppFile.cpp(243,75): note: in instantiation of member function 'Catch::BinaryExpr<const MyCustomStringClass<char> &, char const &[6]>::streamReconstructedExpression' requested here\r\n19>                    REQUIRE(str1 == \"Item1\");\r\n\r\n\r\n### Extra information\r\n  Disabling stringification with CATCH_CONFIG_DISABLE_STRINGIFICATION does not help solve this issue.\r\n\r\n   Commenting out the following line in catch.hpp fixes the compilation error:\r\n   This code starts in line 801:\r\n\r\n    template <typename T, typename = void>\r\n    struct StringMaker {\r\n        template <typename Fake = T>\r\n        static\r\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\r\n            convert(const Fake& value) {\r\n                ReusableStringStream rss;\r\n\r\n                // this line causes the problem\r\n                // rss << value;\r\n\r\n                return rss.str();\r\n        }\r\n\r\n\r\n* Catch version: **v2.2.2**\r\n* Operating System: **Linux**\r\n* Compiler+version: **Clang**\r\n\nClang compilation fails when using REQUIRE with custom string classes that overload the << operator\n## Description\r\n\r\nWe have our own custom string class that overloads the << operator, and it's causing issues when using the REQUIRE macro and compiling under Clang in Linux.\r\n\r\nThe REQUIRE line looks like this:\r\n\r\nREQUIRE(str1 == \"Item1\");\r\n\r\nThe error we get is the following:\r\n\r\n19>project_path\\catch.hpp(810,21): error : use of overloaded operator '<<' is ambiguous (with operand types 'Catch::ReusableStringStream' and 'const MyCustomStringClass<char>')\r\n19>                rss << value;\r\n19>                ~~~ ^  ~~~~~\r\n19>project_path\\catch.hpp(829,114): note: in instantiation of function template specialization 'Catch::StringMaker<type, void>::convert<MyCustomStringClass<char> >' requested here\r\n19>            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\r\n19>                                                                                                                 ^\r\n19>project_path\\catch.hpp(1325,42): note: in instantiation of function template specialization 'Catch::Detail::stringify<MyCustomStringClass<char> >' requested here\r\n19>                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\r\n19>                                         ^\r\n19>project_path\\MyCppFile.cpp(243,75): note: in instantiation of member function 'Catch::BinaryExpr<const MyCustomStringClass<char> &, char const &[6]>::streamReconstructedExpression' requested here\r\n19>                    REQUIRE(str1 == \"Item1\");\r\n\r\n\r\n### Extra information\r\n  Disabling stringification with CATCH_CONFIG_DISABLE_STRINGIFICATION does not help solve this issue.\r\n\r\n   Commenting out the following line in catch.hpp fixes the compilation error:\r\n   This code starts in line 801:\r\n\r\n    template <typename T, typename = void>\r\n    struct StringMaker {\r\n        template <typename Fake = T>\r\n        static\r\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\r\n            convert(const Fake& value) {\r\n                ReusableStringStream rss;\r\n\r\n                // this line causes the problem\r\n                // rss << value;\r\n\r\n                return rss.str();\r\n        }\r\n\r\n\r\n* Catch version: **v2.2.2**\r\n* Operating System: **Linux**\r\n* Compiler+version: **Clang**\r\n\n", "hints_text": "This seems to be the case when operator<< is templated. Otherwise there should be no ambiguity.\r\nSpecializing StringMaker<> for the type works around the issue.\nThis seems to be the case when operator<< is templated. Otherwise there should be no ambiguity.\r\nSpecializing StringMaker<> for the type works around the issue.", "created_at": "2018-06-05T04:30:07Z", "version": "2.2"}
{"repo": "catchorg/Catch2", "pull_number": 876, "instance_id": "catchorg__Catch2-876", "issue_numbers": ["748"], "base_commit": "3a3f1529794059e1f8947c1d44ed10327b2a35d8", "patch": "diff --git a/include/internal/catch_message.hpp b/include/internal/catch_message.hpp\n--- a/include/internal/catch_message.hpp\n+++ b/include/internal/catch_message.hpp\n@@ -38,7 +38,10 @@ namespace Catch {\n     {}\n \n     ScopedMessage::~ScopedMessage() {\n-        getResultCapture().popScopedMessage( m_info );\n+        if (!std::uncaught_exception())\n+        {\n+            getResultCapture().popScopedMessage(m_info);\n+        }\n     }\n \n \ndiff --git a/include/reporters/catch_reporter_console.hpp b/include/reporters/catch_reporter_console.hpp\n--- a/include/reporters/catch_reporter_console.hpp\n+++ b/include/reporters/catch_reporter_console.hpp\n@@ -138,7 +138,11 @@ namespace Catch {\n                     case ResultWas::ThrewException:\n                         colour = Colour::Error;\n                         passOrFail = \"FAILED\";\n-                        messageLabel = \"due to unexpected exception with message\";\n+                        messageLabel = \"due to unexpected exception with \";\n+                        if (_stats.infoMessages.size() == 1)\n+                            messageLabel += \"message\";\n+                        if (_stats.infoMessages.size() > 1)\n+                            messageLabel += \"messages\";\n                         break;\n                     case ResultWas::FatalErrorCondition:\n                         colour = Colour::Error;\n", "test_patch": "diff --git a/projects/SelfTest/ExceptionTests.cpp b/projects/SelfTest/ExceptionTests.cpp\n--- a/projects/SelfTest/ExceptionTests.cpp\n+++ b/projects/SelfTest/ExceptionTests.cpp\n@@ -209,3 +209,18 @@ TEST_CASE( \"Mismatching exception messages failing the test\", \"[.][failing][!thr\n     REQUIRE_THROWS_WITH( thisThrows(), \"should fail\" );\n     REQUIRE_THROWS_WITH( thisThrows(), \"expected exception\" );\n }\n+\n+TEST_CASE( \"#748 - captures with unexpected exceptions\", \"[!shouldfail]\" ) {\n+    int answer = 42;\n+    CAPTURE(answer);\n+    // the message should be printed on the first two sections but not on the third\n+    SECTION( \"outside assertions\" ) {\n+        thisThrows();\n+    }\n+    SECTION( \"inside REQUIRE_NOTHROW\" ) {\n+        REQUIRE_NOTHROW(thisThrows());\n+    }\n+    SECTION( \"inside REQUIRE_THROWS\" ) {\n+        REQUIRE_THROWS(thisThrows());\n+    }\n+}\n\\ No newline at end of file\n", "problem_statement": "captures with unexpected exceptions\nIs it possible to make CAPTURE print its value when an unexpected exception occurs?\r\nCurrently, for the following code\r\n\r\n```c++\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch.hpp>\r\n#include <stdexcept>\r\n\r\nvoid foo()\r\n{\r\n    throw std::logic_error(\"error\");\r\n}\r\n\r\nTEST_CASE(\"test\")\r\n{\r\n    int i = 2;\r\n    CAPTURE(i);\r\n    foo();\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nI get \r\n```cmd\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nTest.exe is a Catch v1.1 b3 host application.\r\nRun with -? for options\r\n\r\n-------------------------------------------------------------------------------\r\ntest\r\n-------------------------------------------------------------------------------\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n0)\r\n...............................................................................\r\n\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n0): FAILED:\r\ndue to unexpected exception with message:\r\n  error\r\n\r\n===============================================================================\r\ntest cases: 1 | 1 failed\r\nassertions: 1 | 1 failed\r\n\r\nPress any key to continue . . .\r\n```\r\n\r\nWhile without calling `foo()` it's\r\n```cmd\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nTest.exe is a Catch v1.1 b3 host application.\r\nRun with -? for options\r\n\r\n-------------------------------------------------------------------------------\r\ntest\r\n-------------------------------------------------------------------------------\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n0)\r\n...............................................................................\r\n\r\n\\giant_nas\\dviry\\my documents\\visual studio 2015\\projects\\test\\test\\source.cpp(1\r\n5): FAILED:\r\n  REQUIRE( false )\r\nwith message:\r\n  i := 2\r\n\r\n===============================================================================\r\ntest cases: 1 | 1 failed\r\nassertions: 1 | 1 failed\r\n\r\nPress any key to continue . . .\r\n```\n", "hints_text": "No it's not possible, because captures are local to the scope they appear in. When an unCHECKed exception occurs, that scope is finished (local objects holding CAPTURE destroyed) before entering the handler (the one that prints \"FAILED: due to unexpected exception\").\r\n\nI think it could be possible with the use of C++17's [```std::uncaught_exceptions```](http://en.cppreference.com/w/cpp/error/uncaught_exception) to do something when the local objects (the capture stuff) are destroyed during stack unwinding due to an exception...\r\n\r\nor maybe just logging in globals in the destructor of the local capture stuff", "created_at": "2017-03-30T22:09:47Z", "version": "1.8"}
{"repo": "catchorg/Catch2", "pull_number": 1468, "instance_id": "catchorg__Catch2-1468", "issue_numbers": ["1454"], "base_commit": "4902cd721586822ded795afe0c418c553137306a", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -148,9 +148,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -226,9 +230,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -313,9 +321,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -384,9 +396,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/catch_meta.hpp\n@@ -0,0 +1,76 @@\n+/*\n+ *  Created by Jozef on 02/12/2018.\n+ *  Copyright 2018 Two Blue Cubes Ltd. All rights reserved.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#ifndef TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+\n+template< typename... >\n+struct TypeList{};\n+\n+template< typename... >\n+struct append;\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t>\n+struct append< L1<E1...>, L2<E2...> >\n+{\n+\tusing type = L1<E1..., E2...>;\n+};\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t, typename...Rest\n+\t>\n+struct append< L1<E1...>, L2<E2...>, Rest...>\n+{\n+\tusing type = typename append< L1<E1..., E2...>, Rest... >::type;\n+};\n+\n+template< template<typename...> class\n+        , typename...\n+        >\n+struct rewrap;\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , typename...elems\n+        >\n+struct rewrap<Container, List<elems...>>\n+{\n+    using type = TypeList< Container< elems... > >;\n+};\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , class...Elems\n+        , typename...Elements>\n+struct rewrap<Container, List<Elems...>, Elements...>\n+{\n+    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n+};\n+\n+template< template<typename...> class...Containers >\n+struct combine\n+{\n+    template< typename...Types >\n+    struct with_types\n+    {\n+        template< template <typename...> class Final >\n+        struct into\n+        {\n+            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n+        };\n+    };\n+};\n+\n+#endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -71,4 +71,9 @@\n #define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+\n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -118,6 +118,7 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_matchers_string.h\n         ${HEADER_DIR}/internal/catch_matchers_vector.h\n         ${HEADER_DIR}/internal/catch_message.h\n+        ${HEADER_DIR}/internal/catch_meta.hpp\n         ${HEADER_DIR}/internal/catch_objc.hpp\n         ${HEADER_DIR}/internal/catch_objc_arc.hpp\n         ${HEADER_DIR}/internal/catch_option.hpp\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -95,7 +95,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by type, in the form of `TEMPLATE_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE` and\n+`TEMPLATE_PRODUCT_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -147,9 +148,48 @@ TEMPLATE_TEST_CASE( \"vectors can be sized and resized\", \"[vector][template]\", in\n }\n ```\n \n+* **TEMPLATE_PRODUCT_TEST_CASE(** _test name_ , _tags_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+_template-type1_ through _template-typen_ is list of template template\n+types which should be combined with each of _template-arg1_ through\n+ _template-argm_, resulting in _n * m_ test cases. Inside the test case,\n+the resulting type is available under the name of `TestType`.\n+\n+To specify more than 1 type as a single _template-type_ or _template-arg_,\n+you must enclose the types in an additional set of parentheses, e.g.\n+`((int, float), (char, double))` specifies 2 template-args, each\n+consisting of 2 concrete types (`int`, `float` and `char`, `double`\n+respectively). You can also omit the outer set of parentheses if you\n+specify only one type as the full set of either the _template-types_,\n+or the _template-args_.\n+\n+\n+Example:\n+```\n+template< typename T>\n+struct Foo {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+```\n+\n+You can also have different arities in the _template-arg_ packs:\n+```\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    TestType x;\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+```\n+\n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n+is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -31,16 +31,22 @@ class UniqueTestsFixture {\n The two test cases here will create uniquely-named derived classes of UniqueTestsFixture and thus can access the `getID()` protected method and `conn` member variables. This ensures that both the test cases are able to create a DBConnection using the same method (DRY principle) and that any ID's created are unique such that the order that tests are executed does not matter.\n \n \n-Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` that can be used together\n-with templated fixtures to perform tests for multiple different types.\n-However, unlike `TEST_CASE_METHOD`, `TEMPLATE_TEST_CASE_METHOD` requires\n-the tag specification to be non-empty, as it is followed by further macros\n-arguments.\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` and\n+`TEMPLATE_PRODUCT_TEST_CASE_METHOD` that can be used together\n+with templated fixtures and templated template fixtures to perform\n+tests for multiple different types. Unlike `TEST_CASE_METHOD`,\n+`TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD` do\n+require the tag specification to be non-empty, as it is followed by\n+further macro arguments.\n \n Also note that, because of limitations of the C++ preprocessor, if you\n want to specify a type with multiple template parameters, you need to\n enclose it in parentheses, e.g. `std::map<int, std::string>` needs to be\n passed as `(std::map<int, std::string>)`.\n+In the case of `TEMPLATE_PRODUCT_TEST_CASE_METHOD`, if a member of the\n+type list should consist of more than single type, it needs to be enclosed\n+in another pair of parentheses, e.g. `(std::map, std::pair)` and\n+`((int, float), (char, double))`.\n \n Example:\n ```cpp\n@@ -54,11 +60,29 @@ struct Template_Fixture {\n TEMPLATE_TEST_CASE_METHOD(Template_Fixture,\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds\", \"[class][template]\", int, float, double) {\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n+\n+template<typename T>\n+struct Template_Template_Fixture {\n+    Template_Template_Fixture() {}\n+\n+    T m_a;\n+};\n+\n+template<typename T>\n+struct Foo_class {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Template_Fixture, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test succeeds\", \"[class][template]\", (Foo_class, std::vector), int) {\n+    REQUIRE( Template_Template_Fixture<TestType>::m_a.size() == 0 );\n+}\n ```\n \n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+the limit is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -14,6 +14,7 @@\n #include \"catch_stringref.h\"\n #include \"catch_type_traits.hpp\"\n #include \"catch_preprocessor.hpp\"\n+#include \"catch_meta.hpp\"\n \n namespace Catch {\n \n@@ -150,6 +151,38 @@ struct AutoReg : NonCopyable {\n             return 0;\\\n         }();\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        template<typename TestType> static void TestFuncName();       \\\n+        namespace {                                                   \\\n+            template<typename... Types>                               \\\n+            struct TestName {                                         \\\n+                TestName() {                                          \\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)       \\\n+                    int index = 0;                                    \\\n+                    using expander = int[];                           \\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }                                                     \\\n+            };                                                        \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n+                TestInit();                                           \\\n+                return 0;                                             \\\n+            }();                                                      \\\n+        }                                                             \\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFuncName()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         namespace{ \\\n@@ -180,4 +213,39 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+                void test();\\\n+            };\\\n+        namespace {\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                TestNameClass(){\\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n+                TestInit();\\\n+                return 0;\\\n+            }(); \\\n+        }\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -46,6 +46,18 @@ struct Template_Fixture {\n     T m_a;\n };\n \n+template<typename T>\n+struct Template_Fixture_2 {\n+    Template_Fixture_2() {}\n+\n+    T m_a;\n+};\n+\n+template< typename T>\n+struct Template_Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n \n@@ -62,6 +74,11 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n+{\n+    REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -74,6 +91,11 @@ namespace Inner\n     {\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n+    {\n+        REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -61,6 +61,11 @@ CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\n static AutoTestReg autoTestReg;\n CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n+template<typename T>\n+struct Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -301,6 +306,15 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\n", "problem_statement": "TEMPLATE_TEST_CASE does not support template templates\n## Description\r\nTEMPLATE_TEST_CASE only supports substitution of simple types, and not template templates.\r\n\r\n### Steps to reproduce\r\n\r\n```cpp\r\ntemplate <template <typename> typename T>\r\nstruct Foo { };\r\n\r\nTEMPLATE_TEST_CASE(\"instantiate a template template with int\", \"\", Foo) {\r\n     using T = TestType<int>;  // ... or something\r\n}\r\n```\n", "hints_text": "@porpoises in your example you probably wanted to do\r\n```c++\r\ntemplate<typename T>\r\nstruct Foo {};\r\n```\r\nin linked PR #1457 i added support for this kind of types. For this kind of tests you will have to use\r\n`TEMPLATE_TEMPLATE_TEST_CASE`.\r\n\nAwesome, thanks!", "created_at": "2018-12-06T19:16:07Z", "version": "2.5"}
{"repo": "catchorg/Catch2", "pull_number": 715, "instance_id": "catchorg__Catch2-715", "issue_numbers": ["651"], "base_commit": "88732e85b2ac0233bba6fec5c032d02f9c5c230b", "patch": "diff --git a/include/internal/catch_approx.hpp b/include/internal/catch_approx.hpp\n--- a/include/internal/catch_approx.hpp\n+++ b/include/internal/catch_approx.hpp\n@@ -58,6 +58,26 @@ namespace Detail {\n             return !operator==( rhs, lhs );\n         }\n \n+        friend bool operator <= ( double lhs, Approx const& rhs )\n+        {\n+          return lhs < rhs.m_value || lhs == rhs;\n+        }\n+\n+        friend bool operator <= ( Approx const& lhs, double rhs )\n+        {\n+          return lhs.m_value < rhs || lhs == rhs;\n+        }\n+\n+        friend bool operator >= ( double lhs, Approx const& rhs )\n+        {\n+          return lhs > rhs.m_value || lhs == rhs;\n+        }\n+\n+        friend bool operator >= ( Approx const& lhs, double rhs )\n+        {\n+          return lhs.m_value > rhs || lhs == rhs;\n+        }\n+\n         Approx& epsilon( double newEpsilon ) {\n             m_epsilon = newEpsilon;\n             return *this;\n", "test_patch": "diff --git a/projects/SelfTest/ApproxTests.cpp b/projects/SelfTest/ApproxTests.cpp\n--- a/projects/SelfTest/ApproxTests.cpp\n+++ b/projects/SelfTest/ApproxTests.cpp\n@@ -39,6 +39,36 @@ TEST_CASE\n     REQUIRE( d == Approx( 1.231 ).epsilon( 0.1 ) );\n }\n \n+///////////////////////////////////////////////////////////////////////////////\n+TEST_CASE\n+(\n+ \"Less-than inequalities with different epsilons\",\n+ \"[Approx]\"\n+)\n+{\n+  double d = 1.23;\n+\n+  REQUIRE( d <= Approx( 1.24 ) );\n+  REQUIRE( d <= Approx( 1.23 ) );\n+  REQUIRE_FALSE( d <= Approx( 1.22 ) );\n+  REQUIRE( d <= Approx( 1.22 ).epsilon(0.1) );\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+TEST_CASE\n+(\n+ \"Greater-than inequalities with different epsilons\",\n+ \"[Approx]\"\n+)\n+{\n+  double d = 1.23;\n+\n+  REQUIRE( d >= Approx( 1.22 ) );\n+  REQUIRE( d >= Approx( 1.23 ) );\n+  REQUIRE_FALSE( d >= Approx( 1.24 ) );\n+  REQUIRE( d >= Approx( 1.24 ).epsilon(0.1) );\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n TEST_CASE\n (\n", "problem_statement": "Add support for <=, >= to Approx\nApprox is very useful and I'd make further use of it if support for <=, >= could be added.\n\nI'll be happy to do this work.\n\n", "hints_text": "Updated issue following face-to-face discussion (small world):\n\nI agree that having < and > both true is daft. All the LP and QP libraries I've seen expose <= and >= instead. If Catch did the same and Approx supported <= and >= would that be ok?\n", "created_at": "2016-09-24T17:01:12Z", "version": "1.5"}
{"repo": "catchorg/Catch2", "pull_number": 877, "instance_id": "catchorg__Catch2-877", "issue_numbers": ["872"], "base_commit": "0354d50278d725d52084601300eb955cee6756d8", "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -72,6 +72,7 @@ namespace Detail {\n \n     extern const std::string unprintableString;\n \n+ #if !defined(CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)\n     struct BorgType {\n         template<typename T> BorgType( T const& );\n     };\n@@ -90,6 +91,20 @@ namespace Detail {\n         static T  const&t;\n         enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };\n     };\n+#else\n+    template<typename T>\n+    class IsStreamInsertable {\n+        template<typename SS, typename TT>\n+        static auto test(int)\n+        -> decltype( std::declval<SS&>() << std::declval<TT>(), std::true_type() );\n+\n+        template<typename, typename>\n+        static auto test(...) -> std::false_type;\n+\n+    public:\n+        static const bool value = decltype(test<std::ostream,const T&>(0))::value;\n+    };\n+#endif\n \n #if defined(CATCH_CONFIG_CPP11_IS_ENUM)\n     template<typename T,\n", "test_patch": "diff --git a/projects/SelfTest/CompilationTests.cpp b/projects/SelfTest/CompilationTests.cpp\n--- a/projects/SelfTest/CompilationTests.cpp\n+++ b/projects/SelfTest/CompilationTests.cpp\n@@ -51,3 +51,22 @@ TEST_CASE(\"#833\") {\n     REQUIRE(templated_tests<int>(3));\n }\n \n+// Test containing example where original stream insertable check breaks compilation\n+#if defined (CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)\n+namespace {\n+    struct A {};\n+    std::ostream& operator<< (std::ostream &o, const A &) { return o << 0; }\n+\n+    struct B : private A {\n+        bool operator== (int) const { return true; }\n+    };\n+\n+    B f ();\n+    std::ostream g ();\n+}\n+\n+TEST_CASE( \"#872\" ) {\n+    B x;\n+    REQUIRE (x == 4);\n+}\n+#endif\n", "problem_statement": "Compilation error when private base of class of tested variable is \"ostreamable\" but class itself isn't\n## Description\r\nWhen private base of class of tested variable is \"ostreamable\" but class itself isn't test code fails to compile.\r\n\r\n### Steps to reproduce\r\n```\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch.hpp>\r\nstruct A {};\r\nstd::ostream &operator<< (std::ostream &o, const A &v) { return o << 0;}\r\n\r\nstruct B : private A\r\n{\r\n    bool operator==(int){ return true;}\r\n};\r\n\r\nB f ();\r\nstd::ostream g ();\r\n\r\nTEST_CASE (\"asdas\")\r\n{\r\n    B x;\r\n    REQUIRE (x == 4);\r\n}\r\n\r\n```\r\n\r\n>main.cpp:1579:49: error: 'A' is an inaccessible base of 'B'\r\n>         enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };\r\n\r\nSo the problem is in `IsStreamInsertable` check which features converting type to some bogus stremable type named `Borgtype` which everything converts to but it's pretty obvious that converting to your base class is still easier and thus error happens. It seems like replacing this check to the one featured in [this stackoverflow answer](http://stackoverflow.com/a/22759544/1269661) fixes this problem. I can send pull-request if that's needed and proposed solution is fine.\r\n\r\n### Extra information\r\n* Catch version: 1.8.2\r\n* Operating System: Windows + online compilers\r\n* Compiler+version: g++ 6.3.0, clang 3.8, MSVC 2017\r\n\n", "hints_text": "Thanks for bringing this up, @Predelnik. We haven't had an `IsStreamInsertable` issue for a while.\r\nThat SO answer is interesting. It can't be used as-is as it relies on (quite a few, actually) C++11 features - and Catch (1.x, at least) needs to keep working on pre-C++11 compilers.\r\nBut if the approach there is genuinely better we could do something conditionally (and would also be useful for Catch2 - which will assume C++11).\r\nThe \"genuinely better\" qualification is there because I know from looking at this before that every technique I investigated had one trade-off or another. That was a few years ago and I don't recall seeing anything like this one - so maybe it's better? But I'd like to see it more road tested before I switch it in by default (even for C++11 compilers) as if it has different trade-offs to the current approach then it will break currently working code.\r\n\r\nSo I think a starting point is to include it as an \"opt-in\" alternative.\r\n\r\nIf you're happy to put together a PR for that I'd be grateful. Otherwise I'll try and get to it myself in the near future (but not this week).\r\n", "created_at": "2017-04-02T11:09:42Z", "version": "1.8"}
