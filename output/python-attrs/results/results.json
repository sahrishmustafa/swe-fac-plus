[
  {
    "repo": "python-attrs/attrs",
    "pull_number": 1009,
    "instance_id": "python-attrs__attrs-1009",
    "issue_numbers": [
      "1004"
    ],
    "base_commit": "5ecc39749a98c7ec3fc63b8cbaa82de5eb17c173",
    "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -922,7 +922,7 @@ def slots_getstate(self):\n             \"\"\"\n             Automatically created by attrs.\n             \"\"\"\n-            return tuple(getattr(self, name) for name in state_attr_names)\n+            return {name: getattr(self, name) for name in state_attr_names}\n \n         hash_caching_enabled = self._cache_hash\n \n@@ -931,8 +931,9 @@ def slots_setstate(self, state):\n             Automatically created by attrs.\n             \"\"\"\n             __bound_setattr = _obj_setattr.__get__(self)\n-            for name, value in zip(state_attr_names, state):\n-                __bound_setattr(name, value)\n+            for name in state_attr_names:\n+                if name in state:\n+                    __bound_setattr(name, state[name])\n \n             # The hash code cache is not included when the object is\n             # serialized, but it still needs to be initialized to None to\n",
    "test_patch": "diff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -9,6 +9,8 @@\n import types\n import weakref\n \n+from unittest import mock\n+\n import pytest\n \n import attr\n@@ -743,3 +745,58 @@ def f(self):\n \n     assert B(11).f == 121\n     assert B(17).f == 289\n+\n+\n+@attr.s(slots=True)\n+class A:\n+    x = attr.ib()\n+    b = attr.ib()\n+    c = attr.ib()\n+\n+\n+@pytest.mark.parametrize(\"cls\", [A])\n+def test_slots_unpickle_after_attr_removed(cls):\n+    \"\"\"\n+    We don't assign attributes we don't have anymore if the class has\n+    removed it.\n+    \"\"\"\n+    a = cls(1, 2, 3)\n+    a_pickled = pickle.dumps(a)\n+    a_unpickled = pickle.loads(a_pickled)\n+    assert a_unpickled == a\n+\n+    @attr.s(slots=True)\n+    class NEW_A:\n+        x = attr.ib()\n+        c = attr.ib()\n+\n+    with mock.patch(f\"{__name__}.A\", NEW_A):\n+        new_a = pickle.loads(a_pickled)\n+        assert new_a.x == 1\n+        assert new_a.c == 3\n+        assert not hasattr(new_a, \"b\")\n+\n+\n+@pytest.mark.parametrize(\"cls\", [A])\n+def test_slots_unpickle_after_attr_added(cls):\n+    \"\"\"\n+    We don't assign attribute we haven't had before if the class has one added.\n+    \"\"\"\n+    a = cls(1, 2, 3)\n+    a_pickled = pickle.dumps(a)\n+    a_unpickled = pickle.loads(a_pickled)\n+    assert a_unpickled == a\n+\n+    @attr.s(slots=True)\n+    class NEW_A:\n+        x = attr.ib()\n+        b = attr.ib()\n+        d = attr.ib()\n+        c = attr.ib()\n+\n+    with mock.patch(f\"{__name__}.A\", NEW_A):\n+        new_a = pickle.loads(a_pickled)\n+        assert new_a.x == 1\n+        assert new_a.b == 2\n+        assert new_a.c == 3\n+        assert not hasattr(new_a, \"d\")\n",
    "problem_statement": "Current default implementation of __getstate__ and __setstate__ could be made safer\nThis is a known \"sharp edge\" of pickle, but attrs could make this a bit safer by slightly modifying the default implementation of `__getstate__` and `__setstate__`. The problem is that due to returning a tuple in the default implementation of `__getstate__`, removing a member, and then unpickling from a previous version can be __very__ unsafe. This is not a hypothetical situation - it commonly happens when an object is pickled, and then stored in a data-store of some sort, and unpickled some time later by a changed version of the code. \r\n\r\nHere's a simple reproducer that demonstrates it (python 3.10, attrs 22.1.0):\r\n\r\n```python\r\nimport pickle\r\n\r\nimport attr\r\n\r\n@attr.s(slots=True, hash=False, auto_attribs=True)\r\nclass Test:\r\n    count: int\r\n    enable_minor_feature: bool\r\n    should_launch_missiles: bool\r\n\r\nt = Test(count=1, should_launch_missiles=False, enable_minor_feature=True)\r\nprint(t)  # Test(count=1, enable_minor_feature=True, should_launch_missiles=False)\r\ntp = pickle.dumps(t)\r\n\r\n@attr.s(slots=True, hash=False, auto_attribs=True)\r\nclass Test:\r\n    count: int\r\n    should_launch_missiles: bool\r\n\r\ntl = pickle.loads(tp)\r\nprint(tl)  # Test(count=1, should_launch_missiles=True)  <== an attribute is assigned a dangerously wrong value\r\n```\r\n\r\nWhile there's certainly an argument to be made that pickle should not be used for such things (and I'd agree) - the default implementation could, I believe, be made safer. Raise if things don't match, or even ignore unknown attributes in __setstate__,  by potentially returning a dictionary instead of a tuple [here](https://github.com/python-attrs/attrs/blob/c58ffd4e4cba5d5e58356722b985fc362358c48e/src/attr/_make.py#L925) would help.\n",
    "hints_text": "Have you tried replacing the tuple by the dict and see how much it breaks? Performance difference should be benign, since we save ourselves zipping.\nI wanted to get some thoughts on the feasibility of making the change at all first. Let me put together a patch and see how much it breaks, and we can take it from there. Thanks :)\nI don't think our implementation of pickling is a public API. So if you can make it compatible, that should  be OK.",
    "created_at": "2022-08-16T16:34:33Z",
    "version": "22.1",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container.\n# Using python:3.9-slim-buster provides Python 3.9 and a slim Debian environment.\nFROM python:3.9-slim-buster\n\n# System dependencies installation. Installs essential tools required for cloning the repository.\n# apt update and apt install for git, followed by clearing apt lists to reduce image size.\nRUN apt update && apt install -y git && rm -rf /var/lib/apt/lists/*\n\n# Set the working directory inside the container to /testbed/. All subsequent commands will run from this directory.\nWORKDIR /testbed/\n\n# Target Project setup.\n# 1. Clones the 'attrs' repository into the /testbed/ directory.\n# 2. Changes the current directory to /testbed/.\n# 3. Resets the repository to the specific commit SHA to ensure reproducibility.\n# 4. Installs the core build dependencies (setuptools, wheel).\n# 5. Installs the 'attrs' project in editable mode, including its 'tests' extra dependencies.\n#    This ensures that the project's local code is used and all necessary test dependencies (like pytest) are installed.\nRUN git clone https://github.com/python-attrs/attrs /testbed && \\\n    cd /testbed && \\\n    git reset --hard 5ecc39749a98c7ec3fc63b8cbaa82de5eb17c173 && \\\n    pip install setuptools wheel && \\\n    pip install -e \".[tests]\"",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\ngit checkout 5ecc39749a98c7ec3fc63b8cbaa82de5eb17c173 \"tests/test_slots.py\"\n\n# Apply test patch\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -9,6 +9,8 @@\n import types\n import weakref\n \n+from unittest import mock\n+\n import pytest\n \n import attr\n@@ -743,3 +745,58 @@ def f(self):\n \n     assert B(11).f == 121\n     assert B(17).f == 289\n+\n+\n+@attr.s(slots=True)\n+class A:\n+    x = attr.ib()\n+    b = attr.ib()\n+    c = attr.ib()\n+\n+\n+@pytest.mark.parametrize(\"cls\", [A])\n+def test_slots_unpickle_after_attr_removed(cls):\n+    \"\"\"\n+    We don't assign attributes we don't have anymore if the class has\n+    removed it.\n+    \"\"\"\n+    a = cls(1, 2, 3)\n+    a_pickled = pickle.dumps(a)\n+    a_unpickled = pickle.loads(a_pickled)\n+    assert a_unpickled == a\n+\n+    @attr.s(slots=True)\n+    class NEW_A:\n+        x = attr.ib()\n+        c = attr.ib()\n+\n+    with mock.patch(f\"{__name__}.A\", NEW_A):\n+        new_a = pickle.loads(a_pickled)\n+        assert new_a.x == 1\n+        assert new_a.c == 3\n+        assert not hasattr(new_a, \"b\")\n+\n+\n+@pytest.mark.parametrize(\"cls\", [A])\n+def test_slots_unpickle_after_attr_added(cls):\n+    \"\"\"\n+    We don't assign attribute we haven't had before if the class has one added.\n+    \"\"\"\n+    a = cls(1, 2, 3)\n+    a_pickled = pickle.dumps(a)\n+    a_unpickled = pickle.loads(a_pickled)\n+    assert a_unpickled == a\n+\n+    @attr.s(slots=True)\n+    class NEW_A:\n+        x = attr.ib()\n+        b = attr.ib()\n+        d = attr.ib()\n+        c = attr.ib()\n+\n+    with mock.patch(f\"{__name__}.A\", NEW_A):\n+        new_a = pickle.loads(a_pickled)\n+        assert new_a.x == 1\n+        assert new_a.b == 2\n+        assert new_a.c == 3\n+        assert not hasattr(new_a, \"d\")\nEOF_114329324912\n\n# Run target tests\npython -m pytest tests/test_slots.py\nrc=$?\n\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up modified test files\ngit checkout 5ecc39749a98c7ec3fc63b8cbaa82de5eb17c173 \"tests/test_slots.py\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\ngit checkout 5ecc39749a98c7ec3fc63b8cbaa82de5eb17c173 \"tests/test_slots.py\"\n\n# Apply test patch\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Run target tests\npython -m pytest tests/test_slots.py\nrc=$?\n\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up modified test files\ngit checkout 5ecc39749a98c7ec3fc63b8cbaa82de5eb17c173 \"tests/test_slots.py\""
  },
  {
    "repo": "python-attrs/attrs",
    "pull_number": 1080,
    "instance_id": "python-attrs__attrs-1080",
    "issue_numbers": [
      "1077"
    ],
    "base_commit": "0de967d6ece1606234ac56d5fe58a800d1b0434f",
    "patch": "diff --git a/src/attr/_cmp.py b/src/attr/_cmp.py\n--- a/src/attr/_cmp.py\n+++ b/src/attr/_cmp.py\n@@ -20,22 +20,22 @@ def cmp_using(\n     class_name=\"Comparable\",\n ):\n     \"\"\"\n-    Create a class that can be passed into `attr.ib`'s ``eq``, ``order``, and\n-    ``cmp`` arguments to customize field comparison.\n-\n-    The resulting class will have a full set of ordering methods if\n-    at least one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n-\n-    :param Optional[callable] eq: `callable` used to evaluate equality\n-        of two objects.\n-    :param Optional[callable] lt: `callable` used to evaluate whether\n-        one object is less than another object.\n-    :param Optional[callable] le: `callable` used to evaluate whether\n-        one object is less than or equal to another object.\n-    :param Optional[callable] gt: `callable` used to evaluate whether\n-        one object is greater than another object.\n-    :param Optional[callable] ge: `callable` used to evaluate whether\n-        one object is greater than or equal to another object.\n+    Create a class that can be passed into `attrs.field`'s ``eq``, ``order``,\n+    and ``cmp`` arguments to customize field comparison.\n+\n+    The resulting class will have a full set of ordering methods if at least\n+    one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n+\n+    :param Optional[callable] eq: `callable` used to evaluate equality of two\n+        objects.\n+    :param Optional[callable] lt: `callable` used to evaluate whether one\n+        object is less than another object.\n+    :param Optional[callable] le: `callable` used to evaluate whether one\n+        object is less than or equal to another object.\n+    :param Optional[callable] gt: `callable` used to evaluate whether one\n+        object is greater than another object.\n+    :param Optional[callable] ge: `callable` used to evaluate whether one\n+        object is greater than or equal to another object.\n \n     :param bool require_same_type: When `True`, equality and ordering methods\n         will return `NotImplemented` if objects are not of the same type.\ndiff --git a/src/attr/_funcs.py b/src/attr/_funcs.py\n--- a/src/attr/_funcs.py\n+++ b/src/attr/_funcs.py\n@@ -16,13 +16,13 @@ def asdict(\n     value_serializer=None,\n ):\n     \"\"\"\n-    Return the ``attrs`` attribute values of *inst* as a dict.\n+    Return the *attrs* attribute values of *inst* as a dict.\n \n-    Optionally recurse into other ``attrs``-decorated classes.\n+    Optionally recurse into other *attrs*-decorated classes.\n \n-    :param inst: Instance of an ``attrs``-decorated class.\n+    :param inst: Instance of an *attrs*-decorated class.\n     :param bool recurse: Recurse into classes that are also\n-        ``attrs``-decorated.\n+        *attrs*-decorated.\n     :param callable filter: A callable whose return code determines whether an\n         attribute or element is included (``True``) or dropped (``False``).  Is\n         called with the `attrs.Attribute` as the first argument and the\n@@ -40,7 +40,7 @@ def asdict(\n \n     :rtype: return type of *dict_factory*\n \n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  versionadded:: 16.0.0 *dict_factory*\n@@ -195,13 +195,13 @@ def astuple(\n     retain_collection_types=False,\n ):\n     \"\"\"\n-    Return the ``attrs`` attribute values of *inst* as a tuple.\n+    Return the *attrs* attribute values of *inst* as a tuple.\n \n-    Optionally recurse into other ``attrs``-decorated classes.\n+    Optionally recurse into other *attrs*-decorated classes.\n \n-    :param inst: Instance of an ``attrs``-decorated class.\n+    :param inst: Instance of an *attrs*-decorated class.\n     :param bool recurse: Recurse into classes that are also\n-        ``attrs``-decorated.\n+        *attrs*-decorated.\n     :param callable filter: A callable whose return code determines whether an\n         attribute or element is included (``True``) or dropped (``False``).  Is\n         called with the `attrs.Attribute` as the first argument and the\n@@ -215,7 +215,7 @@ def astuple(\n \n     :rtype: return type of *tuple_factory*\n \n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  versionadded:: 16.2.0\n@@ -289,7 +289,7 @@ def astuple(\n \n def has(cls):\n     \"\"\"\n-    Check whether *cls* is a class with ``attrs`` attributes.\n+    Check whether *cls* is a class with *attrs* attributes.\n \n     :param type cls: Class to introspect.\n     :raise TypeError: If *cls* is not a class.\n@@ -303,14 +303,14 @@ def assoc(inst, **changes):\n     \"\"\"\n     Copy *inst* and apply *changes*.\n \n-    :param inst: Instance of a class with ``attrs`` attributes.\n+    :param inst: Instance of a class with *attrs* attributes.\n     :param changes: Keyword changes in the new copy.\n \n     :return: A copy of inst with *changes* incorporated.\n \n-    :raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn't\n-        be found on *cls*.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.AttrsAttributeNotFoundError: If *attr_name*\n+        couldn't be found on *cls*.\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  deprecated:: 17.1.0\n@@ -341,14 +341,14 @@ def evolve(inst, **changes):\n     \"\"\"\n     Create a new instance, based on *inst* with *changes* applied.\n \n-    :param inst: Instance of a class with ``attrs`` attributes.\n+    :param inst: Instance of a class with *attrs* attributes.\n     :param changes: Keyword changes in the new copy.\n \n     :return: A copy of inst with *changes* incorporated.\n \n     :raise TypeError: If *attr_name* couldn't be found in the class\n         ``__init__``.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  versionadded:: 17.1.0\n@@ -385,10 +385,10 @@ def resolve_types(cls, globalns=None, localns=None, attribs=None):\n     :param Optional[dict] localns: Dictionary containing local variables.\n     :param Optional[list] attribs: List of attribs for the given class.\n         This is necessary when calling from inside a ``field_transformer``\n-        since *cls* is not an ``attrs`` class yet.\n+        since *cls* is not an *attrs* class yet.\n \n     :raise TypeError: If *cls* is not a class.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class and you didn't pass any attribs.\n     :raise NameError: If types cannot be resolved because of missing variables.\n \ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -109,9 +109,12 @@ def attrib(\n     ..  warning::\n \n         Does *not* do anything unless the class is also decorated with\n-        `attr.s`!\n+        `attr.s` / `attrs.define` / et cetera!\n \n-    :param default: A value that is used if an ``attrs``-generated ``__init__``\n+    Please consider using `attrs.field` in new code (``attr.ib`` will *never*\n+    go away, though).\n+\n+    :param default: A value that is used if an *attrs*-generated ``__init__``\n         is used and no value is passed while instantiating or the attribute is\n         excluded using ``init=False``.\n \n@@ -130,7 +133,7 @@ def attrib(\n     :param callable factory: Syntactic sugar for\n         ``default=attr.Factory(factory)``.\n \n-    :param validator: `callable` that is called by ``attrs``-generated\n+    :param validator: `callable` that is called by *attrs*-generated\n         ``__init__`` methods after the instance has been initialized.  They\n         receive the initialized instance, the :func:`~attrs.Attribute`, and the\n         passed value.\n@@ -142,7 +145,7 @@ def attrib(\n         all pass.\n \n         Validators can be globally disabled and re-enabled using\n-        `get_run_validators`.\n+        `attrs.validators.get_disabled` / `attrs.validators.set_disabled`.\n \n         The validator can also be set using decorator notation as shown below.\n \n@@ -184,7 +187,7 @@ def attrib(\n         value.  In that case this attributed is unconditionally initialized\n         with the specified default value or factory.\n     :param callable converter: `callable` that is called by\n-        ``attrs``-generated ``__init__`` methods to convert attribute's value\n+        *attrs*-generated ``__init__`` methods to convert attribute's value\n         to the desired format.  It is given the passed-in value, and the\n         returned value will be used as the new value of the attribute.  The\n         value is converted before being passed to the validator, if any.\n@@ -197,7 +200,7 @@ def attrib(\n         Regardless of the approach used, the type will be stored on\n         ``Attribute.type``.\n \n-        Please note that ``attrs`` doesn't do anything with this metadata by\n+        Please note that *attrs* doesn't do anything with this metadata by\n         itself. You can use it as part of your own code or for\n         `static type checking <types>`.\n     :param kw_only: Make this attribute keyword-only in the generated\n@@ -1211,12 +1214,15 @@ def attrs(\n     A class decorator that adds :term:`dunder methods` according to the\n     specified attributes using `attr.ib` or the *these* argument.\n \n+    Please consider using `attrs.define` / `attrs.frozen` in new code\n+    (``attr.s`` will *never* go away, though).\n+\n     :param these: A dictionary of name to `attr.ib` mappings.  This is\n         useful to avoid the definition of your attributes within the class body\n         because you can't (e.g. if you want to add ``__repr__`` methods to\n         Django models) or don't want to.\n \n-        If *these* is not ``None``, ``attrs`` will *not* search the class body\n+        If *these* is not ``None``, *attrs* will *not* search the class body\n         for attributes and will *not* remove any attributes from it.\n \n         The order is deduced from the order of the attributes inside *these*.\n@@ -1233,14 +1239,14 @@ def attrs(\n         inherited from some base class).\n \n         So for example by implementing ``__eq__`` on a class yourself,\n-        ``attrs`` will deduce ``eq=False`` and will create *neither*\n+        *attrs* will deduce ``eq=False`` and will create *neither*\n         ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible\n         ``__ne__`` by default, so it *should* be enough to only implement\n         ``__eq__`` in most cases).\n \n         .. warning::\n \n-           If you prevent ``attrs`` from creating the ordering methods for you\n+           If you prevent *attrs* from creating the ordering methods for you\n            (``order=False``, e.g. by implementing ``__le__``), it becomes\n            *your* responsibility to make sure its ordering is sound. The best\n            way is to use the `functools.total_ordering` decorator.\n@@ -1250,14 +1256,14 @@ def attrs(\n         *cmp*, or *hash* overrides whatever *auto_detect* would determine.\n \n     :param bool repr: Create a ``__repr__`` method with a human readable\n-        representation of ``attrs`` attributes..\n+        representation of *attrs* attributes..\n     :param bool str: Create a ``__str__`` method that is identical to\n         ``__repr__``.  This is usually not necessary except for\n         `Exception`\\ s.\n     :param Optional[bool] eq: If ``True`` or ``None`` (default), add ``__eq__``\n         and ``__ne__`` methods that check two instances for equality.\n \n-        They compare the instances as if they were tuples of their ``attrs``\n+        They compare the instances as if they were tuples of their *attrs*\n         attributes if and only if the types of both classes are *identical*!\n     :param Optional[bool] order: If ``True``, add ``__lt__``, ``__le__``,\n         ``__gt__``, and ``__ge__`` methods that behave like *eq* above and\n@@ -1268,7 +1274,7 @@ def attrs(\n     :param Optional[bool] unsafe_hash: If ``None`` (default), the ``__hash__``\n         method is generated according how *eq* and *frozen* are set.\n \n-        1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n+        1. If *both* are True, *attrs* will generate a ``__hash__`` for you.\n         2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n            None, marking it unhashable (which it is).\n         3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n@@ -1276,7 +1282,7 @@ def attrs(\n            ``object``, this means it will fall back to id-based hashing.).\n \n         Although not recommended, you can decide for yourself and force\n-        ``attrs`` to create one (e.g. if the class is immutable even though you\n+        *attrs* to create one (e.g. if the class is immutable even though you\n         didn't freeze it programmatically) by passing ``True`` or not.  Both of\n         these cases are rather special and should be used carefully.\n \n@@ -1287,7 +1293,7 @@ def attrs(\n     :param Optional[bool] hash: Alias for *unsafe_hash*. *unsafe_hash* takes\n         precedence.\n     :param bool init: Create a ``__init__`` method that initializes the\n-        ``attrs`` attributes. Leading underscores are stripped for the argument\n+        *attrs* attributes. Leading underscores are stripped for the argument\n         name. If a ``__attrs_pre_init__`` method exists on the class, it will\n         be called before the class is initialized. If a ``__attrs_post_init__``\n         method exists on the class, it will be called after the class is fully\n@@ -1303,7 +1309,7 @@ def attrs(\n         we encourage you to read the :term:`glossary entry <slotted classes>`.\n     :param bool frozen: Make instances immutable after initialization.  If\n         someone attempts to modify a frozen instance,\n-        `attr.exceptions.FrozenInstanceError` is raised.\n+        `attrs.exceptions.FrozenInstanceError` is raised.\n \n         .. note::\n \n@@ -1328,7 +1334,7 @@ def attrs(\n     :param bool auto_attribs: If ``True``, collect :pep:`526`-annotated\n         attributes from the class body.\n \n-        In this case, you **must** annotate every field.  If ``attrs``\n+        In this case, you **must** annotate every field.  If *attrs*\n         encounters a field that is set to an `attr.ib` but lacks a type\n         annotation, an `attr.exceptions.UnannotatedAttributeError` is\n         raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't\n@@ -1344,9 +1350,9 @@ def attrs(\n \n         .. warning::\n            For features that use the attribute name to create decorators (e.g.\n-           `validators <validators>`), you still *must* assign `attr.ib` to\n-           them. Otherwise Python will either not find the name or try to use\n-           the default value to call e.g. ``validator`` on it.\n+           :ref:`validators <validators>`), you still *must* assign `attr.ib`\n+           to them. Otherwise Python will either not find the name or try to\n+           use the default value to call e.g. ``validator`` on it.\n \n            These errors can be quite confusing and probably the most common bug\n            report on our bug tracker.\n@@ -1367,14 +1373,14 @@ def attrs(\n         class:\n \n         - the values for *eq*, *order*, and *hash* are ignored and the\n-          instances compare and hash by the instance's ids (N.B. ``attrs`` will\n+          instances compare and hash by the instance's ids (N.B. *attrs* will\n           *not* remove existing implementations of ``__hash__`` or the equality\n           methods. It just won't add own ones.),\n         - all attributes that are either passed into ``__init__`` or have a\n           default value are additionally available as a tuple in the ``args``\n           attribute,\n         - the value of *str* is ignored leaving ``__str__`` to base classes.\n-    :param bool collect_by_mro: Setting this to `True` fixes the way ``attrs``\n+    :param bool collect_by_mro: Setting this to `True` fixes the way *attrs*\n        collects attributes from base classes.  The default behavior is\n        incorrect in certain cases of multiple inheritance.  It should be on by\n        default but is kept off for backward-compatibility.\n@@ -1413,7 +1419,7 @@ def attrs(\n \n     :param Optional[callable] field_transformer:\n         A function that is called with the original class object and all\n-        fields right before ``attrs`` finalizes the class.  You can use\n+        fields right before *attrs* finalizes the class.  You can use\n         this, e.g., to automatically add converters or validators to\n         fields based on their types.  See `transform-fields` for more details.\n \n@@ -1891,7 +1897,7 @@ def _add_repr(cls, ns=None, attrs=None):\n \n def fields(cls):\n     \"\"\"\n-    Return the tuple of ``attrs`` attributes for a class.\n+    Return the tuple of *attrs* attributes for a class.\n \n     The tuple also allows accessing the fields by their names (see below for\n     examples).\n@@ -1899,13 +1905,13 @@ def fields(cls):\n     :param type cls: Class to introspect.\n \n     :raise TypeError: If *cls* is not a class.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     :rtype: tuple (with name accessors) of `attrs.Attribute`\n \n-    ..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n-        by name.\n+    .. versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n+       by name.\n     \"\"\"\n     if not isinstance(cls, type):\n         raise TypeError(\"Passed object must be a class.\")\n@@ -1917,13 +1923,13 @@ def fields(cls):\n \n def fields_dict(cls):\n     \"\"\"\n-    Return an ordered dictionary of ``attrs`` attributes for a class, whose\n+    Return an ordered dictionary of *attrs* attributes for a class, whose\n     keys are the attribute names.\n \n     :param type cls: Class to introspect.\n \n     :raise TypeError: If *cls* is not a class.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     :rtype: dict\n@@ -1944,7 +1950,7 @@ def validate(inst):\n \n     Leaves all exceptions through.\n \n-    :param inst: Instance of a class with ``attrs`` attributes.\n+    :param inst: Instance of a class with *attrs* attributes.\n     \"\"\"\n     if _config._run_validators is False:\n         return\n@@ -2382,6 +2388,10 @@ class Attribute:\n     \"\"\"\n     *Read-only* representation of an attribute.\n \n+    .. warning::\n+\n+       You should never instantiate this class yourself.\n+\n     The class has *all* arguments of `attr.ib` (except for ``factory``\n     which is only syntactic sugar for ``default=Factory(...)`` plus the\n     following:\n@@ -2527,13 +2537,13 @@ def from_counting_attr(cls, name, ca, type=None):\n             **inst_dict,\n         )\n \n-    # Don't use attr.evolve since fields(Attribute) doesn't work\n+    # Don't use attrs.evolve since fields(Attribute) doesn't work\n     def evolve(self, **changes):\n         \"\"\"\n         Copy *self* and apply *changes*.\n \n-        This works similarly to `attr.evolve` but that function does not work\n-        with ``Attribute``.\n+        This works similarly to `attrs.evolve` but that function does not work\n+        with `Attribute`.\n \n         It is mainly meant to be used for `transform-fields`.\n \n@@ -2768,10 +2778,6 @@ class Factory:\n     __slots__ = (\"factory\", \"takes_self\")\n \n     def __init__(self, factory, takes_self=False):\n-        \"\"\"\n-        `Factory` is part of the default machinery so if we want a default\n-        value here, we have to implement it ourselves.\n-        \"\"\"\n         self.factory = factory\n         self.takes_self = takes_self\n \ndiff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -46,7 +46,7 @@ def define(\n     match_args=True,\n ):\n     r\"\"\"\n-    Define an ``attrs`` class.\n+    Define an *attrs* class.\n \n     Differences to the classic `attr.s` that it uses underneath:\n \ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\n--- a/src/attr/exceptions.py\n+++ b/src/attr/exceptions.py\n@@ -34,7 +34,7 @@ class FrozenAttributeError(FrozenError):\n \n class AttrsAttributeNotFoundError(ValueError):\n     \"\"\"\n-    An ``attrs`` function couldn't find an attribute that the user asked for.\n+    An *attrs* function couldn't find an attribute that the user asked for.\n \n     .. versionadded:: 16.2.0\n     \"\"\"\n@@ -42,7 +42,7 @@ class AttrsAttributeNotFoundError(ValueError):\n \n class NotAnAttrsClassError(ValueError):\n     \"\"\"\n-    A non-``attrs`` class has been passed into an ``attrs`` function.\n+    A non-*attrs* class has been passed into an *attrs* function.\n \n     .. versionadded:: 16.2.0\n     \"\"\"\n@@ -50,7 +50,7 @@ class NotAnAttrsClassError(ValueError):\n \n class DefaultAlreadySetError(RuntimeError):\n     \"\"\"\n-    A default has been set using ``attr.ib()`` and is attempted to be reset\n+    A default has been set when defining the field and is attempted to be reset\n     using the decorator.\n \n     .. versionadded:: 17.1.0\n@@ -59,8 +59,7 @@ class DefaultAlreadySetError(RuntimeError):\n \n class UnannotatedAttributeError(RuntimeError):\n     \"\"\"\n-    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n-    annotation.\n+    A class with ``auto_attribs=True`` has a field without a type annotation.\n \n     .. versionadded:: 17.3.0\n     \"\"\"\n@@ -68,7 +67,7 @@ class UnannotatedAttributeError(RuntimeError):\n \n class PythonTooOldError(RuntimeError):\n     \"\"\"\n-    It was attempted to use an ``attrs`` feature that requires a newer Python\n+    It was attempted to use an *attrs* feature that requires a newer Python\n     version.\n \n     .. versionadded:: 18.2.0\n@@ -77,8 +76,8 @@ class PythonTooOldError(RuntimeError):\n \n class NotCallableError(TypeError):\n     \"\"\"\n-    A ``attr.ib()`` requiring a callable has been set with a value\n-    that is not callable.\n+    A field requiring a callable has been set with a value that is not\n+    callable.\n \n     .. versionadded:: 19.2.0\n     \"\"\"\ndiff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -359,13 +359,13 @@ def __repr__(self):\n \n def is_callable():\n     \"\"\"\n-    A validator that raises a `attr.exceptions.NotCallableError` if the\n+    A validator that raises a `attrs.exceptions.NotCallableError` if the\n     initializer is called with a value for this particular attribute\n     that is not callable.\n \n     .. versionadded:: 19.1.0\n \n-    :raises `attr.exceptions.NotCallableError`: With a human readable error\n+    :raises attrs.exceptions.NotCallableError: With a human readable error\n         message containing the attribute (`attrs.Attribute`) name,\n         and the value it got.\n     \"\"\"\n",
    "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1106,7 +1106,7 @@ def test_instance(self, C):\n \n     def test_handler_non_attrs_class(self):\n         \"\"\"\n-        Raises `ValueError` if passed a non-``attrs`` instance.\n+        Raises `ValueError` if passed a non-*attrs* instance.\n         \"\"\"\n         with pytest.raises(NotAnAttrsClassError) as e:\n             fields(object)\n@@ -1148,7 +1148,7 @@ def test_instance(self, C):\n \n     def test_handler_non_attrs_class(self):\n         \"\"\"\n-        Raises `ValueError` if passed a non-``attrs`` instance.\n+        Raises `ValueError` if passed a non-*attrs* instance.\n         \"\"\"\n         with pytest.raises(NotAnAttrsClassError) as e:\n             fields_dict(object)\n",
    "problem_statement": "Some API doc entries in objects.inv have double-attr module prefixes\ne.g. `attr.attr.cmp_using`\r\n\r\ncursory looking suggests it's autodoc vs manual.\n",
    "hints_text": "Ah, I missed the dedicated issue and left the comments @ https://github.com/python-attrs/attrs/issues/1073#issuecomment-1369072401 & https://github.com/python-attrs/attrs/issues/1073#issuecomment-1369077722.",
    "created_at": "2023-01-04T11:39:22Z",
    "version": "22.2",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container.\n# Updated to python:3.11-slim-buster to support Python 3.10+ features required by some tests.\nFROM python:3.11-slim-buster\n\n# System dependencies installation. Installs essential tools required for cloning the repository\n# and building potential C extensions (build-essential).\nRUN apt update && apt install -y git build-essential && rm -rf /var/lib/apt/lists/*\n\n# Set the working directory inside the container to /testbed/. All subsequent commands will run from this directory.\nWORKDIR /testbed/\n\n# Target Project setup.\n# 1. Clones the 'attrs' repository into the /testbed/ directory.\n# 2. Changes the current directory to /testbed/.\n# 3. Resets the repository to the specific commit SHA to ensure reproducibility.\n# 4. Installs the core build dependencies (setuptools, wheel) that might be needed by pyproject.toml.\n# 5. Installs the 'attrs' project in editable mode, including its 'tests' extra dependencies.\n#    This ensures that the project's local code is used and all necessary test dependencies (like pytest) are installed.\nRUN git clone https://github.com/python-attrs/attrs /testbed && \\\n    cd /testbed && \\\n    git reset --hard 0de967d6ece1606234ac56d5fe58a800d1b0434f && \\\n    pip install setuptools wheel && \\\n    pip install -e \".[tests]\"",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n# Checkout the original state of the target test file(s) before applying any patch\ngit checkout 0de967d6ece1606234ac56d5fe58a800d1b0434f \"tests/test_make.py\"\n\n# Apply test patch (content will be programmatically inserted)\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1106,7 +1106,7 @@ def test_instance(self, C):\n \n     def test_handler_non_attrs_class(self):\n         \"\"\"\n-        Raises `ValueError` if passed a non-``attrs`` instance.\n+        Raises `ValueError` if passed a non-*attrs* instance.\n         \"\"\"\n         with pytest.raises(NotAnAttrsClassError) as e:\n             fields(object)\n@@ -1148,7 +1148,7 @@ def test_instance(self, C):\n \n     def test_handler_non_attrs_class(self):\n         \"\"\"\n-        Raises `ValueError` if passed a non-``attrs`` instance.\n+        Raises `ValueError` if passed a non-*attrs* instance.\n         \"\"\"\n         with pytest.raises(NotAnAttrsClassError) as e:\n             fields_dict(object)\nEOF_114329324912\n\n# Run target tests using pytest\n# The Dockerfile already set up the environment, so no explicit activation (like conda/venv) is needed.\n# Everything is accessible through the global python 3.9 installation in the container.\npython -m pytest tests/test_make.py\nrc=$?\n\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up modified test files by reverting to the original state\ngit checkout 0de967d6ece1606234ac56d5fe58a800d1b0434f \"tests/test_make.py\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n# Checkout the original state of the target test file(s) before applying any patch\ngit checkout 0de967d6ece1606234ac56d5fe58a800d1b0434f \"tests/test_make.py\"\n\n# Apply test patch (content will be programmatically inserted)\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Run target tests using pytest\n# The Dockerfile already set up the environment, so no explicit activation (like conda/venv) is needed.\n# Everything is accessible through the global python 3.9 installation in the container.\npython -m pytest tests/test_make.py\nrc=$?\n\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up modified test files by reverting to the original state\ngit checkout 0de967d6ece1606234ac56d5fe58a800d1b0434f \"tests/test_make.py\""
  },
  {
    "repo": "python-attrs/attrs",
    "pull_number": 1107,
    "instance_id": "python-attrs__attrs-1107",
    "issue_numbers": [
      "1082"
    ],
    "base_commit": "359c2db460f4410e86782a99eef06dabbfd96d34",
    "patch": "diff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -167,6 +167,7 @@ def field(\n     hash=None,\n     init=True,\n     metadata=None,\n+    type=None,\n     converter=None,\n     factory=None,\n     kw_only=False,\n@@ -179,6 +180,10 @@ def field(\n     Identical to `attr.ib`, except keyword-only and with some arguments\n     removed.\n \n+    .. versionadded:: 22.3.0\n+       The *type* parameter has been re-added; mostly for\n+       {func}`attrs.make_class`. Please note that type checkers ignore this\n+       metadata.\n     .. versionadded:: 20.1.0\n     \"\"\"\n     return attrib(\n@@ -188,6 +193,7 @@ def field(\n         hash=hash,\n         init=init,\n         metadata=metadata,\n+        type=type,\n         converter=converter,\n         factory=factory,\n         kw_only=kw_only,\n",
    "test_patch": "diff --git a/tests/test_next_gen.py b/tests/test_next_gen.py\n--- a/tests/test_next_gen.py\n+++ b/tests/test_next_gen.py\n@@ -28,6 +28,16 @@ def test_simple(self):\n         \"\"\"\n         C(\"1\", 2)\n \n+    def test_field_type(self):\n+        \"\"\"\n+        Make class with attrs.field and type parameter.\n+        \"\"\"\n+        classFields = {\"testint\": attrs.field(type=int)}\n+\n+        A = attrs.make_class(\"A\", classFields)\n+\n+        assert int == attrs.fields(A).testint.type\n+\n     def test_no_slots(self):\n         \"\"\"\n         slots can be deactivated.\n",
    "problem_statement": "Add `type` back to `attrs.field()` for use in `attrs.make_class()`\nI'm using `attrs.make_class()` to dynamically construct a class based on other attrs classes, and it would be nice to be able to specify the `type` of the fields on the generated class using `attrs.field()` instead of `attr.ib()`. In other words, this works:\r\n\r\n```python\r\nfields = {\r\n    field.name: attr.ib(type=field.type)\r\n    for field in itertools.chain.from_iterable(\r\n        attrs.fields(t) for t in SOME_ATTRS_CLASSES\r\n    )\r\n    if not field.name.startswith(\"_\")\r\n}\r\n\r\nMyClass = attrs.make_class(\"MyClass\", fields)\r\n```\r\n\r\nbut this does not:\r\n\r\n```python\r\nfields = {\r\n    field.name: attrs.field(type=field.type)\r\n    for field in itertools.chain.from_iterable(\r\n        attrs.fields(t) for t in SOME_ATTRS_CLASSES\r\n    )\r\n    if not field.name.startswith(\"_\")\r\n}\r\n\r\nMyClass = attrs.make_class(\"MyClass\", fields)\r\n```\n",
    "hints_text": "Aw man yeah when I celebrated to get rid of that, I forgot about `make_class`. \ud83d\ude48\nI'm working on the implementation. ",
    "created_at": "2023-02-28T09:41:01Z",
    "version": "22.2",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container.\nFROM python:3.9-slim-buster\n\n# System dependencies installation. Installs essential tools required for cloning the repository\n# and building potential C extensions (build-essential).\nRUN apt update && apt install -y git build-essential && rm -rf /var/lib/apt/lists/*\n\n# Set the working directory inside the container to /testbed/. All subsequent commands will run from this directory.\nWORKDIR /testbed/\n\n# Target Project setup.\n# 1. Clones the 'attrs' repository into the /testbed/ directory.\n# 2. Changes the current directory to /testbed/.\n# 3. Resets the repository to the specific commit SHA to ensure reproducibility.\n# 4. Installs the core build dependencies (setuptools, wheel) that might be needed by pyproject.toml.\n# 5. Installs the 'attrs' project in editable mode, including its 'tests' extra dependencies.\n#    This ensures that the project's local code is used and all necessary test dependencies (like pytest) are installed.\nRUN git clone https://github.com/python-attrs/attrs /testbed && \\\n    cd /testbed && \\\n    git reset --hard 359c2db460f4410e86782a99eef06dabbfd96d34 && \\\n    pip install setuptools wheel && \\\n    pip install -e \".[tests]\"",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Checkout the original state of the target test file(s) before applying any patch\ngit checkout 359c2db460f4410e86782a99eef06dabbfd96d34 \"tests/test_next_gen.py\"\n\n# Apply test patch (content will be programmatically inserted)\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/tests/test_next_gen.py b/tests/test_next_gen.py\n--- a/tests/test_next_gen.py\n+++ b/tests/test_next_gen.py\n@@ -28,6 +28,16 @@ def test_simple(self):\n         \"\"\"\n         C(\"1\", 2)\n \n+    def test_field_type(self):\n+        \"\"\"\n+        Make class with attrs.field and type parameter.\n+        \"\"\"\n+        classFields = {\"testint\": attrs.field(type=int)}\n+\n+        A = attrs.make_class(\"A\", classFields)\n+\n+        assert int == attrs.fields(A).testint.type\n+\n     def test_no_slots(self):\n         \"\"\"\n         slots can be deactivated.\nEOF_114329324912\n\n# Run target tests using pytest\n# The Dockerfile already set up the environment by installing attrs with its test dependencies.\n# Everything is accessible through the global python 3.9 installation in the container.\npython -m pytest tests/test_next_gen.py\nrc=$?\n\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up modified test files by reverting to the original state\ngit checkout 359c2db460f4410e86782a99eef06dabbfd96d34 \"tests/test_next_gen.py\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Checkout the original state of the target test file(s) before applying any patch\ngit checkout 359c2db460f4410e86782a99eef06dabbfd96d34 \"tests/test_next_gen.py\"\n\n# Apply test patch (content will be programmatically inserted)\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Run target tests using pytest\n# The Dockerfile already set up the environment by installing attrs with its test dependencies.\n# Everything is accessible through the global python 3.9 installation in the container.\npython -m pytest tests/test_next_gen.py\nrc=$?\n\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up modified test files by reverting to the original state\ngit checkout 359c2db460f4410e86782a99eef06dabbfd96d34 \"tests/test_next_gen.py\""
  }
]