{
    "task_id": "python-attrs__attrs-287",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-287_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 287,
        "instance_id": "python-attrs__attrs-287",
        "issue_numbers": [
            "285"
        ],
        "base_commit": "1e6627c9ad64988c3d547606fd379eb1dd32d80b",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -270,7 +270,7 @@ def _transform_attrs(cls, these, auto_attribs):\n     # of attributes we've seen in `take_attr_names` and ignore their\n     # redefinitions deeper in the hierarchy.\n     super_attrs = []\n-    taken_attr_names = set(a.name for a in non_super_attrs)\n+    taken_attr_names = {a.name: a for a in non_super_attrs}\n     for super_cls in cls.__mro__[1:-1]:\n         sub_attrs = getattr(super_cls, \"__attrs_attrs__\", None)\n         if sub_attrs is not None:\n@@ -278,9 +278,16 @@ def _transform_attrs(cls, these, auto_attribs):\n             # list in the end and get all attributes in the order they have\n             # been defined.\n             for a in reversed(sub_attrs):\n-                if a.name not in taken_attr_names:\n+                prev_a = taken_attr_names.get(a.name)\n+                if prev_a is None:\n+                    super_attrs.append(a)\n+                    taken_attr_names[a.name] = a\n+                elif prev_a == a:\n+                    # This happens thru multiple inheritance.  We don't want\n+                    # to favor attributes that are further down in the tree\n+                    # so we move them to the back.\n+                    super_attrs.remove(a)\n                     super_attrs.append(a)\n-                    taken_attr_names.add(a.name)\n \n     # Now reverse the list, such that the attributes are sorted by *descending*\n     # age.  IOW: the oldest attribute definition is at the head of the list.\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -214,6 +214,42 @@ class C(Base):\n             simple_attr(\"x\"),\n         ) == attrs\n \n+    def test_multiple_inheritance(self):\n+        \"\"\"\n+        Order of attributes doesn't get mixed up by multiple inheritance.\n+\n+        See #285\n+        \"\"\"\n+        @attr.s\n+        class A(object):\n+            a1 = attr.ib(default=\"a1\")\n+            a2 = attr.ib(default=\"a2\")\n+\n+        @attr.s\n+        class B(A):\n+            b1 = attr.ib(default=\"b1\")\n+            b2 = attr.ib(default=\"b2\")\n+\n+        @attr.s\n+        class C(B, A):\n+            c1 = attr.ib(default=\"c1\")\n+            c2 = attr.ib(default=\"c2\")\n+\n+        @attr.s\n+        class D(A):\n+            d1 = attr.ib(default=\"d1\")\n+            d2 = attr.ib(default=\"d2\")\n+\n+        @attr.s\n+        class E(D, C):\n+            e1 = attr.ib(default=\"e1\")\n+            e2 = attr.ib(default=\"e2\")\n+\n+        assert (\n+            \"E(a1='a1', a2='a2', b1='b1', b2='b2', c1='c1', c2='c2', d1='d1', \"\n+            \"d2='d2', e1='e1', e2='e2')\"\n+        ) == repr(E())\n+\n \n class TestAttributes(object):\n     \"\"\"\n",
        "problem_statement": "17.3.0 changes the order how inherited class attributes are defined if they have the same base class\nMinimal working example:\r\n```\r\nimport attr\r\n\r\n@attr.s()\r\nclass A:\r\n    name = attr.ib()\r\n    cookie = attr.ib(default=\"Cookie\")\r\n\r\n@attr.s()\r\nclass B:\r\n    cake = attr.ib(default=\"Cake\")\r\n    cereal = attr.ib(default=\"Cereal\")\r\n\r\n@attr.s()\r\nclass C(B, A):\r\n    breakfast = attr.ib(default=\"All\")\r\n\r\n@attr.s()\r\nclass D(A):\r\n    food = attr.ib(default=\"food\")\r\n    melon = attr.ib(default=\"melon\")\r\n\r\n@attr.s()\r\nclass E(D, C):\r\n    apple = attr.ib(default=\"apple\")\r\n```\r\nThis works with attrs==17.2.0 and breaks with attrs==17.3.0. In 17.3.0 the list of non_super_names in base.py: `['cake', 'cereal', 'breakfast', 'name', 'cookie', 'food', 'melon', 'apple']` breaks because attr is trying to create a non-default attribute in between default attributes. \n",
        "hints_text": "When looking at what ``_transform_attrs`` is doing for class E, we see what's going wrong. The MRO for E is E, D, C, B, A.\r\nIt first collects all (not just locally defined) attributes from ``D.__attrs_attrs__`` in reverse order: ``melon``, ``food``, ``cookie``, ``name``. Then it looks at ``C.__attrs_attrs__`` and collects the attributes which are not yet defined: ``breakfast``, ``cereal``, ``cake``.\r\nWhen reversing this again,  ``cake``, ``cereal``and ``breakfast`` end up before the ``name`` attribute.\r\nIt seems that this should work if it only looked at the locally defined attributes when iterating over the MRO, as ``A.name`` would be processed last.\nAs a minimal workaround, this change fixes the order for our usecase:\r\n``` diff\r\n@@ -278,7 +278,9 @@\r\n             # list in the end and get all attributes in the order they have\r\n             # been defined.\r\n             for a in reversed(sub_attrs):\r\n-                if a.name not in taken_attr_names:\r\n+                if a.name in super_cls.__super_names__:\r\n+                    continue\r\n+                elif a.name not in taken_attr_names:\r\n                     super_attrs.append(a)\r\n                     taken_attr_names.add(a.name)\r\n \r\n@@ -354,6 +356,7 @@\r\n         self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\r\n \r\n         self._cls_dict[\"__attrs_attrs__\"] = self._attrs\r\n+        self._cls_dict[\"__super_names__\"] = self._super_names\r\n \r\n         if frozen:\r\n             self._cls_dict[\"__setattr__\"] = _frozen_setattrs\r\n```\r\nThe downside is obviously cluttering the generated classes with the ``__super_names__`` attribute. Perhaps each Attribute could keep a reference to the class where it was defined.\r\nThat would allow ``_transform_attrs`` to filter out those defined on other super classes and only handle them later where they were actually defined.",
        "created_at": "2017-11-09T11:55:51Z",
        "version": "17.3"
    }
}