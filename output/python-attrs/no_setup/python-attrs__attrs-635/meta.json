{
    "task_id": "python-attrs__attrs-635",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-635_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 635,
        "instance_id": "python-attrs__attrs-635",
        "issue_numbers": [
            "428"
        ],
        "base_commit": "f8f3f598a38163481513785c83a555d09b10bcd5",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -343,12 +343,74 @@ def _counter_getter(e):\n     return e[1].counter\n \n \n-def _transform_attrs(cls, these, auto_attribs, kw_only):\n+def _collect_base_attrs(cls, taken_attr_names):\n+    \"\"\"\n+    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n+    \"\"\"\n+    base_attrs = []\n+    base_attr_map = {}  # A dictionary of base attrs to their classes.\n+\n+    # Traverse the MRO and collect attributes.\n+    for base_cls in reversed(cls.__mro__[1:-1]):\n+        for a in getattr(base_cls, \"__attrs_attrs__\", []):\n+            if a.inherited or a.name in taken_attr_names:\n+                continue\n+\n+            a = a._assoc(inherited=True)\n+            base_attrs.append(a)\n+            base_attr_map[a.name] = base_cls\n+\n+    # For each name, only keep the freshest definition i.e. the furthest at the\n+    # back.  base_attr_map is fine because it gets overwritten with every new\n+    # instance.\n+    filtered = []\n+    seen = set()\n+    for a in reversed(base_attrs):\n+        if a.name in seen:\n+            continue\n+        filtered.insert(0, a)\n+        seen.add(a.name)\n+\n+    return filtered, base_attr_map\n+\n+\n+def _collect_base_attrs_broken(cls, taken_attr_names):\n+    \"\"\"\n+    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n+\n+    N.B. *taken_attr_names* will be mutated.\n+\n+    Adhere to the old incorrect behavior.\n+\n+    Notably it collects from the front and considers inherited attributes which\n+    leads to the buggy behavior reported in #428.\n+    \"\"\"\n+    base_attrs = []\n+    base_attr_map = {}  # A dictionary of base attrs to their classes.\n+\n+    # Traverse the MRO and collect attributes.\n+    for base_cls in cls.__mro__[1:-1]:\n+        for a in getattr(base_cls, \"__attrs_attrs__\", []):\n+            if a.name in taken_attr_names:\n+                continue\n+\n+            a = a._assoc(inherited=True)\n+            taken_attr_names.add(a.name)\n+            base_attrs.append(a)\n+            base_attr_map[a.name] = base_cls\n+\n+    return base_attrs, base_attr_map\n+\n+\n+def _transform_attrs(cls, these, auto_attribs, kw_only, collect_by_mro):\n     \"\"\"\n     Transform all `_CountingAttr`s on a class into `Attribute`s.\n \n     If *these* is passed, use that and don't look for them on the class.\n \n+    *collect_by_mro* is True, collect them in the correct MRO order, otherwise\n+    use the old -- incorrect -- order.  See #428.\n+\n     Return an `_Attributes`.\n     \"\"\"\n     cd = cls.__dict__\n@@ -405,24 +467,14 @@ def _transform_attrs(cls, these, auto_attribs, kw_only):\n         for attr_name, ca in ca_list\n     ]\n \n-    base_attrs = []\n-    base_attr_map = {}  # A dictionary of base attrs to their classes.\n-    taken_attr_names = {a.name: a for a in own_attrs}\n-\n-    # Traverse the MRO and collect attributes.\n-    for base_cls in cls.__mro__[1:-1]:\n-        sub_attrs = getattr(base_cls, \"__attrs_attrs__\", None)\n-        if sub_attrs is None:\n-            continue\n-\n-        for a in sub_attrs:\n-            prev_a = taken_attr_names.get(a.name)\n-            # Only add an attribute if it hasn't been defined before.  This\n-            # allows for overwriting attribute definitions by subclassing.\n-            if prev_a is None:\n-                base_attrs.append(a)\n-                taken_attr_names[a.name] = a\n-                base_attr_map[a.name] = base_cls\n+    if collect_by_mro:\n+        base_attrs, base_attr_map = _collect_base_attrs(\n+            cls, {a.name for a in own_attrs}\n+        )\n+    else:\n+        base_attrs, base_attr_map = _collect_base_attrs_broken(\n+            cls, {a.name for a in own_attrs}\n+        )\n \n     attr_names = [a.name for a in base_attrs + own_attrs]\n \n@@ -498,9 +550,10 @@ def __init__(\n         kw_only,\n         cache_hash,\n         is_exc,\n+        collect_by_mro,\n     ):\n         attrs, base_attrs, base_map = _transform_attrs(\n-            cls, these, auto_attribs, kw_only\n+            cls, these, auto_attribs, kw_only, collect_by_mro,\n         )\n \n         self._cls = cls\n@@ -839,6 +892,7 @@ def attrs(\n     eq=None,\n     order=None,\n     auto_detect=False,\n+    collect_by_mro=False,\n ):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -998,6 +1052,13 @@ def attrs(\n           default value are additionally available as a tuple in the ``args``\n           attribute,\n         - the value of *str* is ignored leaving ``__str__`` to base classes.\n+    :param bool collect_by_mro: Setting this to `True` fixes the way ``attrs``\n+       collects attributes from base classes.  The default behavior is\n+       incorrect in certain cases of multiple inheritance.  It should be on by\n+       default but is kept off for backward-compatability.\n+\n+       See issue `#428 <https://github.com/python-attrs/attrs/issues/428>`_ for\n+       more details.\n \n     .. versionadded:: 16.0.0 *slots*\n     .. versionadded:: 16.1.0 *frozen*\n@@ -1024,6 +1085,7 @@ def attrs(\n     .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n     .. versionadded:: 19.2.0 *eq* and *order*\n     .. versionadded:: 20.1.0 *auto_detect*\n+    .. versionadded:: 20.1.0 *collect_by_mro*\n     \"\"\"\n     if auto_detect and PY2:\n         raise PythonTooOldError(\n@@ -1050,6 +1112,7 @@ def wrap(cls):\n             kw_only,\n             cache_hash,\n             is_exc,\n+            collect_by_mro,\n         )\n         if _determine_whether_to_implement(\n             cls, repr, auto_detect, (\"__repr__\",)\n@@ -1884,11 +1947,15 @@ class Attribute(object):\n     *Read-only* representation of an attribute.\n \n     :attribute name: The name of the attribute.\n+    :attribute inherited: Whether or not that attribute has been inherited from\n+        a base class.\n \n     Plus *all* arguments of `attr.ib` (except for ``factory``\n     which is only syntactic sugar for ``default=Factory(...)``.\n \n-    For the version history of the fields, see `attr.ib`.\n+    .. versionadded:: 20.1.0 *inherited*\n+\n+    For the full version history of the fields, see `attr.ib`.\n     \"\"\"\n \n     __slots__ = (\n@@ -1904,6 +1971,7 @@ class Attribute(object):\n         \"type\",\n         \"converter\",\n         \"kw_only\",\n+        \"inherited\",\n     )\n \n     def __init__(\n@@ -1915,6 +1983,7 @@ def __init__(\n         cmp,  # XXX: unused, remove along with other cmp code.\n         hash,\n         init,\n+        inherited,\n         metadata=None,\n         type=None,\n         converter=None,\n@@ -1948,6 +2017,7 @@ def __init__(\n         )\n         bound_setattr(\"type\", type)\n         bound_setattr(\"kw_only\", kw_only)\n+        bound_setattr(\"inherited\", inherited)\n \n     def __setattr__(self, name, value):\n         raise FrozenInstanceError()\n@@ -1970,6 +2040,7 @@ def from_counting_attr(cls, name, ca, type=None):\n                 \"validator\",\n                 \"default\",\n                 \"type\",\n+                \"inherited\",\n             )  # exclude methods and deprecated alias\n         }\n         return cls(\n@@ -1978,6 +2049,7 @@ def from_counting_attr(cls, name, ca, type=None):\n             default=ca._default,\n             type=type,\n             cmp=None,\n+            inherited=False,\n             **inst_dict\n         )\n \n@@ -2042,6 +2114,7 @@ def _setattrs(self, name_values_pairs):\n         order=False,\n         hash=(name != \"metadata\"),\n         init=True,\n+        inherited=False,\n     )\n     for name in Attribute.__slots__\n ]\n@@ -2087,6 +2160,7 @@ class _CountingAttr(object):\n             kw_only=False,\n             eq=True,\n             order=False,\n+            inherited=False,\n         )\n         for name in (\n             \"counter\",\n@@ -2109,6 +2183,7 @@ class _CountingAttr(object):\n             kw_only=False,\n             eq=True,\n             order=False,\n+            inherited=False,\n         ),\n     )\n     cls_counter = 0\n",
        "test_patch": "diff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -131,6 +131,7 @@ def test_fields(self, cls):\n                 order=True,\n                 hash=None,\n                 init=True,\n+                inherited=False,\n             ),\n             Attribute(\n                 name=\"y\",\n@@ -142,6 +143,7 @@ def test_fields(self, cls):\n                 order=True,\n                 hash=None,\n                 init=True,\n+                inherited=False,\n             ),\n         ) == attr.fields(cls)\n \n@@ -199,6 +201,7 @@ def test_programmatic(self, slots, frozen):\n                 order=True,\n                 hash=None,\n                 init=True,\n+                inherited=False,\n             ),\n             Attribute(\n                 name=\"b\",\n@@ -210,6 +213,7 @@ def test_programmatic(self, slots, frozen):\n                 order=True,\n                 hash=None,\n                 init=True,\n+                inherited=False,\n             ),\n         ) == attr.fields(PC)\n \ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -167,7 +167,7 @@ def test_no_modifications(self):\n         Does not attach __attrs_attrs__ to the class.\n         \"\"\"\n         C = make_tc()\n-        _transform_attrs(C, None, False, False)\n+        _transform_attrs(C, None, False, False, True)\n \n         assert None is getattr(C, \"__attrs_attrs__\", None)\n \n@@ -176,7 +176,7 @@ def test_normal(self):\n         Transforms every `_CountingAttr` and leaves others (a) be.\n         \"\"\"\n         C = make_tc()\n-        attrs, _, _ = _transform_attrs(C, None, False, False)\n+        attrs, _, _ = _transform_attrs(C, None, False, False, True)\n \n         assert [\"z\", \"y\", \"x\"] == [a.name for a in attrs]\n \n@@ -190,7 +190,7 @@ class C(object):\n             pass\n \n         assert _Attributes(((), [], {})) == _transform_attrs(\n-            C, None, False, False\n+            C, None, False, False, True\n         )\n \n     def test_transforms_to_attribute(self):\n@@ -198,7 +198,7 @@ def test_transforms_to_attribute(self):\n         All `_CountingAttr`s are transformed into `Attribute`s.\n         \"\"\"\n         C = make_tc()\n-        attrs, base_attrs, _ = _transform_attrs(C, None, False, False)\n+        attrs, base_attrs, _ = _transform_attrs(C, None, False, False, True)\n \n         assert [] == base_attrs\n         assert 3 == len(attrs)\n@@ -215,14 +215,14 @@ class C(object):\n             y = attr.ib()\n \n         with pytest.raises(ValueError) as e:\n-            _transform_attrs(C, None, False, False)\n+            _transform_attrs(C, None, False, False, True)\n         assert (\n             \"No mandatory attributes allowed after an attribute with a \"\n             \"default value or factory.  Attribute in question: Attribute\"\n             \"(name='y', default=NOTHING, validator=None, repr=True, \"\n             \"eq=True, order=True, hash=None, init=True, \"\n             \"metadata=mappingproxy({}), type=None, converter=None, \"\n-            \"kw_only=False)\",\n+            \"kw_only=False, inherited=False)\",\n         ) == e.value.args\n \n     def test_kw_only(self):\n@@ -245,7 +245,7 @@ class C(B):\n             x = attr.ib(default=None)\n             y = attr.ib()\n \n-        attrs, base_attrs, _ = _transform_attrs(C, None, False, True)\n+        attrs, base_attrs, _ = _transform_attrs(C, None, False, True, True)\n \n         assert len(attrs) == 3\n         assert len(base_attrs) == 1\n@@ -268,7 +268,7 @@ class C(Base):\n             y = attr.ib()\n \n         attrs, base_attrs, _ = _transform_attrs(\n-            C, {\"x\": attr.ib()}, False, False\n+            C, {\"x\": attr.ib()}, False, False, True\n         )\n \n         assert [] == base_attrs\n@@ -300,9 +300,9 @@ class C(object):\n \n         assert \"C(a=1, b=2)\" == repr(C())\n \n-    def test_multiple_inheritance(self):\n+    def test_multiple_inheritance_old(self):\n         \"\"\"\n-        Order of attributes doesn't get mixed up by multiple inheritance.\n+        Old multiple inheritance attributre collection behavior is retained.\n \n         See #285\n         \"\"\"\n@@ -337,6 +337,92 @@ class E(C, D):\n             \"d2='d2', e1='e1', e2='e2')\"\n         ) == repr(E())\n \n+    def test_overwrite_proper_mro(self):\n+        \"\"\"\n+        The proper MRO path works single overwrites too.\n+        \"\"\"\n+\n+        @attr.s(collect_by_mro=True)\n+        class C(object):\n+            x = attr.ib(default=1)\n+\n+        @attr.s(collect_by_mro=True)\n+        class D(C):\n+            x = attr.ib(default=2)\n+\n+        assert \"D(x=2)\" == repr(D())\n+\n+    def test_multiple_inheritance_proper_mro(self):\n+        \"\"\"\n+        Attributes are collected according to the MRO.\n+\n+        See #428\n+        \"\"\"\n+\n+        @attr.s\n+        class A(object):\n+            a1 = attr.ib(default=\"a1\")\n+            a2 = attr.ib(default=\"a2\")\n+\n+        @attr.s\n+        class B(A):\n+            b1 = attr.ib(default=\"b1\")\n+            b2 = attr.ib(default=\"b2\")\n+\n+        @attr.s\n+        class C(B, A):\n+            c1 = attr.ib(default=\"c1\")\n+            c2 = attr.ib(default=\"c2\")\n+\n+        @attr.s\n+        class D(A):\n+            d1 = attr.ib(default=\"d1\")\n+            d2 = attr.ib(default=\"d2\")\n+\n+        @attr.s(collect_by_mro=True)\n+        class E(C, D):\n+            e1 = attr.ib(default=\"e1\")\n+            e2 = attr.ib(default=\"e2\")\n+\n+        assert (\n+            \"E(a1='a1', a2='a2', d1='d1', d2='d2', b1='b1', b2='b2', c1='c1', \"\n+            \"c2='c2', e1='e1', e2='e2')\"\n+        ) == repr(E())\n+\n+    def test_mro(self):\n+        \"\"\"\n+        Attributes and methods are looked up the same way.\n+\n+        See #428\n+        \"\"\"\n+\n+        @attr.s\n+        class A(object):\n+\n+            x = attr.ib(10)\n+\n+            def xx(self):\n+                return 10\n+\n+        @attr.s\n+        class B(A):\n+            y = attr.ib(20)\n+\n+        @attr.s\n+        class C(A):\n+            x = attr.ib(50)\n+\n+            def xx(self):\n+                return 50\n+\n+        @attr.s(collect_by_mro=True)\n+        class D(B, C):\n+            pass\n+\n+        d = D()\n+\n+        assert d.x == d.xx()\n+\n \n class TestAttributes(object):\n     \"\"\"\n@@ -1339,7 +1425,7 @@ class C(object):\n             pass\n \n         b = _ClassBuilder(\n-            C, None, True, True, False, False, False, False, False\n+            C, None, True, True, False, False, False, False, False, True\n         )\n \n         assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n@@ -1353,7 +1439,7 @@ class C(object):\n             x = attr.ib()\n \n         b = _ClassBuilder(\n-            C, None, True, True, False, False, False, False, False\n+            C, None, True, True, False, False, False, False, False, True\n         )\n \n         cls = (\n@@ -1428,6 +1514,7 @@ class C(object):\n             is_exc=False,\n             kw_only=False,\n             cache_hash=False,\n+            collect_by_mro=True,\n         )\n         b._cls = {}  # no __module__; no __qualname__\n \ndiff --git a/tests/utils.py b/tests/utils.py\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -46,6 +46,7 @@ def simple_attr(\n     init=True,\n     converter=None,\n     kw_only=False,\n+    inherited=False,\n ):\n     \"\"\"\n     Return an attribute with a name and no other bells and whistles.\n@@ -60,7 +61,8 @@ def simple_attr(\n         hash=hash,\n         init=init,\n         converter=converter,\n-        kw_only=False,\n+        kw_only=kw_only,\n+        inherited=inherited,\n     )\n \n \n",
        "problem_statement": "MRO vs. inherited attributes\nThe way how attributes are collected from super classes is different comparing to how attributes and methods are searched by `getattr` (based on MRO for new-style classes).\r\n\r\nExample:\r\n```python\r\n@attr.s\r\nclass A(object):\r\n\r\n    x = attr.ib(10)\r\n\r\n    def xx(self):\r\n        return 10\r\n\r\n\r\n@attr.s\r\nclass B(A):\r\n    y = attr.ib(20)\r\n\r\n\r\n@attr.s\r\nclass C(A):\r\n    x = attr.ib(50)\r\n\r\n    def xx(self):\r\n        return 50\r\n\r\n\r\nclass D(B, C):\r\n    pass\r\n\r\n\r\nd = D()\r\nprint(d.x)  # prints 10\r\nprint(d.xx())  # prints 50\r\n```\r\n\r\nI think it would be great to the use the same approach for collecting attributes as used for searching methods and attributes. \r\n\r\nThe difference is caused by the fact that the function `_transform_attrs` in `attrs/_make.py` considers all attributes (own+inherited stored in `__attrs_attrs__`) and not only own attributes of super classes: https://github.com/python-attrs/attrs/blob/6a07b035b77ea8756408d65a36160f8670c66933/src/attr/_make.py#L367-L368\n",
        "hints_text": "Hm that\u2019s unfortunate and fixing it likely means breakage. :|\nSo this is interesting.\r\n\r\nThe underlying issue is that `attrs` always writes all methods optimized for the current class to avoid `super()` calls/traversal which means we have to simulate the `__mro__` ourselves when building the lists of attributes. FTR, dataclasses handle it the same way.\r\n\r\nAs such,  I was able to make your test case work by ignoring inherited attributes **iff** D is also decorated with `@attr.s` because _then_ attrs has the chance to intervene.\r\n\r\n---\r\n\r\nThere's another problem too: users expect the attributes to be ordered (in `__init__` parameter lists and reprs for example) in the order they are defined. E.g. if you have:\r\n\r\n```python\r\n        @attr.s\r\n        class C(object):\r\n            c = attr.ib(default=100)\r\n            x = attr.ib(default=1)\r\n            b = attr.ib(default=23)\r\n\r\n        @attr.s\r\n        class D(C):\r\n            a = attr.ib(default=42)\r\n            x = attr.ib(default=2)\r\n            d = attr.ib(default=3.14)\r\n```\r\n\r\nThe attribute order is c, b, a, x, d (N.B. that x changed position due to overwrite).\r\n\r\nIf I ignore inherited attributes and walk the mro, the order becomes a, x, d, c, b.\r\n\r\nI'm open to suggestions how to resolve this to make everyone happy but I banged my head against it for over an hour and didn't really come up with anything viable. :(\r\n\r\nI guess traversing it twice would work? Once for getting the order of the names right and then again to resolve them to the correct classes? \ud83e\udd14",
        "created_at": "2020-03-30T11:25:28Z",
        "version": "19.3"
    }
}