{
    "task_id": "python-attrs__attrs-394",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-394_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 394,
        "instance_id": "python-attrs__attrs-394",
        "issue_numbers": [
            "387"
        ],
        "base_commit": "9c414702bd26c2793386250c4442d48864e3e0b9",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -671,7 +671,7 @@ def attrs(\n     :param bool cmp: Create ``__eq__``, ``__ne__``, ``__lt__``, ``__le__``,\n         ``__gt__``, and ``__ge__`` methods that compare the class as if it were\n         a tuple of its ``attrs`` attributes.  But the attributes are *only*\n-        compared, if the type of both classes is *identical*!\n+        compared, if the types of both classes are *identical*!\n     :param hash: If ``None`` (default), the ``__hash__`` method is generated\n         according how *cmp* and *frozen* are set.\n \n@@ -747,6 +747,11 @@ def attrs(\n     .. versionchanged:: 18.1.0\n        If *these* is passed, no attributes are deleted from the class body.\n     .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.\n+    .. deprecated:: 18.2.0\n+       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a\n+       :class:`DeprecationWarning` if the classes compared are subclasses of\n+       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses\n+       to each other.\n     \"\"\"\n \n     def wrap(cls):\n@@ -885,6 +890,12 @@ def __ne__(self, other):\n     return not result\n \n \n+WARNING_CMP_ISINSTANCE = (\n+    \"Comparision of subclasses using __%s__ is deprecated and will be removed \"\n+    \"in 2019.\"\n+)\n+\n+\n def _make_cmp(attrs):\n     attrs = [a for a in attrs if a.cmp]\n \n@@ -938,6 +949,10 @@ def __lt__(self, other):\n         Automatically created by attrs.\n         \"\"\"\n         if isinstance(other, self.__class__):\n+            if other.__class__ is not self.__class__:\n+                warnings.warn(\n+                    WARNING_CMP_ISINSTANCE % (\"lt\",), DeprecationWarning\n+                )\n             return attrs_to_tuple(self) < attrs_to_tuple(other)\n         else:\n             return NotImplemented\n@@ -947,6 +962,10 @@ def __le__(self, other):\n         Automatically created by attrs.\n         \"\"\"\n         if isinstance(other, self.__class__):\n+            if other.__class__ is not self.__class__:\n+                warnings.warn(\n+                    WARNING_CMP_ISINSTANCE % (\"le\",), DeprecationWarning\n+                )\n             return attrs_to_tuple(self) <= attrs_to_tuple(other)\n         else:\n             return NotImplemented\n@@ -956,6 +975,10 @@ def __gt__(self, other):\n         Automatically created by attrs.\n         \"\"\"\n         if isinstance(other, self.__class__):\n+            if other.__class__ is not self.__class__:\n+                warnings.warn(\n+                    WARNING_CMP_ISINSTANCE % (\"gt\",), DeprecationWarning\n+                )\n             return attrs_to_tuple(self) > attrs_to_tuple(other)\n         else:\n             return NotImplemented\n@@ -965,6 +988,10 @@ def __ge__(self, other):\n         Automatically created by attrs.\n         \"\"\"\n         if isinstance(other, self.__class__):\n+            if other.__class__ is not self.__class__:\n+                warnings.warn(\n+                    WARNING_CMP_ISINSTANCE % (\"ge\",), DeprecationWarning\n+                )\n             return attrs_to_tuple(self) >= attrs_to_tuple(other)\n         else:\n             return NotImplemented\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1249,3 +1249,42 @@ class C(object):\n             )\n \n         assert C() == copy.deepcopy(C())\n+\n+\n+class TestMakeCmp:\n+    \"\"\"\n+    Tests for _make_cmp().\n+    \"\"\"\n+\n+    @pytest.mark.parametrize(\n+        \"op\", [\"__%s__\" % (op,) for op in (\"lt\", \"le\", \"gt\", \"ge\")]\n+    )\n+    def test_subclasses_deprecated(self, recwarn, op):\n+        \"\"\"\n+        Calling comparison methods on subclasses raises a deprecation warning;\n+        calling them on identical classes does not..\n+        \"\"\"\n+\n+        @attr.s\n+        class A(object):\n+            a = attr.ib()\n+\n+        @attr.s\n+        class B(A):\n+            pass\n+\n+        getattr(A(42), op)(A(42))\n+        getattr(B(42), op)(B(42))\n+\n+        assert [] == recwarn.list\n+\n+        getattr(A(42), op)(B(42))\n+\n+        w = recwarn.pop()\n+\n+        assert [] == recwarn.list\n+        assert isinstance(w.message, DeprecationWarning)\n+        assert (\n+            \"Comparision of subclasses using %s is deprecated and will be \"\n+            \"removed in 2019.\" % (op,)\n+        ) == w.message.args[0]\n",
        "problem_statement": "attrs._make should document why it is more restrictive with __eq__ than other comparisons\nThe type check in `__eq__` for generated classes is different than in other comparison methods.\r\n\r\nFor all other methods, `isinstance(other, self.__class__)` is used, which means subclasses will participate in the \"happy\" branch of the comparison.\r\n\r\nFor `__eq__` though, [`other.__class__ is self.__class__`](https://github.com/python-attrs/attrs/blob/master/src/attr/_make.py#L867) is used, so a trivial subclass will *not* compare equal, leading to the quite confusing:\r\n\r\n```\r\n>>> import attr; Parent = attr.make_class(\"Parent\", dict(foo=attr.ib())); Child = type(\"Child\", (Parent,), {}); print (Parent(foo=1) == Parent(foo=1), Parent(foo=1) == Child(foo=1), Parent(foo=1) < Parent(foo=2), Child(foo=1) < Parent(foo=2))\r\n(True, False, True, True)\r\n```\r\n\r\nThis strikes me as a bug (the incongruity), and that `__eq__` should use the same check, but even if it isn't, it likely bears mentioning that there's a difference.\r\n\r\nIt even seems like dataclasses have even done something [oddly similar](https://www.youtube.com/watch?v=T-TwcmT6Rcw#t=24m09s), maybe just straight copying the code here?\r\n\r\nhttps://github.com/python-attrs/attrs/commit/d134ce45fc98323576a19f03e39669dce615c4e1 looks like it's the commit that originally made the change (though since then `__eq__` now is hand-generated).\n",
        "hints_text": "Agreed; a reasonable developer would be surprised by the asymmetry described.\r\n\r\n(FWIW I am; though I try not to subclass, so hadn't noticed this.)\nWell yeah same, I think `attrs` should even have a `attr.s(..., allow_subclassing=True|False)` and default it to false :P, but that's a different story.\nAgree on all counts.\r\n\r\nAnd while it may be a bit off topic, I just wanted to echo a similar thought (experiment), that inheritance might be somewhat redeemed in a world where most types aren't open to extension by default. Not sure how deep attrs wants to dip into metaclasses.\nI suggest we start with some understanding about why this difference exists at all; without that, it's not obvious to me that it's even intentional.  (Though I want to assume that it is.)\nWell yeah, this one even made it to LWN: https://lwn.net/Articles/740153/\r\n\r\nThe question is in what direction we want to go. I find it hard to come to terms that two objects can be equal if they have different types. So my gut feeling would be to add a warning if someone compares instances that have different types and remove it in a year.\r\n\r\nBonus points for an option to allow to configure the behavior for both?\n> Well yeah, this one even made it to LWN: https://lwn.net/Articles/740153/\r\n\r\nFun :)\r\n\r\n> So my gut feeling would be to add a warning if someone compares instances that have different types and remove it in a year.\r\n\r\n+1\r\n\r\n> Bonus points for an option to allow to configure the behavior for both?\r\n\r\nIf I steal my own idea about `repr`, one could support this by having `attr.s(cmp=lambda self, other: isinstance(other, self.__class__))` (vs `cmp=lambda self, other: self.__class__ is other.__class__`, or `lambda self, other: False` / `True`), though I'm not inventive enough at the minute to think of any reason someone would want something other than those four options.\n@hynek I think I'm hearing that the existing difference is, in fact, accidental?  Anyway, I like the idea of warning/deprecating the `isinstance` behavior in the default comparators.\r\n\r\nI like the @Julian's idea of `cmp` accepting a callable, and have be thinking about that for a while\u2026 but  I'd like to consider other uses than the type precondition.  For example, I'd like to be able to change the compared data from the default of calling `attrs_to_tuple` on each object.  In my case I've wanted to change the order of the attributes, or have one of them sorted the other direction than the default (\"descending\"), and right now I have to implement my own comparators in order to do that.  More generally, one might want `cmp` to accept a callable like  Python 2's [`__cmp__`](https://docs.python.org/2/reference/datamodel.html?highlight=__cmp__#object.__cmp__) operator function\u2026\nIf you want to swap out the whole implementation wouldn't you just use `cmp=False`?\nWell, it's a lot more\u2026 boilerplate to implement all of the `__foo__` methods than it is to provide an alternative to `attrs_to_tuple`.\r\n\r\nProbably I should fess up and show an example.  I [did this as a mix-in](https://github.com/burningmantech/ranger-ims-server/blob/master/src/ims/model/_cmp.py#L31) such that all I need to do in classes that inherit from the mix-in is implement `_cmpValue`.  [Here's a simple example](https://github.com/burningmantech/ranger-ims-server/blob/master/src/ims/model/_address.py#L105) in which all I do is change the order of the compared values because I want `description` to be factored in last.  [Here's another](https://github.com/burningmantech/ranger-ims-server/blob/master/src/ims/model/_entry.py#L62) when I just invert one of the values.  This is a lot easier than implementing all of the dunders in each class.\r\n\r\nSorry if this is a tangent; it probably should be a separate ticket, but it effects this if we want to overload `cmp`, so just trying to get ahead of that.\r\n\nI'm not quite sure which way this thread is leaning at this point.  `is` or `isinstance()`?  If configurable, then which default?\n@wsanchez ah I see, well, I guess if we're dragging tangents into things I am pretty strongly against the way the current implementation combines equality with ordering, which is at least partially relevant for what you're doing there. Possibly yet a third ticket (or maybe it exists already I forget) though.\n@altendky My read of @hynek's comment is that we'd prefer `is` as the default, we should deprecate the current use of `isinstance`, and configurability is a bonus.  (And I agree with all that.)\n@Julian yeah, I agree that combining the two is problematic.  Th reason I think it's relevant here is that I suspect any configuration option we pick here (if we do) could make fixing that problem harder.\nI guess I don't follow how `is` would be expected behavior when inheriting.  I get tending away from inheritance (more or less strongly) but trivially inheriting a class shouldn't make it not equal, should it?  Wouldn't LSP encourage `isinstance()`?  I'm split between thinking I'm missing something and thinking that a dislike of inheritance is going to result in breaking it for those that use it.\r\n\r\nNote: I don't think I've inherited from an attrs class yet so I'm not arguing because of any direct effect I expect it to have on me.\n@altendky It's a fair point, because it's really non-obvious and I don't know of a settled best practice here, but the `is` check is simply being conservative, because the parent class' implementation of, say `__eq__` can't be sure that a subclass is equal any more than it can of a rando object.\r\n\r\nIf the subclass adds a field (certainly not uncommon), that field\u2026 wait\u2026 yes?\u2026 that field is not factored into the equality test.  (I hesitate because I'm looking at [`attrs_to_tuple`](https://github.com/python-attrs/attrs/blob/master/src/attr/_make.py#L902) and it's a closure that uses the same `attrs` for both `self` and `other`, but I'm not super familiar with that code.)\r\n\r\nThe thing is that the default implementation provided by `attrs` doesn't know what a subclass considers equal, so returning `NotImplemented` is just saying \"I dunno\".\r\n\r\nIt would be nice if one could explicitly declare a subclass as considering its instances equal to those of the parent class with equal field values, but I'm a little wary of an implementation that assumes this is true.\nI need to get a better understanding of LSP.  It seems to be part of 'proper' inheritance, but it also seems to hog tie subclasses.\nRandom thought: isinstance also means that if you compare a and b and b is a subclass of a, you get different results for a == b and b == a. \nNot sure now I'm following the last few comments --\r\n\r\nthe two options though would have to be `is`, or `isinstance` *plus* a field length check, because a subclass that adds fields seems pretty clearly like it shouldn't be `==` according to anyone, so you can't use *just* `isinstance`.\r\n\r\nBut in the latter case (`isinstance` + field length check) you get associativity and transitivity, so not sure I follow there, maybe I'm missing something.\r\n\r\nAnd if I didn't mention it earlier, yeah personally I'd lean towards that one, but since I am in the \"don't use inheritance\" camp I wouldn't argue heavily for it :P\nI guess comparisons are a well known exception to LSP?  Or LSP is just considered not relevant anymore?\r\n\r\nI still need to study it...\nNo your argument is good IMHO :)\nThen even `isinstance(other, type(self))` is too restrictive because a trivial child will reject a parent with matching attribute values.  Unless LSP is only about full substitution of all instances to the sun type and not about mixing parent and child instances.  I'd think this would agree with both other languages where a parent comparison method wouldn't even be aware of any new attributes on a child class as well as aligning with duck typing in Python.\n> Then even isinstance(other, type(self)) is too restrictive because a trivial child will reject a parent with matching attribute values.\r\n\r\nThis is what I meant in https://github.com/python-attrs/attrs/issues/387#issuecomment-395295204 btw. I guess we\u2019d have to check both ways and that is kind of getting silly.\r\n\r\nThe more I think about it, the more I\u2019m convinced we should go the `is` route and only add more options if there\u2019s enough people complaining.\nWhat about using `super()`?  If that passes and `isinstance(other, type(self))` then extra attributes of the subclass are compared.  I think that would pass.  I think that to satisfy LSP that any attributes added in a subclass would have to have defaults.\nThat won't work when the parent is on the left of the comparison -- it would call super, and not return `NotImplemented`, and then proceed to only compare to a subset of the subclass's fields.\r\n\r\nThough again I must not be following because this is the one option that I think *shouldn't* be on the table -- the only reasonable option that uses `isinstance` is returning `NotImplemented` for `not isinstance(other, self.__class__) or attr.fields(self) != attr.fields(other)`, just using the first part of the conditional there I think definitely produces nonsense for subclasses that add extra fields.\n@Julian I'll try an example and see what I see.  It does seem odd though that we are talking about inheritance and the one thing to not consider using is `super()`.\nFor what it's worth, there's also:\r\n\r\n```python\r\n@attr.s\r\nclass Rectangle(object):\r\n    width: float\r\n    height: float\r\n\r\n    def area(self) \u279c float:\r\n        return self.width * self.height\r\n\r\n@attr.s\r\nclass RedRectangle(object):\r\n    pass\r\n\r\n@attr.s\r\nclass BlueRectangle(object):\r\n    pass\r\n```\r\n\r\nIn which case, one might `assert RedRectangle(1,2) != BlueRectangle(1,2)` and perhaps even `assert RedRectangle(1,2) != Rectangle(1,2)`.  This is obviously contrived, but I don't think one can really just assume that subclasses with the same fields are equal.\r\n\r\nAlso: I see the auto-correct typo above, but Python really should accept `\u279c` as equivalent to `->`.\nJust my two cents here.\r\n\r\nThe most accurate definition of LSP I've ever found is this one:\r\n\r\n> Objects of subtypes should behave like those of supertypes if used via supertype methods.\r\n\r\nFor me it is essentially *the same* than duck typing. And the important point here is the \"if used via supertype methods\" part.\r\n\r\nThis has nothing to do with which fields do the subtypes have. So taking into account the _fields_ in the comparison would go in the wrong direction in respect to LSP... but, does this really have to do with LSP at all? I don't think so, but I'm also not so sure as to make an statement. \r\n\r\nWhat I'm sure of (and I hope anyone seriously following this thread) is that **Identity** is not a simple problem, but a really complex one because it involves what **you** mean by **Identity**. It depends on what you give \"relevance\" to and what you \"filter out\" of the comparison.\r\n\r\nSo what to do in cases like this one? When in doubt, I tend to apply the Fail-soon principle: implement by default the most restrictive code, the one that will throw an error sooner than others (in this case, the `is` comparison) so one will hit the problem the first time \"**it just doesn't work as I thought it worked**\". \r\n\r\nAnd then let me implement a different comparison method by my own when I have a more clear idea of what _equal_ means **for me** (which is already possible with `attrs`). In case of using inheritance, you will have to do this just once at the base class, so it is not a big deal anyway.\r\n\n@xgid I think I agree with almost all of that -- the only issue here is that there is no \"failure\" here -- Python doesn't throw errors when things don't implement equality, it coerces to a value no matter what.\r\n\r\nSo you do need to carefully pick the better of the two options.\nEhm. *Your* EOL Python maybe. \ud83d\ude43\r\n\r\n*Edit* oh wait you wrote equality...well that one is already strict so that can\u2019t be changed anyways. \n@hynek your shiny one too.\r\n\r\n```\r\n\u2299  python3 -c '                                                                                                                                                                                                                                                                                                                                           Julian@Macnetic \u25cf\r\nquote> class Foo(object):\r\nquote>     def __eq__(self, other):\r\nquote>         return NotImplemented\r\nquote> print(Foo() == Foo())'\r\nFalse\r\n```\r\n\r\nThe only thing it fixed there was the comparison operators I believe. Equality ones still always coerce.\n@Julian Sorry, I was not explicit enough regarding the `__eq__` implementation I'm proposing. \r\n\r\nI mean just:\r\n\r\n```python\r\ndef __eq__(self, other):\r\n    return  id(self) == id(other)\r\n```\r\n\r\nWhen I said \"_the one that will throw an error sooner than others_\" I was not meaning to return `NotImplemented` nor an exception. Just that the more restrictive implementation shown above will give you a comparison error in your code whenever you expect that something \"equivalent\"(1) to this will work:\r\n\r\n```python\r\nassert Foo(1,2) == Foo(1,2)\r\n```\r\ninstead of succeeding. \r\n\r\nIf it succeeds, you may not find the (logical) \"bug\" in your code until much much later. It's a kind of \"defensive programming\", but just for those \"corner cases where things may get dangerous if you are not aware of the real implications\", like this one.\r\n\r\n(1) By \"equivalent\" above I mean that this may be a _simple_ `if a == b` in your code for which you expect that the comparison will be successful.\r\n\r\n**Edit**: Just now I see that I made a mess talking about \"the `is` comparison\" at my first comment. Don't know what I was thinking about... \ud83d\ude33 \n@xgid That's just the `object` provided `==` isn't it?  So suggesting that is basically suggesting not implementing `__eq__` at all from an attrs perspective?\r\n\r\nAfter chatting with @Julian and reading around a bit more I think I see what I was missing.  It seems that the basic issue is a contention between satisfying both mathematical properties and Liskov.  The desire to use `==` as a way to access the equality check which should satisfy mathematical constraints brings in the inheritance factor and therefor Liskov.  So, don't use `__eq__`...  :]  My guess is that isn't an option we are looking to consider here but this does make me feel that any solution is going to be a compromise of some principal.  I haven't analyzed the situation carefully but `OrderedDict` is a 'classic' example of this issue and a solution that is tending towards the Liskov side over the math side of correctness.\r\n\r\nThere were suggestions that the reason for `is` type checking making sense is that equality is a type of equivalence relation and that they are defined on members of a set.  An `__eq__` method on a class that can be inherited may be applied to things that we can't include in the set we are considering when writing the `__eq__` because the subclasses haven't even been written yet.  At least by considering only the same type for a `True` result you have restricted the set of things that might be equal.  A bit of a helpful explanation for me at least.\r\n\r\nPerhaps there are some options here.  Default to no `__eq__` method (IOW `id()` checking from `object` iirc) and force people to...  implement their own?  pick between a pre-existing set of options that satisfy either math or Liskov?  It encourages them to check the docs and get a brief explanation of the dilemma and at least they have made the decision.\r\n\r\nI'm really not sure what I think should happen anymore but I at least better understand the issue with where I was going.  FWIW, I made a little implementation and set of tests while exploring my approach.\r\n\r\nhttps://repl.it/@altendky/LSP-and-eq-1\r\n\n@altendky \r\n\r\n> That's just the object provided == isn't it? So suggesting that is basically suggesting not implementing __eq__ at all from an attrs perspective?\r\n\r\nExactly! And for the exact same reasons you have explained better than me in your comment. The final goal is precisely that \"_It encourages them to check the docs and get a brief explanation of the dilemma_\" before they choose anything \"meaninful\" for them.\r\n\r\nIf I can also easily \"pick between a pre-existing set of options\", that would be even better, of course! I was talking only about the **default implementation**.\r\n\n> @xgid That's just the object provided == isn't it? So suggesting that is basically suggesting not implementing __eq__ at all from an attrs perspective?\r\n\r\nReturning `NotImplemented` allows the other object implement a comparator, so explicitly implementing an identity test in a class defeats the design of how Python implements these operators, no?\n@wsanchez I'm not sure what your comment means in regards to that quote.  That if someone were considering not implementing `__eq__` that they should instead implement it and `return NotImplemented`?  By 'object provided ==' I was referring to the `__eq__` provided by the type `object` that we all inherit from.\nWhat I mean is that the way `__eq__` works is that if you don't want to implement it, then don't add the method, or return `NotImplemented` when you don't know.  If you implement it as simply `return  id(self) == id(other)` (which is, I think, more simply written as `self is other`) then you are forcing an identity test to be used, instead of allowing such a test to be a fallback in the absence of, say, the other object implementing a comparator.\nAh, implementing `__eq__` as `self is other` is not the same as leaving it to `object`'s implementation because of other getting a chance in the latter case.  I see the connection.\nJFTR I\u2019ve just noticed that the docs were always very clear on this matter: `But the attributes are only compared, if the type of both classes is identical!`\r\n\r\nSo technically we could even get away without a deprecation period but let\u2019s do it anyways.",
        "created_at": "2018-06-16T05:59:11Z",
        "version": "18.1"
    }
}