{
    "task_id": "python-attrs__attrs-181",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-181_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 181,
        "instance_id": "python-attrs__attrs-181",
        "issue_numbers": [
            "165"
        ],
        "base_commit": "a328e671690be4e6342d50056d121506b64da9d3",
        "patch": "diff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -48,9 +48,9 @@ def instance_of(type):\n     :param type: The type to check for.\n     :type type: type or tuple of types\n \n-    The :exc:`TypeError` is raised with a human readable error message, the\n-    attribute (of type :class:`attr.Attribute`), the expected type, and the\n-    value it got.\n+    :raises TypeError: With a human readable error message, the attribute\n+        (of type :class:`attr.Attribute`), the expected type, and the value it\n+        got.\n     \"\"\"\n     return _InstanceOfValidator(type)\n \n@@ -87,9 +87,9 @@ def provides(interface):\n \n     :param zope.interface.Interface interface: The interface to check for.\n \n-    The :exc:`TypeError` is raised with a human readable error message, the\n-    attribute (of type :class:`attr.Attribute`), the expected interface, and\n-    the value it got.\n+    :raises TypeError: With a human readable error message, the attribute\n+        (of type :class:`attr.Attribute`), the expected interface, and the\n+        value it got.\n     \"\"\"\n     return _ProvidesValidator(interface)\n \n@@ -127,3 +127,39 @@ def optional(validator):\n     if isinstance(validator, list):\n         return _OptionalValidator(_AndValidator(validator))\n     return _OptionalValidator(validator)\n+\n+\n+@attributes(repr=False, slots=True)\n+class _InValidator(object):\n+    options = attr()\n+\n+    def __call__(self, inst, attr, value):\n+        if value not in self.options:\n+            raise ValueError(\n+                \"'{name}' must be in {options!r} (got {value!r})\"\n+                .format(name=attr.name, options=self.options, value=value)\n+            )\n+\n+    def __repr__(self):\n+        return (\n+            \"<in_ validator with options {options!r}>\"\n+            .format(options=self.options)\n+        )\n+\n+\n+def in_(options):\n+    \"\"\"\n+    A validator that raises a :exc:`ValueError` if the initializer is called\n+    with a value that does not belong in the options provided.  The check is\n+    performed using ``value in options``.\n+\n+    :param options: Allowed options.\n+    :type options: list, tuple, :class:`enum.Enum`, ...\n+\n+    :raises ValueError: With a human readable error message, the attribute (of\n+       type :class:`attr.Attribute`), the expected options, and the value it\n+       got.\n+\n+    .. versionadded:: 17.1.0\n+    \"\"\"\n+    return _InValidator(options)\n",
        "test_patch": "diff --git a/tests/test_validators.py b/tests/test_validators.py\n--- a/tests/test_validators.py\n+++ b/tests/test_validators.py\n@@ -7,7 +7,7 @@\n import pytest\n import zope.interface\n \n-from attr.validators import and_, instance_of, provides, optional\n+from attr.validators import and_, instance_of, provides, optional, in_\n from attr._compat import TYPE\n from attr._make import attributes, attr\n \n@@ -214,3 +214,37 @@ def test_repr(self, validator):\n                  \"<{type} 'int'>> or None>\")\n                 .format(type=TYPE)\n             ) == repr(v)\n+\n+\n+class TestIn_(object):\n+    \"\"\"\n+    Tests for `in_`.\n+    \"\"\"\n+    def test_success_with_value(self):\n+        \"\"\"\n+        If the value is in our options, nothing happens.\n+        \"\"\"\n+        v = in_([1, 2, 3])\n+        a = simple_attr(\"test\")\n+        v(1, a, 3)\n+\n+    def test_fail(self):\n+        \"\"\"\n+        Raise ValueError if the value is outside our options.\n+        \"\"\"\n+        v = in_([1, 2, 3])\n+        a = simple_attr(\"test\")\n+        with pytest.raises(ValueError) as e:\n+            v(None, a, None)\n+        assert (\n+            \"'test' must be in [1, 2, 3] (got None)\",\n+        ) == e.value.args\n+\n+    def test_repr(self):\n+        \"\"\"\n+        Returned validator has a useful `__repr__`.\n+        \"\"\"\n+        v = in_([3, 4, 5])\n+        assert(\n+            (\"<in_ validator with options [3, 4, 5]>\")\n+        ) == repr(v)\n",
        "problem_statement": "attr default based on other attributes\nHi!\r\n\r\nI have unsucessfully tried to define a default value by referencing other attributes. I'm sure the code below doesnt' work for some obvious or fundamental reason, but I would be grateful for comments on how to do something like it:\r\n\r\n```python\r\nimport attr\r\nfrom attr.validators import instance_of\r\nimport datetime\r\n\r\n@attr.s\r\nclass Something:\r\n    some_date = attr.ib(validator=instance_of(datetime.date))\r\n    some_number = attr.ib(convert=float)\r\n    name = attr.ib(validator=instance_of(str),\r\n                   default=\"Generic Name {0} - {1}%\".format(\r\n                       some_date.strftime(\"%d-%b-%Y\"),\r\n                       some_number * 100)\r\n                   )\r\n\r\ns = Something(some_date=datetime.date.today(), some_number=0.375)\r\n```\r\n\r\nI included the `.strftime()` conversion to highlight that `name` doesn't see a float and a date, but a `_CountingAttr` object, hence I get an AttributeError (and a TypeError for `some_number * 100`). Since I can't reference self either, what would be the correct way to do this?\n",
        "hints_text": "Hi,\r\n\r\nfor now I suggest using `__attrs_post_init__` (http://attrs.readthedocs.io/en/stable/examples.html?highlight=attrs_post_init#other-goodies). The linked example is basically what you want.\nI have wanted to do this several times. For example, you have a test of a function which takes many inputs. You want to test this function with many different cases. So (of course) you create a quick e.g. `@attr.s class TestInput:...` for that. In many cases you want some attribute to have a default depending on other attributes, but still be able to override it. The existing options are not so good for this:\r\n\r\n- I think you can use `these` for this but it's cumbersome.\r\n- `__attrs_post_init__` is not good because you can't override it.\r\n\r\nWhat I'd want, following the ad-hoc validators example, is something like this:\r\n\r\n```\r\n@attr.s\r\nclass C:\r\n    x = attr.ib()\r\n    y = attr.ib()\r\n    z = attr.ib()\r\n\r\n    @z.default\r\n    def z_default(self, attribute):\r\n        return self.x + self.y\r\n```\r\n\r\nThis is sensitive to the initialization order. However, if you have a stateful factory, the order is already important, so this is not new. And the natural order is the definition order which is intuitive.\r\n\r\nAnother issue is that this makes it possible to specify multiple defaults. I would just raise an error if this is detected.\r\n\r\nFinal issue I can think of is that an occasional user might confuse this with a property, while it does not behave like a property:\r\n\r\n- The value is persisted.\r\n- In mutable objects, the value doesn't change if the dependencies change, unlike a dynamically-computed property.\r\n\r\nBut I think \"default\" is clear on the behavior it has.\nAt first glance I like the proposed API :)\nI guess we could have a lot fun with decorators based on `_CountingAttr`.\nI *think* I want this in 17.1 but it entirely depends on the goodwill of reviewers (most likely @Tinche \u2013 I *gotta* shanghai some innocent souls at PyCon).",
        "created_at": "2017-05-01T17:45:41Z",
        "version": "16.3"
    }
}