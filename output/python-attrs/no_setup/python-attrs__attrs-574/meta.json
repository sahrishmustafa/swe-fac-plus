{
    "task_id": "python-attrs__attrs-574",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-574_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 574,
        "instance_id": "python-attrs__attrs-574",
        "issue_numbers": [
            "170"
        ],
        "base_commit": "6e7b9f2cfaeb95936edea53c5f5f67800aaa20ee",
        "patch": "diff --git a/conftest.py b/conftest.py\n--- a/conftest.py\n+++ b/conftest.py\n@@ -2,8 +2,6 @@\n \n import sys\n \n-import pytest\n-\n from hypothesis import HealthCheck, settings\n \n \n@@ -15,21 +13,6 @@ def pytest_configure(config):\n     settings.load_profile(\"patience\")\n \n \n-@pytest.fixture(scope=\"session\")\n-def C():\n-    \"\"\"\n-    Return a simple but fully featured attrs class with an x and a y attribute.\n-    \"\"\"\n-    import attr\n-\n-    @attr.s\n-    class C(object):\n-        x = attr.ib()\n-        y = attr.ib()\n-\n-    return C\n-\n-\n collect_ignore = []\n if sys.version_info[:2] < (3, 6):\n     collect_ignore.extend(\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -5,6 +5,7 @@\n import sys\n import threading\n import uuid\n+import warnings\n \n from operator import itemgetter\n \n@@ -73,7 +74,7 @@ def attrib(\n     default=NOTHING,\n     validator=None,\n     repr=True,\n-    cmp=True,\n+    cmp=None,\n     hash=None,\n     init=True,\n     metadata=None,\n@@ -81,6 +82,8 @@ def attrib(\n     converter=None,\n     factory=None,\n     kw_only=False,\n+    eq=None,\n+    order=None,\n ):\n     \"\"\"\n     Create a new attribute on a class.\n@@ -135,10 +138,15 @@ def attrib(\n         as-is, i.e. it will be used directly *instead* of calling ``repr()``\n         (the default).\n     :type repr: a ``bool`` or a ``callable`` to use a custom function.\n-    :param bool cmp: Include this attribute in the generated comparison methods\n-        (``__eq__`` et al).\n+    :param bool eq: If ``True`` (default), include this attribute in the\n+        generated ``__eq__`` and ``__ne__`` methods that check two instances\n+        for equality.\n+    :param bool order: If ``True`` (default), include this attributes in the\n+        generated ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods.\n+    :param bool cmp: Setting to ``True`` is equivalent to setting ``eq=True,\n+        order=True``. Deprecated in favor of *eq* and *order*.\n     :param hash: Include this attribute in the generated ``__hash__``\n-        method.  If ``None`` (default), mirror *cmp*'s value.  This is the\n+        method.  If ``None`` (default), mirror *eq*'s value.  This is the\n         correct behavior according the Python spec.  Setting this value to\n         anything else than ``None`` is *discouraged*.\n     :type hash: ``bool`` or ``None``\n@@ -171,7 +179,7 @@ def attrib(\n     .. versionadded:: 16.3.0 *metadata*\n     .. versionchanged:: 17.1.0 *validator* can be a ``list`` now.\n     .. versionchanged:: 17.1.0\n-       *hash* is ``None`` and therefore mirrors *cmp* by default.\n+       *hash* is ``None`` and therefore mirrors *eq* by default.\n     .. versionadded:: 17.3.0 *type*\n     .. deprecated:: 17.4.0 *convert*\n     .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated\n@@ -181,7 +189,11 @@ def attrib(\n     .. versionadded:: 18.2.0 *kw_only*\n     .. versionchanged:: 19.2.0 *convert* keyword argument removed\n     .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.\n+    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n+    .. versionadded:: 19.2.0 *eq* and *order*\n     \"\"\"\n+    eq, order = _determine_eq_order(cmp, eq, order)\n+\n     if hash is not None and hash is not True and hash is not False:\n         raise TypeError(\n             \"Invalid value for hash.  Must be True, False, or None.\"\n@@ -204,13 +216,15 @@ def attrib(\n         default=default,\n         validator=validator,\n         repr=repr,\n-        cmp=cmp,\n+        cmp=None,\n         hash=hash,\n         init=init,\n         converter=converter,\n         metadata=metadata,\n         type=type,\n         kw_only=kw_only,\n+        eq=eq,\n+        order=order,\n     )\n \n \n@@ -678,14 +692,22 @@ def add_init(self):\n \n         return self\n \n-    def add_cmp(self):\n+    def add_eq(self):\n         cd = self._cls_dict\n \n-        cd[\"__eq__\"], cd[\"__ne__\"], cd[\"__lt__\"], cd[\"__le__\"], cd[\n-            \"__gt__\"\n-        ], cd[\"__ge__\"] = (\n+        cd[\"__eq__\"], cd[\"__ne__\"] = (\n             self._add_method_dunders(meth)\n-            for meth in _make_cmp(self._cls, self._attrs)\n+            for meth in _make_eq(self._cls, self._attrs)\n+        )\n+\n+        return self\n+\n+    def add_order(self):\n+        cd = self._cls_dict\n+\n+        cd[\"__lt__\"], cd[\"__le__\"], cd[\"__gt__\"], cd[\"__ge__\"] = (\n+            self._add_method_dunders(meth)\n+            for meth in _make_order(self._cls, self._attrs)\n         )\n \n         return self\n@@ -709,12 +731,45 @@ def _add_method_dunders(self, method):\n         return method\n \n \n+_CMP_DEPRECATION = (\n+    \"The usage of `cmp` is deprecated and will be removed on or after \"\n+    \"2021-06-01.  Please use `eq` and `order` instead.\"\n+)\n+\n+\n+def _determine_eq_order(cmp, eq, order):\n+    \"\"\"\n+    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective\n+    values of eq and order.\n+    \"\"\"\n+    if cmp is not None and any((eq is not None, order is not None)):\n+        raise ValueError(\"Don't mix `cmp` with `eq' and `order`.\")\n+\n+    # cmp takes precedence due to bw-compatibility.\n+    if cmp is not None:\n+        warnings.warn(_CMP_DEPRECATION, DeprecationWarning, stacklevel=3)\n+\n+        return cmp, cmp\n+\n+    # If left None, equality is on and ordering mirrors equality.\n+    if eq is None:\n+        eq = True\n+\n+    if order is None:\n+        order = eq\n+\n+    if eq is False and order is True:\n+        raise ValueError(\"`order` can only be True if `eq` is True too.\")\n+\n+    return eq, order\n+\n+\n def attrs(\n     maybe_cls=None,\n     these=None,\n     repr_ns=None,\n     repr=True,\n-    cmp=True,\n+    cmp=None,\n     hash=None,\n     init=True,\n     slots=False,\n@@ -725,6 +780,8 @@ def attrs(\n     kw_only=False,\n     cache_hash=False,\n     auto_exc=False,\n+    eq=None,\n+    order=None,\n ):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -754,17 +811,28 @@ def attrs(\n     :param bool str: Create a ``__str__`` method that is identical to\n         ``__repr__``.  This is usually not necessary except for\n         `Exception`\\ s.\n-    :param bool cmp: Create ``__eq__``, ``__ne__``, ``__lt__``, ``__le__``,\n-        ``__gt__``, and ``__ge__`` methods that compare the class as if it were\n-        a tuple of its ``attrs`` attributes.  But the attributes are *only*\n-        compared, if the types of both classes are *identical*!\n+    :param bool eq: If ``True`` or ``None`` (default), add ``__eq__`` and\n+        ``__ne__`` methods that check two instances for equality.\n+\n+        They compare the instances as if they were tuples of their ``attrs``\n+        attributes, but only iff the types of both classes are *identical*!\n+    :type eq: `bool` or `None`\n+    :param bool order: If ``True``, add ``__lt__``, ``__le__``, ``__gt__``,\n+        and ``__ge__`` methods that behave like *eq* above and allow instances\n+        to be ordered. If ``None`` (default) mirror value of *eq*.\n+    :type order: `bool` or `None`\n+    :param cmp: Setting to ``True`` is equivalent to setting ``eq=True,\n+        order=True``. Deprecated in favor of *eq* and *order*, has precedence\n+        over them for backward-compatibility though. Must not be mixed with\n+        *eq* or *order*.\n+    :type cmp: `bool` or `None`\n     :param hash: If ``None`` (default), the ``__hash__`` method is generated\n-        according how *cmp* and *frozen* are set.\n+        according how *eq* and *frozen* are set.\n \n         1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n-        2. If *cmp* is True and *frozen* is False, ``__hash__`` will be set to\n+        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n            None, marking it unhashable (which it is).\n-        3. If *cmp* is False, ``__hash__`` will be left untouched meaning the\n+        3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n            ``__hash__`` method of the base class will be used (if base class is\n            ``object``, this means it will fall back to id-based hashing.).\n \n@@ -838,10 +906,10 @@ def attrs(\n         following happens to behave like a well-behaved Python exceptions\n         class:\n \n-        - the values for *cmp* and *hash* are ignored and the instances compare\n-          and hash by the instance's ids (N.B. ``attrs`` will *not* remove\n-          existing implementations of ``__hash__`` or the equality methods. It\n-          just won't add own ones.),\n+        - the values for *eq*, *order*, and *hash* are ignored and the\n+          instances compare and hash by the instance's ids (N.B. ``attrs`` will\n+          *not* remove existing implementations of ``__hash__`` or the equality\n+          methods. It just won't add own ones.),\n         - all attributes that are either passed into ``__init__`` or have a\n           default value are additionally available as a tuple in the ``args``\n           attribute,\n@@ -869,7 +937,10 @@ def attrs(\n     .. versionadded:: 18.2.0 *kw_only*\n     .. versionadded:: 18.2.0 *cache_hash*\n     .. versionadded:: 19.1.0 *auto_exc*\n+    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n+    .. versionadded:: 19.2.0 *eq* and *order*\n     \"\"\"\n+    eq, order = _determine_eq_order(cmp, eq, order)\n \n     def wrap(cls):\n \n@@ -894,15 +965,17 @@ def wrap(cls):\n             builder.add_repr(repr_ns)\n         if str is True:\n             builder.add_str()\n-        if cmp is True and not is_exc:\n-            builder.add_cmp()\n+        if eq is True and not is_exc:\n+            builder.add_eq()\n+        if order is True and not is_exc:\n+            builder.add_order()\n \n         if hash is not True and hash is not False and hash is not None:\n             # Can't use `hash in` because 1 == True for example.\n             raise TypeError(\n                 \"Invalid value for hash.  Must be True, False, or None.\"\n             )\n-        elif hash is False or (hash is None and cmp is False) or is_exc:\n+        elif hash is False or (hash is None and eq is False) or is_exc:\n             # Don't do anything. Should fall back to __object__'s __hash__\n             # which is by id.\n             if cache_hash:\n@@ -911,7 +984,7 @@ def wrap(cls):\n                     \" hashing must be either explicitly or implicitly \"\n                     \"enabled.\"\n                 )\n-        elif hash is True or (hash is None and cmp is True and frozen is True):\n+        elif hash is True or (hash is None and eq is True and frozen is True):\n             # Build a __hash__ if told so, or if it's safe.\n             builder.add_hash()\n         else:\n@@ -1013,9 +1086,7 @@ def _generate_unique_filename(cls, func_name):\n \n def _make_hash(cls, attrs, frozen, cache_hash):\n     attrs = tuple(\n-        a\n-        for a in attrs\n-        if a.hash is True or (a.hash is None and a.cmp is True)\n+        a for a in attrs if a.hash is True or (a.hash is None and a.eq is True)\n     )\n \n     tab = \"        \"\n@@ -1093,8 +1164,8 @@ def __ne__(self, other):\n     return not result\n \n \n-def _make_cmp(cls, attrs):\n-    attrs = [a for a in attrs if a.cmp]\n+def _make_eq(cls, attrs):\n+    attrs = [a for a in attrs if a.eq]\n \n     unique_filename = _generate_unique_filename(cls, \"eq\")\n     lines = [\n@@ -1129,8 +1200,11 @@ def _make_cmp(cls, attrs):\n         script.splitlines(True),\n         unique_filename,\n     )\n-    eq = locs[\"__eq__\"]\n-    ne = __ne__\n+    return locs[\"__eq__\"], __ne__\n+\n+\n+def _make_order(cls, attrs):\n+    attrs = [a for a in attrs if a.order]\n \n     def attrs_to_tuple(obj):\n         \"\"\"\n@@ -1174,19 +1248,17 @@ def __ge__(self, other):\n \n         return NotImplemented\n \n-    return eq, ne, __lt__, __le__, __gt__, __ge__\n+    return __lt__, __le__, __gt__, __ge__\n \n \n-def _add_cmp(cls, attrs=None):\n+def _add_eq(cls, attrs=None):\n     \"\"\"\n-    Add comparison methods to *cls*.\n+    Add equality methods to *cls* with *attrs*.\n     \"\"\"\n     if attrs is None:\n         attrs = cls.__attrs_attrs__\n \n-    cls.__eq__, cls.__ne__, cls.__lt__, cls.__le__, cls.__gt__, cls.__ge__ = _make_cmp(  # noqa\n-        cls, attrs\n-    )\n+    cls.__eq__, cls.__ne__ = _make_eq(cls, attrs)\n \n     return cls\n \n@@ -1682,7 +1754,8 @@ class Attribute(object):\n         \"default\",\n         \"validator\",\n         \"repr\",\n-        \"cmp\",\n+        \"eq\",\n+        \"order\",\n         \"hash\",\n         \"init\",\n         \"metadata\",\n@@ -1697,14 +1770,18 @@ def __init__(\n         default,\n         validator,\n         repr,\n-        cmp,\n+        cmp,  # XXX: unused, remove along with other cmp code.\n         hash,\n         init,\n         metadata=None,\n         type=None,\n         converter=None,\n         kw_only=False,\n+        eq=None,\n+        order=None,\n     ):\n+        eq, order = _determine_eq_order(cmp, eq, order)\n+\n         # Cache this descriptor here to speed things up later.\n         bound_setattr = _obj_setattr.__get__(self, Attribute)\n \n@@ -1714,7 +1791,8 @@ def __init__(\n         bound_setattr(\"default\", default)\n         bound_setattr(\"validator\", validator)\n         bound_setattr(\"repr\", repr)\n-        bound_setattr(\"cmp\", cmp)\n+        bound_setattr(\"eq\", eq)\n+        bound_setattr(\"order\", order)\n         bound_setattr(\"hash\", hash)\n         bound_setattr(\"init\", init)\n         bound_setattr(\"converter\", converter)\n@@ -1757,9 +1835,19 @@ def from_counting_attr(cls, name, ca, type=None):\n             validator=ca._validator,\n             default=ca._default,\n             type=type,\n+            cmp=None,\n             **inst_dict\n         )\n \n+    @property\n+    def cmp(self):\n+        \"\"\"\n+        Simulate the presence of a cmp attribute and warn.\n+        \"\"\"\n+        warnings.warn(_CMP_DEPRECATION, DeprecationWarning, stacklevel=2)\n+\n+        return self.eq and self.order\n+\n     # Don't use attr.assoc since fields(Attribute) doesn't work\n     def _assoc(self, **changes):\n         \"\"\"\n@@ -1807,7 +1895,9 @@ def _setattrs(self, name_values_pairs):\n         default=NOTHING,\n         validator=None,\n         repr=True,\n-        cmp=True,\n+        cmp=None,\n+        eq=True,\n+        order=False,\n         hash=(name != \"metadata\"),\n         init=True,\n     )\n@@ -1815,7 +1905,7 @@ def _setattrs(self, name_values_pairs):\n ]\n \n Attribute = _add_hash(\n-    _add_cmp(_add_repr(Attribute, attrs=_a), attrs=_a),\n+    _add_eq(_add_repr(Attribute, attrs=_a), attrs=_a),\n     attrs=[a for a in _a if a.hash],\n )\n \n@@ -1833,7 +1923,8 @@ class _CountingAttr(object):\n         \"counter\",\n         \"_default\",\n         \"repr\",\n-        \"cmp\",\n+        \"eq\",\n+        \"order\",\n         \"hash\",\n         \"init\",\n         \"metadata\",\n@@ -1848,22 +1939,34 @@ class _CountingAttr(object):\n             default=NOTHING,\n             validator=None,\n             repr=True,\n-            cmp=True,\n+            cmp=None,\n             hash=True,\n             init=True,\n             kw_only=False,\n+            eq=True,\n+            order=False,\n+        )\n+        for name in (\n+            \"counter\",\n+            \"_default\",\n+            \"repr\",\n+            \"eq\",\n+            \"order\",\n+            \"hash\",\n+            \"init\",\n         )\n-        for name in (\"counter\", \"_default\", \"repr\", \"cmp\", \"hash\", \"init\")\n     ) + (\n         Attribute(\n             name=\"metadata\",\n             default=None,\n             validator=None,\n             repr=True,\n-            cmp=True,\n+            cmp=None,\n             hash=False,\n             init=True,\n             kw_only=False,\n+            eq=True,\n+            order=False,\n         ),\n     )\n     cls_counter = 0\n@@ -1873,13 +1976,15 @@ def __init__(\n         default,\n         validator,\n         repr,\n-        cmp,\n+        cmp,  # XXX: unused, remove along with cmp\n         hash,\n         init,\n         converter,\n         metadata,\n         type,\n         kw_only,\n+        eq,\n+        order,\n     ):\n         _CountingAttr.cls_counter += 1\n         self.counter = _CountingAttr.cls_counter\n@@ -1890,7 +1995,8 @@ def __init__(\n         else:\n             self._validator = validator\n         self.repr = repr\n-        self.cmp = cmp\n+        self.eq = eq\n+        self.order = order\n         self.hash = hash\n         self.init = init\n         self.converter = converter\n@@ -1930,7 +2036,7 @@ def default(self, meth):\n         return meth\n \n \n-_CountingAttr = _add_cmp(_add_repr(_CountingAttr))\n+_CountingAttr = _add_eq(_add_repr(_CountingAttr))\n \n \n @attrs(slots=True, init=False, hash=True)\n@@ -2011,6 +2117,14 @@ def make_class(name, attrs, bases=(object,), **attributes_arguments):\n     except (AttributeError, ValueError):\n         pass\n \n+    # We do it here for proper warnings with meaningful stacklevel.\n+    cmp = attributes_arguments.pop(\"cmp\", None)\n+    attributes_arguments[\"eq\"], attributes_arguments[\n+        \"order\"\n+    ] = _determine_eq_order(\n+        cmp, attributes_arguments.get(\"eq\"), attributes_arguments.get(\"order\")\n+    )\n+\n     return _attrs(these=cls_dict, **attributes_arguments)(type_)\n \n \n",
        "test_patch": "diff --git a/tests/strategies.py b/tests/strategies.py\n--- a/tests/strategies.py\n+++ b/tests/strategies.py\n@@ -14,6 +14,9 @@\n from .utils import make_class\n \n \n+optional_bool = st.one_of(st.none(), st.booleans())\n+\n+\n def gen_attr_names():\n     \"\"\"\n     Generate names for attributes, 'a'...'z', then 'aa'...'zz'.\n@@ -131,7 +134,8 @@ def simple_attrs_with_metadata(draw):\n         default=c_attr._default,\n         validator=c_attr._validator,\n         repr=c_attr.repr,\n-        cmp=c_attr.cmp,\n+        eq=c_attr.eq,\n+        order=c_attr.order,\n         hash=c_attr.hash,\n         init=c_attr.init,\n         metadata=metadata,\ndiff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -11,15 +11,17 @@\n import pytest\n import six\n \n-from hypothesis import given\n+from hypothesis import assume, given\n from hypothesis.strategies import booleans\n \n import attr\n \n-from attr._compat import TYPE\n+from attr._compat import PY2, TYPE\n from attr._make import NOTHING, Attribute\n from attr.exceptions import FrozenInstanceError\n \n+from .strategies import optional_bool\n+\n \n @attr.s\n class C1(object):\n@@ -124,7 +126,9 @@ def test_fields(self, cls):\n                 default=foo,\n                 validator=None,\n                 repr=True,\n-                cmp=True,\n+                cmp=None,\n+                eq=True,\n+                order=True,\n                 hash=None,\n                 init=True,\n             ),\n@@ -133,7 +137,9 @@ def test_fields(self, cls):\n                 default=attr.Factory(list),\n                 validator=None,\n                 repr=True,\n-                cmp=True,\n+                cmp=None,\n+                eq=True,\n+                order=True,\n                 hash=None,\n                 init=True,\n             ),\n@@ -181,13 +187,16 @@ def test_programmatic(self, slots, frozen):\n         `attr.make_class` works.\n         \"\"\"\n         PC = attr.make_class(\"PC\", [\"a\", \"b\"], slots=slots, frozen=frozen)\n+\n         assert (\n             Attribute(\n                 name=\"a\",\n                 default=NOTHING,\n                 validator=None,\n                 repr=True,\n-                cmp=True,\n+                cmp=None,\n+                eq=True,\n+                order=True,\n                 hash=None,\n                 init=True,\n             ),\n@@ -196,7 +205,9 @@ def test_programmatic(self, slots, frozen):\n                 default=NOTHING,\n                 validator=None,\n                 repr=True,\n-                cmp=True,\n+                cmp=None,\n+                eq=True,\n+                order=True,\n                 hash=None,\n                 init=True,\n             ),\n@@ -380,7 +391,7 @@ class HashByIDBackwardCompat(object):\n             HashByIDBackwardCompat(1)\n         )\n \n-        @attr.s(hash=False, cmp=False)\n+        @attr.s(hash=False, eq=False)\n         class HashByID(object):\n             x = attr.ib()\n \n@@ -412,10 +423,10 @@ class D(C):\n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_hash_false_cmp_false(self, slots):\n         \"\"\"\n-        hash=False and cmp=False make a class hashable by ID.\n+        hash=False and eq=False make a class hashable by ID.\n         \"\"\"\n \n-        @attr.s(hash=False, cmp=False, slots=slots)\n+        @attr.s(hash=False, eq=False, slots=slots)\n         class C(object):\n             pass\n \n@@ -581,3 +592,76 @@ class FooError(Exception):\n             x = attr.ib()\n \n         FooError(1)\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_eq_only(self, slots, frozen):\n+        \"\"\"\n+        Classes with order=False cannot be ordered.\n+\n+        Python 3 throws a TypeError, in Python2 we have to check for the\n+        absence.\n+        \"\"\"\n+\n+        @attr.s(eq=True, order=False, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+        if not PY2:\n+            possible_errors = (\n+                \"unorderable types: C() < C()\",\n+                \"'<' not supported between instances of 'C' and 'C'\",\n+                \"unorderable types: C < C\",  # old PyPy 3\n+            )\n+\n+            with pytest.raises(TypeError) as ei:\n+                C(5) < C(6)\n+\n+            assert ei.value.args[0] in possible_errors\n+        else:\n+            i = C(42)\n+            for m in (\"lt\", \"le\", \"gt\", \"ge\"):\n+                assert None is getattr(i, \"__%s__\" % (m,), None)\n+\n+    @given(cmp=optional_bool, eq=optional_bool, order=optional_bool)\n+    def test_cmp_deprecated_attribute(self, cmp, eq, order):\n+        \"\"\"\n+        Accessing Attribute.cmp raises a deprecation warning but returns True\n+        if cmp is True, or eq and order are *both* effectively True.\n+        \"\"\"\n+        # These cases are invalid and raise a ValueError.\n+        assume(cmp is None or (eq is None and order is None))\n+        assume(not (eq is False and order is True))\n+\n+        if cmp is not None:\n+            rv = cmp\n+        elif eq is True or eq is None:\n+            rv = order is None or order is True\n+        elif cmp is None and eq is None and order is None:\n+            rv = True\n+        elif cmp is None or eq is None:\n+            rv = False\n+        else:\n+            pytest.fail(\n+                \"Unexpected state: cmp=%r eq=%r order=%r\" % (cmp, eq, order)\n+            )\n+\n+        with pytest.deprecated_call() as dc:\n+\n+            @attr.s\n+            class C(object):\n+                x = attr.ib(cmp=cmp, eq=eq, order=order)\n+\n+            assert rv == attr.fields(C).x.cmp\n+\n+        if cmp is not None:\n+            # Remove warning from creating the attribute if cmp is not None.\n+            dc.pop()\n+\n+        w, = dc.list\n+\n+        assert (\n+            \"The usage of `cmp` is deprecated and will be removed on or after \"\n+            \"2021-06-01.  Please use `eq` and `order` instead.\"\n+            == w.message.args[0]\n+        )\ndiff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -29,8 +29,10 @@\n from .utils import simple_attr, simple_class\n \n \n-CmpC = simple_class(cmp=True)\n-CmpCSlots = simple_class(cmp=True, slots=True)\n+EqC = simple_class(eq=True)\n+EqCSlots = simple_class(eq=True, slots=True)\n+OrderC = simple_class(order=True)\n+OrderCSlots = simple_class(order=True, slots=True)\n ReprC = simple_class(repr=True)\n ReprCSlots = simple_class(repr=True, slots=True)\n \n@@ -38,10 +40,10 @@\n # implicitly.  The \"Cached\" versions are the same, except with hash code\n # caching enabled\n HashC = simple_class(hash=True)\n-HashCSlots = simple_class(hash=None, cmp=True, frozen=True, slots=True)\n+HashCSlots = simple_class(hash=None, eq=True, frozen=True, slots=True)\n HashCCached = simple_class(hash=True, cache_hash=True)\n HashCSlotsCached = simple_class(\n-    hash=None, cmp=True, frozen=True, slots=True, cache_hash=True\n+    hash=None, eq=True, frozen=True, slots=True, cache_hash=True\n )\n # the cached hash code is stored slightly differently in this case\n # so it needs to be tested separately\n@@ -77,23 +79,23 @@ class InitC(object):\n InitC = _add_init(InitC, False)\n \n \n-class TestAddCmp(object):\n+class TestEqOrder(object):\n     \"\"\"\n-    Tests for `_add_cmp`.\n+    Tests for eq and order related methods.\n     \"\"\"\n \n     @given(booleans())\n-    def test_cmp(self, slots):\n+    def test_eq_ignore_attrib(self, slots):\n         \"\"\"\n-        If `cmp` is False, ignore that attribute.\n+        If `eq` is False for an attribute, ignore that attribute.\n         \"\"\"\n         C = make_class(\n-            \"C\", {\"a\": attr.ib(cmp=False), \"b\": attr.ib()}, slots=slots\n+            \"C\", {\"a\": attr.ib(eq=False), \"b\": attr.ib()}, slots=slots\n         )\n \n         assert C(1, 2) == C(2, 2)\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [EqC, EqCSlots])\n     def test_equal(self, cls):\n         \"\"\"\n         Equal objects are detected as equal.\n@@ -101,7 +103,7 @@ def test_equal(self, cls):\n         assert cls(1, 2) == cls(1, 2)\n         assert not (cls(1, 2) != cls(1, 2))\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [EqC, EqCSlots])\n     def test_unequal_same_class(self, cls):\n         \"\"\"\n         Unequal objects of correct type are detected as unequal.\n@@ -109,21 +111,21 @@ def test_unequal_same_class(self, cls):\n         assert cls(1, 2) != cls(2, 1)\n         assert not (cls(1, 2) == cls(2, 1))\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [EqC, EqCSlots])\n     def test_unequal_different_class(self, cls):\n         \"\"\"\n         Unequal objects of different type are detected even if their attributes\n         match.\n         \"\"\"\n \n-        class NotCmpC(object):\n+        class NotEqC(object):\n             a = 1\n             b = 2\n \n-        assert cls(1, 2) != NotCmpC()\n-        assert not (cls(1, 2) == NotCmpC())\n+        assert cls(1, 2) != NotEqC()\n+        assert not (cls(1, 2) == NotEqC())\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_lt(self, cls):\n         \"\"\"\n         __lt__ compares objects as tuples of attribute values.\n@@ -135,14 +137,14 @@ def test_lt(self, cls):\n         ]:\n             assert cls(*a) < cls(*b)\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_lt_unordable(self, cls):\n         \"\"\"\n         __lt__ returns NotImplemented if classes differ.\n         \"\"\"\n         assert NotImplemented == (cls(1, 2).__lt__(42))\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_le(self, cls):\n         \"\"\"\n         __le__ compares objects as tuples of attribute values.\n@@ -156,14 +158,14 @@ def test_le(self, cls):\n         ]:\n             assert cls(*a) <= cls(*b)\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_le_unordable(self, cls):\n         \"\"\"\n         __le__ returns NotImplemented if classes differ.\n         \"\"\"\n         assert NotImplemented == (cls(1, 2).__le__(42))\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_gt(self, cls):\n         \"\"\"\n         __gt__ compares objects as tuples of attribute values.\n@@ -175,14 +177,14 @@ def test_gt(self, cls):\n         ]:\n             assert cls(*a) > cls(*b)\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_gt_unordable(self, cls):\n         \"\"\"\n         __gt__ returns NotImplemented if classes differ.\n         \"\"\"\n         assert NotImplemented == (cls(1, 2).__gt__(42))\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_ge(self, cls):\n         \"\"\"\n         __ge__ compares objects as tuples of attribute values.\n@@ -196,7 +198,7 @@ def test_ge(self, cls):\n         ]:\n             assert cls(*a) >= cls(*b)\n \n-    @pytest.mark.parametrize(\"cls\", [CmpC, CmpCSlots])\n+    @pytest.mark.parametrize(\"cls\", [OrderC, OrderCSlots])\n     def test_ge_unordable(self, cls):\n         \"\"\"\n         __ge__ returns NotImplemented if classes differ.\n@@ -347,7 +349,7 @@ def test_enforce_no_cache_hash_without_hash(self):\n         # unhashable case\n         with pytest.raises(TypeError) as e:\n             make_class(\n-                \"C\", {}, hash=None, cmp=True, frozen=False, cache_hash=True\n+                \"C\", {}, hash=None, eq=True, frozen=False, cache_hash=True\n             )\n         assert exc_args == e.value.args\n \n@@ -380,13 +382,13 @@ def test_hash_attribute(self, slots, cache_hash):\n         assert hash(C(1, 2)) == hash(C(2, 2))\n \n     @given(booleans())\n-    def test_hash_attribute_mirrors_cmp(self, cmp):\n+    def test_hash_attribute_mirrors_eq(self, eq):\n         \"\"\"\n-        If `hash` is None, the hash generation mirrors `cmp`.\n+        If `hash` is None, the hash generation mirrors `eq`.\n         \"\"\"\n-        C = make_class(\"C\", {\"a\": attr.ib(cmp=cmp)}, cmp=True, frozen=True)\n+        C = make_class(\"C\", {\"a\": attr.ib(eq=eq)}, eq=True, frozen=True)\n \n-        if cmp:\n+        if eq:\n             assert C(1) != C(2)\n             assert hash(C(1)) != hash(C(2))\n             assert hash(C(1)) == hash(C(1))\n@@ -395,18 +397,18 @@ def test_hash_attribute_mirrors_cmp(self, cmp):\n             assert hash(C(1)) == hash(C(2))\n \n     @given(booleans())\n-    def test_hash_mirrors_cmp(self, cmp):\n+    def test_hash_mirrors_eq(self, eq):\n         \"\"\"\n-        If `hash` is None, the hash generation mirrors `cmp`.\n+        If `hash` is None, the hash generation mirrors `eq`.\n         \"\"\"\n-        C = make_class(\"C\", {\"a\": attr.ib()}, cmp=cmp, frozen=True)\n+        C = make_class(\"C\", {\"a\": attr.ib()}, eq=eq, frozen=True)\n \n         i = C(1)\n \n         assert i == i\n         assert hash(i) == hash(i)\n \n-        if cmp:\n+        if eq:\n             assert C(1) == C(1)\n             assert hash(C(1)) == hash(C(1))\n         else:\n@@ -777,7 +779,7 @@ def test_eq(self):\n         assert 1 != _Nothing()\n \n \n-@attr.s(hash=True, cmp=True)\n+@attr.s(hash=True, order=True)\n class C(object):\n     pass\n \n@@ -786,7 +788,7 @@ class C(object):\n OriginalC = C\n \n \n-@attr.s(hash=True, cmp=True)\n+@attr.s(hash=True, order=True)\n class C(object):\n     pass\n \ndiff --git a/tests/test_funcs.py b/tests/test_funcs.py\n--- a/tests/test_funcs.py\n+++ b/tests/test_funcs.py\n@@ -25,6 +25,21 @@\n SEQUENCE_TYPES = (list, tuple)\n \n \n+@pytest.fixture(scope=\"session\", name=\"C\")\n+def fixture_C():\n+    \"\"\"\n+    Return a simple but fully featured attrs class with an x and a y attribute.\n+    \"\"\"\n+    import attr\n+\n+    @attr.s\n+    class C(object):\n+        x = attr.ib()\n+        y = attr.ib()\n+\n+    return C\n+\n+\n class TestAsDict(object):\n     \"\"\"\n     Tests for `asdict`.\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -14,7 +14,7 @@\n \n import pytest\n \n-from hypothesis import given\n+from hypothesis import assume, given\n from hypothesis.strategies import booleans, integers, lists, sampled_from, text\n \n import attr\n@@ -28,6 +28,7 @@\n     _Attributes,\n     _ClassBuilder,\n     _CountingAttr,\n+    _determine_eq_order,\n     _transform_attrs,\n     and_,\n     fields,\n@@ -44,6 +45,7 @@\n from .strategies import (\n     gen_attr_names,\n     list_of_attrs,\n+    optional_bool,\n     simple_attrs,\n     simple_attrs_with_metadata,\n     simple_attrs_without_metadata,\n@@ -216,8 +218,9 @@ class C(object):\n             \"No mandatory attributes allowed after an attribute with a \"\n             \"default value or factory.  Attribute in question: Attribute\"\n             \"(name='y', default=NOTHING, validator=None, repr=True, \"\n-            \"cmp=True, hash=None, init=True, metadata=mappingproxy({}), \"\n-            \"type=None, converter=None, kw_only=False)\",\n+            \"eq=True, order=True, hash=None, init=True, \"\n+            \"metadata=mappingproxy({}), type=None, converter=None, \"\n+            \"kw_only=False)\",\n         ) == e.value.args\n \n     def test_kw_only(self):\n@@ -411,21 +414,30 @@ class C(object):\n         \"arg_name, method_name\",\n         [\n             (\"repr\", \"__repr__\"),\n-            (\"cmp\", \"__eq__\"),\n+            (\"eq\", \"__eq__\"),\n+            (\"order\", \"__le__\"),\n             (\"hash\", \"__hash__\"),\n             (\"init\", \"__init__\"),\n         ],\n     )\n     def test_respects_add_arguments(self, arg_name, method_name):\n         \"\"\"\n-        If a certain `add_XXX` is `False`, `__XXX__` is not added to the class.\n+        If a certain `XXX` is `False`, `__XXX__` is not added to the class.\n         \"\"\"\n         # Set the method name to a sentinel and check whether it has been\n         # overwritten afterwards.\n         sentinel = object()\n \n-        am_args = {\"repr\": True, \"cmp\": True, \"hash\": True, \"init\": True}\n+        am_args = {\n+            \"repr\": True,\n+            \"eq\": True,\n+            \"order\": True,\n+            \"hash\": True,\n+            \"init\": True,\n+        }\n         am_args[arg_name] = False\n+        if arg_name == \"eq\":\n+            am_args[\"order\"] = False\n \n         class C(object):\n             x = attr.ib()\n@@ -918,16 +930,17 @@ class TestFields(object):\n     Tests for `fields`.\n     \"\"\"\n \n+    @given(simple_classes())\n     def test_instance(self, C):\n         \"\"\"\n         Raises `TypeError` on non-classes.\n         \"\"\"\n         with pytest.raises(TypeError) as e:\n-            fields(C(1, 2))\n+            fields(C())\n \n         assert \"Passed object must be a class.\" == e.value.args[0]\n \n-    def test_handler_non_attrs_class(self, C):\n+    def test_handler_non_attrs_class(self):\n         \"\"\"\n         Raises `ValueError` if passed a non-``attrs`` instance.\n         \"\"\"\n@@ -959,16 +972,17 @@ class TestFieldsDict(object):\n     Tests for `fields_dict`.\n     \"\"\"\n \n+    @given(simple_classes())\n     def test_instance(self, C):\n         \"\"\"\n         Raises `TypeError` on non-classes.\n         \"\"\"\n         with pytest.raises(TypeError) as e:\n-            fields_dict(C(1, 2))\n+            fields_dict(C())\n \n         assert \"Passed object must be a class.\" == e.value.args[0]\n \n-    def test_handler_non_attrs_class(self, C):\n+    def test_handler_non_attrs_class(self):\n         \"\"\"\n         Raises `ValueError` if passed a non-``attrs`` instance.\n         \"\"\"\n@@ -1341,7 +1355,8 @@ class C(object):\n         )\n \n         cls = (\n-            b.add_cmp()\n+            b.add_eq()\n+            .add_order()\n             .add_hash()\n             .add_init()\n             .add_repr(\"ns\")\n@@ -1427,7 +1442,7 @@ def test_weakref_setstate(self):\n         @attr.s(slots=True)\n         class C(object):\n             __weakref__ = attr.ib(\n-                init=False, hash=False, repr=False, cmp=False\n+                init=False, hash=False, repr=False, eq=False, order=False\n             )\n \n         assert C() == copy.deepcopy(C())\n@@ -1452,9 +1467,9 @@ class C2(C):\n         assert [C2] == C.__subclasses__()\n \n \n-class TestMakeCmp:\n+class TestMakeOrder:\n     \"\"\"\n-    Tests for _make_cmp().\n+    Tests for _make_order().\n     \"\"\"\n \n     def test_subclasses_cannot_be_compared(self):\n@@ -1500,3 +1515,57 @@ class B(A):\n \n             with pytest.raises(TypeError):\n                 a > b\n+\n+\n+class TestDetermineEqOrder(object):\n+    def test_default(self):\n+        \"\"\"\n+        If all are set to None, do the default: True, True\n+        \"\"\"\n+        assert (True, True) == _determine_eq_order(None, None, None)\n+\n+    @pytest.mark.parametrize(\"eq\", [True, False])\n+    def test_order_mirrors_eq_by_default(self, eq):\n+        \"\"\"\n+        If order is None, it mirrors eq.\n+        \"\"\"\n+        assert (eq, eq) == _determine_eq_order(None, eq, None)\n+\n+    def test_order_without_eq(self):\n+        \"\"\"\n+        eq=False, order=True raises a meaningful ValueError.\n+        \"\"\"\n+        with pytest.raises(\n+            ValueError, match=\"`order` can only be True if `eq` is True too.\"\n+        ):\n+            _determine_eq_order(None, False, True)\n+\n+    @given(cmp=booleans(), eq=optional_bool, order=optional_bool)\n+    def test_mix(self, cmp, eq, order):\n+        \"\"\"\n+        If cmp is not None, eq and order must be None and vice versa.\n+        \"\"\"\n+        assume(eq is not None or order is not None)\n+\n+        with pytest.raises(\n+            ValueError, match=\"Don't mix `cmp` with `eq' and `order`.\"\n+        ):\n+            _determine_eq_order(cmp, eq, order)\n+\n+    def test_cmp_deprecated(self):\n+        \"\"\"\n+        Passing a cmp that is not None raises a DeprecationWarning.\n+        \"\"\"\n+        with pytest.deprecated_call() as dc:\n+\n+            @attr.s(cmp=True)\n+            class C(object):\n+                pass\n+\n+        w, = dc.list\n+\n+        assert (\n+            \"The usage of `cmp` is deprecated and will be removed on or after \"\n+            \"2021-06-01.  Please use `eq` and `order` instead.\"\n+            == w.message.args[0]\n+        )\ndiff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -272,7 +272,9 @@ def test_bare_inheritance_from_slots():\n     Inheriting from a bare attrs slotted class works.\n     \"\"\"\n \n-    @attr.s(init=False, cmp=False, hash=False, repr=False, slots=True)\n+    @attr.s(\n+        init=False, eq=False, order=False, hash=False, repr=False, slots=True\n+    )\n     class C1BareSlots(object):\n         x = attr.ib(validator=attr.validators.instance_of(int))\n         y = attr.ib()\n@@ -288,7 +290,7 @@ def classmethod(cls):\n         def staticmethod():\n             return \"staticmethod\"\n \n-    @attr.s(init=False, cmp=False, hash=False, repr=False)\n+    @attr.s(init=False, eq=False, order=False, hash=False, repr=False)\n     class C1Bare(object):\n         x = attr.ib(validator=attr.validators.instance_of(int))\n         y = attr.ib()\n@@ -533,7 +535,9 @@ def tests_weakref_does_not_add_with_weakref_attribute():\n \n     @attr.s(slots=True, weakref_slot=True)\n     class C(object):\n-        __weakref__ = attr.ib(init=False, hash=False, repr=False, cmp=False)\n+        __weakref__ = attr.ib(\n+            init=False, hash=False, repr=False, eq=False, order=False\n+        )\n \n     c = C()\n     w = weakref.ref(c)\ndiff --git a/tests/typing_example.py b/tests/typing_example.py\n--- a/tests/typing_example.py\n+++ b/tests/typing_example.py\n@@ -166,3 +166,10 @@ class WithCustomRepr:\n     b = attr.ib(repr=False)\n     c = attr.ib(repr=lambda value: \"c is for cookie\")\n     d = attr.ib(repr=str)\n+\n+\n+# Check some of our own types\n+@attr.s(eq=True, order=False)\n+class OrderFlags:\n+    a = attr.ib(eq=False, order=False)\n+    b = attr.ib(eq=True, order=True)\ndiff --git a/tests/utils.py b/tests/utils.py\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -9,7 +9,8 @@\n \n \n def simple_class(\n-    cmp=False,\n+    eq=False,\n+    order=False,\n     repr=False,\n     hash=False,\n     str=False,\n@@ -23,7 +24,8 @@ def simple_class(\n     return make_class(\n         \"C\",\n         [\"a\", \"b\"],\n-        cmp=cmp,\n+        eq=eq or order,\n+        order=order,\n         repr=repr,\n         hash=hash,\n         init=True,\n@@ -39,7 +41,7 @@ def simple_attr(\n     default=NOTHING,\n     validator=None,\n     repr=True,\n-    cmp=True,\n+    eq=True,\n     hash=None,\n     init=True,\n     converter=None,\n@@ -53,7 +55,8 @@ def simple_attr(\n         default=default,\n         validator=validator,\n         repr=repr,\n-        cmp=cmp,\n+        cmp=None,\n+        eq=eq,\n         hash=hash,\n         init=init,\n         converter=converter,\n",
        "problem_statement": "Suggestion: differentiate in cmp between (== , !=) and (>,>=, <, <=).\nThanks for a fantastic library!\r\n\r\nOne thing that surprised me at first was that I could not write an effective `__gt__()`-function for my attr-class. I found the `cmp`-init-parameter later (in the code), but I still wonder if it wouldn't be a good idea if I could have the option of keeping the tuple-based `__eq__` and `__ne__`-implementations, but override size-comparisons (maybe based on a single `__lt__`-function?).\n",
        "hints_text": "I agree with this suggestion, but for a different reason. I use `cmp=True` for 99% of my classes but only because I want `==` and `!=` to work. Virtually none of these classes I want to be orderable. So there are IMO two good reasons to decouple `__eq__` from ordering.\r\n\r\nNot really sure how to deal with backwards compatibility though. Introduce `eq` and `order` (or `ordering`, `ordered`?) arguments to `attr.s`, keeping `cmp` for a year and letting `cmp` override `eq` and `order` if explicitly specified. I would default `cmp` to true and `order` to false.\r\n\r\nI'm not sure about the use case where you define `__lt__`. This is already covered by https://docs.python.org/3/library/functools.html#functools.total_ordering, so you can just say:\r\n\r\n```\r\n@attr.s(eq=True, order=False)\r\n@total_ordering\r\nclass A:\r\n    a = attr.ib()\r\n\r\n    def __lt__(self, other):\r\n        ...\r\n```\r\n\r\nOr we could actually do this for you if we detect one of the methods.\r\n\r\n@hynek @glyph ?\nThis does seem like a good idea.\r\n\r\nI think backwards compatibility is reasonably easy; introduce just `eq`, no `order`.  I'd say `cmp=True` means full comparison (i.e.: ordering, since you can't have ordering without equality) and `eq=True` implies `cmp=False`; we can switch `cmp`'s default to be `NOTHING` so as to distinguish \"not passed\" from \"explicit `True`\".\n(Since `cmp` implies `eq`, passing both `eq` and `cmp` explicitly, regardless of their values, ought to be an error, I think.)\nI was thinking ideally `cmp` would start defaulting to false, and `eq` to true. This would be a compatibility break, no? In my mind very few classes require ordering. We can be better than namedtuple here :)\nFour things:\r\n\r\n1. I don't care, you'll have to hash it out yourselves. :)\r\n2. We break cmp/hash compat with the next release so this ought to be resolved before 17.1 lands.\r\n3. Do those proposal play well with the current state of cmp at all?\r\n4. We'll I *do* care a bit...are you sure implying a False by passing True to eq is a good, not confusing API? :-/\r\n\r\nAlso you should consult @njsmith; I'm not merging any changes to those parts without his approval. :)\nFTR, dataclasses seem to have a split between eq and cmp.\r\n\r\nI think it would be nice if an attrs-based back port would be possible and I think currently this is the only feature where attrs is not a superset.\r\n\r\n***\r\n\r\nIt also might be another case where my intention to move from bools to Enums makes a lot of sense.\nI'm interested in this, too. Otherwise, how could this be done elegantly: I have a Status class like this:\r\n```\r\n@attr.s(frozen=True, auto_attribs=True)\r\nclass Status:\r\n    weight: int = attr.ib(cmp=True)\r\n    message: str = attr.ib(\r\n        cmp=False,\r\n        converter=lambda value: str() if value is None else value,\r\n    )\r\n    code: str = attr.ib(\r\n        cmp=False,\r\n        converter=lambda value: str() if value is None else value,\r\n    )\r\n\r\n    @classmethod\r\n    def Debug(cls, message=None, code=None):\r\n        return cls(weight=0, message=message, code=code)\r\n\r\n    [...]\r\n\r\n    @classmethod\r\n    def Error(cls, message=None, code=None):\r\n        return cls(weight=6, message=message, code=code)\r\n```\r\nIt can be instantiated like this: `Status.Error(\"This and that is wrong etc.\", code=\"mismatched-something\")`. I want to test for equality of two instances using `weight` and `code`, but order only by `weight`.\nUnrelatedly:\r\n\r\n> `converter=lambda value: str() if value is None else value`\r\n\r\nI think what you want here is `default=\"\"`?\nI wish, the constructors pass in `None` for stuff and I want to never have a `None` object in there so I don't need to care about `AttributeError`s. I could do this in the constructors but didn't feel like copy-pasting the boilerplate :)\nAh\u2026hm\u2026you may get away with using `attr.NOTHING` instead of None in the class methods. :) I don\u2019t know if I should encourage that but it definitely will never stop working.",
        "created_at": "2019-09-16T12:13:24Z",
        "version": "19.1"
    }
}