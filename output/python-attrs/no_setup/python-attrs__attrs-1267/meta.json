{
    "task_id": "python-attrs__attrs-1267",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1267_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1267,
        "instance_id": "python-attrs__attrs-1267",
        "issue_numbers": [
            "709"
        ],
        "base_commit": "0f045cd231f01716c9c81ac78fa2c237c0dd1933",
        "patch": "diff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -15,6 +15,7 @@\n from ._make import (\n     NOTHING,\n     Attribute,\n+    Converter,\n     Factory,\n     attrib,\n     attrs,\n@@ -39,6 +40,7 @@ class AttrsInstance(Protocol):\n __all__ = [\n     \"Attribute\",\n     \"AttrsInstance\",\n+    \"Converter\",\n     \"Factory\",\n     \"NOTHING\",\n     \"asdict\",\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -1,5 +1,7 @@\n # SPDX-License-Identifier: MIT\n \n+from __future__ import annotations\n+\n import contextlib\n import copy\n import enum\n@@ -32,7 +34,6 @@\n \n # This is used at least twice, so cache it here.\n _OBJ_SETATTR = object.__setattr__\n-_INIT_CONVERTER_PAT = \"__attr_converter_%s\"\n _INIT_FACTORY_PAT = \"__attr_factory_%s\"\n _CLASSVAR_PREFIXES = (\n     \"typing.ClassVar\",\n@@ -213,11 +214,17 @@ def attrib(\n \n             .. seealso:: `init`\n \n-        converter (typing.Callable(): `callable` that is called by\n-            *attrs*-generated ``__init__`` methods to convert attribute's value\n-            to the desired format.  It is given the passed-in value, and the\n-            returned value will be used as the new value of the attribute.  The\n-            value is converted before being passed to the validator, if any.\n+        converter (typing.Callable | Converter):\n+            `callable` that is called by *attrs*-generated ``__init__`` methods\n+            to convert attribute's value to the desired format.\n+\n+            If a vanilla callable is passed, it is given the passed-in value as\n+            the only positional argument. It is possible to receive additional\n+            arguments by wrapping the callable in a `Converter`.\n+\n+            Either way, the returned value will be used as the new value of the\n+            attribute.  The value is converted before being passed to the\n+            validator, if any.\n \n             .. seealso:: :ref:`converters`\n \n@@ -2239,7 +2246,7 @@ def _make_init(\n         is_exc,\n         needs_cached_setattr,\n         has_cls_on_setattr,\n-        attrs_init,\n+        \"__attrs_init__\" if attrs_init else \"__init__\",\n     )\n     if cls.__module__ in sys.modules:\n         # This makes typing.get_type_hints(CLS.__init__) resolve string types.\n@@ -2263,26 +2270,24 @@ def _make_init(\n     return init\n \n \n-def _setattr(attr_name, value_var, has_on_setattr):\n+def _setattr(attr_name: str, value_var: str, has_on_setattr: bool) -> str:\n     \"\"\"\n     Use the cached object.setattr to set *attr_name* to *value_var*.\n     \"\"\"\n     return f\"_setattr('{attr_name}', {value_var})\"\n \n \n-def _setattr_with_converter(attr_name, value_var, has_on_setattr):\n+def _setattr_with_converter(\n+    attr_name: str, value_var: str, has_on_setattr: bool, converter: Converter\n+) -> str:\n     \"\"\"\n     Use the cached object.setattr to set *attr_name* to *value_var*, but run\n     its converter first.\n     \"\"\"\n-    return \"_setattr('%s', %s(%s))\" % (\n-        attr_name,\n-        _INIT_CONVERTER_PAT % (attr_name,),\n-        value_var,\n-    )\n+    return f\"_setattr('{attr_name}', {converter._fmt_converter_call(attr_name, value_var)})\"\n \n \n-def _assign(attr_name, value, has_on_setattr):\n+def _assign(attr_name: str, value: str, has_on_setattr: bool) -> str:\n     \"\"\"\n     Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise\n     relegate to _setattr.\n@@ -2293,22 +2298,22 @@ def _assign(attr_name, value, has_on_setattr):\n     return f\"self.{attr_name} = {value}\"\n \n \n-def _assign_with_converter(attr_name, value_var, has_on_setattr):\n+def _assign_with_converter(\n+    attr_name: str, value_var: str, has_on_setattr: bool, converter: Converter\n+) -> str:\n     \"\"\"\n     Unless *attr_name* has an on_setattr hook, use normal assignment after\n     conversion. Otherwise relegate to _setattr_with_converter.\n     \"\"\"\n     if has_on_setattr:\n-        return _setattr_with_converter(attr_name, value_var, True)\n+        return _setattr_with_converter(attr_name, value_var, True, converter)\n \n-    return \"self.%s = %s(%s)\" % (\n-        attr_name,\n-        _INIT_CONVERTER_PAT % (attr_name,),\n-        value_var,\n-    )\n+    return f\"self.{attr_name} = {converter._fmt_converter_call(attr_name, value_var)}\"\n \n \n-def _determine_setters(frozen, slots, base_attr_map):\n+def _determine_setters(\n+    frozen: bool, slots: bool, base_attr_map: dict[str, type]\n+):\n     \"\"\"\n     Determine the correct setter functions based on whether a class is frozen\n     and/or slotted.\n@@ -2322,23 +2327,26 @@ def _determine_setters(frozen, slots, base_attr_map):\n         # class.\n         # Note _inst_dict will be used again below if cache_hash is True\n \n-        def fmt_setter(attr_name, value_var, has_on_setattr):\n+        def fmt_setter(\n+            attr_name: str, value_var: str, has_on_setattr: bool\n+        ) -> str:\n             if _is_slot_attr(attr_name, base_attr_map):\n                 return _setattr(attr_name, value_var, has_on_setattr)\n \n             return f\"_inst_dict['{attr_name}'] = {value_var}\"\n \n-        def fmt_setter_with_converter(attr_name, value_var, has_on_setattr):\n+        def fmt_setter_with_converter(\n+            attr_name: str,\n+            value_var: str,\n+            has_on_setattr: bool,\n+            converter: Converter,\n+        ) -> str:\n             if has_on_setattr or _is_slot_attr(attr_name, base_attr_map):\n                 return _setattr_with_converter(\n-                    attr_name, value_var, has_on_setattr\n+                    attr_name, value_var, has_on_setattr, converter\n                 )\n \n-            return \"_inst_dict['%s'] = %s(%s)\" % (\n-                attr_name,\n-                _INIT_CONVERTER_PAT % (attr_name,),\n-                value_var,\n-            )\n+            return f\"_inst_dict['{attr_name}'] = {converter._fmt_converter_call(attr_name, value_var)}\"\n \n         return (\n             (\"_inst_dict = self.__dict__\",),\n@@ -2351,39 +2359,37 @@ def fmt_setter_with_converter(attr_name, value_var, has_on_setattr):\n \n \n def _attrs_to_init_script(\n-    attrs,\n-    frozen,\n-    slots,\n-    pre_init,\n-    pre_init_has_args,\n-    post_init,\n-    cache_hash,\n-    base_attr_map,\n-    is_exc,\n-    needs_cached_setattr,\n-    has_cls_on_setattr,\n-    attrs_init,\n-):\n-    \"\"\"\n-    Return a script of an initializer for *attrs* and a dict of globals.\n-\n-    The globals are expected by the generated script.\n-\n-    If *frozen* is True, we cannot set the attributes directly so we use\n-    a cached ``object.__setattr__``.\n-    \"\"\"\n-    lines = [\"self.__attrs_pre_init__()\"] if pre_init else []\n+    attrs: list[Attribute],\n+    is_frozen: bool,\n+    is_slotted: bool,\n+    call_pre_init: bool,\n+    pre_init_has_args: bool,\n+    call_post_init: bool,\n+    does_cache_hash: bool,\n+    base_attr_map: dict[str, type],\n+    is_exc: bool,\n+    needs_cached_setattr: bool,\n+    has_cls_on_setattr: bool,\n+    method_name: str,\n+) -> tuple[str, dict, dict]:\n+    \"\"\"\n+    Return a script of an initializer for *attrs*, a dict of globals, and\n+    annotations for the initializer.\n+\n+    The globals are required by the generated script.\n+    \"\"\"\n+    lines = [\"self.__attrs_pre_init__()\"] if call_pre_init else []\n \n     if needs_cached_setattr:\n         lines.append(\n             # Circumvent the __setattr__ descriptor to save one lookup per\n-            # assignment.\n-            # Note _setattr will be used again below if cache_hash is True\n+            # assignment. Note _setattr will be used again below if\n+            # does_cache_hash is True.\n             \"_setattr = _cached_setattr_get(self)\"\n         )\n \n     extra_lines, fmt_setter, fmt_setter_with_converter = _determine_setters(\n-        frozen, slots, base_attr_map\n+        is_frozen, is_slotted, base_attr_map\n     )\n     lines.extend(extra_lines)\n \n@@ -2411,19 +2417,25 @@ def _attrs_to_init_script(\n         has_factory = isinstance(a.default, Factory)\n         maybe_self = \"self\" if has_factory and a.default.takes_self else \"\"\n \n+        if a.converter and not isinstance(a.converter, Converter):\n+            converter = Converter(a.converter)\n+        else:\n+            converter = a.converter\n+\n         if a.init is False:\n             if has_factory:\n                 init_factory_name = _INIT_FACTORY_PAT % (a.name,)\n-                if a.converter is not None:\n+                if converter is not None:\n                     lines.append(\n                         fmt_setter_with_converter(\n                             attr_name,\n                             init_factory_name + f\"({maybe_self})\",\n                             has_on_setattr,\n+                            converter,\n                         )\n                     )\n-                    names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n-                        a.converter\n+                    names_for_globals[converter._get_global_name(a.name)] = (\n+                        converter.converter\n                     )\n                 else:\n                     lines.append(\n@@ -2434,16 +2446,17 @@ def _attrs_to_init_script(\n                         )\n                     )\n                 names_for_globals[init_factory_name] = a.default.factory\n-            elif a.converter is not None:\n+            elif converter is not None:\n                 lines.append(\n                     fmt_setter_with_converter(\n                         attr_name,\n                         f\"attr_dict['{attr_name}'].default\",\n                         has_on_setattr,\n+                        converter,\n                     )\n                 )\n-                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n-                    a.converter\n+                names_for_globals[converter._get_global_name(a.name)] = (\n+                    converter.converter\n                 )\n             else:\n                 lines.append(\n@@ -2460,14 +2473,14 @@ def _attrs_to_init_script(\n             else:\n                 args.append(arg)\n \n-            if a.converter is not None:\n+            if converter is not None:\n                 lines.append(\n                     fmt_setter_with_converter(\n-                        attr_name, arg_name, has_on_setattr\n+                        attr_name, arg_name, has_on_setattr, converter\n                     )\n                 )\n-                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n-                    a.converter\n+                names_for_globals[converter._get_global_name(a.name)] = (\n+                    converter.converter\n                 )\n             else:\n                 lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n@@ -2481,11 +2494,11 @@ def _attrs_to_init_script(\n             lines.append(f\"if {arg_name} is not NOTHING:\")\n \n             init_factory_name = _INIT_FACTORY_PAT % (a.name,)\n-            if a.converter is not None:\n+            if converter is not None:\n                 lines.append(\n                     \"    \"\n                     + fmt_setter_with_converter(\n-                        attr_name, arg_name, has_on_setattr\n+                        attr_name, arg_name, has_on_setattr, converter\n                     )\n                 )\n                 lines.append(\"else:\")\n@@ -2495,10 +2508,11 @@ def _attrs_to_init_script(\n                         attr_name,\n                         init_factory_name + \"(\" + maybe_self + \")\",\n                         has_on_setattr,\n+                        converter,\n                     )\n                 )\n-                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n-                    a.converter\n+                names_for_globals[converter._get_global_name(a.name)] = (\n+                    converter.converter\n                 )\n             else:\n                 lines.append(\n@@ -2520,26 +2534,24 @@ def _attrs_to_init_script(\n             else:\n                 args.append(arg_name)\n \n-            if a.converter is not None:\n+            if converter is not None:\n                 lines.append(\n                     fmt_setter_with_converter(\n-                        attr_name, arg_name, has_on_setattr\n+                        attr_name, arg_name, has_on_setattr, converter\n                     )\n                 )\n-                names_for_globals[_INIT_CONVERTER_PAT % (a.name,)] = (\n-                    a.converter\n+                names_for_globals[converter._get_global_name(a.name)] = (\n+                    converter.converter\n                 )\n             else:\n                 lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n \n         if a.init is True:\n-            if a.type is not None and a.converter is None:\n+            if a.type is not None and converter is None:\n                 annotations[arg_name] = a.type\n-            elif a.converter is not None:\n-                # Try to get the type from the converter.\n-                t = _AnnotationExtractor(a.converter).get_first_param_type()\n-                if t:\n-                    annotations[arg_name] = t\n+            elif converter is not None and converter._first_param_type:\n+                # Use the type from the converter if present.\n+                annotations[arg_name] = converter._first_param_type\n \n     if attrs_to_validate:  # we can skip this if there are no validators.\n         names_for_globals[\"_config\"] = _config\n@@ -2551,25 +2563,23 @@ def _attrs_to_init_script(\n             names_for_globals[val_name] = a.validator\n             names_for_globals[attr_name] = a\n \n-    if post_init:\n+    if call_post_init:\n         lines.append(\"self.__attrs_post_init__()\")\n \n-    # because this is set only after __attrs_post_init__ is called, a crash\n+    # Because this is set only after __attrs_post_init__ is called, a crash\n     # will result if post-init tries to access the hash code.  This seemed\n-    # preferable to setting this beforehand, in which case alteration to\n-    # field values during post-init combined with post-init accessing the\n-    # hash code would result in silent bugs.\n-    if cache_hash:\n-        if frozen:\n-            if slots:  # noqa: SIM108\n-                # if frozen and slots, then _setattr defined above\n-                init_hash_cache = \"_setattr('%s', %s)\"\n+    # preferable to setting this beforehand, in which case alteration to field\n+    # values during post-init combined with post-init accessing the hash code\n+    # would result in silent bugs.\n+    if does_cache_hash:\n+        if is_frozen:\n+            if is_slotted:\n+                init_hash_cache = f\"_setattr('{_HASH_CACHE_FIELD}', None)\"\n             else:\n-                # if frozen and not slots, then _inst_dict defined above\n-                init_hash_cache = \"_inst_dict['%s'] = %s\"\n+                init_hash_cache = f\"_inst_dict['{_HASH_CACHE_FIELD}'] = None\"\n         else:\n-            init_hash_cache = \"self.%s = %s\"\n-        lines.append(init_hash_cache % (_HASH_CACHE_FIELD, \"None\"))\n+            init_hash_cache = f\"self.{_HASH_CACHE_FIELD} = None\"\n+        lines.append(init_hash_cache)\n \n     # For exceptions we rely on BaseException.__init__ for proper\n     # initialization.\n@@ -2593,14 +2603,13 @@ def _attrs_to_init_script(\n         )  # handle only kwargs and no regular args\n         pre_init_args += pre_init_kw_only_args\n \n-    if pre_init and pre_init_has_args:\n+    if call_pre_init and pre_init_has_args:\n         # If pre init method has arguments, pass same arguments as `__init__`\n-        lines[0] = \"self.__attrs_pre_init__(%s)\" % pre_init_args\n+        lines[0] = f\"self.__attrs_pre_init__({pre_init_args})\"\n \n     return (\n-        \"def %s(self, %s):\\n    %s\\n\"\n+        f\"def {method_name}(self, %s):\\n    %s\\n\"\n         % (\n-            (\"__attrs_init__\" if attrs_init else \"__init__\"),\n             args,\n             \"\\n    \".join(lines) if lines else \"pass\",\n         ),\n@@ -3056,6 +3065,109 @@ def __setstate__(self, state):\n Factory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)\n \n \n+class Converter:\n+    \"\"\"\n+    Stores a converter callable.\n+\n+    Allows for the wrapped converter to take additional arguments. The\n+    arguments are passed in the order they are documented.\n+\n+    Args:\n+        converter (Callable): A callable that converts the passed value.\n+\n+        takes_self (bool):\n+            Pass the partially initialized instance that is being initialized\n+            as a positional argument. (default: `False`)\n+\n+        takes_field (bool):\n+            Pass the field definition (an `Attribute`) into the converter as a\n+            positional argument. (default: `False`)\n+\n+    .. versionadded:: 24.1.0\n+    \"\"\"\n+\n+    __slots__ = (\n+        \"converter\",\n+        \"takes_self\",\n+        \"takes_field\",\n+        \"_first_param_type\",\n+        \"_global_name\",\n+        \"__call__\",\n+    )\n+\n+    def __init__(self, converter, *, takes_self=False, takes_field=False):\n+        self.converter = converter\n+        self.takes_self = takes_self\n+        self.takes_field = takes_field\n+\n+        self._first_param_type = _AnnotationExtractor(\n+            converter\n+        ).get_first_param_type()\n+\n+    @staticmethod\n+    def _get_global_name(attr_name: str) -> str:\n+        \"\"\"\n+        Return the name that a converter for an attribute name *attr_name*\n+        would have.\n+        \"\"\"\n+        return f\"__attr_converter_{attr_name}\"\n+\n+    def _fmt_converter_call(self, attr_name: str, value_var: str) -> str:\n+        \"\"\"\n+        Return a string that calls the converter for an attribute name\n+        *attr_name* and the value in variable named *value_var* according to\n+        `self.takes_self` and `self.takes_field`.\n+        \"\"\"\n+        if not (self.takes_self or self.takes_field):\n+            return f\"{self._get_global_name(attr_name)}({value_var})\"\n+\n+        if self.takes_self and self.takes_field:\n+            return f\"{self._get_global_name(attr_name)}({value_var}, self, attr_dict['{attr_name}'])\"\n+\n+        if self.takes_self:\n+            return f\"{self._get_global_name(attr_name)}({value_var}, self)\"\n+\n+        return f\"{self._get_global_name(attr_name)}({value_var}, attr_dict['{attr_name}'])\"\n+\n+    def __getstate__(self):\n+        \"\"\"\n+        Return a dict containing only converter and takes_self -- the rest gets\n+        computed when loading.\n+        \"\"\"\n+        return {\n+            \"converter\": self.converter,\n+            \"takes_self\": self.takes_self,\n+            \"takes_field\": self.takes_field,\n+        }\n+\n+    def __setstate__(self, state):\n+        \"\"\"\n+        Load instance from state.\n+        \"\"\"\n+        self.__init__(**state)\n+\n+\n+_f = [\n+    Attribute(\n+        name=name,\n+        default=NOTHING,\n+        validator=None,\n+        repr=True,\n+        cmp=None,\n+        eq=True,\n+        order=False,\n+        hash=True,\n+        init=True,\n+        inherited=False,\n+    )\n+    for name in (\"converter\", \"takes_self\", \"takes_field\")\n+]\n+\n+Converter = _add_hash(\n+    _add_eq(_add_repr(Converter, attrs=_f), attrs=_f), attrs=_f\n+)\n+\n+\n def make_class(\n     name, attrs, bases=(object,), class_body=None, **attributes_arguments\n ):\n@@ -3196,16 +3308,27 @@ def pipe(*converters):\n     .. versionadded:: 20.1.0\n     \"\"\"\n \n-    def pipe_converter(val):\n-        for converter in converters:\n-            val = converter(val)\n+    def pipe_converter(val, inst, field):\n+        for c in converters:\n+            if isinstance(c, Converter):\n+                val = c.converter(\n+                    val,\n+                    *{\n+                        (False, False): (),\n+                        (True, False): (c.takes_self,),\n+                        (False, True): (c.takes_field,),\n+                        (True, True): (c.takes_self, c.takes_field),\n+                    }[c.takes_self, c.takes_field],\n+                )\n+            else:\n+                val = c(val)\n \n         return val\n \n     if not converters:\n         # If the converter list is empty, pipe_converter is the identity.\n         A = typing.TypeVar(\"A\")\n-        pipe_converter.__annotations__ = {\"val\": A, \"return\": A}\n+        pipe_converter.__annotations__.update({\"val\": A, \"return\": A})\n     else:\n         # Get parameter type from first converter.\n         t = _AnnotationExtractor(converters[0]).get_first_param_type()\n@@ -3217,4 +3340,4 @@ def pipe_converter(val):\n         if rt:\n             pipe_converter.__annotations__[\"return\"] = rt\n \n-    return pipe_converter\n+    return Converter(pipe_converter, takes_self=True, takes_field=True)\ndiff --git a/src/attrs/__init__.py b/src/attrs/__init__.py\n--- a/src/attrs/__init__.py\n+++ b/src/attrs/__init__.py\n@@ -4,6 +4,7 @@\n     NOTHING,\n     Attribute,\n     AttrsInstance,\n+    Converter,\n     Factory,\n     _make_getattr,\n     assoc,\n@@ -42,6 +43,7 @@\n     \"Attribute\",\n     \"AttrsInstance\",\n     \"cmp_using\",\n+    \"Converter\",\n     \"converters\",\n     \"define\",\n     \"evolve\",\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -277,25 +277,27 @@ def strlen(y: str) -> int:\n         def identity(z):\n             return z\n \n-        assert attr.converters.pipe(int2str).__annotations__ == {\n+        assert attr.converters.pipe(int2str).converter.__annotations__ == {\n             \"val\": int,\n             \"return\": str,\n         }\n-        assert attr.converters.pipe(int2str, strlen).__annotations__ == {\n+        assert attr.converters.pipe(\n+            int2str, strlen\n+        ).converter.__annotations__ == {\n             \"val\": int,\n             \"return\": int,\n         }\n-        assert attr.converters.pipe(identity, strlen).__annotations__ == {\n-            \"return\": int\n-        }\n-        assert attr.converters.pipe(int2str, identity).__annotations__ == {\n-            \"val\": int\n-        }\n+        assert attr.converters.pipe(\n+            identity, strlen\n+        ).converter.__annotations__ == {\"return\": int}\n+        assert attr.converters.pipe(\n+            int2str, identity\n+        ).converter.__annotations__ == {\"val\": int}\n \n         def int2str_(x: int, y: int = 0) -> str:\n             return str(x)\n \n-        assert attr.converters.pipe(int2str_).__annotations__ == {\n+        assert attr.converters.pipe(int2str_).converter.__annotations__ == {\n             \"val\": int,\n             \"return\": str,\n         }\n@@ -306,17 +308,20 @@ def test_pipe_empty(self):\n         \"\"\"\n \n         p = attr.converters.pipe()\n-        assert \"val\" in p.__annotations__\n-        t = p.__annotations__[\"val\"]\n+\n+        assert \"val\" in p.converter.__annotations__\n+\n+        t = p.converter.__annotations__[\"val\"]\n+\n         assert isinstance(t, typing.TypeVar)\n-        assert p.__annotations__ == {\"val\": t, \"return\": t}\n+        assert p.converter.__annotations__ == {\"val\": t, \"return\": t}\n \n     def test_pipe_non_introspectable(self):\n         \"\"\"\n         pipe() doesn't crash when passed a non-introspectable converter.\n         \"\"\"\n \n-        assert attr.converters.pipe(print).__annotations__ == {}\n+        assert attr.converters.pipe(print).converter.__annotations__ == {}\n \n     def test_pipe_nullary(self):\n         \"\"\"\n@@ -326,7 +331,7 @@ def test_pipe_nullary(self):\n         def noop():\n             pass\n \n-        assert attr.converters.pipe(noop).__annotations__ == {}\n+        assert attr.converters.pipe(noop).converter.__annotations__ == {}\n \n     def test_optional(self):\n         \"\"\"\ndiff --git a/tests/test_converters.py b/tests/test_converters.py\n--- a/tests/test_converters.py\n+++ b/tests/test_converters.py\n@@ -4,15 +4,61 @@\n Tests for `attr.converters`.\n \"\"\"\n \n+import pickle\n \n import pytest\n \n import attr\n \n-from attr import Factory, attrib\n+from attr import Converter, Factory, attrib\n from attr.converters import default_if_none, optional, pipe, to_bool\n \n \n+class TestConverter:\n+    @pytest.mark.parametrize(\"takes_self\", [True, False])\n+    @pytest.mark.parametrize(\"takes_field\", [True, False])\n+    def test_pickle(self, takes_self, takes_field):\n+        \"\"\"\n+        Wrapped converters can be pickled.\n+        \"\"\"\n+        c = Converter(int, takes_self=takes_self, takes_field=takes_field)\n+\n+        new_c = pickle.loads(pickle.dumps(c))\n+\n+        assert c == new_c\n+        assert takes_self == new_c.takes_self\n+        assert takes_field == new_c.takes_field\n+\n+    @pytest.mark.parametrize(\n+        \"scenario\",\n+        [\n+            ((False, False), \"__attr_converter_le_name(le_value)\"),\n+            (\n+                (True, True),\n+                \"__attr_converter_le_name(le_value, self, attr_dict['le_name'])\",\n+            ),\n+            (\n+                (True, False),\n+                \"__attr_converter_le_name(le_value, self)\",\n+            ),\n+            (\n+                (False, True),\n+                \"__attr_converter_le_name(le_value, attr_dict['le_name'])\",\n+            ),\n+        ],\n+    )\n+    def test_fmt_converter_call(self, scenario):\n+        \"\"\"\n+        _fmt_converter_call determines the arguments to the wrapped converter\n+        according to `takes_self` and `takes_field`.\n+        \"\"\"\n+        (takes_self, takes_field), expect = scenario\n+\n+        c = Converter(None, takes_self=takes_self, takes_field=takes_field)\n+\n+        assert expect == c._fmt_converter_call(\"le_name\", \"le_value\")\n+\n+\n class TestOptional:\n     \"\"\"\n     Tests for `optional`.\n@@ -105,9 +151,13 @@ def test_success(self):\n         \"\"\"\n         Succeeds if all wrapped converters succeed.\n         \"\"\"\n-        c = pipe(str, to_bool, bool)\n+        c = pipe(str, Converter(to_bool), bool)\n \n-        assert True is c(\"True\") is c(True)\n+        assert (\n+            True\n+            is c.converter(\"True\", None, None)\n+            is c.converter(True, None, None)\n+        )\n \n     def test_fail(self):\n         \"\"\"\n@@ -117,11 +167,11 @@ def test_fail(self):\n \n         # First wrapped converter fails:\n         with pytest.raises(ValueError):\n-            c(33)\n+            c.converter(33, None, None)\n \n         # Last wrapped converter fails:\n         with pytest.raises(ValueError):\n-            c(\"33\")\n+            c.converter(\"33\", None, None)\n \n     def test_sugar(self):\n         \"\"\"\n@@ -142,7 +192,7 @@ def test_empty(self):\n         \"\"\"\n         o = object()\n \n-        assert o is pipe()(o)\n+        assert o is pipe().converter(o, None, None)\n \n \n class TestToBool:\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1312,7 +1312,7 @@ class TestConverter:\n     Tests for attribute conversion.\n     \"\"\"\n \n-    def test_convert(self):\n+    def test_converter(self):\n         \"\"\"\n         Return value of converter is used as the attribute's value.\n         \"\"\"\n@@ -1324,6 +1324,46 @@ def test_convert(self):\n         assert c.x == 2\n         assert c.y == 2\n \n+    def test_converter_wrapped_takes_self(self):\n+        \"\"\"\n+        When wrapped and passed `takes_self`, the converter receives the\n+        instance that's being initializes -- and the return value is used as\n+        the field's value.\n+        \"\"\"\n+\n+        def converter_with_self(v, self_):\n+            return v * self_.y\n+\n+        @attr.define\n+        class C:\n+            x: int = attr.field(\n+                converter=attr.Converter(converter_with_self, takes_self=True)\n+            )\n+            y = 42\n+\n+        assert 84 == C(2).x\n+\n+    def test_converter_wrapped_takes_field(self):\n+        \"\"\"\n+        When wrapped and passed `takes_field`, the converter receives the field\n+        definition -- and the return value is used as the field's value.\n+        \"\"\"\n+\n+        def converter_with_field(v, field):\n+            assert isinstance(field, attr.Attribute)\n+            return v * field.metadata[\"x\"]\n+\n+        @attr.define\n+        class C:\n+            x: int = attr.field(\n+                converter=attr.Converter(\n+                    converter_with_field, takes_field=True\n+                ),\n+                metadata={\"x\": 42},\n+            )\n+\n+        assert 84 == C(2).x\n+\n     @given(integers(), booleans())\n     def test_convert_property(self, val, init):\n         \"\"\"\ndiff --git a/tests/test_mypy.yml b/tests/test_mypy.yml\n--- a/tests/test_mypy.yml\n+++ b/tests/test_mypy.yml\n@@ -767,7 +767,7 @@\n             return 'hello'\n \n - case: testAttrsUsingBadConverter\n-  regex: true\n+  skip: sys.version_info[:2] < (3, 10)\n   main: |\n     import attr\n     from typing import overload\n@@ -787,14 +787,14 @@\n         bad_overloaded: int = attr.ib(converter=bad_overloaded_converter)\n     reveal_type(A)\n   out: |\n-    main:15: error: Cannot determine __init__ type from converter  \\[misc\\]\n-    main:15: error: Argument \"converter\" has incompatible type \\\"Callable\\[\\[\\], str\\]\\\"; expected (\\\"Callable\\[\\[Any\\], Any\\] \\| None\\\"|\\\"Optional\\[Callable\\[\\[Any\\], Any\\]\\]\\\")  \\[arg-type\\]\n-    main:16: error: Cannot determine __init__ type from converter  \\[misc\\]\n-    main:16: error: Argument \"converter\" has incompatible type overloaded function; expected (\\\"Callable\\[\\[Any\\], Any\\] \\| None\\\"|\\\"Optional\\[Callable\\[\\[Any\\], Any\\]\\]\\\")  \\[arg-type\\]\n-    main:17: note: Revealed type is \"def (bad: Any, bad_overloaded: Any\\) -> main.A\"\n+    main:15: error: Cannot determine __init__ type from converter  [misc]\n+    main:15: error: Argument \"converter\" has incompatible type \"Callable[[], str]\"; expected \"Callable[[Any], Any] | Converter[Any, Never] | None\"  [arg-type]\n+    main:16: error: Cannot determine __init__ type from converter  [misc]\n+    main:16: error: Argument \"converter\" has incompatible type overloaded function; expected \"Callable[[Any], Any] | Converter[Any, Never] | None\"  [arg-type]\n+    main:17: note: Revealed type is \"def (bad: Any, bad_overloaded: Any) -> main.A\"\n \n - case: testAttrsUsingBadConverterReprocess\n-  regex: true\n+  skip: sys.version_info[:2] < (3, 10)\n   main: |\n     import attr\n     from typing import overload\n@@ -815,11 +815,11 @@\n         bad_overloaded: int = attr.ib(converter=bad_overloaded_converter)\n     reveal_type(A)\n   out: |\n-    main:16: error: Cannot determine __init__ type from converter  \\[misc\\]\n-    main:16: error: Argument \\\"converter\\\" has incompatible type \\\"Callable\\[\\[\\], str\\]\\\"; expected (\\\"Callable\\[\\[Any\\], Any\\] \\| None\\\"|\\\"Optional\\[Callable\\[\\[Any\\], Any\\]\\]\\\")  \\[arg-type\\]\n-    main:17: error: Cannot determine __init__ type from converter  \\[misc\\]\n-    main:17: error: Argument \"converter\" has incompatible type overloaded function; expected (\\\"Callable\\[\\[Any\\], Any\\] \\| None\\\"|\\\"Optional\\[Callable\\[\\[Any\\], Any\\]\\]\\\")  \\[arg-type\\]\n-    main:18: note: Revealed type is \"def (bad: Any, bad_overloaded: Any\\) -> main.A\"\n+    main:16: error: Cannot determine __init__ type from converter  [misc]\n+    main:16: error: Argument \"converter\" has incompatible type \"Callable[[], str]\"; expected \"Callable[[Any], Any] | Converter[Any, Never] | None\"  [arg-type]\n+    main:17: error: Cannot determine __init__ type from converter  [misc]\n+    main:17: error: Argument \"converter\" has incompatible type overloaded function; expected \"Callable[[Any], Any] | Converter[Any, Never] | None\"  [arg-type]\n+    main:18: note: Revealed type is \"def (bad: Any, bad_overloaded: Any) -> main.A\"\n \n - case: testAttrsUsingUnsupportedConverter\n   main: |\n@@ -874,6 +874,66 @@\n     o = C(\"1\", \"2\", \"3\")\n     o = C(1, 2, \"3\")\n \n+- case: testThreeArgConverterTypes\n+  main: |\n+    from typing import Any\n+    from attrs import AttrsInstance, Attribute, Converter\n+\n+    def my_converter(value: Any) -> str:\n+        \"\"\"A converter that only takes the value.\"\"\"\n+        return str(value)\n+\n+    def my_converter_with_self(value: Any, self: AttrsInstance) -> str:\n+        \"\"\"This converter takes the value and the self.\"\"\"\n+        return str(value)\n+\n+\n+    def my_converter_with_field(value: Any, field: Attribute) -> str:\n+        \"\"\"This converter takes the value and the field.\"\"\"\n+        return str(value)\n+\n+    reveal_type(Converter(my_converter))\n+    Converter(my_converter_with_self)\n+    Converter(my_converter_with_field)\n+\n+    reveal_type(Converter(my_converter_with_self, takes_self=True))\n+    Converter(my_converter, takes_self=True)\n+    Converter(my_converter_with_field, takes_self=True)\n+\n+    reveal_type(Converter(my_converter_with_field, takes_field=True))\n+    Converter(my_converter, takes_field=True)\n+    Converter(my_converter_with_self, takes_field=True)\n+  out: |\n+    main:17: note: Revealed type is \"attr.Converter[Any, builtins.str]\"\n+    main:18: error: Argument 1 to \"Converter\" has incompatible type \"Callable[[Any, AttrsInstance], str]\"; expected \"Callable[[Any], str]\"  [arg-type]\n+    main:19: error: Argument 1 to \"Converter\" has incompatible type \"Callable[[Any, Attribute[Any]], str]\"; expected \"Callable[[Any], str]\"  [arg-type]\n+    main:21: note: Revealed type is \"attr.Converter[Any, builtins.str]\"\n+    main:22: error: No overload variant of \"Converter\" matches argument types \"Callable[[Any], str]\", \"bool\"  [call-overload]\n+    main:22: note: Possible overload variants:\n+    main:22: note:     def [In, Out] Converter(self, converter: Callable[[In], Out]) -> Converter[In, Out]\n+    main:22: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance, Attribute[Any]], Out], *, takes_self: Literal[True], takes_field: Literal[True]) -> Converter[In, Out]\n+    main:22: note:     def [In, Out] Converter(self, converter: Callable[[In, Attribute[Any]], Out], *, takes_field: Literal[True]) -> Converter[In, Out]\n+    main:22: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance], Out], *, takes_self: Literal[True]) -> Converter[In, Out]\n+    main:23: error: No overload variant of \"Converter\" matches argument types \"Callable[[Any, Attribute[Any]], str]\", \"bool\"  [call-overload]\n+    main:23: note: Possible overload variants:\n+    main:23: note:     def [In, Out] Converter(self, converter: Callable[[In], Out]) -> Converter[In, Out]\n+    main:23: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance, Attribute[Any]], Out], *, takes_self: Literal[True], takes_field: Literal[True]) -> Converter[In, Out]\n+    main:23: note:     def [In, Out] Converter(self, converter: Callable[[In, Attribute[Any]], Out], *, takes_field: Literal[True]) -> Converter[In, Out]\n+    main:23: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance], Out], *, takes_self: Literal[True]) -> Converter[In, Out]\n+    main:25: note: Revealed type is \"attr.Converter[Any, builtins.str]\"\n+    main:26: error: No overload variant of \"Converter\" matches argument types \"Callable[[Any], str]\", \"bool\"  [call-overload]\n+    main:26: note: Possible overload variants:\n+    main:26: note:     def [In, Out] Converter(self, converter: Callable[[In], Out]) -> Converter[In, Out]\n+    main:26: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance, Attribute[Any]], Out], *, takes_self: Literal[True], takes_field: Literal[True]) -> Converter[In, Out]\n+    main:26: note:     def [In, Out] Converter(self, converter: Callable[[In, Attribute[Any]], Out], *, takes_field: Literal[True]) -> Converter[In, Out]\n+    main:26: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance], Out], *, takes_self: Literal[True]) -> Converter[In, Out]\n+    main:27: error: No overload variant of \"Converter\" matches argument types \"Callable[[Any, AttrsInstance], str]\", \"bool\"  [call-overload]\n+    main:27: note: Possible overload variants:\n+    main:27: note:     def [In, Out] Converter(self, converter: Callable[[In], Out]) -> Converter[In, Out]\n+    main:27: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance, Attribute[Any]], Out], *, takes_self: Literal[True], takes_field: Literal[True]) -> Converter[In, Out]\n+    main:27: note:     def [In, Out] Converter(self, converter: Callable[[In, Attribute[Any]], Out], *, takes_field: Literal[True]) -> Converter[In, Out]\n+    main:27: note:     def [In, Out] Converter(self, converter: Callable[[In, AttrsInstance], Out], *, takes_self: Literal[True]) -> Converter[In, Out]\n+\n - case: testAttrsCmpWithSubclasses\n   regex: true\n   main: |\n",
        "problem_statement": "Allow three-argument converters (like validators/on_setattr)\nI'd like to move the discussion from [converter decorator PR](https://github.com/python-attrs/attrs/pull/404) to this issue.\r\n\r\nI think converters are semantically closer to `on_setattr` and `validator` than `default`. E.g. `attr.ib(converter=...)` allows you to pass a list of callables and pipes them automatically - exactly like `attr.ib(validator=...)` and `attr.ib(on_setattr=...)` and there is `attr.converters` module, like `attr.setters` and `attr.validators`. \r\n\r\nIf we allow passing half-initialized self to converter, why don't allow full-form converters, `converter(self, attr, value)` to make them the same as `on_setattr`, but for initialization? \r\n\r\nTo support one, two and three-argument converters there should be either inspect-magic (in py2 - getargspec, in py3 - signature) or mandatory `Converter` wrapper for two and three-argument converters. \n",
        "hints_text": "Maybe, converters and validators can (or event should) be merged (similarly to [click callbacks](https://click.palletsprojects.com/en/7.x/options/#callbacks-for-validation))?\r\n\r\n```python\r\ndef int_validator(self, attrib, value):\r\n    return int(value)  # Validates and converts at the same time :-)\r\n```\r\n\r\nI guess that would be very backwards incompatible, but maybe this can (still) be added to the new `attrs` API?\n> To support one, two and three-argument converters there should be either inspect-magic (in py2 - getargspec, in py3 - signature) or mandatory `Converter` wrapper for two and three-argument converters.\r\n\r\nThis is something I've been thinking about in the past days. I _think_ a marker-wrapper for three-argument converters would be most solid and in line with our other APIs?\nThere's also #146  which still bothers me that it's unresolved but to which I still don't have a good answer, 3.5 years later. :(\nThank you for the discussion! \r\n\r\n@sscherfke I think this is kind of thing that happened to `on_setattr` already. The only big difference here is that converters should work with half-initialized self, but `@default` shows that it can be tackled by users (and #404 shows that some of them are actually craving that possibility in a converter). \r\n\r\nPersonally I like separate validators, as they are running after all the conversions (hence - guaranteed to work with fully-initialized self!) and imply that the field value doesn't change (unless some reckless guy will do  `object.__setattr__(self, attr.name, new_value)` inside, but it seems like a dirty hack and wouldn't pass any code-review. Or at least I hope so...)\r\n\r\n@hynek #146 is pretty informative, thank you for mentioning it! :) I actually missed the stacktrace point when I was thinking about it (and maybe some performance issues, as there is a level of indirection here...). Though, I think that having `on_setattr` on board actually introduces some `common` API for a pipeline here. \r\n\r\nI do like the marker-wrapper idea (e.g. `Converter(fun, takes_self=True, takes_attr=True)`), though it may be a bit unexpected for a newcomer that `attr.ib(converter=c)` expects one-argument function or wrapper, while `attr.ib(validator=v, on_seattr=s)` expect three-argument function (and no wrappers provided). But - considering possible issues with half-initialized `self` - it may be a good practice, actually. \r\n\r\nUPD: Just saw the comment in the PR. Actually, if `converter` is kind of shortcut to something like `on_init` - it sounds like a great way to get away from this unexpected behavior :)\nAny update to this issue ? ",
        "created_at": "2024-03-17T12:19:06Z",
        "version": "23.2"
    }
}