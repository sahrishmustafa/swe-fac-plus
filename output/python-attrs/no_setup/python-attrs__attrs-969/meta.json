{
    "task_id": "python-attrs__attrs-969",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-969_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 969,
        "instance_id": "python-attrs__attrs-969",
        "issue_numbers": [
            "910"
        ],
        "base_commit": "a7e82b5c4121633cff792ed1cbc371843d590960",
        "patch": "diff --git a/setup.py b/setup.py\n--- a/setup.py\n+++ b/setup.py\n@@ -39,6 +39,7 @@\n     \"Programming Language :: Python :: 3.8\",\n     \"Programming Language :: Python :: 3.9\",\n     \"Programming Language :: Python :: 3.10\",\n+    \"Programming Language :: Python :: 3.11\",\n     \"Programming Language :: Python :: Implementation :: CPython\",\n     \"Programming Language :: Python :: Implementation :: PyPy\",\n     \"Topic :: Software Development :: Libraries :: Python Modules\",\ndiff --git a/src/attr/_compat.py b/src/attr/_compat.py\n--- a/src/attr/_compat.py\n+++ b/src/attr/_compat.py\n@@ -111,12 +111,10 @@ def force_x_to_be_a_cell():  # pragma: no cover\n         # Convert this code object to a code object that sets the\n         # function's first _freevar_ (not cellvar) to the argument.\n         if sys.version_info >= (3, 8):\n-            # CPython 3.8+ has an incompatible CodeType signature\n-            # (added a posonlyargcount argument) but also added\n-            # CodeType.replace() to do this without counting parameters.\n-            set_first_freevar_code = co.replace(\n-                co_cellvars=co.co_freevars, co_freevars=co.co_cellvars\n-            )\n+\n+            def set_closure_cell(cell, value):\n+                cell.cell_contents = value\n+\n         else:\n             args = [co.co_argcount]\n             args.append(co.co_kwonlyargcount)\n@@ -140,15 +138,15 @@ def force_x_to_be_a_cell():  # pragma: no cover\n             )\n             set_first_freevar_code = types.CodeType(*args)\n \n-        def set_closure_cell(cell, value):\n-            # Create a function using the set_first_freevar_code,\n-            # whose first closure cell is `cell`. Calling it will\n-            # change the value of that cell.\n-            setter = types.FunctionType(\n-                set_first_freevar_code, {}, \"setter\", (), (cell,)\n-            )\n-            # And call it to set the cell.\n-            setter(value)\n+            def set_closure_cell(cell, value):\n+                # Create a function using the set_first_freevar_code,\n+                # whose first closure cell is `cell`. Calling it will\n+                # change the value of that cell.\n+                setter = types.FunctionType(\n+                    set_first_freevar_code, {}, \"setter\", (), (cell,)\n+                )\n+                # And call it to set the cell.\n+                setter(value)\n \n         # Make sure it works on this interpreter:\n         def make_func_with_cell():\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -94,6 +94,10 @@ class C:\n         assert 1 == len(attr.fields(C))\n         assert_init_annotations(C, x=typing.List[int])\n \n+    @pytest.mark.skipif(\n+        sys.version_info[:2] < (3, 11),\n+        reason=\"Incompatible behavior on older Pythons\",\n+    )\n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_auto_attribs(self, slots):\n         \"\"\"\n@@ -149,7 +153,7 @@ class C:\n             x=typing.List[int],\n             y=int,\n             z=int,\n-            foo=typing.Optional[typing.Any],\n+            foo=typing.Any,\n         )\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n@@ -384,8 +388,9 @@ def noop():\n \n         assert attr.converters.optional(noop).__annotations__ == {}\n \n-    @pytest.mark.xfail(\n-        sys.version_info[:2] == (3, 6), reason=\"Does not work on 3.6.\"\n+    @pytest.mark.skipif(\n+        sys.version_info[:2] < (3, 11),\n+        reason=\"Incompatible behavior on older Pythons\",\n     )\n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_annotations_strings(self, slots):\n@@ -417,7 +422,7 @@ class C:\n             x=typing.List[int],\n             y=int,\n             z=int,\n-            foo=typing.Optional[typing.Any],\n+            foo=typing.Any,\n         )\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -2275,7 +2275,9 @@ class C:\n             def __getstate__(self):\n                 return (\"hi\",)\n \n-        assert None is getattr(C(), \"__setstate__\", None)\n+        assert getattr(object, \"__setstate__\", None) is getattr(\n+            C, \"__setstate__\", None\n+        )\n \n         @attr.s(slots=slots, auto_detect=True)\n         class C:\n@@ -2291,7 +2293,9 @@ def __setstate__(self, state):\n         i.__setstate__(())\n \n         assert True is i.called\n-        assert None is getattr(C(), \"__getstate__\", None)\n+        assert getattr(object, \"__getstate__\", None) is getattr(\n+            C, \"__getstate__\", None\n+        )\n \n     @pytest.mark.skipif(PY310, reason=\"Pre-3.10 only.\")\n     def test_match_args_pre_310(self):\ndiff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -660,10 +660,12 @@ def test_no_getstate_setstate_for_dict_classes(self):\n         As long as getstate_setstate is None, nothing is done to dict\n         classes.\n         \"\"\"\n-        i = C1(1, 2)\n-\n-        assert None is getattr(i, \"__getstate__\", None)\n-        assert None is getattr(i, \"__setstate__\", None)\n+        assert getattr(object, \"__getstate__\", None) is getattr(\n+            C1, \"__getstate__\", None\n+        )\n+        assert getattr(object, \"__setstate__\", None) is getattr(\n+            C1, \"__setstate__\", None\n+        )\n \n     def test_no_getstate_setstate_if_option_false(self):\n         \"\"\"\n@@ -674,10 +676,12 @@ def test_no_getstate_setstate_if_option_false(self):\n         class C:\n             x = attr.ib()\n \n-        i = C(42)\n-\n-        assert None is getattr(i, \"__getstate__\", None)\n-        assert None is getattr(i, \"__setstate__\", None)\n+        assert getattr(object, \"__getstate__\", None) is getattr(\n+            C, \"__getstate__\", None\n+        )\n+        assert getattr(object, \"__setstate__\", None) is getattr(\n+            C, \"__setstate__\", None\n+        )\n \n     @pytest.mark.parametrize(\"cls\", [C2(1), C2Slots(1)])\n     def test_getstate_set_state_force_true(self, cls):\n",
        "problem_statement": "Fix set_closure_cell on 3.11\nThe fix for 3.11 compatibility (https://github.com/python-attrs/attrs/issues/907).\r\n\r\nMaybe hold off on merging until a discussion on BPO.\n",
        "hints_text": "I guess we'll have to finish this up before 3.11? :-/\nI don't think the other failing tests were related to this, but other 3.11 incompatibilities. Since the beta is out I can revisit this",
        "created_at": "2022-06-09T12:31:11Z",
        "version": "21.4"
    }
}