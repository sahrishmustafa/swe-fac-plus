{
    "task_id": "python-attrs__attrs-189",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-189_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 189,
        "instance_id": "python-attrs__attrs-189",
        "issue_numbers": [
            "165"
        ],
        "base_commit": "fbe0bd5967801ecff11bda0918e9ecda66ab75fd",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -7,12 +7,17 @@\n \n from . import _config\n from ._compat import PY2, iteritems, isclass, iterkeys, metadata_proxy\n-from .exceptions import FrozenInstanceError, NotAnAttrsClassError\n+from .exceptions import (\n+    DefaultAlreadySetError,\n+    FrozenInstanceError,\n+    NotAnAttrsClassError,\n+)\n \n \n # This is used at least twice, so cache it here.\n _obj_setattr = object.__setattr__\n _init_convert_pat = \"__attr_convert_{}\"\n+_init_factory_pat = \"__attr_factory_{}\"\n _tuple_property_pat = \"    {attr_name} = property(itemgetter({index}))\"\n _empty_metadata_singleton = metadata_proxy({})\n \n@@ -701,21 +706,26 @@ def fmt_setter_with_converter(attr_name, value_var):\n             attrs_to_validate.append(a)\n         attr_name = a.name\n         arg_name = a.name.lstrip(\"_\")\n+        has_factory = isinstance(a.default, Factory)\n+        if has_factory and a.default.takes_self:\n+            maybe_self = \"self\"\n+        else:\n+            maybe_self = \"\"\n         if a.init is False:\n-            if isinstance(a.default, Factory):\n+            if has_factory:\n+                init_factory_name = _init_factory_pat.format(a.name)\n                 if a.convert is not None:\n                     lines.append(fmt_setter_with_converter(\n                         attr_name,\n-                        \"attr_dict['{attr_name}'].default.factory()\"\n-                        .format(attr_name=attr_name)))\n+                        init_factory_name + \"({0})\".format(maybe_self)))\n                     conv_name = _init_convert_pat.format(a.name)\n                     names_for_globals[conv_name] = a.convert\n                 else:\n                     lines.append(fmt_setter(\n                         attr_name,\n-                        \"attr_dict['{attr_name}'].default.factory()\"\n-                        .format(attr_name=attr_name)\n+                        init_factory_name + \"({0})\".format(maybe_self)\n                     ))\n+                names_for_globals[init_factory_name] = a.default.factory\n             else:\n                 if a.convert is not None:\n                     lines.append(fmt_setter_with_converter(\n@@ -731,7 +741,7 @@ def fmt_setter_with_converter(attr_name, value_var):\n                         \"attr_dict['{attr_name}'].default\"\n                         .format(attr_name=attr_name)\n                     ))\n-        elif a.default is not NOTHING and not isinstance(a.default, Factory):\n+        elif a.default is not NOTHING and not has_factory:\n             args.append(\n                 \"{arg_name}=attr_dict['{attr_name}'].default\".format(\n                     arg_name=arg_name,\n@@ -743,18 +753,18 @@ def fmt_setter_with_converter(attr_name, value_var):\n                 names_for_globals[_init_convert_pat.format(a.name)] = a.convert\n             else:\n                 lines.append(fmt_setter(attr_name, arg_name))\n-        elif a.default is not NOTHING and isinstance(a.default, Factory):\n+        elif has_factory:\n             args.append(\"{arg_name}=NOTHING\".format(arg_name=arg_name))\n             lines.append(\"if {arg_name} is not NOTHING:\"\n                          .format(arg_name=arg_name))\n+            init_factory_name = _init_factory_pat.format(a.name)\n             if a.convert is not None:\n                 lines.append(\"    \" + fmt_setter_with_converter(attr_name,\n                                                                 arg_name))\n                 lines.append(\"else:\")\n                 lines.append(\"    \" + fmt_setter_with_converter(\n                     attr_name,\n-                    \"attr_dict['{attr_name}'].default.factory()\"\n-                    .format(attr_name=attr_name)\n+                    init_factory_name + \"({0})\".format(maybe_self)\n                 ))\n                 names_for_globals[_init_convert_pat.format(a.name)] = a.convert\n             else:\n@@ -762,9 +772,9 @@ def fmt_setter_with_converter(attr_name, value_var):\n                 lines.append(\"else:\")\n                 lines.append(\"    \" + fmt_setter(\n                     attr_name,\n-                    \"attr_dict['{attr_name}'].default.factory()\"\n-                    .format(attr_name=attr_name)\n+                    init_factory_name + \"({0})\".format(maybe_self)\n                 ))\n+            names_for_globals[init_factory_name] = a.default.factory\n         else:\n             args.append(arg_name)\n             if a.convert is not None:\n@@ -808,21 +818,21 @@ class Attribute(object):\n         \"convert\", \"metadata\",\n     )\n \n-    def __init__(self, name, default, _validator, repr, cmp, hash, init,\n+    def __init__(self, name, _default, _validator, repr, cmp, hash, init,\n                  convert=None, metadata=None):\n         # Cache this descriptor here to speed things up later.\n-        __bound_setattr = _obj_setattr.__get__(self, Attribute)\n-\n-        __bound_setattr(\"name\", name)\n-        __bound_setattr(\"default\", default)\n-        __bound_setattr(\"validator\", _validator)\n-        __bound_setattr(\"repr\", repr)\n-        __bound_setattr(\"cmp\", cmp)\n-        __bound_setattr(\"hash\", hash)\n-        __bound_setattr(\"init\", init)\n-        __bound_setattr(\"convert\", convert)\n-        __bound_setattr(\"metadata\", (metadata_proxy(metadata) if metadata\n-                                     else _empty_metadata_singleton))\n+        bound_setattr = _obj_setattr.__get__(self, Attribute)\n+\n+        bound_setattr(\"name\", name)\n+        bound_setattr(\"default\", _default)\n+        bound_setattr(\"validator\", _validator)\n+        bound_setattr(\"repr\", repr)\n+        bound_setattr(\"cmp\", cmp)\n+        bound_setattr(\"hash\", hash)\n+        bound_setattr(\"init\", init)\n+        bound_setattr(\"convert\", convert)\n+        bound_setattr(\"metadata\", (metadata_proxy(metadata) if metadata\n+                                   else _empty_metadata_singleton))\n \n     def __setattr__(self, name, value):\n         raise FrozenInstanceError()\n@@ -832,8 +842,10 @@ def from_counting_attr(cls, name, ca):\n         inst_dict = {\n             k: getattr(ca, k)\n             for k\n-            in Attribute.__slots__ + (\"_validator\",)\n-            if k != \"name\" and k != \"validator\"  # `validator` is a method\n+            in Attribute.__slots__ + (\"_validator\", \"_default\")\n+            if k != \"name\" and k not in (\n+                \"validator\", \"default\",\n+            )  # exclude methods\n         }\n         return cls(name=name, **inst_dict)\n \n@@ -850,16 +862,16 @@ def __setstate__(self, state):\n         \"\"\"\n         Play nice with pickle.\n         \"\"\"\n-        __bound_setattr = _obj_setattr.__get__(self, Attribute)\n+        bound_setattr = _obj_setattr.__get__(self, Attribute)\n         for name, value in zip(self.__slots__, state):\n             if name != \"metadata\":\n-                __bound_setattr(name, value)\n+                bound_setattr(name, value)\n             else:\n-                __bound_setattr(name, metadata_proxy(value) if value else\n-                                _empty_metadata_singleton)\n+                bound_setattr(name, metadata_proxy(value) if value else\n+                              _empty_metadata_singleton)\n \n \n-_a = [Attribute(name=name, default=NOTHING, _validator=None,\n+_a = [Attribute(name=name, _default=NOTHING, _validator=None,\n                 repr=True, cmp=True, hash=(name != \"metadata\"), init=True)\n       for name in Attribute.__slots__]\n \n@@ -877,15 +889,15 @@ class _CountingAttr(object):\n     *Internal* data structure of the attrs library.  Running into is most\n     likely the result of a bug like a forgotten `@attr.s` decorator.\n     \"\"\"\n-    __slots__ = (\"counter\", \"default\", \"repr\", \"cmp\", \"hash\", \"init\",\n+    __slots__ = (\"counter\", \"_default\", \"repr\", \"cmp\", \"hash\", \"init\",\n                  \"metadata\", \"_validator\", \"convert\")\n     __attrs_attrs__ = tuple(\n-        Attribute(name=name, default=NOTHING, _validator=None,\n+        Attribute(name=name, _default=NOTHING, _validator=None,\n                   repr=True, cmp=True, hash=True, init=True)\n         for name\n-        in (\"counter\", \"default\", \"repr\", \"cmp\", \"hash\", \"init\",)\n+        in (\"counter\", \"_default\", \"repr\", \"cmp\", \"hash\", \"init\",)\n     ) + (\n-        Attribute(name=\"metadata\", default=None, _validator=None,\n+        Attribute(name=\"metadata\", _default=None, _validator=None,\n                   repr=True, cmp=True, hash=False, init=True),\n     )\n     cls_counter = 0\n@@ -894,7 +906,7 @@ def __init__(self, default, validator, repr, cmp, hash, init, convert,\n                  metadata):\n         _CountingAttr.cls_counter += 1\n         self.counter = _CountingAttr.cls_counter\n-        self.default = default\n+        self._default = default\n         # If validator is a list/tuple, wrap it using helper validator.\n         if validator and isinstance(validator, (list, tuple)):\n             self._validator = and_(*validator)\n@@ -912,6 +924,8 @@ def validator(self, meth):\n         Decorator that adds *meth* to the list of validators.\n \n         Returns *meth* unchanged.\n+\n+        .. versionadded:: 17.1.0\n         \"\"\"\n         if self._validator is None:\n             self._validator = meth\n@@ -919,19 +933,52 @@ def validator(self, meth):\n             self._validator = and_(self._validator, meth)\n         return meth\n \n+    def default(self, meth):\n+        \"\"\"\n+        Decorator that allows to set the default for an attribute.\n+\n+        Returns *meth* unchanged.\n+\n+        :raises DefaultAlreadySetError: If default has been set before.\n+\n+        .. versionadded:: 17.1.0\n+        \"\"\"\n+        if self._default is not NOTHING:\n+            raise DefaultAlreadySetError()\n+\n+        self._default = Factory(meth, takes_self=True)\n+\n+        return meth\n+\n \n _CountingAttr = _add_cmp(_add_repr(_CountingAttr))\n \n \n-@attributes(slots=True)\n+@attributes(slots=True, init=False)\n class Factory(object):\n     \"\"\"\n     Stores a factory callable.\n \n     If passed as the default value to :func:`attr.ib`, the factory is used to\n     generate a new value.\n+\n+    :param callable factory: A callable that takes either none or exactly one\n+        mandatory positional argument depending on *takes_self*.\n+    :param bool takes_self: Pass the partially initialized instance that is\n+        being initialized as a positional argument.\n+\n+    .. versionadded:: 17.1.0  *takes_self*\n     \"\"\"\n     factory = attr()\n+    takes_self = attr()\n+\n+    def __init__(self, factory, takes_self=False):\n+        \"\"\"\n+        `Factory` is part of the default machinery so if we want a default\n+        value here, we have to implement it ourselves.\n+        \"\"\"\n+        self.factory = factory\n+        self.takes_self = takes_self\n \n \n def make_class(name, attrs, bases=(object,), **attributes_arguments):\ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\n--- a/src/attr/exceptions.py\n+++ b/src/attr/exceptions.py\n@@ -28,3 +28,12 @@ class NotAnAttrsClassError(ValueError):\n \n     .. versionadded:: 16.2.0\n     \"\"\"\n+\n+\n+class DefaultAlreadySetError(RuntimeError):\n+    \"\"\"\n+    A default has been set using ``attr.ib()`` and is attempted to be reset\n+    using the decorator.\n+\n+    .. versionadded:: 17.1.0\n+    \"\"\"\n",
        "test_patch": "diff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -109,9 +109,9 @@ def test_fields(self, cls):\n         `attr.fields` works.\n         \"\"\"\n         assert (\n-            Attribute(name=\"x\", default=foo, _validator=None,\n+            Attribute(name=\"x\", _default=foo, _validator=None,\n                       repr=True, cmp=True, hash=None, init=True),\n-            Attribute(name=\"y\", default=attr.Factory(list), _validator=None,\n+            Attribute(name=\"y\", _default=attr.Factory(list), _validator=None,\n                       repr=True, cmp=True, hash=None, init=True),\n         ) == attr.fields(cls)\n \n@@ -158,9 +158,9 @@ def test_programmatic(self, slots, frozen):\n         \"\"\"\n         PC = attr.make_class(\"PC\", [\"a\", \"b\"], slots=slots, frozen=frozen)\n         assert (\n-            Attribute(name=\"a\", default=NOTHING, _validator=None,\n+            Attribute(name=\"a\", _default=NOTHING, _validator=None,\n                       repr=True, cmp=True, hash=None, init=True),\n-            Attribute(name=\"b\", default=NOTHING, _validator=None,\n+            Attribute(name=\"b\", _default=NOTHING, _validator=None,\n                       repr=True, cmp=True, hash=None, init=True),\n         ) == attr.fields(PC)\n \n@@ -251,4 +251,23 @@ def test_subclassing_frozen_gives_frozen(self):\n \n     @pytest.mark.parametrize(\"cls\", [WithMeta, WithMetaSlots])\n     def test_metaclass_preserved(self, cls):\n+        \"\"\"\n+        Metaclass data is preserved.\n+        \"\"\"\n         assert Meta == type(cls)\n+\n+    def test_default_decorator(self):\n+        \"\"\"\n+        Default decorator sets the default and the respective method gets\n+        called.\n+        \"\"\"\n+        @attr.s\n+        class C(object):\n+            x = attr.ib(default=1)\n+            y = attr.ib()\n+\n+            @y.default\n+            def compute(self):\n+                return self.x + 1\n+\n+        assert C(1, 2) == C()\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -28,7 +28,7 @@\n     make_class,\n     validate,\n )\n-from attr.exceptions import NotAnAttrsClassError\n+from attr.exceptions import NotAnAttrsClassError, DefaultAlreadySetError\n \n from .utils import (gen_attr_names, list_of_attrs, simple_attr, simple_attrs,\n                     simple_attrs_without_metadata, simple_classes)\n@@ -105,6 +105,31 @@ def v2(self, _, __):\n \n         assert _AndValidator((v, v2,)) == a._validator\n \n+    def test_default_decorator_already_set(self):\n+        \"\"\"\n+        Raise DefaultAlreadySetError if the decorator is used after a default\n+        has been set.\n+        \"\"\"\n+        a = attr(default=42)\n+\n+        with pytest.raises(DefaultAlreadySetError):\n+            @a.default\n+            def f(self):\n+                pass\n+\n+    def test_default_decorator_sets(self):\n+        \"\"\"\n+        Decorator wraps the method in a Factory with pass_self=True and sets\n+        the default.\n+        \"\"\"\n+        a = attr()\n+\n+        @a.default\n+        def f(self):\n+            pass\n+\n+        assert Factory(f, True) == a._default\n+\n \n def make_tc():\n     class TransformC(object):\n@@ -535,6 +560,18 @@ def test_convert_factory_property(self, val, init):\n         assert c.x == val + 1\n         assert c.y == 2\n \n+    def test_factory_takes_self(self):\n+        \"\"\"\n+        If takes_self on factories is True, self is passed.\n+        \"\"\"\n+        C = make_class(\"C\", {\"x\": attr(default=Factory(\n+            (lambda self: self), takes_self=True\n+        ))})\n+\n+        i = C()\n+\n+        assert i is i.x\n+\n     def test_convert_before_validate(self):\n         \"\"\"\n         Validation happens after conversion.\ndiff --git a/tests/utils.py b/tests/utils.py\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -35,7 +35,7 @@ def simple_attr(name, default=NOTHING, validator=None, repr=True,\n     Return an attribute with a name and no other bells and whistles.\n     \"\"\"\n     return Attribute(\n-        name=name, default=default, _validator=validator, repr=repr,\n+        name=name, _default=default, _validator=validator, repr=repr,\n         cmp=cmp, hash=hash, init=init\n     )\n \n",
        "problem_statement": "attr default based on other attributes\nHi!\r\n\r\nI have unsucessfully tried to define a default value by referencing other attributes. I'm sure the code below doesnt' work for some obvious or fundamental reason, but I would be grateful for comments on how to do something like it:\r\n\r\n```python\r\nimport attr\r\nfrom attr.validators import instance_of\r\nimport datetime\r\n\r\n@attr.s\r\nclass Something:\r\n    some_date = attr.ib(validator=instance_of(datetime.date))\r\n    some_number = attr.ib(convert=float)\r\n    name = attr.ib(validator=instance_of(str),\r\n                   default=\"Generic Name {0} - {1}%\".format(\r\n                       some_date.strftime(\"%d-%b-%Y\"),\r\n                       some_number * 100)\r\n                   )\r\n\r\ns = Something(some_date=datetime.date.today(), some_number=0.375)\r\n```\r\n\r\nI included the `.strftime()` conversion to highlight that `name` doesn't see a float and a date, but a `_CountingAttr` object, hence I get an AttributeError (and a TypeError for `some_number * 100`). Since I can't reference self either, what would be the correct way to do this?\n",
        "hints_text": "Hi,\r\n\r\nfor now I suggest using `__attrs_post_init__` (http://attrs.readthedocs.io/en/stable/examples.html?highlight=attrs_post_init#other-goodies). The linked example is basically what you want.\nI have wanted to do this several times. For example, you have a test of a function which takes many inputs. You want to test this function with many different cases. So (of course) you create a quick e.g. `@attr.s class TestInput:...` for that. In many cases you want some attribute to have a default depending on other attributes, but still be able to override it. The existing options are not so good for this:\r\n\r\n- I think you can use `these` for this but it's cumbersome.\r\n- `__attrs_post_init__` is not good because you can't override it.\r\n\r\nWhat I'd want, following the ad-hoc validators example, is something like this:\r\n\r\n```\r\n@attr.s\r\nclass C:\r\n    x = attr.ib()\r\n    y = attr.ib()\r\n    z = attr.ib()\r\n\r\n    @z.default\r\n    def z_default(self, attribute):\r\n        return self.x + self.y\r\n```\r\n\r\nThis is sensitive to the initialization order. However, if you have a stateful factory, the order is already important, so this is not new. And the natural order is the definition order which is intuitive.\r\n\r\nAnother issue is that this makes it possible to specify multiple defaults. I would just raise an error if this is detected.\r\n\r\nFinal issue I can think of is that an occasional user might confuse this with a property, while it does not behave like a property:\r\n\r\n- The value is persisted.\r\n- In mutable objects, the value doesn't change if the dependencies change, unlike a dynamically-computed property.\r\n\r\nBut I think \"default\" is clear on the behavior it has.\nAt first glance I like the proposed API :)\nI guess we could have a lot fun with decorators based on `_CountingAttr`.\nI *think* I want this in 17.1 but it entirely depends on the goodwill of reviewers (most likely @Tinche \u2013 I *gotta* shanghai some innocent souls at PyCon).",
        "created_at": "2017-05-13T10:49:50Z",
        "version": "16.3"
    }
}