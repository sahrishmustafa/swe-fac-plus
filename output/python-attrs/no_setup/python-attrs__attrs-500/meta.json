{
    "task_id": "python-attrs__attrs-500",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-500_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 500,
        "instance_id": "python-attrs__attrs-500",
        "issue_numbers": [
            "368"
        ],
        "base_commit": "a35d8fb4c4c057cc6778879f2d01ac7b9ac4b6ad",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -453,6 +453,7 @@ class _ClassBuilder(object):\n         \"_has_post_init\",\n         \"_delete_attribs\",\n         \"_base_attr_map\",\n+        \"_is_exc\",\n     )\n \n     def __init__(\n@@ -465,6 +466,7 @@ def __init__(\n         auto_attribs,\n         kw_only,\n         cache_hash,\n+        is_exc,\n     ):\n         attrs, base_attrs, base_map = _transform_attrs(\n             cls, these, auto_attribs, kw_only\n@@ -482,6 +484,7 @@ def __init__(\n         self._cache_hash = cache_hash\n         self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\n         self._delete_attribs = not bool(these)\n+        self._is_exc = is_exc\n \n         self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n \n@@ -688,6 +691,7 @@ def add_init(self):\n                 self._slots,\n                 self._cache_hash,\n                 self._base_attr_map,\n+                self._is_exc,\n             )\n         )\n \n@@ -738,6 +742,7 @@ def attrs(\n     auto_attribs=False,\n     kw_only=False,\n     cache_hash=False,\n+    auto_exc=False,\n ):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -847,6 +852,19 @@ def attrs(\n         fields involved in hash code computation or mutations of the objects\n         those fields point to after object creation.  If such changes occur,\n         the behavior of the object's hash code is undefined.\n+    :param bool auto_exc: If the class subclasses :class:`BaseException`\n+        (which implicitly includes any subclass of any exception), the\n+        following happens to behave like a well-behaved Python exceptions\n+        class:\n+\n+        - the values for *cmp* and *hash* are ignored and the instances compare\n+          and hash by the instance's ids (N.B. ``attrs`` will *not* remove\n+          existing implementations of ``__hash__`` or the equality methods. It\n+          just won't add own ones.),\n+        - all attributes that are either passed into ``__init__`` or have a\n+          default value are additionally available as a tuple in the ``args``\n+          attribute,\n+        - the value of *str* is ignored leaving ``__str__`` to base classes.\n \n     .. versionadded:: 16.0.0 *slots*\n     .. versionadded:: 16.1.0 *frozen*\n@@ -866,12 +884,16 @@ def attrs(\n        to each other.\n     .. versionadded:: 18.2.0 *kw_only*\n     .. versionadded:: 18.2.0 *cache_hash*\n+    .. versionadded:: 19.1.0 *auto_exc*\n     \"\"\"\n \n     def wrap(cls):\n+\n         if getattr(cls, \"__class__\", None) is None:\n             raise TypeError(\"attrs only works with new-style classes.\")\n \n+        is_exc = auto_exc is True and issubclass(cls, BaseException)\n+\n         builder = _ClassBuilder(\n             cls,\n             these,\n@@ -881,13 +903,14 @@ def wrap(cls):\n             auto_attribs,\n             kw_only,\n             cache_hash,\n+            is_exc,\n         )\n \n         if repr is True:\n             builder.add_repr(repr_ns)\n         if str is True:\n             builder.add_str()\n-        if cmp is True:\n+        if cmp is True and not is_exc:\n             builder.add_cmp()\n \n         if hash is not True and hash is not False and hash is not None:\n@@ -902,7 +925,11 @@ def wrap(cls):\n                     \" hashing must be either explicitly or implicitly \"\n                     \"enabled.\"\n                 )\n-        elif hash is True or (hash is None and cmp is True and frozen is True):\n+        elif (\n+            hash is True\n+            or (hash is None and cmp is True and frozen is True)\n+            and is_exc is False\n+        ):\n             builder.add_hash()\n         else:\n             if cache_hash:\n@@ -1241,7 +1268,9 @@ def _add_repr(cls, ns=None, attrs=None):\n     return cls\n \n \n-def _make_init(attrs, post_init, frozen, slots, cache_hash, base_attr_map):\n+def _make_init(\n+    attrs, post_init, frozen, slots, cache_hash, base_attr_map, is_exc\n+):\n     attrs = [a for a in attrs if a.init or a.default is not NOTHING]\n \n     # We cache the generated init methods for the same kinds of attributes.\n@@ -1250,16 +1279,18 @@ def _make_init(attrs, post_init, frozen, slots, cache_hash, base_attr_map):\n     unique_filename = \"<attrs generated init {0}>\".format(sha1.hexdigest())\n \n     script, globs, annotations = _attrs_to_init_script(\n-        attrs, frozen, slots, post_init, cache_hash, base_attr_map\n+        attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc\n     )\n     locs = {}\n     bytecode = compile(script, unique_filename, \"exec\")\n     attr_dict = dict((a.name, a) for a in attrs)\n     globs.update({\"NOTHING\": NOTHING, \"attr_dict\": attr_dict})\n+\n     if frozen is True:\n         # Save the lookup overhead in __init__ if we need to circumvent\n         # immutability.\n         globs[\"_cached_setattr\"] = _obj_setattr\n+\n     eval(bytecode, globs, locs)\n \n     # In order of debuggers like PDB being able to step through the code,\n@@ -1273,6 +1304,7 @@ def _make_init(attrs, post_init, frozen, slots, cache_hash, base_attr_map):\n \n     __init__ = locs[\"__init__\"]\n     __init__.__annotations__ = annotations\n+\n     return __init__\n \n \n@@ -1287,6 +1319,7 @@ def _add_init(cls, frozen):\n         _is_slot_cls(cls),\n         cache_hash=False,\n         base_attr_map={},\n+        is_exc=False,\n     )\n     return cls\n \n@@ -1376,7 +1409,7 @@ def _is_slot_attr(a_name, base_attr_map):\n \n \n def _attrs_to_init_script(\n-    attrs, frozen, slots, post_init, cache_hash, base_attr_map\n+    attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc\n ):\n     \"\"\"\n     Return a script of an initializer for *attrs* and a dict of globals.\n@@ -1625,6 +1658,13 @@ def fmt_setter_with_converter(attr_name, value_var):\n             init_hash_cache = \"self.%s = %s\"\n         lines.append(init_hash_cache % (_hash_cache_field, \"None\"))\n \n+    # For exceptions we rely on BaseException.__init__ for proper\n+    # initialization.\n+    if is_exc:\n+        vals = \",\".join(\"self.\" + a.name for a in attrs if a.init)\n+\n+        lines.append(\"BaseException.__init__(self, %s)\" % (vals,))\n+\n     args = \", \".join(args)\n     if kw_only_args:\n         if PY2:\n",
        "test_patch": "diff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -6,6 +6,8 @@\n \n import pickle\n \n+from copy import deepcopy\n+\n import pytest\n import six\n \n@@ -508,3 +510,68 @@ class C(object):\n         assert \"property\" == attr.fields(C).property.name\n         assert \"itemgetter\" == attr.fields(C).itemgetter.name\n         assert \"x\" == attr.fields(C).x.name\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_auto_exc(self, slots, frozen):\n+        \"\"\"\n+        Classes with auto_exc=True have a Exception-style __str__, are neither\n+        comparable nor hashable, and store the fields additionally in\n+        self.args.\n+        \"\"\"\n+\n+        @attr.s(auto_exc=True, slots=slots, frozen=frozen)\n+        class FooError(Exception):\n+            x = attr.ib()\n+            y = attr.ib(init=False, default=42)\n+            z = attr.ib(init=False)\n+            a = attr.ib()\n+\n+        FooErrorMade = attr.make_class(\n+            \"FooErrorMade\",\n+            bases=(Exception,),\n+            attrs={\n+                \"x\": attr.ib(),\n+                \"y\": attr.ib(init=False, default=42),\n+                \"z\": attr.ib(init=False),\n+                \"a\": attr.ib(),\n+            },\n+            auto_exc=True,\n+            slots=slots,\n+            frozen=frozen,\n+        )\n+\n+        assert FooError(1, \"foo\") != FooError(1, \"foo\")\n+        assert FooErrorMade(1, \"foo\") != FooErrorMade(1, \"foo\")\n+\n+        for cls in (FooError, FooErrorMade):\n+            with pytest.raises(cls) as ei:\n+                raise cls(1, \"foo\")\n+\n+            e = ei.value\n+\n+            assert e is e\n+            assert e == e\n+            assert \"(1, 'foo')\" == str(e)\n+            assert (1, \"foo\") == e.args\n+\n+            with pytest.raises(TypeError):\n+                hash(e)\n+\n+            if not frozen:\n+                deepcopy(e)\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_auto_exc_one_attrib(self, slots, frozen):\n+        \"\"\"\n+        Having one attribute works with auto_exc=True.\n+\n+        Easy to get wrong with tuple literals.\n+        \"\"\"\n+\n+        @attr.s(auto_exc=True, slots=slots, frozen=frozen)\n+        class FooError(Exception):\n+            x = attr.ib()\n+\n+        FooError(1)\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1425,7 +1425,9 @@ def test_repr(self):\n         class C(object):\n             pass\n \n-        b = _ClassBuilder(C, None, True, True, False, False, False, False)\n+        b = _ClassBuilder(\n+            C, None, True, True, False, False, False, False, False\n+        )\n \n         assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n \n@@ -1437,7 +1439,9 @@ def test_returns_self(self):\n         class C(object):\n             x = attr.ib()\n \n-        b = _ClassBuilder(C, None, True, True, False, False, False, False)\n+        b = _ClassBuilder(\n+            C, None, True, True, False, False, False, False, False\n+        )\n \n         cls = (\n             b.add_cmp()\n@@ -1500,6 +1504,7 @@ class C(object):\n             frozen=False,\n             weakref_slot=True,\n             auto_attribs=False,\n+            is_exc=False,\n             kw_only=False,\n             cache_hash=False,\n         )\ndiff --git a/tests/typing_example.py b/tests/typing_example.py\n--- a/tests/typing_example.py\n+++ b/tests/typing_example.py\n@@ -80,6 +80,20 @@ class HH(DD, EE):\n c == cc\n \n \n+# Exceptions\n+@attr.s(auto_exc=True)\n+class Error(Exception):\n+    x = attr.ib()\n+\n+\n+try:\n+    raise Error(1)\n+except Error as e:\n+    e.x\n+    e.args\n+    str(e)\n+\n+\n # Converters\n # XXX: Currently converters can only be functions so none of this works\n # although the stubs should be correct.\n",
        "problem_statement": "Add a convenience flag for upcalling on Exception subclasses\nCurrently, these tests both fail on 2.7 and only the latter fails on 3.6.\r\n\r\n```python\r\n@attr.s\r\nclass E1(Exception):\r\n    x = attr.ib()\r\n    y = attr.ib()\r\n\r\n\r\ndef test_exception_init_called():\r\n    e = E1(1, 2)\r\n    assert e.args == (e.x, e.y) == (1, 2)\r\n\r\n\r\ndef test_exception_init_called_even_with_kw():\r\n    e = E1(y=3, x=4)\r\n    assert e.args == (e.x, e.y) == (4, 3)\r\n```\r\n\r\nIf attrs is overriding `__init__` then this makes sense; `args` is filled in by `__init__` in 2.x and `__new__` in 3.x, but only pulling from the `*args` and never `**kwargs`. I discussed this a bit with @markrwilliams but I'm not sure what the best way to handle an attrs-ified exception would be. Maybe it's okay to consider `args` vestigal.\r\n\r\nMostly I'm raising this on the issue tracker because there are some references to using attrs for exceptions, but only indirectly. It'd be nice to have some documentation on a suggested approach either way.\n",
        "hints_text": "Is `test_exception_init_called_even_with_kw` a valid test?\r\n\r\nThe `args` attribute on `Exception` is documented as \"The tuple of arguments given to the exception constructor.\"\r\n\r\nAnd `Exception` itself doesn't accept `kwargs`.  So I think the behavior in the case of `kwargs` to init with respect to what goes into the `args` attribute is\u2026 undefined.  So I'd have no expectation of that test passing on exception classes generically.\nI included it because of the usual attrs isomorphism:\r\n\r\n```python\r\nclass E1(Exception):\r\n    def __init__(self, x, y):\r\n        super(E1, self).__init__(x, y)\r\n        self.x = x\r\n        self.y = y\r\n```\r\n\r\nIt might not abide strictly by the documentation of `Exception` that you'd end up with `e.args == (e.x, e.y)` but I wasn't sure if a case could be made since this is how one would write the class without attrs.\nI guess what I'm saying is that it's not clear to me that when one calls the super init, that including the kwargs is a common practice.\r\n\r\nThat said, I find the `args` attribute's design to be severely lacking in clarity, basically a \"tuple of whatever rando stuff the caller threw in here\", so I'm rather sympathetic to the argument that it is vestigal.\r\n\r\nThe only reason to care about it as far as I'm aware is that it effects `str()`, and that's true even when using `attrs`, which leaves something to be desired:\r\n\r\n```console\r\n>>> str(C(1,2))\r\n'C(x=1, y=2)'\r\n>>> str(C(x=1,y=2))\r\n'C(x=1, y=2)'\r\n>>> str(E1(1,2))\r\n'(1, 2)'\r\n>>> str(E1(x=1,y=2))\r\n''\r\n```\r\n\r\nHere `E1` is defined as in your example, and `C` is the same as `E1`, but without inheriting from `Exception`.\r\n\nAfter running into #217 I came up with an `@attrs_exception` decorator that passes both of your tests on Python 2.7 (and probably 3.6):\r\n\r\n```python\r\nimport inspect\r\n\r\nimport attr\r\n\r\n\r\ndef attrs_exception(maybe_cls=None, *args, **kwargs):\r\n    r\"\"\"\r\n    A class decorator to eliminate boilerplate when creating Exceptions using\r\n    :func:`attr.s`.\r\n\r\n    Adds ``__str__`` (because Exceptions don't use ``__repr__``) and an\r\n    ``__attrs_post_init__`` that calls ``Exception.__init__`` with the class's\r\n    :func:`attr.ib`\\ s. Without this, instances cannot be deepcopied on Python 2.\r\n\r\n    ref: https://github.com/python-attrs/attrs/issues/217\r\n\r\n    :param args: additional positional arguments to be passed to :func:`attr.s`\r\n    :param kwargs: additional keyword arguments to be passed to :func:`attr.s`\r\n    \"\"\"\r\n    def wrap(cls):\r\n        def _attrs_post_init__(obj):\r\n            Exception.__init__(obj, *attr.astuple(obj))\r\n\r\n        existing_post_init = getattr(cls, '__attrs_post_init__', None)\r\n        if (\r\n            existing_post_init\r\n            and (\r\n                inspect.getsource(existing_post_init)\r\n                != inspect.getsource(_attrs_post_init__)\r\n            )\r\n        ):\r\n            raise TypeError(\r\n                \"'%s' already has an '__attrs_post_init__' method\" % (cls,),\r\n            )\r\n        if not issubclass(cls, Exception):\r\n            raise TypeError(\r\n                \"'%s' is not a subclass of Exception! Use 'attr.s' instead\" % (cls,),\r\n            )\r\n        cls.__attrs_post_init__ = _attrs_post_init__\r\n\r\n        kwargs['str'] = True\r\n        kwargs['slots'] = True\r\n        return attr.attributes(cls, *args, **kwargs)\r\n\r\n    # maybe_cls depends on the usage of the decorator. It's a class if it's\r\n    # used as @attrs_exception but None if it's used as @attrs_exception()\r\n    if maybe_cls is None:\r\n        return wrap\r\n    else:\r\n        return wrap(maybe_cls)\r\n```\r\n\r\nIf anyone is interested, I can probably put that (and its accompanying tests) on PyPI.\nSo, what we want here is basically:\r\n\r\n1. `@attr.s(str=True)`\r\n2.  All fields *additionally* put into `self.args`?\r\n3. Exceptions usually can\u2019t be compared \u2013 so maybe also `cmp=False`?\r\n\r\nI\u2019d be sympathetic to add something like `@attr.exc` since I use it quite often myself.\nJust hit this myself, blindly assuming Exceptions would work - `@attr.exc` (`@attr.err`?) would be very handy.",
        "created_at": "2019-02-10T16:13:44Z",
        "version": "18.2"
    }
}