{
    "task_id": "python-attrs__attrs-1320",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1320_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1320,
        "instance_id": "python-attrs__attrs-1320",
        "issue_numbers": [
            "1295"
        ],
        "base_commit": "09161fc9181bf94aa3bbc5509c663d736a9553dc",
        "patch": "diff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -234,6 +234,7 @@ def optional(validator):\n @attrs(repr=False, slots=True, hash=True)\n class _InValidator:\n     options = attrib()\n+    _original_options = attrib(hash=False)\n \n     def __call__(self, inst, attr, value):\n         try:\n@@ -242,23 +243,28 @@ def __call__(self, inst, attr, value):\n             in_options = False\n \n         if not in_options:\n-            msg = f\"'{attr.name}' must be in {self.options!r} (got {value!r})\"\n+            msg = f\"'{attr.name}' must be in {self._original_options!r} (got {value!r})\"\n             raise ValueError(\n                 msg,\n                 attr,\n-                self.options,\n+                self._original_options,\n                 value,\n             )\n \n     def __repr__(self):\n-        return f\"<in_ validator with options {self.options!r}>\"\n+        return f\"<in_ validator with options {self._original_options!r}>\"\n \n \n def in_(options):\n     \"\"\"\n     A validator that raises a `ValueError` if the initializer is called with a\n-    value that does not belong in the options provided.  The check is performed\n-    using ``value in options``, so *options* has to support that operation.\n+    value that does not belong in the *options* provided.\n+\n+    The check is performed using ``value in options``, so *options* has to\n+    support that operation.\n+\n+    To keep the validator hashable, dicts, lists, and sets are transparently\n+    transformed into a `tuple`.\n \n     Args:\n         options: Allowed options.\n@@ -273,8 +279,15 @@ def in_(options):\n        The ValueError was incomplete until now and only contained the human\n        readable error message. Now it contains all the information that has\n        been promised since 17.1.0.\n+    .. versionchanged:: 24.1.0\n+       *options* that are a list, dict, or a set are now transformed into a\n+       tuple to keep the validator hashable.\n     \"\"\"\n-    return _InValidator(options)\n+    repr_options = options\n+    if isinstance(options, (list, dict, set)):\n+        options = tuple(options)\n+\n+    return _InValidator(options, repr_options)\n \n \n @attrs(repr=False, slots=False, hash=True)\n",
        "test_patch": "diff --git a/tests/test_validators.py b/tests/test_validators.py\n--- a/tests/test_validators.py\n+++ b/tests/test_validators.py\n@@ -391,6 +391,7 @@ def test_success_with_value(self):\n         \"\"\"\n         v = in_([1, 2, 3])\n         a = simple_attr(\"test\")\n+\n         v(1, a, 3)\n \n     def test_fail(self):\n@@ -433,6 +434,21 @@ def test_repr(self):\n         v = in_([3, 4, 5])\n         assert (\"<in_ validator with options [3, 4, 5]>\") == repr(v)\n \n+    def test_is_hashable(self):\n+        \"\"\"\n+        `in_` is hashable, so fields using it can be used with the include and\n+        exclude filters.\n+        \"\"\"\n+\n+        @attr.s\n+        class C:\n+            x: int = attr.ib(validator=attr.validators.in_({1, 2}))\n+\n+        i = C(2)\n+\n+        attr.asdict(i, filter=attr.filters.include(lambda val: True))\n+        attr.asdict(i, filter=attr.filters.exclude(lambda val: True))\n+\n \n @pytest.fixture(\n     name=\"member_validator\",\n",
        "problem_statement": "`attr.filters.exclude` or `include` not simultaneously usable with `validators.in_` set.\nWhen using one of the mentioned filter functions in `attrs.as_dict` or `as_tuple` on frozen nodes that have attributes with `attrs.validators.in_`  set as their validator, the following TypeError is thrown: \r\n\r\n```pytb\r\n  File \"<>/venv/lib/python3.11/site-packages/attr/filters.py\", line 63, in exclude_\r\n    or attribute in attrs\r\n       ^^^^^^^^^^^^^^^^^^\r\n  File \"<>/venv/lib/python3.11/site-packages/attr/_funcs.py\", line 57, in asdict\r\n    if filter is not None and not filter(a, v):\r\n                                  ^^^^^^^^^^^^\r\n  File \"<>/venv/lib/python3.11/site-packages/attr/_next_gen.py\", line 211, in asdict\r\n    return _asdict(\r\n           ^^^^^^^^\r\n  [...]\r\nTypeError: unhashable type: 'set'\r\n``` \r\n\r\nTrying to execute line 63, in exclude_ (top of traceback) resulted in the following error:\r\n\r\n```pytb\r\nTraceback (most recent call last):\r\n [...]\r\n  File \"<attrs generated hash attr._make.Attribute>\", line 2, in __hash__\r\n    return hash((\r\n           ^^^^^^\r\n  File \"<attrs generated hash attr.validators._InValidator>\", line 2, in __hash__\r\n    return hash((\r\n           ^^^^^^\r\nTypeError: unhashable type: 'set'\r\n```\r\n\r\nTherefore I suspect, that the issue lies in hashing of `attrs.validators.in_`. \r\n\n",
        "hints_text": "Looking further into it, I noticed that this issue occurs if the options passed to to the `in_` function are not of a hashable type (in my case list objects), what made the corresponding attribute unhashable. \r\n\r\nCasting the options into a hashable type such as `tuple` or `frozenset` might resolve this issue. \r\n\nFor posterity, this is what breaks:\r\n\r\n```python\r\nimport attrs\r\n\r\n\r\n@attrs.define\r\nclass C:\r\n    x: int = attrs.field(validator=attrs.validators.in_({1, 2}))\r\n\r\n\r\ni = C(2)\r\n\r\nattrs.asdict(i, filter=attrs.filters.exclude(lambda val: True))\r\n```",
        "created_at": "2024-08-02T07:53:19Z",
        "version": "23.2"
    }
}