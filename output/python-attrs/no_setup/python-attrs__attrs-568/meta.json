{
    "task_id": "python-attrs__attrs-568",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-568_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 568,
        "instance_id": "python-attrs__attrs-568",
        "issue_numbers": [
            "212"
        ],
        "base_commit": "daf2bc8182a681ed0c85271bafbd24c2ca5ea70b",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -128,8 +128,14 @@ def attrib(\n \n     :type validator: ``callable`` or a ``list`` of ``callable``\\\\ s.\n \n-    :param bool repr: Include this attribute in the generated ``__repr__``\n-        method.\n+    :param repr: Include this attribute in the generated ``__repr__``\n+        method. If ``True``, include the attribute; if ``False``, omit it. By\n+        default, the built-in ``repr()`` function is used. To override how the\n+        attribute value is formatted, pass a ``callable`` that takes a single\n+        value and returns a string. Note that the resulting string is used\n+        as-is, i.e. it will be used directly *instead* of calling ``repr()``\n+        (the default).\n+    :type repr: a ``bool`` or a ``callable`` to use a custom function.\n     :param bool cmp: Include this attribute in the generated comparison methods\n         (``__eq__`` et al).\n     :param hash: Include this attribute in the generated ``__hash__``\n@@ -175,6 +181,7 @@ def attrib(\n        ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.\n     .. versionadded:: 18.2.0 *kw_only*\n     .. versionchanged:: 19.2.0 *convert* keyword argument removed\n+    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.\n     \"\"\"\n     if hash is not None and hash is not True and hash is not False:\n         raise TypeError(\n@@ -1210,9 +1217,17 @@ def _add_cmp(cls, attrs=None):\n \n def _make_repr(attrs, ns):\n     \"\"\"\n-    Make a repr method for *attr_names* adding *ns* to the full name.\n+    Make a repr method that includes relevant *attrs*, adding *ns* to the full\n+    name.\n     \"\"\"\n-    attr_names = tuple(a.name for a in attrs if a.repr)\n+\n+    # Figure out which attributes to include, and which function to use to\n+    # format them. The a.repr value can be either bool or a custom callable.\n+    attr_names_with_reprs = tuple(\n+        (a.name, repr if a.repr is True else a.repr)\n+        for a in attrs\n+        if a.repr is not False\n+    )\n \n     def __repr__(self):\n         \"\"\"\n@@ -1244,12 +1259,14 @@ def __repr__(self):\n         try:\n             result = [class_name, \"(\"]\n             first = True\n-            for name in attr_names:\n+            for name, attr_repr in attr_names_with_reprs:\n                 if first:\n                     first = False\n                 else:\n                     result.append(\", \")\n-                result.extend((name, \"=\", repr(getattr(self, name, NOTHING))))\n+                result.extend(\n+                    (name, \"=\", attr_repr(getattr(self, name, NOTHING)))\n+                )\n             return \"\".join(result) + \")\"\n         finally:\n             working_set.remove(id(self))\n",
        "test_patch": "diff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -227,6 +227,21 @@ def test_repr_works(self, cls):\n         \"\"\"\n         assert \"C(a=1, b=2)\" == repr(cls(1, 2))\n \n+    def test_custom_repr_works(self):\n+        \"\"\"\n+        repr returns a sensible value for attributes with a custom repr\n+        callable.\n+        \"\"\"\n+\n+        def custom_repr(value):\n+            return \"foo:\" + str(value)\n+\n+        @attr.s\n+        class C(object):\n+            a = attr.ib(repr=custom_repr)\n+\n+        assert \"C(a=foo:1)\" == repr(C(1))\n+\n     def test_infinite_recursion(self):\n         \"\"\"\n         In the presence of a cyclic graph, repr will emit an ellipsis and not\ndiff --git a/tests/typing_example.py b/tests/typing_example.py\n--- a/tests/typing_example.py\n+++ b/tests/typing_example.py\n@@ -151,3 +151,12 @@ class Validated:\n             attr.validators.instance_of(C), attr.validators.instance_of(D)\n         ),\n     )\n+\n+\n+# Custom repr()\n+@attr.s\n+class WithCustomRepr:\n+    a = attr.ib(repr=True)\n+    b = attr.ib(repr=False)\n+    c = attr.ib(repr=lambda value: \"c is for cookie\")\n+    d = attr.ib(repr=str)\n",
        "problem_statement": "Allow repr (+ str?) to take callables\nIt would be useful to be able to pass in a callable to do `repr`'ing of attributes.\r\n\r\nFor me this happens if I want to present a value in the repr differently than just `repr(foo)`, which is sometimes useful, especially if the \"different way\" is to use e.g. `reprlib.repr` to do auto-truncation of long values.\r\n\r\nBeing able to pass in callables to the `repr` argument seems at first glance like a reasonably easy way to do that.\r\n\r\nE.g.\r\n\r\n`attr.ib(repr=reprlib.repr)`\r\n\r\nand\r\n\r\n`attr.ib(repr=lambda value: repr(value) * 12)`\r\n\r\nYou could preserve backwards compatibility by having True be equivalent to `repr`, and False be a sentinel (which you need anyways).\r\n\r\nI think this could also satisfy #41, if you do the same to `attr.s`, and then provide an `attr.simple_repr`, so you'd do `attr.s(repr=attr.simple_repr)` and get the normal bracket repr instead of the eval one.\n",
        "hints_text": "See https://github.com/python-attrs/attrs/issues/224#issuecomment-319078193 for a patch to support a callable with `repr`.\nThis is an interesting idea.\r\n\r\nI think our repr support can be improved in any case; we're doing more work in the method that is generally needed, so it can be sped up by eval-ing a tailored function. Part of this work can be changing the `Attribute.repr` type to essentially be `Union[bool, Callable[[], str]` (so, either a boolean or a callable) and applying the callable when `__repr__`-ing.\nAnother use case where this is useful are numbers which you'd like to show in hexadecimal (`modifiers = attr.ib(repr=lambda mod: hex(int(mod)))`, or PyQt (not Python) enum values where you want to get a human-readable value instead of an int.\nAnother use case I have is when you have  a list attribute and you'd like `__repr__` to print out only the list length (for example in cases where it is extremely large).\r\n\r\nWould be happy to know if there is another way to do it.\r\n\nI've created a small extension which provides callable reprs and allows titles to be overridden too (e.g. for the length case cited above): [attrs_flexible_reprs.py](https://gist.github.com/gimbo/19f1fede170090fdf029a4f3f5c7fece)\r\n\r\nInput/feedback welcomed.\n@gimbo I think your flexible repr doesn\u2019t take into account our recursion handler?\r\n\r\n***\r\n\r\nRe earlier comments, I wouldn\u2019t make this issue depend on transforming our repr generator to code generation. It would be nice to have, but not required for fixing this particular issue.\n@hynek I'm sure you're right - it's very simplistic, just the simplest thing I came up with that scratched the itch I had.\r\n\r\nI haven't delved into the code of `attrs` at all - when you say \"recursion handler\" I'm guessing you mean something to handle the case where a class `A` has a field also of type `A`? Certainly my code doesn't handle that gracefully, it seems. Perhaps I'll take a look at what `attrs` does by default and try to upgrade. :-) Thanks!\nGlyph has recently taught our repr to detect loops in definitions so it doesn\u2019t run into max recursion error. You'd have to look at the current code and shoehorn the callable thing into it.",
        "created_at": "2019-09-05T12:56:14Z",
        "version": "19.1"
    }
}