{
    "task_id": "python-attrs__attrs-806",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-806_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 806,
        "instance_id": "python-attrs__attrs-806",
        "issue_numbers": [
            "804"
        ],
        "base_commit": "24a2c1e7a5b1b1b979a647de2ef36a35ff4c39a1",
        "patch": "diff --git a/src/attr/_funcs.py b/src/attr/_funcs.py\n--- a/src/attr/_funcs.py\n+++ b/src/attr/_funcs.py\n@@ -319,8 +319,7 @@ def evolve(inst, **changes):\n     Create a new instance, based on *inst* with *changes* applied.\n \n     :param inst: Instance of a class with ``attrs`` attributes.\n-    :param changes: Keyword changes in the new copy.  Nested ``attrs`` classes\n-       can be updated by passing (nested) dicts of values.\n+    :param changes: Keyword changes in the new copy.\n \n     :return: A copy of inst with *changes* incorporated.\n \n@@ -338,13 +337,8 @@ def evolve(inst, **changes):\n             continue\n         attr_name = a.name  # To deal with private attributes.\n         init_name = attr_name if attr_name[0] != \"_\" else attr_name[1:]\n-        value = getattr(inst, attr_name)\n         if init_name not in changes:\n-            # Add original value to changes\n-            changes[init_name] = value\n-        elif has(value):\n-            # Evolve nested attrs classes\n-            changes[init_name] = evolve(value, **changes[init_name])\n+            changes[init_name] = getattr(inst, attr_name)\n \n     return cls(**changes)\n \n",
        "test_patch": "diff --git a/tests/test_funcs.py b/tests/test_funcs.py\n--- a/tests/test_funcs.py\n+++ b/tests/test_funcs.py\n@@ -598,43 +598,50 @@ class C(object):\n \n         assert evolve(C(1), a=2).a == 2\n \n-    def test_recursive(self):\n+    def test_regression_attrs_classes(self):\n         \"\"\"\n-        evolve() recursively evolves nested attrs classes when a dict is\n-        passed for an attribute.\n+        evolve() can evolve fields that are instances of attrs classes.\n+\n+        Regression test for #804\n         \"\"\"\n \n         @attr.s\n-        class N2(object):\n-            e = attr.ib(type=int)\n+        class Cls1(object):\n+            param1 = attr.ib()\n \n         @attr.s\n-        class N1(object):\n-            c = attr.ib(type=N2)\n-            d = attr.ib(type=int)\n+        class Cls2(object):\n+            param2 = attr.ib()\n \n-        @attr.s\n-        class C(object):\n-            a = attr.ib(type=N1)\n-            b = attr.ib(type=int)\n+        obj2a = Cls2(param2=\"a\")\n+        obj2b = Cls2(param2=\"b\")\n \n-        c1 = C(N1(N2(1), 2), 3)\n-        c2 = evolve(c1, a={\"c\": {\"e\": 23}}, b=42)\n+        obj1a = Cls1(param1=obj2a)\n \n-        assert c2 == C(N1(N2(23), 2), 42)\n+        assert Cls1(param1=Cls2(param2=\"b\")) == attr.evolve(\n+            obj1a, param1=obj2b\n+        )\n \n-    def test_recursive_dict_val(self):\n+    def test_dicts(self):\n         \"\"\"\n-        evolve() only attempts recursion when the current value is an ``attrs``\n-        class.  Dictionaries as values can be replaced like any other value.\n+        evolve() can replace an attrs class instance with a dict.\n+\n+        See #806\n         \"\"\"\n \n         @attr.s\n-        class C(object):\n-            a = attr.ib(type=dict)\n-            b = attr.ib(type=int)\n+        class Cls1(object):\n+            param1 = attr.ib()\n+\n+        @attr.s\n+        class Cls2(object):\n+            param2 = attr.ib()\n \n-        c1 = C({\"spam\": 1}, 2)\n-        c2 = evolve(c1, a={\"eggs\": 2}, b=42)\n+        obj2a = Cls2(param2=\"a\")\n+        obj2b = {\"foo\": 42, \"param2\": 42}\n \n-        assert c2 == C({\"eggs\": 2}, 42)\n+        obj1a = Cls1(param1=obj2a)\n+\n+        assert Cls1({\"foo\": 42, \"param2\": 42}) == attr.evolve(\n+            obj1a, param1=obj2b\n+        )\n",
        "problem_statement": "`attr.evolve` no longer supports setting an attr object as attribute\nHi,\r\n\r\nI don't know if this is an intentional side-effect of #759, but `attr.evolve` no longer works in the non-recursive recursive case if the argument is an attr class.\r\n\r\nHere is a snippet to reproduce it:\r\n\r\n```py\r\nimport attr\r\n\r\n@attr.s\r\nclass Cls1:\r\n    param1 = attr.ib()\r\n\r\n\r\n@attr.s\r\nclass Cls2:\r\n    param2 = attr.ib()\r\n\r\n\r\nobj2a = Cls2(param2=\"a\")\r\nobj2b = Cls2(param2=\"b\")\r\n\r\nobj1a = Cls1(param1=obj2a)\r\nobj1b = attr.evolve(obj1a, param1=obj2b)\r\n\r\nprint(obj1b)\r\n```\r\n\r\nBefore fe6eb3120013833d1927374eb5e826b72815a775, it printed this: `Cls1(param1=Cls2(param2='b'))`\r\n\r\nBut after this commit, it raises this error:\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"test.py\", line 17, in <module>\r\n    obj1b = attr.evolve(obj1a, param1=obj2b)\r\n  File \"/home/dev/.local/lib/python3.7/site-packages/attrs-21.2.0.dev0-py3.7.egg/attr/_funcs.py\", line 347, in evolve\r\n    changes[init_name] = evolve(value, **changes[init_name])\r\nTypeError: evolve() argument after ** must be a mapping, not Cls2\r\n```\r\n\r\nThanks!\n",
        "hints_text": "same here. Issue is in attr._funcs.evolve at:\r\n```\r\n    for a in attrs:\r\n        ...\r\n        elif has(value):\r\n            # Evolve nested attrs classes\r\n            changes[init_name] = evolve(value, **changes[init_name])\r\n```\r\n`value` - is old value (param1 from example above)\r\n`changes[init_name]` - is new value (obj2b from above) \r\nbut for recursive evolve it should be dict\r\nprobably the best way to make it backward compatible will be to check\r\n`elif has(value) and isinstance(changes[init_name], Mapping):`\nYeah, we'll have to revert #759 and push out 21.2.\r\n\r\nI'm gonna wait a bit with the release to see if there's other breakages that should be fixed.",
        "created_at": "2021-05-06T12:26:12Z",
        "version": "21.1"
    }
}