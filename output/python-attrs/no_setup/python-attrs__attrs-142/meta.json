{
    "task_id": "python-attrs__attrs-142",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-142_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 142,
        "instance_id": "python-attrs__attrs-142",
        "issue_numbers": [
            "136"
        ],
        "base_commit": "0563f44b477666143fb81e9c3822de1f87b9a8c5",
        "patch": "diff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -48,8 +48,8 @@\n     \"Factory\",\n     \"NOTHING\",\n     \"asdict\",\n-    \"astuple\",\n     \"assoc\",\n+    \"astuple\",\n     \"attr\",\n     \"attrib\",\n     \"attributes\",\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -49,7 +49,7 @@ def __hash__(self):\n \n \n def attr(default=NOTHING, validator=None,\n-         repr=True, cmp=True, hash=True, init=True,\n+         repr=True, cmp=True, hash=None, init=True,\n          convert=None, metadata={}):\n     \"\"\"\n     Create a new attribute on a class.\n@@ -92,8 +92,11 @@ def attr(default=NOTHING, validator=None,\n         method.\n     :param bool cmp: Include this attribute in the generated comparison methods\n         (``__eq__`` et al).\n-    :param bool hash: Include this attribute in the generated ``__hash__``\n-        method.\n+    :param hash: Include this attribute in the generated ``__hash__``\n+        method.  If ``None`` (default), mirror *cmp*'s value.  This is the\n+        correct behavior according the Python spec.  Setting this value to\n+        anything else than ``None`` is *discouraged*.\n+    :type hash: ``bool`` or ``None``\n     :param bool init: Include this attribute in the generated ``__init__``\n         method.  It is possible to set this to ``False`` and set a default\n         value.  In that case this attributed is unconditionally initialized\n@@ -104,10 +107,16 @@ def attr(default=NOTHING, validator=None,\n         returned value will be used as the new value of the attribute.  The\n         value is converted before being passed to the validator, if any.\n     :param metadata: An arbitrary mapping, to be used by third-party\n-        components.\n+        components.  See :ref:`extending_metadata`.\n \n     ..  versionchanged:: 17.1.0 *validator* can be a ``list`` now.\n+    ..  versionchanged:: 17.1.0\n+        *hash* is ``None`` and therefore mirrors *cmp* by default .\n     \"\"\"\n+    if hash is not None and hash is not True and hash is not False:\n+        raise TypeError(\n+            \"Invalid value for hash.  Must be True, False, or None.\"\n+        )\n     return _CountingAttr(\n         default=default,\n         validator=validator,\n@@ -216,7 +225,7 @@ def _frozen_delattrs(self, name):\n \n \n def attributes(maybe_cls=None, these=None, repr_ns=None,\n-               repr=True, cmp=True, hash=True, init=True,\n+               repr=True, cmp=True, hash=None, init=True,\n                slots=False, frozen=False, str=False):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -245,8 +254,26 @@ def attributes(maybe_cls=None, these=None, repr_ns=None,\n         ``__gt__``, and ``__ge__`` methods that compare the class as if it were\n         a tuple of its ``attrs`` attributes.  But the attributes are *only*\n         compared, if the type of both classes is *identical*!\n-    :param bool hash: Create a ``__hash__`` method that returns the\n-        :func:`hash` of a tuple of all ``attrs`` attribute values.\n+    :param hash: If ``None`` (default), the ``__hash__`` method is generated\n+        according how *cmp* and *frozen* are set.\n+\n+        1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n+        2. If *cmp* is True and *frozen* is False, ``__hash__`` will be set to\n+           None, marking it unhashable (which it is).\n+        3. If *cmp* is False, ``__hash__`` will be left untouched meaning the\n+           ``__hash__`` method of the superclass will be used (if superclass is\n+           ``object``, this means it will fall back to id-based hashing.).\n+\n+        Although not recommended, you can decide for yourself and force\n+        ``attrs`` to create one (e.g. if the class is immutable even though you\n+        didn't freeze it programmatically) by passing ``True`` or not.  Both of\n+        these cases are rather special and should be used carefully.\n+\n+        See the `Python documentation \\\n+        <https://docs.python.org/3/reference/datamodel.html#object.__hash__>`_\n+        and the `GitHub issue that led to the default behavior \\\n+        <https://github.com/hynek/attrs/issues/136>`_ for more details.\n+    :type hash: ``bool`` or ``None``\n     :param bool init: Create a ``__init__`` method that initialiazes the\n         ``attrs`` attributes.  Leading underscores are stripped for the\n         argument name.  If a ``__attrs_post_init__`` method exists on the\n@@ -273,6 +300,9 @@ def attributes(maybe_cls=None, these=None, repr_ns=None,\n     ..  versionadded:: 16.0.0 *slots*\n     ..  versionadded:: 16.1.0 *frozen*\n     ..  versionadded:: 16.3.0 *str*, and support for ``__attrs_post_init__``.\n+    ..  versionchanged::\n+            17.1.0 *hash* supports ``None`` as value which is also the default\n+            now.\n     \"\"\"\n     def wrap(cls):\n         if getattr(cls, \"__class__\", None) is None:\n@@ -303,8 +333,18 @@ def wrap(cls):\n             cls.__str__ = cls.__repr__\n         if cmp is True:\n             cls = _add_cmp(cls)\n-        if hash is True:\n+\n+        if hash is not True and hash is not False and hash is not None:\n+            raise TypeError(\n+                \"Invalid value for hash.  Must be True, False, or None.\"\n+            )\n+        elif hash is False or (hash is None and cmp is False):\n+            pass\n+        elif hash is True or (hash is None and cmp is True and frozen is True):\n             cls = _add_hash(cls)\n+        else:\n+            cls.__hash__ = None\n+\n         if init is True:\n             cls = _add_init(cls, effectively_frozen)\n         if effectively_frozen is True:\n@@ -369,7 +409,9 @@ def _add_hash(cls, attrs=None):\n     Add a hash method to *cls*.\n     \"\"\"\n     if attrs is None:\n-        attrs = [a for a in cls.__attrs_attrs__ if a.hash]\n+        attrs = [a\n+                 for a in cls.__attrs_attrs__\n+                 if a.hash is True or (a.hash is None and a.cmp is True)]\n \n     def hash_(self):\n         \"\"\"\n",
        "test_patch": "diff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -1,7 +1,9 @@\n from __future__ import absolute_import, division, print_function\n+\n import pickle\n \n import pytest\n+\n from hypothesis import given\n from hypothesis.strategies import booleans\n \n@@ -91,9 +93,9 @@ def test_fields(self, cls):\n         \"\"\"\n         assert (\n             Attribute(name=\"x\", default=foo, _validator=None,\n-                      repr=True, cmp=True, hash=True, init=True),\n+                      repr=True, cmp=True, hash=None, init=True),\n             Attribute(name=\"y\", default=attr.Factory(list), _validator=None,\n-                      repr=True, cmp=True, hash=True, init=True),\n+                      repr=True, cmp=True, hash=None, init=True),\n         ) == attr.fields(cls)\n \n     @pytest.mark.parametrize(\"cls\", [C1, C1Slots])\n@@ -140,9 +142,9 @@ def test_programmatic(self, slots, frozen):\n         PC = attr.make_class(\"PC\", [\"a\", \"b\"], slots=slots, frozen=frozen)\n         assert (\n             Attribute(name=\"a\", default=NOTHING, _validator=None,\n-                      repr=True, cmp=True, hash=True, init=True),\n+                      repr=True, cmp=True, hash=None, init=True),\n             Attribute(name=\"b\", default=NOTHING, _validator=None,\n-                      repr=True, cmp=True, hash=True, init=True),\n+                      repr=True, cmp=True, hash=None, init=True),\n         ) == attr.fields(PC)\n \n     @pytest.mark.parametrize(\"cls\", [Sub, SubSlots])\ndiff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -29,8 +29,11 @@\n CmpCSlots = simple_class(cmp=True, slots=True)\n ReprC = simple_class(repr=True)\n ReprCSlots = simple_class(repr=True, slots=True)\n+\n+# HashC is hashable by explicit definition while HashCSlots is hashable\n+# implicitly.\n HashC = simple_class(hash=True)\n-HashCSlots = simple_class(hash=True, slots=True)\n+HashCSlots = simple_class(hash=None, cmp=True, frozen=True, slots=True)\n \n \n class InitC(object):\n@@ -227,15 +230,67 @@ class TestAddHash(object):\n     \"\"\"\n     Tests for `_add_hash`.\n     \"\"\"\n+    def test_enforces_type(self):\n+        \"\"\"\n+        The `hash` argument to both attrs and attrib must be None, True, or\n+        False.\n+        \"\"\"\n+        exc_args = (\"Invalid value for hash.  Must be True, False, or None.\",)\n+\n+        with pytest.raises(TypeError) as e:\n+            make_class(\"C\", {}, hash=1),\n+\n+        assert exc_args == e.value.args\n+\n+        with pytest.raises(TypeError) as e:\n+            make_class(\"C\", {\"a\": attr(hash=1)}),\n+\n+        assert exc_args == e.value.args\n+\n     @given(booleans())\n-    def test_hash(self, slots):\n+    def test_hash_attribute(self, slots):\n         \"\"\"\n-        If `hash` is False, ignore that attribute.\n+        If `hash` is False on an attribute, ignore that attribute.\n         \"\"\"\n-        C = make_class(\"C\", {\"a\": attr(hash=False), \"b\": attr()}, slots=slots)\n+        C = make_class(\"C\", {\"a\": attr(hash=False), \"b\": attr()},\n+                       slots=slots, hash=True)\n \n         assert hash(C(1, 2)) == hash(C(2, 2))\n \n+    @given(booleans())\n+    def test_hash_attribute_mirrors_cmp(self, cmp):\n+        \"\"\"\n+        If `hash` is None, the hash generation mirrors `cmp`.\n+        \"\"\"\n+        C = make_class(\"C\", {\"a\": attr(cmp=cmp)}, cmp=True, frozen=True)\n+\n+        if cmp:\n+            assert C(1) != C(2)\n+            assert hash(C(1)) != hash(C(2))\n+            assert hash(C(1)) == hash(C(1))\n+        else:\n+            assert C(1) == C(2)\n+            assert hash(C(1)) == hash(C(2))\n+\n+    @given(booleans())\n+    def test_hash_mirrors_cmp(self, cmp):\n+        \"\"\"\n+        If `hash` is None, the hash generation mirrors `cmp`.\n+        \"\"\"\n+        C = make_class(\"C\", {\"a\": attr()}, cmp=cmp, frozen=True)\n+\n+        i = C(1)\n+\n+        assert i == i\n+        assert hash(i) == hash(i)\n+\n+        if cmp:\n+            assert C(1) == C(1)\n+            assert hash(C(1)) == hash(C(1))\n+        else:\n+            assert C(1) != C(1)\n+            assert hash(C(1)) != hash(C(1))\n+\n     @pytest.mark.parametrize(\"cls\", [HashC, HashCSlots])\n     def test_hash_works(self, cls):\n         \"\"\"\n@@ -243,6 +298,20 @@ def test_hash_works(self, cls):\n         \"\"\"\n         assert hash(cls(1, 2)) != hash(cls(1, 1))\n \n+    def test_hash_default(self):\n+        \"\"\"\n+        Classes are not hashable by default.\n+        \"\"\"\n+        C = make_class(\"C\", {})\n+\n+        with pytest.raises(TypeError) as e:\n+            hash(C())\n+\n+        assert e.value.args[0] in (\n+            \"'C' objects are unhashable\",  # PyPy\n+            \"unhashable type: 'C'\",  # CPython\n+        )\n+\n \n class TestAddInit(object):\n     \"\"\"\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -159,7 +159,7 @@ class C(object):\n             \"No mandatory attributes allowed after an attribute with a \"\n             \"default value or factory.  Attribute in question: Attribute\"\n             \"(name='y', default=NOTHING, validator=None, repr=True, \"\n-            \"cmp=True, hash=True, init=True, convert=None, \"\n+            \"cmp=True, hash=None, init=True, convert=None, \"\n             \"metadata=mappingproxy({}))\",\n         ) == e.value.args\n \n@@ -213,7 +213,7 @@ class E(D):\n \n class TestAttributes(object):\n     \"\"\"\n-    Tests for the `attributes` class decorator.\n+    Tests for the `attrs`/`attr.s` class decorator.\n     \"\"\"\n     @pytest.mark.skipif(not PY2, reason=\"No old-style classes in Py3\")\n     def test_catches_old_style(self):\n@@ -262,29 +262,24 @@ def test_immutable(self, attr, attr_name):\n     ])\n     def test_adds_all_by_default(self, method_name):\n         \"\"\"\n-        If no further arguments are supplied, all add_XXX functions are\n-        applied.\n+        If no further arguments are supplied, all add_XXX functions except\n+        add_hash are applied.  __hash__ is set to None.\n         \"\"\"\n         # Set the method name to a sentinel and check whether it has been\n         # overwritten afterwards.\n         sentinel = object()\n \n-        class C1(object):\n-            x = attr()\n-\n-        setattr(C1, method_name, sentinel)\n-\n-        C1 = attributes(C1)\n-\n-        class C2(object):\n+        class C(object):\n             x = attr()\n \n-        setattr(C2, method_name, sentinel)\n+        setattr(C, method_name, sentinel)\n \n-        C2 = attributes(C2)\n+        C = attributes(C)\n+        meth = getattr(C, method_name)\n \n-        assert sentinel != getattr(C1, method_name)\n-        assert sentinel != getattr(C2, method_name)\n+        assert sentinel != meth\n+        if method_name == \"__hash__\":\n+            assert meth is None\n \n     @pytest.mark.parametrize(\"arg_name, method_name\", [\n         (\"repr\", \"__repr__\"),\n@@ -294,7 +289,7 @@ class C2(object):\n     ])\n     def test_respects_add_arguments(self, arg_name, method_name):\n         \"\"\"\n-        If a certain `add_XXX` is `True`, XXX is not added to the class.\n+        If a certain `add_XXX` is `False`, `__XXX__` is not added to the class.\n         \"\"\"\n         # Set the method name to a sentinel and check whether it has been\n         # overwritten afterwards.\n@@ -635,7 +630,6 @@ class TestMetadata(object):\n     \"\"\"\n     Tests for metadata handling.\n     \"\"\"\n-\n     @given(sorted_lists_of_attrs)\n     def test_metadata_present(self, list_of_attrs):\n         \"\"\"\ndiff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -31,7 +31,7 @@ def staticmethod():\n         return \"staticmethod\"\n \n \n-@attr.s(slots=True)\n+@attr.s(slots=True, hash=True)\n class C1Slots(object):\n     x = attr.ib(validator=attr.validators.instance_of(int))\n     y = attr.ib()\n@@ -106,7 +106,7 @@ def test_inheritance_from_nonslots():\n     Note that a slots class inheriting from an ordinary class loses most of the\n     benefits of slots classes, but it should still work.\n     \"\"\"\n-    @attr.s(slots=True)\n+    @attr.s(slots=True, hash=True)\n     class C2Slots(C1):\n         z = attr.ib()\n \n@@ -159,7 +159,7 @@ def staticmethod():\n             return \"staticmethod\"\n \n     C2Slots = attr.s(these={\"x\": attr.ib(), \"y\": attr.ib(), \"z\": attr.ib()},\n-                     init=False, slots=True)(SimpleOrdinaryClass)\n+                     init=False, slots=True, hash=True)(SimpleOrdinaryClass)\n \n     c2 = C2Slots(x=1, y=2, z=\"test\")\n     assert 1 == c2.x\n@@ -190,11 +190,11 @@ def test_inheritance_from_slots():\n     \"\"\"\n     Inheriting from an attr slot class works.\n     \"\"\"\n-    @attr.s(slots=True)\n+    @attr.s(slots=True, hash=True)\n     class C2Slots(C1Slots):\n         z = attr.ib()\n \n-    @attr.s(slots=True)\n+    @attr.s(slots=True, hash=True)\n     class C2(C1):\n         z = attr.ib()\n \n@@ -264,11 +264,11 @@ def classmethod(cls):\n         def staticmethod():\n             return \"staticmethod\"\n \n-    @attr.s(slots=True)\n+    @attr.s(slots=True, hash=True)\n     class C2Slots(C1BareSlots):\n         z = attr.ib()\n \n-    @attr.s(slots=True)\n+    @attr.s(slots=True, hash=True)\n     class C2(C1Bare):\n         z = attr.ib()\n \ndiff --git a/tests/utils.py b/tests/utils.py\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -17,18 +17,20 @@\n from attr._make import NOTHING, make_class\n \n \n-def simple_class(cmp=False, repr=False, hash=False, str=False, slots=False):\n+def simple_class(cmp=False, repr=False, hash=False, str=False, slots=False,\n+                 frozen=False):\n     \"\"\"\n     Return a new simple class.\n     \"\"\"\n     return make_class(\n         \"C\", [\"a\", \"b\"],\n         cmp=cmp, repr=repr, hash=hash, init=True, slots=slots, str=str,\n+        frozen=frozen,\n     )\n \n \n def simple_attr(name, default=NOTHING, validator=None, repr=True,\n-                cmp=True, hash=True, init=True):\n+                cmp=True, hash=None, init=True):\n     \"\"\"\n     Return an attribute with a name and no other bells and whistles.\n     \"\"\"\n",
        "problem_statement": "It doesn't make sense that cmp and hash are set independently, does it?\nRight now, `cmp=` and `hash=` are treated as independent options, both in `attr.s()` and `attr.ib()`. This does't make much sense to me.\r\n\r\nIf you do `attr.s(cmp=True, hash=False)` then you get a broken class that violates Python's invariant that objects which compare equal must hash equal (if they are hashable at all).\r\n\r\nIf you do `attr.s(cmp=False, hash=True)` then you get a class with a really weird `hash` that has lots of collisions (`Foo(x=1)` and `Foo(x=1)` are different objects so they compare non-equal, but their hashes are the same.) Also, it is broken if the object is mutable, because the hash can change over time. ...and now that I think about it, objects that have `cmp=True` also have the same problem with mutability. Actually I guess all of my `attrs` classes are currently illegal, because the defaults are to generate illegal classes. I guess I should go fix that.\r\n\r\nAnyway, I think the only plausible configurations are:\r\n* `cmp=True`, `frozen=True`, `hash=True`\r\n* `cmp=True`, `frozen=True`, hash undefined (attrs doesn't have a nice way to do this right now I think?)\r\n* `cmp=False`, `hash=False` (use `object.__hash__`)\r\n* `cmp=False`, hash undefined\r\n\r\nAnd then for `attr.ib`, why are `cmp` and `hash` separate arguments? Wouldn't it make more sense to drop the `hash` argument, and just use the logic that if `attr.ib(cmp=True)` and we're generating a hash method at all, then we should include this attrib?\r\n\n",
        "hints_text": "There\u2019s exactly one reason: unhashable attributes.  Sometimes you want an attribute contain a dictionary and still be comparable.\nOh and sometimes you want to implement `__hash__` yourself.\nSure, the \"contain a dictionary and still be comparable\" case is `cmp=True`, hash raises an error, and the implement-`__hash__`-yourself case is `cmp=False`. Once `__eq__` is defined, though, there are exactly two correct ways to implement `__hash__`: either it hashes exactly the same things that `__eq__` cares about *and* those things are immutable, or it else raises an exception.\r\n\r\nCurrently there are 2^3 = 8 possible settings for cmp/hash/frozen when calling `attr.s`, but:\r\n\r\n* if `frozen=False`, then `hash=True` is just broken (I guess modulo some edge cases around classes where some attributes are immutable in practice, and those are the only ones that participate in comparison; because of missing #133 then the only way to express this to attrs is by telling it that the whole class is mutable and then just carefully not touching the immutable subset)\r\n* if `cmp=False`, then `hash=True` is just broken\r\n* if `cmp=True`, then `hash=False` is just broken, unless the user also adds `__hash__ = None` to the body of their class\r\n\r\nAnd when calling `attr.ib`, there's literally never any options about how to set `hash`, right? Either it doesn't matter (if you used `attr.s(hash=False)`, or else it must be set to match `cmp`.\r\n\r\nMy main concern is that plain `@attr.s` by default generates broken classes, and the obvious fix of using `@attr.s(cmp=False)` doesn't fix it. So the minimal correct ways of calling `@attr.s` are either `@attr.s(frozen=True)` or `@attr.s(cmp=False, hash=False)`, right?\r\n\r\nI think in a perfect world the API I'd prefer is: `attr.s` takes two arguments, `cmp=` and `frozen=` (well and other ones that aren't relevant here, but not `hash=`). The defaults are `frozen=True`, and `cmp=<whatever frozen is set to>`. (Rationale: 99% of the time you want `frozen == cmp`, and immutable is a better default than mutable.) If `cmp=True` and `frozen=True`, then the default is to generate a `__hash__`. If `cmp=True` and `frozen=False`, then the default is to set `__hash__ = None`. If `cmp=False`, then the default is not to generate a `__hash__` at all. In all cases if the user defined `__hash__` then we leave it alone. (This covers the weird cases like if you to explicitly mark an immutable comparable object as being non-hashable, it's written:\r\n```python\r\n@attr.s(cmp=True, frozen=True)\r\nclass Foo:\r\n    __hash__ = None\r\n```\r\n)\r\n\r\nOf course backwards-compatibility is a problem...\nUgh, this is a complicated issue.\r\n\r\nI think #3 is relevant here. Some of the ideas from #3 were having `attr.value` and `attr.object` as higher-level, more opinionated wrappers for `attr.s` that made sure the affected classes made sense according to certain internal rules. Maybe defining these could be used to get around backwards compatibility problems.\r\n\r\nI agree we're maybe too trigger happy with defining hashes for classes. Making your class hashable is a complex thing. Basically the only reason to make your class hashable is to use it as a key in a dict, or to put it in a set, which introduces additional constraints, which makes this even more complex.\r\n\r\n```\r\n@attr.s(hash=False)\r\nclass A:\r\n    pass\r\n\r\nhash(A())\r\n-9223372036575954421\r\n```\r\nThis is probably a bug. (Interestingly, it will work properly and raise an exception if `slots=True`, because that will recreate the class.)\r\n\r\nI think an easy case could be made for the following change: if the class is `slots=False`, `cmp=True`, `hash=False` and `Cls.__hash__ is object.__hash__`, set `Cls.__hash__` to None (to make the class unhashable).\nThere\u2019s a lot of issues raised here and honestly I can\u2019t follow all of them.  Just as a preamble/excuse:  the reason you can set all these things is that attrs started out with a different scope.  More of a class construction kit so the users was supposed to know what they did and invariants weren\u2019t caught.  The reality changed though (which makes me happy of course) and this dark little corner is just something nobody really cared about (which is also why I\u2019m OK with being a bit more aggressive about fixing it).\r\n\r\n# What I understand:\r\n- If `hash=False` is set for the whole class, we shouldn\u2019t just not set a hash, we should set `__hash__` to None (instead of falling though to `object`\u2019s).  I agree this is a bug and I\u2019d be willing allow this change.  If anyone was relying on this behavior it's most likely a bug and it will explode loudly as it should.  Maybe it\u2019s necessary to allow the use to signal they *want* to inherit the `__hash__` because they do (god forbid) subclass something else than `object`)?  That makes me think that it would be best to use `hash=False` for current behavior and `hash=None` for the correct one (and document it properly).\r\n- We have a related issue for `cmp=False` because  `Foo(x=1) == Foo(x=1)` is `False` but `hash(Foo(x=1)) == hash(Foo(x=1))` is `True`.   `hash=None` would take care of it.\r\n- I was coming up with examples for `attr.ib(hash=False)` but the answer is always \u201cyep, but then they can also carry `cmp=False`\u201d). :)\r\n- I never really thought about it, but yeah mutable objects shouldn\u2019t have a `__hash__` at all. \u2192 `If a class defines mutable objects and implements an __eq__() method, it should not implement __hash__(), since the implementation of hashable collections requires that a key\u2019s hash value is immutable (if the object\u2019s hash value changes, it will be in the wrong hash bucket).`\r\n\r\n# What I don\u2019t understand\r\nWhat\u2019s wrong with `cmp=True, hash=None, frozen=False` because I\u2019d tend to make that the new default.  I know y\u2019all love immutable data, but let\u2019s think of the 99,999% of developers out there that don\u2019t want to slow down their software. :) \r\n\r\nThis is in line with what the Python docs say, and if people want to have it hashed, they have to put extra effort into it.  But it\u2019s still comparable.\r\n\r\n# What Should Be Done\r\n1. Add the case of `hash=None` and promote it. \r\n2. Maybe even make it default because it might be masking bugs and is currently in violation with the Python spec.\r\n3. Let\u2019s assume `hash`, `cmp`, `slots`, and `frozen` are more of internal knobs.  You list four plausible configurations, I think there\u2019s a fifth.  We should give them names and add them as high-level, opinionated templates.  Which is basically #3.  It just makes me sad, that it breaks the naming.  `@attr.s` should not become an implementation detail.  Going that way is even more fodder for #131.\r\n4. I\u2019m not sure what to do about `attr.ib()`.  With the new thinking, *un*hashable is the default.  It seems weird to add something like `hashable=True` to all attributes.  But maybe this is the lowest priority of them all.\r\n\r\nI think 1+2 is something we should tackle before the new release.\r\n\r\n***\r\n\r\nIn any case thank you for being patient with me.  It took me two coffees, to write this down and honestly I don\u2019t think anyone really thought this completely though.\r\n\r\nI\u2019d also welcome input from @glyph as usual :)\nAFAICT the cases that make sense are:\r\n\r\n* mutable object, inherit `__eq__` from superclass, inherit `__hash__` from superclass (= the default behavior if defining a class without using attrs at all)\r\n* mutable object, attrs-generated `__eq__`, `__hash__ = None`\r\n* immutable object, inherit `__eq__` from superclass, inherit `__hash__` from superclass\r\n* immutable object, attrs-generated `__eq__`, attrs-generated `__hash__`\r\n\r\nMy proposal above was that we map these 4 cases to the 4 argument patterns, respectively:\r\n\r\n* `frozen=False, cmp=False`\r\n* `frozen=False, cmp=True`\r\n* `frozen=True, cmp=False`\r\n* `frozen=True, cmp=True`\r\n\r\nSo I don't see any use for a `hash=` argument at all really... it's always implied by the other arguments. And this nicely avoids the issue you mention about having a split between high-level \"templates\" and the actual `attr.s` arguments.\r\n\r\nThe one additional wrinkle is that in *principle* someone might want something really odd, like, \"this is an immutable class with an attrs-defined `__eq__`, so it totally could be hashable, but for some reason I have decided that I never want to use it as a dictionary key, and I want to get an error if that happens\". My suggestion to cover that case is to say that if the user explicitly defines a `__hash__` in the class body, then that we always leave it alone. (So this would be written like:\r\n```python\r\n@attr.s(frozen=True, cmp=True)\r\nclass Foo:\r\n    __hash__ = None\r\n```\r\n)\r\n\r\nDoes this cover all of your 5 cases? I'm not quite clear on what they are, since the 5th one you added is already on my list of 4 :-).\r\n\r\nAnd yeah of these four cases probably the best default is `frozen=False, cmp=True`.\nMy fifth is `frozen=False, cmp=True, hash=None` which isn\u2019t in your original list.  The use of the hash argument might be debatable but it\u2019s here to stay so we have to take it into account when modeling the cases. :)\r\n\r\nMy understanding is the following:\r\n\r\n`hash=False` doesn\u2019t make sense, except when subclassing:\r\n\r\n```python\r\nclass Base:\r\n    def __hash__(self):\r\n        return something_something_very_smart_that_we_cannot_anticipate\r\n\r\n@attr.s(hash=False)\r\nclass C(Base):\r\n    ...\r\n```\r\n\r\nMain cases:\r\n\r\n- `frozen=False, cmp=True, hash=None`: normal Python class.\r\n- `frozen=False, cmp=False, hash=None`: immutable container that may contain mutable/unhashable attributes\r\n- `frozen=True, cmp=True, hash=True`: immutable container with only hashable contents\r\n\r\nValid but kind of pointless:\r\n\r\n- `frozen=False, cmp=False, hash=None`\r\n\r\n***\r\n\r\nAfter we\u2019ve added `hash=None` (and made it default), the only deficiency seems to be that there should be a nicer/more idiomatic way to define immutable containers (\u2192 #3).  People can still manually break their classes but that\u2019s their problem if they really want to, I\u2019m not their nanny.\r\n\r\nAm I missing something?\r\n\r\n***\r\n\r\nOne final thought: in attrs, True/False for hash etc always meant \u201cattrs won\u2019t attach one\u201d not \u201cclass won\u2019t have one\u201d.  Which seems fine except for `hash`.  Again, when attrs started, I had a different scope in mind\u2026\n> `hash=False` doesn\u2019t make sense, except when subclassing:\r\n\r\nI use `frozen=False, cmp=False, hash=False` all the time, for when I want `object`-style compare-and-hash-by-identity but still want to take advantage of attrs' other conveniences. (I know this is kind of an abuse of attrs compared to how you were imagining it would be used, but those conveniences are pretty convenient! :-)) I just checked and in my current code-base I have 26 uses of `@attr.s`, and they're split exactly 50/50 between ones that use `frozen=True, cmp=True, hash=True` and ones that use `frozen=False, cmp=False, hash=False`.\r\n\r\n> but it\u2019s here to stay so we have to take it into account when modeling the cases. :)\r\n\r\nWhy does it have to stay? The only case you've come up with where it's meaningful is `hash=None`, which would be a new feature anyway -- all the existing cases are either broken or redundant, no?\n> Why does it have to stay? The only case you've come up with where it's meaningful is hash=None, which would be a new feature anyway -- all the existing cases are either broken or redundant, no?\r\n\r\nThe subclassing use-case is still existent.   I want to discourage it\u2019s use but I\u2019m not comfortable to take away the knob altogether. \r\n\r\nThe only thing you\u2019re arguing against is `hash=False`, not `hash` itself, isn\u2019t it?  You said yourself, that you use it sometimes?\r\n\r\nSorry if I\u2019m too dumb to follow. :|\r\n\r\n***\r\n\r\nAnyhow:  can we agree, that adding `hash=None`, making it default, (and attending PyCon under a pseudonym) would fix the actual *bug* in attrs?\r\n\r\nThere\u2019s two additional feature requests that should be handled in separate issues:\r\n\r\n1. better way to define a class, where `hash=True` makes sense.\r\n2. do something about `attr.ib(cmp/hash)`.\r\n\r\nOr is there something I\u2019m missing?\n> The subclassing use-case is still existent. I want to discourage it\u2019s use but I\u2019m not comfortable to take away the knob altogether.\r\n\r\nsubclassing is `cmp=False, hash=False` in your proposal, and `cmp=False` in my proposal, no?\r\n\r\n> Anyhow: can we agree, that adding `hash=None`, making it default, (and attending PyCon under a pseudonym) would fix the actual *bug* in attrs?\r\n\r\nYes, this would make it so that attrs never generates classes that break Python's rules without being explicitly asked to, because it's always legal to have `__hash__ = None`. The reason I prefer my proposal is that mine does that and also avoids boilerplate in the common cases, and also removes a bunch of options that don't make any sense (e.g. `cmp=False, hash=True`).\r\n\r\nConcretely, for the project I mentioned that has 26 calls to `@attr.s`:\r\n\r\nRight now, I have:\r\n\r\n* 13 `frozen=True`\r\n* 13 `cmp=False, hash=False`\r\n\r\nWith the `hash=None`-by-default approach, I'd have to change it to:\r\n* 13 `frozen=True, hash=True`\r\n* 13 `cmp=False, hash=False`\r\n\r\nWith my proposal, it becomes:\r\n* 13 `frozen=True`\r\n* 13 `cmp=False`\r\n\r\nI.e. on this codebase then the `hash=None`-by-default approach actually increases the necessary boilerplate, while my proposal removes it.\r\n\nYour proposal is pretty much my point 1 from above.\r\n\r\nTo my maintainer eyes things look like this:\r\n\r\n1. attrs does something wrong by default.  Nobody really cares about this stuff so I\u2019m gonna take the risk and fix it to do the right thing.\r\n2. It\u2019s annoying to create certain types of classes.  I\u2019m *very* much opposed to add implicit effects by setting one or another.  But I understand where you\u2018re coming from (and @glyph basically complained about the same thing).\r\n\r\nNow, I really want to tackle those things separately because they\u2019re separate to me.  One bug and one feature.  I\u2019ll open a PR later for 1 unless you convince me it\u2019s wrong but let\u2019s talk about 2 to give your mind some peace. :)\r\n\r\n***\r\n\r\nI\u2019m thinking to talk about \u201carchetypes\u201d (code name?)?\r\n\r\nHow does this look to you:\r\n\r\n```python\r\nfrom attr.archetypes import hashable\r\n\r\n@hashable\r\nclass Item:\r\n    \"\"\"Implies frozen=True, cmp=True, hash=True.\"\"\"\r\n```\r\n\r\nThe intent would be apparent from the name, not by squinting at the combination of parameters and figuring out side-effects that would vary by attrs release.\r\n\r\nI\u2019m open to other ways to achieve that.  Adding more arguments to `@attr.s` seams like the wrong way tho?  It\u2019s pretty crowded already.",
        "created_at": "2017-02-04T12:22:14Z",
        "version": "16.3"
    }
}