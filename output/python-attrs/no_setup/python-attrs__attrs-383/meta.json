{
    "task_id": "python-attrs__attrs-383",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-383_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 383,
        "instance_id": "python-attrs__attrs-383",
        "issue_numbers": [
            "382"
        ],
        "base_commit": "8274c9fdbc1513c87272340f92cd51dfea27c2ab",
        "patch": "diff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -135,7 +135,12 @@ class _InValidator(object):\n     options = attrib()\n \n     def __call__(self, inst, attr, value):\n-        if value not in self.options:\n+        try:\n+            in_options = value in self.options\n+        except TypeError as e:  # e.g. `1 in \"abc\"`\n+            in_options = False\n+\n+        if not in_options:\n             raise ValueError(\n                 \"'{name}' must be in {options!r} (got {value!r})\"\n                 .format(name=attr.name, options=self.options, value=value)\n",
        "test_patch": "diff --git a/tests/test_validators.py b/tests/test_validators.py\n--- a/tests/test_validators.py\n+++ b/tests/test_validators.py\n@@ -243,6 +243,19 @@ def test_fail(self):\n             \"'test' must be in [1, 2, 3] (got None)\",\n         ) == e.value.args\n \n+    def test_fail_with_string(self):\n+        \"\"\"\n+        Raise ValueError if the value is outside our options when the\n+        options are specified as a string and the value is not a string.\n+        \"\"\"\n+        v = in_(\"abc\")\n+        a = simple_attr(\"test\")\n+        with pytest.raises(ValueError) as e:\n+            v(None, a, None)\n+        assert (\n+            \"'test' must be in 'abc' (got None)\",\n+        ) == e.value.args\n+\n     def test_repr(self):\n         \"\"\"\n         Returned validator has a useful `__repr__`.\n",
        "problem_statement": "Poor error message/type for validators.in_ with a string\n```python\r\nimport attr\r\n\r\n@attr.s\r\nclass C:\r\n   s = attr.ib(validator=attr.validators.in_('abc'))\r\n\r\nC(s=1)  # TypeError: 'in <string>' requires string as left operand, not int\r\n```\r\n\r\n`__contains__` behaves a little weirdly for strings, but I still think this error could be improved.\r\n\r\nObvious options would be to catch exceptions and re-raise something with a clearer error message, and/or to deprecate use of strings as the collection here.\r\n\r\nFound in attrs=18.1.0 while working on HypothesisWorks/hypothesis#954.\n",
        "hints_text": "What is the actual problem here? I don't think it's fair to expect in_ to also type check?\r\n\r\nI think you want\r\n\r\n```python\r\ns = attr.ib(validator=[attr.validators.instance_of(str), attr.validators.in_('abc')])\r\n```\r\n\r\n?\nI think the request is for something like:\r\n\r\n```python\r\n    def __call__(self, inst, attr, value):\r\n        if value not in self.options:\r\n            try:\r\n                raise ValueError(\r\n                    \"'{name}' must be in {options!r} (got {value!r})\"\r\n                    .format(name=attr.name, options=self.options, value=value)\r\n                )\r\n            except Exception as e:\r\n                raise AssertionError(\r\n                    \"in_ validator for attribute {attr} raised exception for value {value}: {error}\"\r\n                    .format(attr=attr, value=value, error=e)\r\n                )\r\n```\r\n\nAlmost - the idea is that if `value in self.options` raises an exception instead of returning a bool, we should still raise a ValueError (not e.g. TypeError), and preferably one with a useful and consistent message.\r\n\r\nI'd write this as follows, and would be happy to open a PR if that would be helpful \ud83d\ude04 \r\n\r\n```python\r\ndef __call__(self, inst, attr, value):\r\n\ttry:\r\n\t\tif value not in self.options:\r\n\t\t\traise ValueError(\r\n\t\t\t\t\"'{name}' must be in {options!r} (got {value!r})\"\r\n\t\t\t\t.format(name=attr.name, options=self.options, value=value)\r\n\t\t\t)\r\n\texcept Exception:\r\n\t\traise ValueError(\r\n\t\t\t\"'{name}' must be in {options!r} \"\r\n\t\t\t\"(got {value!r}, which caused an internal error)\"\r\n\t\t\t.format(name=attr.name, options=self.options, value=value)\r\n\t\t)\r\n```\nThe contract for validators isn't super clear in the docs, but I don't see anything that says that `ValueError` is the only acceptable sort of exception to raise.  That probably should be clarified, but I would think `TypeError` is a valid exception to raise in the case where data of the wrong type is given, as in this example.\r\n\r\nI do agree that the a better error message would be useful, but I'd definitely include the original exception text.\nUh yeah there is absolutely no contract about what kind of exceptions are raised by validators and I\u2019d even argue that changing it could be backward incompatible. \ud83e\udd14\nI think it might make some sense for us to advise that certain exceptions are used, but I wouldn't go farther than that.  Otherwise, every validator would have to wrap a try/except around it's body, which could be a best practice, but seems like a lame thing to require.\r\n\r\nWhich leaves us with: should we do better than the above error message.  I notice I wrapped the try/except in my example around the wrong code (oops).\r\n\r\nLemme try again with a different suggestion:\r\n\r\n```python\r\n    def __call__(self, inst, attr, value):\r\n        try:\r\n            in_options = value in self.options\r\n        except TypeError as e:\r\n            in_options = False\r\n\r\n        if not in_options:\r\n            raise ValueError(\r\n                \"'{name}' must be in {options!r} (got {value!r})\"\r\n                .format(name=attr.name, options=self.options, value=value)\r\n            )\r\n```\r\n\r\nI don't think trying to catch all exceptions is necessarily more correct, but we can definitely say that a non-string object isn't in the provide bucket (that happens to be a string) of options.  Since that bucket isn't required to contain objects of a homogenous type, I returning `False` is more appropriate (or consistent with, say a `list`) than raising a `TypeError`.\r\n\nI guess I would accept a PR in this case.",
        "created_at": "2018-05-23T13:16:10Z",
        "version": "18.1"
    }
}