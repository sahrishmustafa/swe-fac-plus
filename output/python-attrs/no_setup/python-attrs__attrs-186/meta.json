{
    "task_id": "python-attrs__attrs-186",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-186_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 186,
        "instance_id": "python-attrs__attrs-186",
        "issue_numbers": [
            "161"
        ],
        "base_commit": "fdfd51e249f11483a9f731a4f19282df0f97e1e7",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -897,7 +897,7 @@ def __init__(self, default, validator, repr, cmp, hash, init, convert,\n         self.default = default\n         # If validator is a list/tuple, wrap it using helper validator.\n         if validator and isinstance(validator, (list, tuple)):\n-            self._validator = _AndValidator(tuple(validator))\n+            self._validator = and_(*validator)\n         else:\n             self._validator = validator\n         self.repr = repr\n@@ -911,37 +911,18 @@ def validator(self, meth):\n         \"\"\"\n         Decorator that adds *meth* to the list of validators.\n \n-        Returns meth unchanged.\n+        Returns *meth* unchanged.\n         \"\"\"\n-        if not isinstance(self._validator, _AndValidator):\n-            self._validator = _AndValidator(\n-                (self._validator,) if self._validator else ()\n-            )\n-        self._validator.add(meth)\n+        if self._validator is None:\n+            self._validator = meth\n+        else:\n+            self._validator = and_(self._validator, meth)\n         return meth\n \n \n _CountingAttr = _add_cmp(_add_repr(_CountingAttr))\n \n \n-@attributes(slots=True)\n-class _AndValidator(object):\n-    \"\"\"\n-    Compose many validators to a single one.\n-    \"\"\"\n-    _validators = attr()\n-\n-    def __call__(self, inst, attr, value):\n-        for v in self._validators:\n-            v(inst, attr, value)\n-\n-    def add(self, validator):\n-        \"\"\"\n-        Add *validator*.  Shouldn't be called after the class is done.\n-        \"\"\"\n-        self._validators += (validator,)\n-\n-\n @attributes(slots=True)\n class Factory(object):\n     \"\"\"\n@@ -981,3 +962,40 @@ def make_class(name, attrs, bases=(object,), **attributes_arguments):\n         raise TypeError(\"attrs argument must be a dict or a list.\")\n \n     return attributes(**attributes_arguments)(type(name, bases, cls_dict))\n+\n+\n+# These are required by whithin this module so we define them here and merely\n+# import into .validators.\n+\n+\n+@attributes(slots=True)\n+class _AndValidator(object):\n+    \"\"\"\n+    Compose many validators to a single one.\n+    \"\"\"\n+    _validators = attr()\n+\n+    def __call__(self, inst, attr, value):\n+        for v in self._validators:\n+            v(inst, attr, value)\n+\n+\n+def and_(*validators):\n+    \"\"\"\n+    A validator that composes multiple validators into one.\n+\n+    When called on a value, it runs all wrapped validators.\n+\n+    :param validators: Arbitrary number of validators.\n+    :type validators: callables\n+\n+    .. versionadded:: 17.1.0\n+    \"\"\"\n+    vals = []\n+    for validator in validators:\n+        vals.extend(\n+            validator._validators if isinstance(validator, _AndValidator)\n+            else [validator]\n+        )\n+\n+    return _AndValidator(tuple(vals))\ndiff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -4,7 +4,15 @@\n \n from __future__ import absolute_import, division, print_function\n \n-from ._make import attr, attributes\n+from ._make import attr, attributes, and_, _AndValidator\n+\n+\n+__all__ = [\n+    \"and_\",\n+    \"instance_of\",\n+    \"optional\",\n+    \"provides\",\n+]\n \n \n @attributes(repr=False, slots=True)\n@@ -93,12 +101,13 @@ class _OptionalValidator(object):\n     def __call__(self, inst, attr, value):\n         if value is None:\n             return\n-        return self.validator(inst, attr, value)\n+\n+        self.validator(inst, attr, value)\n \n     def __repr__(self):\n         return (\n-            \"<optional validator for {type} or None>\"\n-            .format(type=repr(self.validator))\n+            \"<optional validator for {what} or None>\"\n+            .format(what=repr(self.validator))\n         )\n \n \n@@ -108,6 +117,13 @@ def optional(validator):\n     which can be set to ``None`` in addition to satisfying the requirements of\n     the sub-validator.\n \n-    :param validator: A validator that is used for non-``None`` values.\n+    :param validator: A validator (or a list of validators) that is used for\n+        non-``None`` values.\n+    :type validator: callable or :class:`list` of callables.\n+\n+    .. versionadded:: 15.1.0\n+    .. versionchanged:: 17.1.0 *validator* can be a list of validators.\n     \"\"\"\n+    if isinstance(validator, list):\n+        return _OptionalValidator(_AndValidator(validator))\n     return _OptionalValidator(validator)\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -21,6 +21,7 @@\n     _AndValidator,\n     _CountingAttr,\n     _transform_attrs,\n+    and_,\n     attr,\n     attributes,\n     fields,\n@@ -71,6 +72,8 @@ def v2(_, __):\n \n     def test_validator_decorator_single(self):\n         \"\"\"\n+        If _CountingAttr.validator is used as a decorator and there is no\n+        decorator set, the decorated method is used as the validator.\n         \"\"\"\n         a = attr()\n \n@@ -78,17 +81,23 @@ def test_validator_decorator_single(self):\n         def v():\n             pass\n \n-        assert _AndValidator((v,)) == a._validator\n+        assert v == a._validator\n \n-    def test_validator_decorator(self):\n+    @pytest.mark.parametrize(\"wrap\", [\n+        lambda v: v,\n+        lambda v: [v],\n+        lambda v: and_(v)\n+\n+    ])\n+    def test_validator_decorator(self, wrap):\n         \"\"\"\n-        If _CountingAttr.validator is used as a decorator, the decorated method\n-        is added to validators.\n+        If _CountingAttr.validator is used as a decorator and there is already\n+        a decorator set, the decorators are composed using `and_`.\n         \"\"\"\n         def v(_, __):\n             pass\n \n-        a = attr(validator=[v])\n+        a = attr(validator=wrap(v))\n \n         @a.validator\n         def v2(self, _, __):\ndiff --git a/tests/test_validators.py b/tests/test_validators.py\n--- a/tests/test_validators.py\n+++ b/tests/test_validators.py\n@@ -7,8 +7,9 @@\n import pytest\n import zope.interface\n \n-from attr.validators import instance_of, provides, optional\n+from attr.validators import and_, instance_of, provides, optional\n from attr._compat import TYPE\n+from attr._make import attributes, attr\n \n from .utils import simple_attr\n \n@@ -58,6 +59,53 @@ def test_repr(self):\n         ) == repr(v)\n \n \n+def always_pass(_, __, ___):\n+    \"\"\"\n+    Toy validator that always passses.\n+    \"\"\"\n+\n+\n+def always_fail(_, __, ___):\n+    \"\"\"\n+    Toy validator that always fails.\n+    \"\"\"\n+    0/0\n+\n+\n+class TestAnd(object):\n+    def test_success(self):\n+        \"\"\"\n+        Succeeds if all wrapped validators succeed.\n+        \"\"\"\n+        v = and_(instance_of(int), always_pass)\n+\n+        v(None, simple_attr(\"test\"), 42)\n+\n+    def test_fail(self):\n+        \"\"\"\n+        Fails if any wrapped validator fails.\n+        \"\"\"\n+        v = and_(instance_of(int), always_fail)\n+\n+        with pytest.raises(ZeroDivisionError):\n+            v(None, simple_attr(\"test\"), 42)\n+\n+    def test_sugar(self):\n+        \"\"\"\n+        `and_(v1, v2, v3)` and `[v1, v2, v3]` are equivalent.\n+        \"\"\"\n+        @attributes\n+        class C(object):\n+            a1 = attr(\"a1\", validator=and_(\n+                instance_of(int),\n+            ))\n+            a2 = attr(\"a2\", validator=[\n+                instance_of(int),\n+            ])\n+\n+        assert C.__attrs_attrs__[0].validator == C.__attrs_attrs__[1].validator\n+\n+\n class IFoo(zope.interface.Interface):\n     \"\"\"\n     An interface.\n@@ -111,29 +159,33 @@ def test_repr(self):\n         ) == repr(v)\n \n \n+@pytest.mark.parametrize(\"validator\", [\n+    instance_of(int),\n+    [always_pass, instance_of(int)],\n+])\n class TestOptional(object):\n     \"\"\"\n     Tests for `optional`.\n     \"\"\"\n-    def test_success_with_type(self):\n+    def test_success(self, validator):\n         \"\"\"\n-        Nothing happens if types match.\n+        Nothing happens if validator succeeds.\n         \"\"\"\n-        v = optional(instance_of(int))\n+        v = optional(validator)\n         v(None, simple_attr(\"test\"), 42)\n \n-    def test_success_with_none(self):\n+    def test_success_with_none(self, validator):\n         \"\"\"\n         Nothing happens if None.\n         \"\"\"\n-        v = optional(instance_of(int))\n+        v = optional(validator)\n         v(None, simple_attr(\"test\"), None)\n \n-    def test_fail(self):\n+    def test_fail(self, validator):\n         \"\"\"\n         Raises `TypeError` on wrong types.\n         \"\"\"\n-        v = optional(instance_of(int))\n+        v = optional(validator)\n         a = simple_attr(\"test\")\n         with pytest.raises(TypeError) as e:\n             v(None, a, \"42\")\n@@ -144,13 +196,21 @@ def test_fail(self):\n \n         ) == e.value.args\n \n-    def test_repr(self):\n+    def test_repr(self, validator):\n         \"\"\"\n         Returned validator has a useful `__repr__`.\n         \"\"\"\n-        v = optional(instance_of(int))\n-        assert (\n-            (\"<optional validator for <instance_of validator for type \"\n-             \"<{type} 'int'>> or None>\")\n-            .format(type=TYPE)\n-        ) == repr(v)\n+        v = optional(validator)\n+\n+        if isinstance(validator, list):\n+            assert (\n+                (\"<optional validator for _AndValidator(_validators=[{func}, \"\n+                 \"<instance_of validator for type <{type} 'int'>>]) or None>\")\n+                .format(func=repr(always_pass), type=TYPE)\n+            ) == repr(v)\n+        else:\n+            assert (\n+                (\"<optional validator for <instance_of validator for type \"\n+                 \"<{type} 'int'>> or None>\")\n+                .format(type=TYPE)\n+            ) == repr(v)\n",
        "problem_statement": "validators.optional should take lists like validator=\nWe\u2019ve added the support for taking a list of validators to validator=, optional() should be able to take lists too otherwise users have to wrap all validators in the list with optional().\n",
        "hints_text": "",
        "created_at": "2017-05-10T09:52:56Z",
        "version": "16.3"
    }
}