{
    "task_id": "python-attrs__attrs-1383",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1383_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1383,
        "instance_id": "python-attrs__attrs-1383",
        "issue_numbers": [
            "1313"
        ],
        "base_commit": "103d51f6efa36efcc7be4adecfd571da3f63291c",
        "patch": "diff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -10,7 +10,7 @@\n from . import converters, exceptions, filters, setters, validators\n from ._cmp import cmp_using\n from ._config import get_run_validators, set_run_validators\n-from ._funcs import asdict, assoc, astuple, evolve, has, resolve_types\n+from ._funcs import asdict, assoc, astuple, has, resolve_types\n from ._make import (\n     NOTHING,\n     Attribute,\n@@ -19,6 +19,7 @@\n     _Nothing,\n     attrib,\n     attrs,\n+    evolve,\n     fields,\n     fields_dict,\n     make_class,\ndiff --git a/src/attr/_funcs.py b/src/attr/_funcs.py\n--- a/src/attr/_funcs.py\n+++ b/src/attr/_funcs.py\n@@ -394,60 +394,6 @@ def assoc(inst, **changes):\n     return new\n \n \n-def evolve(*args, **changes):\n-    \"\"\"\n-    Create a new instance, based on the first positional argument with\n-    *changes* applied.\n-\n-    Args:\n-\n-        inst:\n-            Instance of a class with *attrs* attributes. *inst* must be passed\n-            as a positional argument.\n-\n-        changes:\n-            Keyword changes in the new copy.\n-\n-    Returns:\n-        A copy of inst with *changes* incorporated.\n-\n-    Raises:\n-        TypeError:\n-            If *attr_name* couldn't be found in the class ``__init__``.\n-\n-        attrs.exceptions.NotAnAttrsClassError:\n-            If *cls* is not an *attrs* class.\n-\n-    .. versionadded:: 17.1.0\n-    .. deprecated:: 23.1.0\n-       It is now deprecated to pass the instance using the keyword argument\n-       *inst*. It will raise a warning until at least April 2024, after which\n-       it will become an error. Always pass the instance as a positional\n-       argument.\n-    .. versionchanged:: 24.1.0\n-       *inst* can't be passed as a keyword argument anymore.\n-    \"\"\"\n-    try:\n-        (inst,) = args\n-    except ValueError:\n-        msg = (\n-            f\"evolve() takes 1 positional argument, but {len(args)} were given\"\n-        )\n-        raise TypeError(msg) from None\n-\n-    cls = inst.__class__\n-    attrs = fields(cls)\n-    for a in attrs:\n-        if not a.init:\n-            continue\n-        attr_name = a.name  # To deal with private attributes.\n-        init_name = a.alias\n-        if init_name not in changes:\n-            changes[init_name] = getattr(inst, attr_name)\n-\n-    return cls(**changes)\n-\n-\n def resolve_types(\n     cls, globalns=None, localns=None, attribs=None, include_extras=True\n ):\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -22,6 +22,7 @@\n from ._compat import (\n     PY_3_10_PLUS,\n     PY_3_11_PLUS,\n+    PY_3_13_PLUS,\n     _AnnotationExtractor,\n     _get_annotations,\n     get_generic_base,\n@@ -565,6 +566,64 @@ def _frozen_delattrs(self, name):\n     raise FrozenInstanceError\n \n \n+def evolve(*args, **changes):\n+    \"\"\"\n+    Create a new instance, based on the first positional argument with\n+    *changes* applied.\n+\n+    .. tip::\n+\n+       On Python 3.13 and later, you can also use `copy.replace` instead.\n+\n+    Args:\n+\n+        inst:\n+            Instance of a class with *attrs* attributes. *inst* must be passed\n+            as a positional argument.\n+\n+        changes:\n+            Keyword changes in the new copy.\n+\n+    Returns:\n+        A copy of inst with *changes* incorporated.\n+\n+    Raises:\n+        TypeError:\n+            If *attr_name* couldn't be found in the class ``__init__``.\n+\n+        attrs.exceptions.NotAnAttrsClassError:\n+            If *cls* is not an *attrs* class.\n+\n+    .. versionadded:: 17.1.0\n+    .. deprecated:: 23.1.0\n+       It is now deprecated to pass the instance using the keyword argument\n+       *inst*. It will raise a warning until at least April 2024, after which\n+       it will become an error. Always pass the instance as a positional\n+       argument.\n+    .. versionchanged:: 24.1.0\n+       *inst* can't be passed as a keyword argument anymore.\n+    \"\"\"\n+    try:\n+        (inst,) = args\n+    except ValueError:\n+        msg = (\n+            f\"evolve() takes 1 positional argument, but {len(args)} were given\"\n+        )\n+        raise TypeError(msg) from None\n+\n+    cls = inst.__class__\n+    attrs = fields(cls)\n+    for a in attrs:\n+        if not a.init:\n+            continue\n+        attr_name = a.name  # To deal with private attributes.\n+        init_name = a.alias\n+        if init_name not in changes:\n+            changes[init_name] = getattr(inst, attr_name)\n+\n+    return cls(**changes)\n+\n+\n class _ClassBuilder:\n     \"\"\"\n     Iteratively build *one* class.\n@@ -979,6 +1038,12 @@ def add_init(self):\n \n         return self\n \n+    def add_replace(self):\n+        self._cls_dict[\"__replace__\"] = self._add_method_dunders(\n+            lambda self, **changes: evolve(self, **changes)\n+        )\n+        return self\n+\n     def add_match_args(self):\n         self._cls_dict[\"__match_args__\"] = tuple(\n             field.name\n@@ -1381,6 +1446,9 @@ def wrap(cls):\n                 msg = \"Invalid value for cache_hash.  To use hash caching, init must be True.\"\n                 raise TypeError(msg)\n \n+        if PY_3_13_PLUS and not _has_own_attribute(cls, \"__replace__\"):\n+            builder.add_replace()\n+\n         if (\n             PY_3_10_PLUS\n             and match_args\n@@ -2394,7 +2462,7 @@ def evolve(self, **changes):\n         Copy *self* and apply *changes*.\n \n         This works similarly to `attrs.evolve` but that function does not work\n-        with {class}`Attribute`.\n+        with :class:`attrs.Attribute`.\n \n         It is mainly meant to be used for `transform-fields`.\n \ndiff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -316,6 +316,9 @@ def define(\n        If a class has an *inherited* classmethod called\n        ``__attrs_init_subclass__``, it is executed after the class is created.\n     .. deprecated:: 24.1.0 *hash* is deprecated in favor of *unsafe_hash*.\n+    .. versionadded:: 24.3.0\n+       Unless already present, a ``__replace__`` method is automatically\n+       created for `copy.replace` (Python 3.13+ only).\n \n     .. note::\n \n",
        "test_patch": "diff --git a/tests/test_functional.py b/tests/test_functional.py\n--- a/tests/test_functional.py\n+++ b/tests/test_functional.py\n@@ -4,6 +4,7 @@\n End-to-end tests.\n \"\"\"\n \n+import copy\n import inspect\n import pickle\n \n@@ -16,6 +17,7 @@\n \n import attr\n \n+from attr._compat import PY_3_13_PLUS\n from attr._make import NOTHING, Attribute\n from attr.exceptions import FrozenInstanceError\n \n@@ -766,3 +768,40 @@ class ToRegister(Base):\n             pass\n \n         assert [ToRegister] == REGISTRY\n+\n+\n+@pytest.mark.skipif(not PY_3_13_PLUS, reason=\"requires Python 3.13+\")\n+class TestReplace:\n+    def test_replaces(self):\n+        \"\"\"\n+        copy.replace() is added by default and works like `attrs.evolve`.\n+        \"\"\"\n+        inst = C1(1, 2)\n+\n+        assert C1(1, 42) == copy.replace(inst, y=42)\n+        assert C1(42, 2) == copy.replace(inst, x=42)\n+\n+    def test_already_has_one(self):\n+        \"\"\"\n+        If the object already has a __replace__, it's left alone.\n+        \"\"\"\n+        sentinel = object()\n+\n+        @attr.s\n+        class C:\n+            x = attr.ib()\n+\n+            __replace__ = sentinel\n+\n+        assert sentinel == C.__replace__\n+\n+    def test_invalid_field_name(self):\n+        \"\"\"\n+        Invalid field names raise a TypeError.\n+\n+        This is consistent with dataclasses.\n+        \"\"\"\n+        inst = C1(1, 2)\n+\n+        with pytest.raises(TypeError):\n+            copy.replace(inst, z=42)\n",
        "problem_statement": "`copy.replace` support\nPython 3.13 introduced the `__replace__` dunder, exposed via [`copy.replace`](https://docs.python.org/3.13/library/copy.html#copy.replace), as a [generalised method](https://discuss.python.org/t/generalize-replace-function/28511) through which to replace fields in immutable dataclass-likes.  Would you be interested in supporting it in addition to attrs' own `evolve`?\n",
        "hints_text": "Yeah, that sounds super cool!",
        "created_at": "2024-12-14T12:23:52Z",
        "version": "24.2"
    }
}