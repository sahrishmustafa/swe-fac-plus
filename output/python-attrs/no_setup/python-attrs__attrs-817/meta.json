{
    "task_id": "python-attrs__attrs-817",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-817_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 817,
        "instance_id": "python-attrs__attrs-817",
        "issue_numbers": [
            "816"
        ],
        "base_commit": "8ae2d6f1c3c067c941fd9d212e52972c7d3382cc",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -654,7 +654,7 @@ class _ClassBuilder(object):\n         \"_on_setattr\",\n         \"_slots\",\n         \"_weakref_slot\",\n-        \"_has_own_setattr\",\n+        \"_wrote_own_setattr\",\n         \"_has_custom_setattr\",\n     )\n \n@@ -701,7 +701,7 @@ def __init__(\n         self._on_setattr = on_setattr\n \n         self._has_custom_setattr = has_custom_setattr\n-        self._has_own_setattr = False\n+        self._wrote_own_setattr = False\n \n         self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n \n@@ -709,7 +709,15 @@ def __init__(\n             self._cls_dict[\"__setattr__\"] = _frozen_setattrs\n             self._cls_dict[\"__delattr__\"] = _frozen_delattrs\n \n-            self._has_own_setattr = True\n+            self._wrote_own_setattr = True\n+        elif on_setattr == setters.validate:\n+            for a in attrs:\n+                if a.validator is not None:\n+                    break\n+            else:\n+                # If class-level on_setattr is set to validating, but there's\n+                # no field to validate, pretend like there's no on_setattr.\n+                self._on_setattr = None\n \n         if getstate_setstate:\n             (\n@@ -759,7 +767,7 @@ def _patch_original_class(self):\n \n         # If we've inherited an attrs __setattr__ and don't write our own,\n         # reset it to object's.\n-        if not self._has_own_setattr and getattr(\n+        if not self._wrote_own_setattr and getattr(\n             cls, \"__attrs_own_setattr__\", False\n         ):\n             cls.__attrs_own_setattr__ = False\n@@ -787,7 +795,7 @@ def _create_slots_class(self):\n         # XXX: a non-attrs class and subclass the resulting class with an attrs\n         # XXX: class.  See `test_slotted_confused` for details.  For now that's\n         # XXX: OK with us.\n-        if not self._has_own_setattr:\n+        if not self._wrote_own_setattr:\n             cd[\"__attrs_own_setattr__\"] = False\n \n             if not self._has_custom_setattr:\n@@ -958,8 +966,7 @@ def add_init(self):\n                 self._cache_hash,\n                 self._base_attr_map,\n                 self._is_exc,\n-                self._on_setattr is not None\n-                and self._on_setattr is not setters.NO_OP,\n+                self._on_setattr,\n                 attrs_init=False,\n             )\n         )\n@@ -978,8 +985,7 @@ def add_attrs_init(self):\n                 self._cache_hash,\n                 self._base_attr_map,\n                 self._is_exc,\n-                self._on_setattr is not None\n-                and self._on_setattr is not setters.NO_OP,\n+                self._on_setattr,\n                 attrs_init=True,\n             )\n         )\n@@ -1038,7 +1044,7 @@ def __setattr__(self, name, val):\n \n         self._cls_dict[\"__attrs_own_setattr__\"] = True\n         self._cls_dict[\"__setattr__\"] = self._add_method_dunders(__setattr__)\n-        self._has_own_setattr = True\n+        self._wrote_own_setattr = True\n \n         return self\n \n@@ -2008,10 +2014,14 @@ def _make_init(\n     cache_hash,\n     base_attr_map,\n     is_exc,\n-    has_global_on_setattr,\n+    cls_on_setattr,\n     attrs_init,\n ):\n-    if frozen and has_global_on_setattr:\n+    has_cls_on_setattr = (\n+        cls_on_setattr is not None and cls_on_setattr is not setters.NO_OP\n+    )\n+\n+    if frozen and has_cls_on_setattr:\n         raise ValueError(\"Frozen classes can't use on_setattr.\")\n \n     needs_cached_setattr = cache_hash or frozen\n@@ -2030,7 +2040,7 @@ def _make_init(\n \n             needs_cached_setattr = True\n         elif (\n-            has_global_on_setattr and a.on_setattr is not setters.NO_OP\n+            has_cls_on_setattr and a.on_setattr is not setters.NO_OP\n         ) or _is_slot_attr(a.name, base_attr_map):\n             needs_cached_setattr = True\n \n@@ -2046,7 +2056,7 @@ def _make_init(\n         base_attr_map,\n         is_exc,\n         needs_cached_setattr,\n-        has_global_on_setattr,\n+        has_cls_on_setattr,\n         attrs_init,\n     )\n     if cls.__module__ in sys.modules:\n@@ -2183,7 +2193,7 @@ def _attrs_to_init_script(\n     base_attr_map,\n     is_exc,\n     needs_cached_setattr,\n-    has_global_on_setattr,\n+    has_cls_on_setattr,\n     attrs_init,\n ):\n     \"\"\"\n@@ -2257,7 +2267,7 @@ def fmt_setter_with_converter(\n \n         attr_name = a.name\n         has_on_setattr = a.on_setattr is not None or (\n-            a.on_setattr is not setters.NO_OP and has_global_on_setattr\n+            a.on_setattr is not setters.NO_OP and has_cls_on_setattr\n         )\n         arg_name = a.name.lstrip(\"_\")\n \n",
        "test_patch": "diff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -94,7 +94,7 @@ def _add_init(cls, frozen):\n         cache_hash=False,\n         base_attr_map={},\n         is_exc=False,\n-        has_global_on_setattr=False,\n+        cls_on_setattr=None,\n         attrs_init=False,\n     )\n     return cls\ndiff --git a/tests/test_functional.py b/tests/test_functional.py\n--- a/tests/test_functional.py\n+++ b/tests/test_functional.py\n@@ -4,6 +4,7 @@\n \n from __future__ import absolute_import, division, print_function\n \n+import inspect\n import pickle\n \n from copy import deepcopy\n@@ -687,3 +688,48 @@ class C(object):\n             \"2021-06-01.  Please use `eq` and `order` instead.\"\n             == w.message.args[0]\n         )\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_no_setattr_if_validate_without_validators(self, slots):\n+        \"\"\"\n+        If a class has on_setattr=attr.setters.validate (default in NG APIs)\n+        but sets no validators, don't use the (slower) setattr in __init__.\n+\n+        Regression test for #816.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=attr.setters.validate)\n+        class C(object):\n+            x = attr.ib()\n+\n+        @attr.s(on_setattr=attr.setters.validate)\n+        class D(C):\n+            y = attr.ib()\n+\n+        src = inspect.getsource(D.__init__)\n+\n+        assert \"setattr\" not in src\n+        assert \"self.x = x\" in src\n+        assert \"self.y = y\" in src\n+        assert object.__setattr__ == D.__setattr__\n+\n+    def test_on_setattr_detect_inherited_validators(self):\n+        \"\"\"\n+        _make_init detects the presence of a validator even if the field is\n+        inherited.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=attr.setters.validate)\n+        class C(object):\n+            x = attr.ib(validator=42)\n+\n+        @attr.s(on_setattr=attr.setters.validate)\n+        class D(C):\n+            y = attr.ib()\n+\n+        src = inspect.getsource(D.__init__)\n+\n+        assert \"_setattr = _cached_setattr\" in src\n+        assert \"_setattr('x', x)\" in src\n+        assert \"_setattr('y', y)\" in src\n+        assert object.__setattr__ != D.__setattr__\n",
        "problem_statement": "Warning in docs about frozen classes no longer applicable\nIf you check the docs on frozen classes (https://www.attrs.org/en/stable/how-does-it-work.html#immutability), you'll note it says \"You should avoid instantiating lots of frozen slotted classes [...] in performance-critical code.\"\r\n\r\nHowever... with `attr.define`/`attr.frozen` both take the same amount of time.\r\n\r\n```py\r\nIn [1]: import attr\r\n\r\nIn [2]: @attr.frozen\r\n   ...: class SlottedFrozen:\r\n   ...:     foo: int\r\n   ...:     bar: int\r\n   ...:     baz: str\r\n   ...:     bing: float = 5.0\r\n   ...: \r\n\r\nIn [3]: @attr.define\r\n   ...: class SlottedUnfrozen:\r\n   ...:     foo: int\r\n   ...:     bar: int\r\n   ...:     baz: str\r\n   ...:     bing: float = 5.0\r\n   ...: \r\n\r\nIn [4]: @attr.s(slots=True, frozen=True, auto_attribs=True)\r\n   ...: class OldSlottedFrozen:\r\n   ...:     foo: int\r\n   ...:     bar: int\r\n   ...:     baz: str\r\n   ...:     bing: float = 5.0\r\n   ...: \r\n\r\nIn [5]: @attr.s(slots=True, auto_attribs=True)\r\n   ...: class OldSlottedUnfrozen:\r\n   ...:     foo: int\r\n   ...:     bar: int\r\n   ...:     baz: str\r\n   ...:     bing: float = 5.0\r\n   ...: \r\n\r\nIn [6]: %timeit SlottedFrozen(7, 42, \"hi!\")\r\n553 ns \u00b1 10.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\r\n\r\nIn [7]: %timeit SlottedUnfrozen(7, 42, \"hi!\")\r\n566 ns \u00b1 17.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\r\n\r\nIn [8]: %timeit OldSlottedFrozen(7, 42, \"hi!\")\r\n553 ns \u00b1 8.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\r\n\r\nIn [9]: %timeit OldSlottedUnfrozen(7, 42, \"hi!\")\r\n296 ns \u00b1 3.09 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\r\n```\r\n\r\nWhat's up? Well, turns out the new API is setting `on_setattr=attr.setters.validate`. This turns the `__init__` from this: (old)\r\n```py\r\nIn [14]: print(inspect.getsource(OldSlottedUnfrozen.__init__))\r\ndef __init__(self, foo, bar, baz, bing=attr_dict['bing'].default):\r\n    self.foo = foo\r\n    self.bar = bar\r\n    self.baz = baz\r\n    self.bing = bing\r\n```\r\n\r\nTo this: (new)\r\n```py\r\nIn [15]: print(inspect.getsource(SlottedUnfrozen.__init__))\r\ndef __init__(self, foo, bar, baz, bing=attr_dict['bing'].default):\r\n    _setattr = _cached_setattr.__get__(self, self.__class__)\r\n    _setattr('foo', foo)\r\n    _setattr('bar', bar)\r\n    _setattr('baz', baz)\r\n    _setattr('bing', bing)\r\n```\r\n\r\nPossible solutions:\r\n - Mark that the note no longer applies\r\n - Make a fast path -- only set `on_setattr=attr.setters.validate` in new API if there is a validator.\n",
        "hints_text": "Ooph, I was not aware of this. A fast path would be great here.\nYeah fast path is definitely the way here. I'm surprised there isn't one \u2013 I suspect I just forgot to implement it.",
        "created_at": "2021-05-16T10:15:41Z",
        "version": "21.2"
    }
}