{
    "task_id": "python-attrs__attrs-642",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-642_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 642,
        "instance_id": "python-attrs__attrs-642",
        "issue_numbers": [
            "512"
        ],
        "base_commit": "784179bab6457cd603602d37865fc3ecf8a8181a",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -546,6 +546,7 @@ def __init__(\n         slots,\n         frozen,\n         weakref_slot,\n+        getstate_setstate,\n         auto_attribs,\n         kw_only,\n         cache_hash,\n@@ -576,6 +577,12 @@ def __init__(\n             self._cls_dict[\"__setattr__\"] = _frozen_setattrs\n             self._cls_dict[\"__delattr__\"] = _frozen_delattrs\n \n+        if getstate_setstate:\n+            (\n+                self._cls_dict[\"__getstate__\"],\n+                self._cls_dict[\"__setstate__\"],\n+            ) = self._make_getstate_setstate()\n+\n     def __repr__(self):\n         return \"<_ClassBuilder(cls={cls})>\".format(cls=self._cls.__name__)\n \n@@ -657,37 +664,6 @@ def _create_slots_class(self):\n         if qualname is not None:\n             cd[\"__qualname__\"] = qualname\n \n-        # __weakref__ is not writable.\n-        state_attr_names = tuple(\n-            an for an in self._attr_names if an != \"__weakref__\"\n-        )\n-\n-        def slots_getstate(self):\n-            \"\"\"\n-            Automatically created by attrs.\n-            \"\"\"\n-            return tuple(getattr(self, name) for name in state_attr_names)\n-\n-        hash_caching_enabled = self._cache_hash\n-\n-        def slots_setstate(self, state):\n-            \"\"\"\n-            Automatically created by attrs.\n-            \"\"\"\n-            __bound_setattr = _obj_setattr.__get__(self, Attribute)\n-            for name, value in zip(state_attr_names, state):\n-                __bound_setattr(name, value)\n-\n-            # The hash code cache is not included when the object is\n-            # serialized, but it still needs to be initialized to None to\n-            # indicate that the first call to __hash__ should be a cache miss.\n-            if hash_caching_enabled:\n-                __bound_setattr(_hash_cache_field, None)\n-\n-        # slots and frozen require __getstate__/__setstate__ to work\n-        cd[\"__getstate__\"] = slots_getstate\n-        cd[\"__setstate__\"] = slots_setstate\n-\n         # Create new class based on old class and our methods.\n         cls = type(self._cls)(self._cls.__name__, self._cls.__bases__, cd)\n \n@@ -737,6 +713,40 @@ def __str__(self):\n         self._cls_dict[\"__str__\"] = self._add_method_dunders(__str__)\n         return self\n \n+    def _make_getstate_setstate(self):\n+        \"\"\"\n+        Create custom __setstate__ and __getstate__ methods.\n+        \"\"\"\n+        # __weakref__ is not writable.\n+        state_attr_names = tuple(\n+            an for an in self._attr_names if an != \"__weakref__\"\n+        )\n+\n+        def slots_getstate(self):\n+            \"\"\"\n+            Automatically created by attrs.\n+            \"\"\"\n+            return tuple(getattr(self, name) for name in state_attr_names)\n+\n+        hash_caching_enabled = self._cache_hash\n+\n+        def slots_setstate(self, state):\n+            \"\"\"\n+            Automatically created by attrs.\n+            \"\"\"\n+            __bound_setattr = _obj_setattr.__get__(self, Attribute)\n+            for name, value in zip(state_attr_names, state):\n+                __bound_setattr(name, value)\n+\n+            # The hash code cache is not included when the object is\n+            # serialized, but it still needs to be initialized to None to\n+            # indicate that the first call to __hash__ should be a cache\n+            # miss.\n+            if hash_caching_enabled:\n+                __bound_setattr(_hash_cache_field, None)\n+\n+        return slots_getstate, slots_setstate\n+\n     def make_unhashable(self):\n         self._cls_dict[\"__hash__\"] = None\n         return self\n@@ -849,7 +859,9 @@ def _determine_eq_order(cmp, eq, order, default_eq):\n     return eq, order\n \n \n-def _determine_whether_to_implement(cls, flag, auto_detect, dunders):\n+def _determine_whether_to_implement(\n+    cls, flag, auto_detect, dunders, default=True\n+):\n     \"\"\"\n     Check whether we should implement a set of methods for *cls*.\n \n@@ -857,20 +869,22 @@ def _determine_whether_to_implement(cls, flag, auto_detect, dunders):\n     same as passed into @attr.s and *dunders* is a tuple of attribute names\n     whose presence signal that the user has implemented it themselves.\n \n+    Return *default* if no reason for either for or against is found.\n+\n     auto_detect must be False on Python 2.\n     \"\"\"\n-    if flag is True or flag is None and auto_detect is False:\n-        return True\n+    if flag is True or flag is False:\n+        return flag\n \n-    if flag is False:\n-        return False\n+    if flag is None and auto_detect is False:\n+        return default\n \n     # Logically, flag is None and auto_detect is True here.\n     for dunder in dunders:\n         if _has_own_attribute(cls, dunder):\n             return False\n \n-    return True\n+    return default\n \n \n def attrs(\n@@ -893,6 +907,7 @@ def attrs(\n     order=None,\n     auto_detect=False,\n     collect_by_mro=False,\n+    getstate_setstate=None,\n ):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -1060,6 +1075,21 @@ def attrs(\n        See issue `#428 <https://github.com/python-attrs/attrs/issues/428>`_ for\n        more details.\n \n+    :param Optional[bool] getstate_setstate:\n+       .. note::\n+          This is usually only interesting for slotted classes and you should\n+          probably just set *auto_detect* to `True`.\n+\n+       If `True`, ``__getstate__`` and\n+       ``__setstate__`` are generated and attached to the class. This is\n+       necessary for slotted classes to be pickleable. If left `None`, it's\n+       `True` by default for slotted classes and ``False`` for dict classes.\n+\n+       If *auto_detect* is `True`, and *getstate_setstate* is left `None`,\n+       and **either** ``__getstate__`` or ``__setstate__`` is detected directly\n+       on the class (i.e. not inherited), it is set to `False` (this is usually\n+       what you want).\n+\n     .. versionadded:: 16.0.0 *slots*\n     .. versionadded:: 16.1.0 *frozen*\n     .. versionadded:: 16.3.0 *str*\n@@ -1086,6 +1116,7 @@ def attrs(\n     .. versionadded:: 19.2.0 *eq* and *order*\n     .. versionadded:: 20.1.0 *auto_detect*\n     .. versionadded:: 20.1.0 *collect_by_mro*\n+    .. versionadded:: 20.1.0 *getstate_setstate*\n     \"\"\"\n     if auto_detect and PY2:\n         raise PythonTooOldError(\n@@ -1093,7 +1124,7 @@ def attrs(\n         )\n \n     eq_, order_ = _determine_eq_order(cmp, eq, order, None)\n-    hash_ = hash  # workaround the lack of nonlocal\n+    hash_ = hash  # work around the lack of nonlocal\n \n     def wrap(cls):\n \n@@ -1108,6 +1139,13 @@ def wrap(cls):\n             slots,\n             frozen,\n             weakref_slot,\n+            _determine_whether_to_implement(\n+                cls,\n+                getstate_setstate,\n+                auto_detect,\n+                (\"__getstate__\", \"__setstate__\"),\n+                default=slots,\n+            ),\n             auto_attribs,\n             kw_only,\n             cache_hash,\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1425,7 +1425,7 @@ class C(object):\n             pass\n \n         b = _ClassBuilder(\n-            C, None, True, True, False, False, False, False, False, True\n+            C, None, True, True, False, False, False, False, False, False, True\n         )\n \n         assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n@@ -1439,7 +1439,7 @@ class C(object):\n             x = attr.ib()\n \n         b = _ClassBuilder(\n-            C, None, True, True, False, False, False, False, False, True\n+            C, None, True, True, False, False, False, False, False, False, True\n         )\n \n         cls = (\n@@ -1510,6 +1510,7 @@ class C(object):\n             slots=False,\n             frozen=False,\n             weakref_slot=True,\n+            getstate_setstate=False,\n             auto_attribs=False,\n             is_exc=False,\n             kw_only=False,\n@@ -2101,3 +2102,32 @@ def __le__(self, o):\n         assert c1 == c1\n \n         assert c1.own_eq_called\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_detects_setstate_getstate(self, slots):\n+        \"\"\"\n+        __getstate__ and __setstate__ are not overwritten if either is present.\n+        \"\"\"\n+\n+        @attr.s(slots=slots, auto_detect=True)\n+        class C(object):\n+            def __getstate__(self):\n+                return (\"hi\",)\n+\n+        assert None is getattr(C(), \"__setstate__\", None)\n+\n+        @attr.s(slots=slots, auto_detect=True)\n+        class C(object):\n+            called = attr.ib(False)\n+\n+            def __setstate__(self, state):\n+                self.called = True\n+\n+        i = C()\n+\n+        assert False is i.called\n+\n+        i.__setstate__(())\n+\n+        assert True is i.called\n+        assert None is getattr(C(), \"__getstate__\", None)\ndiff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -2,6 +2,7 @@\n Unit tests for slots-related functionality.\n \"\"\"\n \n+import pickle\n import sys\n import types\n import weakref\n@@ -568,3 +569,59 @@ def f(self, a):\n             super(C, self).__init__()\n \n     C(field=1)\n+\n+\n+@attr.s(getstate_setstate=True)\n+class C2(object):\n+    x = attr.ib()\n+\n+\n+@attr.s(slots=True, getstate_setstate=True)\n+class C2Slots(object):\n+    x = attr.ib()\n+\n+\n+class TestPickle(object):\n+    @pytest.mark.parametrize(\"protocol\", range(pickle.HIGHEST_PROTOCOL))\n+    def test_pickleable_by_default(self, protocol):\n+        \"\"\"\n+        If nothing else is passed, slotted classes can be pickled and\n+        unpickled with all supported protocols.\n+        \"\"\"\n+        i1 = C1Slots(1, 2)\n+        i2 = pickle.loads(pickle.dumps(i1, protocol))\n+\n+        assert i1 == i2\n+        assert i1 is not i2\n+\n+    def test_no_getstate_setstate_for_dict_classes(self):\n+        \"\"\"\n+        As long as getstate_setstate is None, nothing is done to dict\n+        classes.\n+        \"\"\"\n+        i = C1(1, 2)\n+\n+        assert None is getattr(i, \"__getstate__\", None)\n+        assert None is getattr(i, \"__setstate__\", None)\n+\n+    def test_no_getstate_setstate_if_option_false(self):\n+        \"\"\"\n+        Don't add getstate/setstate if getstate_setstate is False.\n+        \"\"\"\n+\n+        @attr.s(slots=True, getstate_setstate=False)\n+        class C(object):\n+            x = attr.ib()\n+\n+        i = C(42)\n+\n+        assert None is getattr(i, \"__getstate__\", None)\n+        assert None is getattr(i, \"__setstate__\", None)\n+\n+    @pytest.mark.parametrize(\"cls\", [C2(1), C2Slots(1)])\n+    def test_getstate_set_state_force_true(self, cls):\n+        \"\"\"\n+        If getstate_setstate is True, add them unconditionally.\n+        \"\"\"\n+        assert None is not getattr(cls, \"__getstate__\", None)\n+        assert None is not getattr(cls, \"__setstate__\", None)\n",
        "problem_statement": "Support custom __getstate__, __setstate__ for slotted classes (or improve docs)?\nThe assertion fails in the following example, but is ok with `slots=False`:\r\n```\r\nimport attr, pickle\r\n\r\n@attr.s(slots=True)\r\nclass MyClass(object):\r\n    a = attr.ib()\r\n    not_picklable = attr.ib()\r\n\r\n    def __getstate__(self):\r\n        return self.a, \"replacement\"\r\n\r\n    def __setstate__(self, state):\r\n        self.a, self.not_picklable = state\r\n\r\nmc = MyClass(\"a\", \"b\")\r\nmc_new = pickle.loads(pickle.dumps(mc))\r\nassert mc_new.not_picklable == \"replacement\"\r\n```\r\nThis is clearly because `attrs` auto creates these methods on the new slots-class: https://github.com/python-attrs/attrs/blob/master/src/attr/_make.py#L601\r\n\r\nIs there another prefered way to solve this, or would it be possible to support these methods also for slots-classes? If not, it would be good to clarify this in the documentation for [slotted-classes](http://www.attrs.org/en/stable/glossary.html#term-slotted-classes), it says:\r\n\r\n> You can support protocol 0 and 1 by implementing `__getstate__` and `__setstate__` methods yourself. Those methods are created for frozen slotted classes because they won\u2019t pickle otherwise. Think twice before using pickle though.\r\n\r\nThis is confusing to me, since implementing these methods have no effect for slotted classes?\r\n\r\nSomewhat related:\r\nhttps://github.com/python-attrs/attrs/issues/139\r\nhttps://github.com/python-attrs/attrs/issues/475\n",
        "hints_text": "You have opened this issue in the best possible moment because I'm prototyping a new API right now and this might go in. No promises about timeline and whether it'll be python2-compatible for now tho.\nGlad to hear! In the meantime, I made this suggestion: https://github.com/python-attrs/attrs/pull/513. I think it makes sense. Maybe I'm missing something, but isn't the docs (referenced above) misleading/inconsistent with current behaviour?\nOk, read the docs more carefully and now understand that \"You can support protocol 0 and 1 by implementing `__getstate__` and `__setstate__` methods yourself\" refers to `__slots__` classes in general but _not_ to `attr.s(slots=True)` classes. Still don't see any downside from making it possible to define these methods in `attr.s(slots=True)` classes.\n> Ok, read the docs more carefully and now understand\r\n\r\nWith that you're way ahead of me because I don't understand that paragraph at all anymore. \ud83d\ude05\r\n\r\nIt would be great if we could rewrite it once this has been resolved.",
        "created_at": "2020-04-28T09:55:40Z",
        "version": "19.3"
    }
}