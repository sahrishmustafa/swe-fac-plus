{
    "task_id": "python-attrs__attrs-1009",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1009_2025-07-03_17-42-31",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1009,
        "instance_id": "python-attrs__attrs-1009",
        "issue_numbers": [
            "1004"
        ],
        "base_commit": "5ecc39749a98c7ec3fc63b8cbaa82de5eb17c173",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -922,7 +922,7 @@ def slots_getstate(self):\n             \"\"\"\n             Automatically created by attrs.\n             \"\"\"\n-            return tuple(getattr(self, name) for name in state_attr_names)\n+            return {name: getattr(self, name) for name in state_attr_names}\n \n         hash_caching_enabled = self._cache_hash\n \n@@ -931,8 +931,9 @@ def slots_setstate(self, state):\n             Automatically created by attrs.\n             \"\"\"\n             __bound_setattr = _obj_setattr.__get__(self)\n-            for name, value in zip(state_attr_names, state):\n-                __bound_setattr(name, value)\n+            for name in state_attr_names:\n+                if name in state:\n+                    __bound_setattr(name, state[name])\n \n             # The hash code cache is not included when the object is\n             # serialized, but it still needs to be initialized to None to\n",
        "test_patch": "diff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -9,6 +9,8 @@\n import types\n import weakref\n \n+from unittest import mock\n+\n import pytest\n \n import attr\n@@ -743,3 +745,58 @@ def f(self):\n \n     assert B(11).f == 121\n     assert B(17).f == 289\n+\n+\n+@attr.s(slots=True)\n+class A:\n+    x = attr.ib()\n+    b = attr.ib()\n+    c = attr.ib()\n+\n+\n+@pytest.mark.parametrize(\"cls\", [A])\n+def test_slots_unpickle_after_attr_removed(cls):\n+    \"\"\"\n+    We don't assign attributes we don't have anymore if the class has\n+    removed it.\n+    \"\"\"\n+    a = cls(1, 2, 3)\n+    a_pickled = pickle.dumps(a)\n+    a_unpickled = pickle.loads(a_pickled)\n+    assert a_unpickled == a\n+\n+    @attr.s(slots=True)\n+    class NEW_A:\n+        x = attr.ib()\n+        c = attr.ib()\n+\n+    with mock.patch(f\"{__name__}.A\", NEW_A):\n+        new_a = pickle.loads(a_pickled)\n+        assert new_a.x == 1\n+        assert new_a.c == 3\n+        assert not hasattr(new_a, \"b\")\n+\n+\n+@pytest.mark.parametrize(\"cls\", [A])\n+def test_slots_unpickle_after_attr_added(cls):\n+    \"\"\"\n+    We don't assign attribute we haven't had before if the class has one added.\n+    \"\"\"\n+    a = cls(1, 2, 3)\n+    a_pickled = pickle.dumps(a)\n+    a_unpickled = pickle.loads(a_pickled)\n+    assert a_unpickled == a\n+\n+    @attr.s(slots=True)\n+    class NEW_A:\n+        x = attr.ib()\n+        b = attr.ib()\n+        d = attr.ib()\n+        c = attr.ib()\n+\n+    with mock.patch(f\"{__name__}.A\", NEW_A):\n+        new_a = pickle.loads(a_pickled)\n+        assert new_a.x == 1\n+        assert new_a.b == 2\n+        assert new_a.c == 3\n+        assert not hasattr(new_a, \"d\")\n",
        "problem_statement": "Current default implementation of __getstate__ and __setstate__ could be made safer\nThis is a known \"sharp edge\" of pickle, but attrs could make this a bit safer by slightly modifying the default implementation of `__getstate__` and `__setstate__`. The problem is that due to returning a tuple in the default implementation of `__getstate__`, removing a member, and then unpickling from a previous version can be __very__ unsafe. This is not a hypothetical situation - it commonly happens when an object is pickled, and then stored in a data-store of some sort, and unpickled some time later by a changed version of the code. \r\n\r\nHere's a simple reproducer that demonstrates it (python 3.10, attrs 22.1.0):\r\n\r\n```python\r\nimport pickle\r\n\r\nimport attr\r\n\r\n@attr.s(slots=True, hash=False, auto_attribs=True)\r\nclass Test:\r\n    count: int\r\n    enable_minor_feature: bool\r\n    should_launch_missiles: bool\r\n\r\nt = Test(count=1, should_launch_missiles=False, enable_minor_feature=True)\r\nprint(t)  # Test(count=1, enable_minor_feature=True, should_launch_missiles=False)\r\ntp = pickle.dumps(t)\r\n\r\n@attr.s(slots=True, hash=False, auto_attribs=True)\r\nclass Test:\r\n    count: int\r\n    should_launch_missiles: bool\r\n\r\ntl = pickle.loads(tp)\r\nprint(tl)  # Test(count=1, should_launch_missiles=True)  <== an attribute is assigned a dangerously wrong value\r\n```\r\n\r\nWhile there's certainly an argument to be made that pickle should not be used for such things (and I'd agree) - the default implementation could, I believe, be made safer. Raise if things don't match, or even ignore unknown attributes in __setstate__,  by potentially returning a dictionary instead of a tuple [here](https://github.com/python-attrs/attrs/blob/c58ffd4e4cba5d5e58356722b985fc362358c48e/src/attr/_make.py#L925) would help.\n",
        "hints_text": "Have you tried replacing the tuple by the dict and see how much it breaks? Performance difference should be benign, since we save ourselves zipping.\nI wanted to get some thoughts on the feasibility of making the change at all first. Let me put together a patch and see how much it breaks, and we can take it from there. Thanks :)\nI don't think our implementation of pickling is a public API. So if you can make it compatible, that should  be OK.",
        "created_at": "2022-08-16T16:34:33Z",
        "version": "22.1"
    }
}