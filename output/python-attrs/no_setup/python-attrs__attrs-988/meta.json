{
    "task_id": "python-attrs__attrs-988",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-988_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 988,
        "instance_id": "python-attrs__attrs-988",
        "issue_numbers": [
            "965"
        ],
        "base_commit": "107367d437484006a7d01854e91e478401690087",
        "patch": "diff --git a/conftest.py b/conftest.py\n--- a/conftest.py\n+++ b/conftest.py\n@@ -1,9 +1,8 @@\n # SPDX-License-Identifier: MIT\n \n-\n from hypothesis import HealthCheck, settings\n \n-from attr._compat import PY36, PY310\n+from attr._compat import PY310\n \n \n def pytest_configure(config):\n@@ -15,14 +14,5 @@ def pytest_configure(config):\n \n \n collect_ignore = []\n-if not PY36:\n-    collect_ignore.extend(\n-        [\n-            \"tests/test_annotations.py\",\n-            \"tests/test_hooks.py\",\n-            \"tests/test_init_subclass.py\",\n-            \"tests/test_next_gen.py\",\n-        ]\n-    )\n if not PY310:\n     collect_ignore.extend([\"tests/test_pattern_matching.py\"])\ndiff --git a/setup.py b/setup.py\n--- a/setup.py\n+++ b/setup.py\n@@ -4,7 +4,6 @@\n import os\n import platform\n import re\n-import sys\n \n from setuptools import find_packages, setup\n \n@@ -33,7 +32,6 @@\n     \"Operating System :: OS Independent\",\n     \"Programming Language :: Python\",\n     \"Programming Language :: Python :: 3\",\n-    \"Programming Language :: Python :: 3.5\",\n     \"Programming Language :: Python :: 3.6\",\n     \"Programming Language :: Python :: 3.7\",\n     \"Programming Language :: Python :: 3.8\",\n@@ -57,10 +55,7 @@\n         \"pytest>=4.3.0\",  # 4.3.0 dropped last use of `convert`\n     ],\n }\n-if (\n-    sys.version_info[:2] >= (3, 6)\n-    and platform.python_implementation() != \"PyPy\"\n-):\n+if platform.python_implementation() != \"PyPy\":\n     EXTRAS_REQUIRE[\"tests_no_zope\"].extend(\n         [\"mypy>=0.900,!=0.940\", \"pytest-mypy-plugins\"]\n     )\n@@ -92,11 +87,11 @@ def find_meta(meta):\n     Extract __*meta*__ from META_FILE.\n     \"\"\"\n     meta_match = re.search(\n-        r\"^__{meta}__ = ['\\\"]([^'\\\"]*)['\\\"]\".format(meta=meta), META_FILE, re.M\n+        rf\"^__{meta}__ = ['\\\"]([^'\\\"]*)['\\\"]\", META_FILE, re.M\n     )\n     if meta_match:\n         return meta_match.group(1)\n-    raise RuntimeError(\"Unable to find __{meta}__ string.\".format(meta=meta))\n+    raise RuntimeError(f\"Unable to find __{meta}__ string.\")\n \n \n LOGO = \"\"\"\n@@ -119,7 +114,7 @@ def find_meta(meta):\n         re.S,\n     ).group(1)\n     + \"\\n\\n`Full changelog \"\n-    + \"<{url}en/stable/changelog.html>`_.\\n\\n\".format(url=URL)\n+    + f\"<{URL}en/stable/changelog.html>`_.\\n\\n\"\n     + read(\"AUTHORS.rst\")\n )\n \n@@ -141,7 +136,7 @@ def find_meta(meta):\n         long_description_content_type=\"text/x-rst\",\n         packages=PACKAGES,\n         package_dir={\"\": \"src\"},\n-        python_requires=\">=3.5\",\n+        python_requires=\">=3.6\",\n         zip_safe=False,\n         classifiers=CLASSIFIERS,\n         install_requires=INSTALL_REQUIRES,\ndiff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -1,8 +1,5 @@\n # SPDX-License-Identifier: MIT\n \n-\n-import sys\n-\n from functools import partial\n \n from . import converters, exceptions, filters, setters, validators\n@@ -20,6 +17,7 @@\n     make_class,\n     validate,\n )\n+from ._next_gen import define, field, frozen, mutable\n from ._version_info import VersionInfo\n \n \n@@ -56,15 +54,19 @@\n     \"attrs\",\n     \"cmp_using\",\n     \"converters\",\n+    \"define\",\n     \"evolve\",\n     \"exceptions\",\n+    \"field\",\n     \"fields\",\n     \"fields_dict\",\n     \"filters\",\n+    \"frozen\",\n     \"get_run_validators\",\n     \"has\",\n     \"ib\",\n     \"make_class\",\n+    \"mutable\",\n     \"resolve_types\",\n     \"s\",\n     \"set_run_validators\",\n@@ -72,8 +74,3 @@\n     \"validate\",\n     \"validators\",\n ]\n-\n-if sys.version_info[:2] >= (3, 6):\n-    from ._next_gen import define, field, frozen, mutable  # noqa: F401\n-\n-    __all__.extend((\"define\", \"field\", \"frozen\", \"mutable\"))\ndiff --git a/src/attr/_compat.py b/src/attr/_compat.py\n--- a/src/attr/_compat.py\n+++ b/src/attr/_compat.py\n@@ -12,19 +12,9 @@\n \n \n PYPY = platform.python_implementation() == \"PyPy\"\n-PY36 = sys.version_info[:2] >= (3, 6)\n-HAS_F_STRINGS = PY36\n PY310 = sys.version_info[:2] >= (3, 10)\n \n \n-if PYPY or PY36:\n-    ordered_dict = dict\n-else:\n-    from collections import OrderedDict\n-\n-    ordered_dict = OrderedDict\n-\n-\n def just_warn(*args, **kw):\n     warnings.warn(\n         \"Running interpreter doesn't sufficiently support code object \"\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -11,14 +11,7 @@\n # We need to import _compat itself in addition to the _compat members to avoid\n # having the thread-local in the globals here.\n from . import _compat, _config, setters\n-from ._compat import (\n-    HAS_F_STRINGS,\n-    PY310,\n-    PYPY,\n-    _AnnotationExtractor,\n-    ordered_dict,\n-    set_closure_cell,\n-)\n+from ._compat import PY310, PYPY, _AnnotationExtractor, set_closure_cell\n from .exceptions import (\n     DefaultAlreadySetError,\n     FrozenInstanceError,\n@@ -201,9 +194,9 @@ def attrib(\n         value is converted before being passed to the validator, if any.\n     :param metadata: An arbitrary mapping, to be used by third-party\n         components.  See `extending_metadata`.\n-    :param type: The type of the attribute.  In Python 3.6 or greater, the\n-        preferred method to specify the type is using a variable annotation\n-        (see :pep:`526`).\n+\n+    :param type: The type of the attribute. Nowadays, the preferred method to\n+        specify the type is using a variable annotation (see :pep:`526`).\n         This argument is provided for backward compatibility.\n         Regardless of the approach used, the type will be stored on\n         ``Attribute.type``.\n@@ -323,7 +316,7 @@ def _make_method(name, script, filename, globs):\n         if old_val == linecache_tuple:\n             break\n         else:\n-            filename = \"{}-{}>\".format(base_filename[:-1], count)\n+            filename = f\"{base_filename[:-1]}-{count}>\"\n             count += 1\n \n     _compile_and_eval(script, globs, locs, filename)\n@@ -341,9 +334,9 @@ class MyClassAttributes(tuple):\n         __slots__ = ()\n         x = property(itemgetter(0))\n     \"\"\"\n-    attr_class_name = \"{}Attributes\".format(cls_name)\n+    attr_class_name = f\"{cls_name}Attributes\"\n     attr_class_template = [\n-        \"class {}(tuple):\".format(attr_class_name),\n+        f\"class {attr_class_name}(tuple):\",\n         \"    __slots__ = ()\",\n     ]\n     if attr_names:\n@@ -418,13 +411,6 @@ def _get_annotations(cls):\n     return {}\n \n \n-def _counter_getter(e):\n-    \"\"\"\n-    Key function for sorting to avoid re-creating a lambda for every class.\n-    \"\"\"\n-    return e[1].counter\n-\n-\n def _collect_base_attrs(cls, taken_attr_names):\n     \"\"\"\n     Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n@@ -502,9 +488,6 @@ def _transform_attrs(\n \n     if these is not None:\n         ca_list = [(name, ca) for name, ca in these.items()]\n-\n-        if not isinstance(these, ordered_dict):\n-            ca_list.sort(key=_counter_getter)\n     elif auto_attribs is True:\n         ca_names = {\n             name\n@@ -735,7 +718,7 @@ def __init__(\n             ) = self._make_getstate_setstate()\n \n     def __repr__(self):\n-        return \"<_ClassBuilder(cls={cls})>\".format(cls=self._cls.__name__)\n+        return f\"<_ClassBuilder(cls={self._cls.__name__})>\"\n \n     def build_class(self):\n         \"\"\"\n@@ -1218,10 +1201,7 @@ def attrs(\n         If *these* is not ``None``, ``attrs`` will *not* search the class body\n         for attributes and will *not* remove any attributes from it.\n \n-        If *these* is an ordered dict (`dict` on Python 3.6+,\n-        `collections.OrderedDict` otherwise), the order is deduced from\n-        the order of the attributes inside *these*.  Otherwise the order\n-        of the definition of the attributes is used.\n+        The order is deduced from the order of the attributes inside *these*.\n \n     :type these: `dict` of `str` to `attr.ib`\n \n@@ -1329,7 +1309,7 @@ def attrs(\n     :param bool weakref_slot: Make instances weak-referenceable.  This has no\n         effect unless ``slots`` is also enabled.\n     :param bool auto_attribs: If ``True``, collect :pep:`526`-annotated\n-        attributes (Python 3.6 and later only) from the class body.\n+        attributes from the class body.\n \n         In this case, you **must** annotate every field.  If ``attrs``\n         encounters a field that is set to an `attr.ib` but lacks a type\n@@ -1833,126 +1813,61 @@ def _add_eq(cls, attrs=None):\n     return cls\n \n \n-if HAS_F_STRINGS:\n-\n-    def _make_repr(attrs, ns, cls):\n-        unique_filename = _generate_unique_filename(cls, \"repr\")\n-        # Figure out which attributes to include, and which function to use to\n-        # format them. The a.repr value can be either bool or a custom\n-        # callable.\n-        attr_names_with_reprs = tuple(\n-            (a.name, (repr if a.repr is True else a.repr), a.init)\n-            for a in attrs\n-            if a.repr is not False\n+def _make_repr(attrs, ns, cls):\n+    unique_filename = _generate_unique_filename(cls, \"repr\")\n+    # Figure out which attributes to include, and which function to use to\n+    # format them. The a.repr value can be either bool or a custom\n+    # callable.\n+    attr_names_with_reprs = tuple(\n+        (a.name, (repr if a.repr is True else a.repr), a.init)\n+        for a in attrs\n+        if a.repr is not False\n+    )\n+    globs = {\n+        name + \"_repr\": r for name, r, _ in attr_names_with_reprs if r != repr\n+    }\n+    globs[\"_compat\"] = _compat\n+    globs[\"AttributeError\"] = AttributeError\n+    globs[\"NOTHING\"] = NOTHING\n+    attribute_fragments = []\n+    for name, r, i in attr_names_with_reprs:\n+        accessor = (\n+            \"self.\" + name if i else 'getattr(self, \"' + name + '\", NOTHING)'\n         )\n-        globs = {\n-            name + \"_repr\": r\n-            for name, r, _ in attr_names_with_reprs\n-            if r != repr\n-        }\n-        globs[\"_compat\"] = _compat\n-        globs[\"AttributeError\"] = AttributeError\n-        globs[\"NOTHING\"] = NOTHING\n-        attribute_fragments = []\n-        for name, r, i in attr_names_with_reprs:\n-            accessor = (\n-                \"self.\" + name\n-                if i\n-                else 'getattr(self, \"' + name + '\", NOTHING)'\n-            )\n-            fragment = (\n-                \"%s={%s!r}\" % (name, accessor)\n-                if r == repr\n-                else \"%s={%s_repr(%s)}\" % (name, name, accessor)\n-            )\n-            attribute_fragments.append(fragment)\n-        repr_fragment = \", \".join(attribute_fragments)\n-\n-        if ns is None:\n-            cls_name_fragment = (\n-                '{self.__class__.__qualname__.rsplit(\">.\", 1)[-1]}'\n-            )\n-        else:\n-            cls_name_fragment = ns + \".{self.__class__.__name__}\"\n-\n-        lines = [\n-            \"def __repr__(self):\",\n-            \"  try:\",\n-            \"    already_repring = _compat.repr_context.already_repring\",\n-            \"  except AttributeError:\",\n-            \"    already_repring = {id(self),}\",\n-            \"    _compat.repr_context.already_repring = already_repring\",\n-            \"  else:\",\n-            \"    if id(self) in already_repring:\",\n-            \"      return '...'\",\n-            \"    else:\",\n-            \"      already_repring.add(id(self))\",\n-            \"  try:\",\n-            \"    return f'%s(%s)'\" % (cls_name_fragment, repr_fragment),\n-            \"  finally:\",\n-            \"    already_repring.remove(id(self))\",\n-        ]\n-\n-        return _make_method(\n-            \"__repr__\", \"\\n\".join(lines), unique_filename, globs=globs\n+        fragment = (\n+            \"%s={%s!r}\" % (name, accessor)\n+            if r == repr\n+            else \"%s={%s_repr(%s)}\" % (name, name, accessor)\n         )\n+        attribute_fragments.append(fragment)\n+    repr_fragment = \", \".join(attribute_fragments)\n \n-else:\n-\n-    def _make_repr(attrs, ns, _):\n-        \"\"\"\n-        Make a repr method that includes relevant *attrs*, adding *ns* to the\n-        full name.\n-        \"\"\"\n-\n-        # Figure out which attributes to include, and which function to use to\n-        # format them. The a.repr value can be either bool or a custom\n-        # callable.\n-        attr_names_with_reprs = tuple(\n-            (a.name, repr if a.repr is True else a.repr)\n-            for a in attrs\n-            if a.repr is not False\n-        )\n-\n-        def __repr__(self):\n-            \"\"\"\n-            Automatically created by attrs.\n-            \"\"\"\n-            try:\n-                already_repring = _compat.repr_context.already_repring\n-            except AttributeError:\n-                already_repring = set()\n-                _compat.repr_context.already_repring = already_repring\n-\n-            if id(self) in already_repring:\n-                return \"...\"\n-            real_cls = self.__class__\n-            if ns is None:\n-                class_name = real_cls.__qualname__.rsplit(\">.\", 1)[-1]\n-            else:\n-                class_name = ns + \".\" + real_cls.__name__\n+    if ns is None:\n+        cls_name_fragment = '{self.__class__.__qualname__.rsplit(\">.\", 1)[-1]}'\n+    else:\n+        cls_name_fragment = ns + \".{self.__class__.__name__}\"\n \n-            # Since 'self' remains on the stack (i.e.: strongly referenced)\n-            # for the duration of this call, it's safe to depend on id(...)\n-            # stability, and not need to track the instance and therefore\n-            # worry about properties like weakref- or hash-ability.\n-            already_repring.add(id(self))\n-            try:\n-                result = [class_name, \"(\"]\n-                first = True\n-                for name, attr_repr in attr_names_with_reprs:\n-                    if first:\n-                        first = False\n-                    else:\n-                        result.append(\", \")\n-                    result.extend(\n-                        (name, \"=\", attr_repr(getattr(self, name, NOTHING)))\n-                    )\n-                return \"\".join(result) + \")\"\n-            finally:\n-                already_repring.remove(id(self))\n+    lines = [\n+        \"def __repr__(self):\",\n+        \"  try:\",\n+        \"    already_repring = _compat.repr_context.already_repring\",\n+        \"  except AttributeError:\",\n+        \"    already_repring = {id(self),}\",\n+        \"    _compat.repr_context.already_repring = already_repring\",\n+        \"  else:\",\n+        \"    if id(self) in already_repring:\",\n+        \"      return '...'\",\n+        \"    else:\",\n+        \"      already_repring.add(id(self))\",\n+        \"  try:\",\n+        \"    return f'%s(%s)'\" % (cls_name_fragment, repr_fragment),\n+        \"  finally:\",\n+        \"    already_repring.remove(id(self))\",\n+    ]\n \n-        return __repr__\n+    return _make_method(\n+        \"__repr__\", \"\\n\".join(lines), unique_filename, globs=globs\n+    )\n \n \n def _add_repr(cls, ns=None, attrs=None):\n@@ -1988,9 +1903,7 @@ def fields(cls):\n         raise TypeError(\"Passed object must be a class.\")\n     attrs = getattr(cls, \"__attrs_attrs__\", None)\n     if attrs is None:\n-        raise NotAnAttrsClassError(\n-            \"{cls!r} is not an attrs-decorated class.\".format(cls=cls)\n-        )\n+        raise NotAnAttrsClassError(f\"{cls!r} is not an attrs-decorated class.\")\n     return attrs\n \n \n@@ -2005,10 +1918,7 @@ def fields_dict(cls):\n     :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n         class.\n \n-    :rtype: an ordered dict where keys are attribute names and values are\n-        `attrs.Attribute`\\\\ s. This will be a `dict` if it's\n-        naturally ordered like on Python 3.6+ or an\n-        :class:`~collections.OrderedDict` otherwise.\n+    :rtype: dict\n \n     .. versionadded:: 18.1.0\n     \"\"\"\n@@ -2016,10 +1926,8 @@ def fields_dict(cls):\n         raise TypeError(\"Passed object must be a class.\")\n     attrs = getattr(cls, \"__attrs_attrs__\", None)\n     if attrs is None:\n-        raise NotAnAttrsClassError(\n-            \"{cls!r} is not an attrs-decorated class.\".format(cls=cls)\n-        )\n-    return ordered_dict((a.name, a) for a in attrs)\n+        raise NotAnAttrsClassError(f\"{cls!r} is not an attrs-decorated class.\")\n+    return {a.name: a for a in attrs}\n \n \n def validate(inst):\n@@ -2579,7 +2487,7 @@ def from_counting_attr(cls, name, ca, type=None):\n             type=type,\n             cmp=None,\n             inherited=False,\n-            **inst_dict\n+            **inst_dict,\n         )\n \n     # Don't use attr.evolve since fields(Attribute) doesn't work\n@@ -2865,10 +2773,9 @@ def make_class(name, attrs, bases=(object,), **attributes_arguments):\n     :param attrs: A list of names or a dictionary of mappings of names to\n         attributes.\n \n-        If *attrs* is a list or an ordered dict (`dict` on Python 3.6+,\n-        `collections.OrderedDict` otherwise), the order is deduced from\n-        the order of the names or attributes inside *attrs*.  Otherwise the\n-        order of the definition of the attributes is used.\n+        The order is deduced from the order of the names or attributes inside\n+        *attrs*.  Otherwise the order of the definition of the attributes is\n+        used.\n     :type attrs: `list` or `dict`\n \n     :param tuple bases: Classes that the new class will subclass.\ndiff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -1,8 +1,8 @@\n # SPDX-License-Identifier: MIT\n \n \"\"\"\n-These are Python 3.6+-only and keyword-only APIs that call `attr.s` and\n-`attr.ib` with different default values.\n+These are keyword-only APIs that call `attr.s` and `attr.ib` with different\n+default values.\n \"\"\"\n \n \ndiff --git a/src/attr/converters.py b/src/attr/converters.py\n--- a/src/attr/converters.py\n+++ b/src/attr/converters.py\n@@ -141,4 +141,4 @@ def to_bool(val):\n     except TypeError:\n         # Raised when \"val\" is not hashable (e.g., lists)\n         pass\n-    raise ValueError(\"Cannot convert value to bool: {}\".format(val))\n+    raise ValueError(f\"Cannot convert value to bool: {val}\")\ndiff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -391,7 +391,7 @@ def __repr__(self):\n         iterable_identifier = (\n             \"\"\n             if self.iterable_validator is None\n-            else \" {iterable!r}\".format(iterable=self.iterable_validator)\n+            else f\" {self.iterable_validator!r}\"\n         )\n         return (\n             \"<deep_iterable validator for{iterable_identifier}\"\n@@ -548,7 +548,7 @@ def __call__(self, inst, attr, value):\n             )\n \n     def __repr__(self):\n-        return \"<max_len validator for {max}>\".format(max=self.max_length)\n+        return f\"<max_len validator for {self.max_length}>\"\n \n \n def max_len(length):\n@@ -579,7 +579,7 @@ def __call__(self, inst, attr, value):\n             )\n \n     def __repr__(self):\n-        return \"<min_len validator for {min}>\".format(min=self.min_length)\n+        return f\"<min_len validator for {self.min_length}>\"\n \n \n def min_len(length):\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -2,8 +2,6 @@\n \n \"\"\"\n Tests for PEP-526 type annotations.\n-\n-Python 3.6+ only.\n \"\"\"\n \n import sys\n@@ -397,7 +395,7 @@ def test_annotations_strings(self, slots):\n         \"\"\"\n         String annotations are passed into __init__ as is.\n \n-        It fails on 3.6 due to a bug in Python.\n+        The strings keep changing between releases.\n         \"\"\"\n         import typing as t\n \ndiff --git a/tests/test_funcs.py b/tests/test_funcs.py\n--- a/tests/test_funcs.py\n+++ b/tests/test_funcs.py\n@@ -15,7 +15,7 @@\n import attr\n \n from attr import asdict, assoc, astuple, evolve, fields, has\n-from attr._compat import Mapping, Sequence, ordered_dict\n+from attr._compat import Mapping, Sequence\n from attr.exceptions import AttrsAttributeNotFoundError\n from attr.validators import instance_of\n \n@@ -196,7 +196,7 @@ def test_asdict_preserve_order(self, cls):\n         Field order should be preserved when dumping to an ordered_dict.\n         \"\"\"\n         instance = cls()\n-        dict_instance = asdict(instance, dict_factory=ordered_dict)\n+        dict_instance = asdict(instance, dict_factory=dict)\n \n         assert [a.name for a in fields(cls)] == list(dict_instance.keys())\n \n@@ -483,9 +483,7 @@ def test_unknown(self, C):\n         ) as e, pytest.deprecated_call():\n             assoc(C(), aaaa=2)\n \n-        assert (\n-            \"aaaa is not an attrs attribute on {cls!r}.\".format(cls=C),\n-        ) == e.value.args\n+        assert (f\"aaaa is not an attrs attribute on {C!r}.\",) == e.value.args\n \n     def test_frozen(self):\n         \"\"\"\ndiff --git a/tests/test_functional.py b/tests/test_functional.py\n--- a/tests/test_functional.py\n+++ b/tests/test_functional.py\n@@ -17,7 +17,6 @@\n \n import attr\n \n-from attr._compat import PY36\n from attr._make import NOTHING, Attribute\n from attr.exceptions import FrozenInstanceError\n \n@@ -224,9 +223,9 @@ def test_subclassing_with_extra_attrs(self, cls):\n         assert i.x is i.meth() is obj\n         assert i.y == 2\n         if cls is Sub:\n-            assert \"Sub(x={obj}, y=2)\".format(obj=obj) == repr(i)\n+            assert f\"Sub(x={obj}, y=2)\" == repr(i)\n         else:\n-            assert \"SubSlots(x={obj}, y=2)\".format(obj=obj) == repr(i)\n+            assert f\"SubSlots(x={obj}, y=2)\" == repr(i)\n \n     @pytest.mark.parametrize(\"base\", [Base, BaseSlots])\n     def test_subclass_without_extra_attrs(self, base):\n@@ -241,7 +240,7 @@ class Sub2(base):\n         obj = object()\n         i = Sub2(x=obj)\n         assert i.x is i.meth() is obj\n-        assert \"Sub2(x={obj})\".format(obj=obj) == repr(i)\n+        assert f\"Sub2(x={obj})\" == repr(i)\n \n     @pytest.mark.parametrize(\n         \"frozen_class\",\n@@ -701,7 +700,6 @@ class D(C):\n         assert \"self.y = y\" in src\n         assert object.__setattr__ == D.__setattr__\n \n-    @pytest.mark.skipif(not PY36, reason=\"NG APIs are 3.6+\")\n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_no_setattr_with_ng_defaults(self, slots):\n         \"\"\"\ndiff --git a/tests/test_init_subclass.py b/tests/test_init_subclass.py\n--- a/tests/test_init_subclass.py\n+++ b/tests/test_init_subclass.py\n@@ -2,8 +2,6 @@\n \n \"\"\"\n Tests for `__init_subclass__` related tests.\n-\n-Python 3.6+ only.\n \"\"\"\n \n import pytest\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -22,7 +22,7 @@\n import attr\n \n from attr import _config\n-from attr._compat import PY310, ordered_dict\n+from attr._compat import PY310\n from attr._make import (\n     Attribute,\n     Factory,\n@@ -297,7 +297,7 @@ def test_these_ordered(self):\n         b = attr.ib(default=2)\n         a = attr.ib(default=1)\n \n-        @attr.s(these=ordered_dict([(\"a\", a), (\"b\", b)]))\n+        @attr.s(these=dict([(\"a\", a), (\"b\", b)]))\n         class C:\n             pass\n \n@@ -1071,7 +1071,7 @@ def test_make_class_ordered(self):\n         b = attr.ib(default=2)\n         a = attr.ib(default=1)\n \n-        C = attr.make_class(\"C\", ordered_dict([(\"a\", a), (\"b\", b)]))\n+        C = attr.make_class(\"C\", dict([(\"a\", a), (\"b\", b)]))\n \n         assert \"C(a=1, b=2)\" == repr(C())\n \n@@ -1114,7 +1114,7 @@ def test_handler_non_attrs_class(self):\n             fields(object)\n \n         assert (\n-            \"{o!r} is not an attrs-decorated class.\".format(o=object)\n+            f\"{object!r} is not an attrs-decorated class.\"\n         ) == e.value.args[0]\n \n     @given(simple_classes())\n@@ -1156,7 +1156,7 @@ def test_handler_non_attrs_class(self):\n             fields_dict(object)\n \n         assert (\n-            \"{o!r} is not an attrs-decorated class.\".format(o=object)\n+            f\"{object!r} is not an attrs-decorated class.\"\n         ) == e.value.args[0]\n \n     @given(simple_classes())\n@@ -1166,7 +1166,7 @@ def test_fields_dict(self, C):\n         \"\"\"\n         d = fields_dict(C)\n \n-        assert isinstance(d, ordered_dict)\n+        assert isinstance(d, dict)\n         assert list(fields(C)) == list(d.values())\n         assert [a.name for a in fields(C)] == [field_name for field_name in d]\n \n@@ -1214,7 +1214,7 @@ def test_converter_factory_property(self, val, init):\n         \"\"\"\n         C = make_class(\n             \"C\",\n-            ordered_dict(\n+            dict(\n                 [\n                     (\"y\", attr.ib()),\n                     (\ndiff --git a/tests/test_next_gen.py b/tests/test_next_gen.py\n--- a/tests/test_next_gen.py\n+++ b/tests/test_next_gen.py\n@@ -1,7 +1,7 @@\n # SPDX-License-Identifier: MIT\n \n \"\"\"\n-Python 3-only integration tests for provisional next-generation APIs.\n+Integration tests for next-generation APIs.\n \"\"\"\n \n import re\ndiff --git a/tests/test_pyright.py b/tests/test_pyright.py\n--- a/tests/test_pyright.py\n+++ b/tests/test_pyright.py\n@@ -4,17 +4,13 @@\n import os.path\n import shutil\n import subprocess\n-import sys\n \n import pytest\n \n import attr\n \n \n-if sys.version_info < (3, 6):\n-    _found_pyright = False\n-else:\n-    _found_pyright = shutil.which(\"pyright\")\n+_found_pyright = shutil.which(\"pyright\")\n \n \n @attr.s(frozen=True)\n",
        "problem_statement": "Cannot import attrs for Python 3.5\nFirst of all, attrs is great, thanks to all who work on it.\r\n\r\nOn Python 3.5, the next-gen API (`define`, `field`, etc.) is not defined in `attr/__init__.py`, which causes an ImportError on startup.  Here's a reproducer:\r\n\r\n```\r\n# python3\r\nPython 3.5.3 (default, Dec  3 2018, 20:11:08) \r\n[GCC 7.3.0] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import attrs\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/usr/lib/python3.5/site-packages/attrs/__init__.py\", line 3, in <module>\r\n    from attr import (\r\nImportError: cannot import name 'define'\r\n```\r\n\r\nLooks like it's happening because of these lines in `attr/__init__`: https://github.com/python-attrs/attrs/blob/main/src/attr/__init__.py#L76-L79\r\n\r\nalong with  https://github.com/python-attrs/attrs/blob/main/src/attrs/__init__.py#L19 (which tries to import those names unconditionally).\n",
        "hints_text": "That is expected, because the `attrs` import path is 3.6-only:\r\n\r\n<img width=\"810\" alt=\"Screenshot 2022-06-07 at 13 44 52@2x\" src=\"https://user-images.githubusercontent.com/41240/172371553-504e2f8c-592b-4c5e-ae34-7d6849a62291.png\">\r\n\nAh!  Got it.  Thanks.  \r\n\r\nWould you be interested in a PR for attrs that adds a more helpful error message, something like this in `attrs/__init__.py`?\r\n\r\n```python3\r\n# at the top of attrs/__init__.py\r\nimport sys\r\n\r\nif sys.version_info[:2] <= 3, 5:\r\n    raise ImportError('The attrs namespace is only available for Python > 3.5. Please use the attr namespace instead.')\r\n```\nIf you'd like to contribute that, fire away. I'm just not sure how much longer we're gonna support Python 3.5 though. :)",
        "created_at": "2022-07-29T04:12:11Z",
        "version": "22.1"
    }
}