{
    "task_id": "python-attrs__attrs-681",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-681_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 681,
        "instance_id": "python-attrs__attrs-681",
        "issue_numbers": [
            "680"
        ],
        "base_commit": "bfd7bb49b467e7ab586deb475c23974a91df4dab",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -556,6 +556,7 @@ class _ClassBuilder(object):\n         \"_slots\",\n         \"_weakref_slot\",\n         \"_has_own_setattr\",\n+        \"_has_custom_setattr\",\n     )\n \n     def __init__(\n@@ -593,7 +594,8 @@ def __init__(\n         self._is_exc = is_exc\n         self._on_setattr = on_setattr\n \n-        self._has_own_setattr = has_custom_setattr\n+        self._has_custom_setattr = has_custom_setattr\n+        self._has_own_setattr = False\n \n         self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n \n@@ -654,7 +656,10 @@ def _patch_original_class(self):\n         if not self._has_own_setattr and getattr(\n             cls, \"__attrs_own_setattr__\", False\n         ):\n-            cls.__setattr__ = object.__setattr__\n+            cls.__attrs_own_setattr__ = False\n+\n+            if not self._has_custom_setattr:\n+                cls.__setattr__ = object.__setattr__\n \n         return cls\n \n@@ -669,24 +674,30 @@ def _create_slots_class(self):\n             if k not in tuple(self._attr_names) + (\"__dict__\", \"__weakref__\")\n         }\n \n-        # Traverse the MRO to check for an existing __weakref__ and\n-        # __setattr__.\n-        custom_setattr_inherited = False\n+        # If our class doesn't have its own implementation of __setattr__\n+        # (either from the user or by us), check the bases, if one of them has\n+        # an attrs-made __setattr__, that needs to be reset. We don't walk the\n+        # MRO because we only care about our immediate base classes.\n+        # XXX: This can be confused by subclassing a slotted attrs class with\n+        # XXX: a non-attrs class and subclass the resulting class with an attrs\n+        # XXX: class.  See `test_slotted_confused` for details.  For now that's\n+        # XXX: OK with us.\n+        if not self._has_own_setattr:\n+            cd[\"__attrs_own_setattr__\"] = False\n+\n+            if not self._has_custom_setattr:\n+                for base_cls in self._cls.__bases__:\n+                    if base_cls.__dict__.get(\"__attrs_own_setattr__\", False):\n+                        cd[\"__setattr__\"] = object.__setattr__\n+                        break\n+\n+        # Traverse the MRO to check for an existing __weakref__.\n         weakref_inherited = False\n         for base_cls in self._cls.__mro__[1:-1]:\n-            d = getattr(base_cls, \"__dict__\", {})\n-\n-            weakref_inherited = weakref_inherited or \"__weakref__\" in d\n-            custom_setattr_inherited = custom_setattr_inherited or not (\n-                d.get(\"__attrs_own_setattr__\", False)\n-            )\n-\n-            if weakref_inherited and custom_setattr_inherited:\n+            if base_cls.__dict__.get(\"__weakref__\", None) is not None:\n+                weakref_inherited = True\n                 break\n \n-        if not self._has_own_setattr and not custom_setattr_inherited:\n-            cd[\"__setattr__\"] = object.__setattr__\n-\n         names = self._attr_names\n         if (\n             self._weakref_slot\n@@ -697,7 +708,7 @@ def _create_slots_class(self):\n             names += (\"__weakref__\",)\n \n         # We only add the names of attributes that aren't inherited.\n-        # Settings __slots__ to inherited attributes wastes memory.\n+        # Setting __slots__ to inherited attributes wastes memory.\n         slot_names = [name for name in names if name not in base_names]\n         if self._cache_hash:\n             slot_names.append(_hash_cache_field)\n@@ -857,20 +868,14 @@ def add_setattr(self):\n         if not sa_attrs:\n             return self\n \n-        if self._has_own_setattr:\n+        if self._has_custom_setattr:\n             # We need to write a __setattr__ but there already is one!\n             raise ValueError(\n                 \"Can't combine custom __setattr__ with on_setattr hooks.\"\n             )\n \n-        cls = self._cls\n-\n+        # docstring comes from _add_method_dunders\n         def __setattr__(self, name, val):\n-            \"\"\"\n-            Method generated by attrs for class %s.\n-            \"\"\" % (\n-                cls.__name__,\n-            )\n             try:\n                 a, hook = sa_attrs[name]\n             except KeyError:\n",
        "test_patch": "diff --git a/tests/test_setattr.py b/tests/test_setattr.py\n--- a/tests/test_setattr.py\n+++ b/tests/test_setattr.py\n@@ -227,6 +227,9 @@ class NoHook(WithOnSetAttrHook):\n             assert NoHook.__setattr__ == object.__setattr__\n \n         assert 1 == NoHook(1).x\n+        assert Hooked.__attrs_own_setattr__\n+        assert not NoHook.__attrs_own_setattr__\n+        assert WithOnSetAttrHook.__attrs_own_setattr__\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_setattr_inherited_do_not_reset(self, slots):\n@@ -274,6 +277,45 @@ def test_pickling_retains_attrs_own(self, slots):\n \n         assert True is WOSAH.__attrs_own_setattr__\n \n+    def test_slotted_class_can_have_custom_setattr(self):\n+        \"\"\"\n+        A slotted class can define a custom setattr and it doesn't get\n+        overwritten.\n+\n+        Regression test for #680.\n+        \"\"\"\n+\n+        @attr.s(slots=True)\n+        class A(object):\n+            def __setattr__(self, key, value):\n+                raise SystemError\n+\n+        with pytest.raises(SystemError):\n+            A().x = 1\n+\n+    @pytest.mark.xfail(raises=attr.exceptions.FrozenAttributeError)\n+    def test_slotted_confused(self):\n+        \"\"\"\n+        If we have a in-between non-attrs class, setattr reset detection\n+        should still work, but currently doesn't.\n+\n+        It works with dict classes because we can look the finished class and\n+        patch it.  With slotted classes we have to deduce it ourselves.\n+        \"\"\"\n+\n+        @attr.s(slots=True)\n+        class A(object):\n+            x = attr.ib(on_setattr=setters.frozen)\n+\n+        class B(A):\n+            pass\n+\n+        @attr.s(slots=True)\n+        class C(B):\n+            x = attr.ib()\n+\n+        C(1).x = 2\n+\n \n @pytest.mark.skipif(PY2, reason=\"Python 3-only.\")\n class TestSetAttrNoPy2(object):\n@@ -298,6 +340,7 @@ def __setattr__(self, name, val):\n \n         i = RemoveNeedForOurSetAttr(1)\n \n+        assert not RemoveNeedForOurSetAttr.__attrs_own_setattr__\n         assert 2 == i.x\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n@@ -345,3 +388,48 @@ class HookAndCustomSetAttr(object):\n \n                 def __setattr__(self, _, __):\n                     pass\n+\n+    @pytest.mark.parametrize(\"a_slots\", [True, False])\n+    @pytest.mark.parametrize(\"b_slots\", [True, False])\n+    @pytest.mark.parametrize(\"c_slots\", [True, False])\n+    def test_setattr_inherited_do_not_reset_intermediate(\n+        self, a_slots, b_slots, c_slots\n+    ):\n+        \"\"\"\n+        A user-provided intermediate __setattr__ is not reset to\n+        object.__setattr__.\n+\n+        This only can work on Python 3+ with auto_detect activated, such that\n+        attrs can know that there is a user-provided __setattr__.\n+        \"\"\"\n+\n+        @attr.s(slots=a_slots)\n+        class A(object):\n+            x = attr.ib(on_setattr=setters.frozen)\n+\n+        @attr.s(slots=b_slots, auto_detect=True)\n+        class B(A):\n+            x = attr.ib(on_setattr=setters.NO_OP)\n+\n+            def __setattr__(self, key, value):\n+                raise SystemError\n+\n+        @attr.s(slots=c_slots)\n+        class C(B):\n+            pass\n+\n+        assert getattr(A, \"__attrs_own_setattr__\", False) is True\n+        assert getattr(B, \"__attrs_own_setattr__\", False) is False\n+        assert getattr(C, \"__attrs_own_setattr__\", False) is False\n+\n+        with pytest.raises(SystemError):\n+            C(1).x = 3\n+\n+    def test_docstring(self):\n+        \"\"\"\n+        Generated __setattr__ has a useful docstring.\n+        \"\"\"\n+        assert (\n+            \"Method generated by attrs for class WithOnSetAttrHook.\"\n+            == WithOnSetAttrHook.__setattr__.__doc__\n+        )\n",
        "problem_statement": "Using slots class overrides custom `__setattr__` in 20.1.0\nIn 19.3.0, it was possible to have a custom `__setattr__` on your `slots` class, but in 20.1.0 the custom `__setattr__` is replaced with the default one:\r\n\r\n```python\r\nimport attr\r\n@attr.s(slots=True)\r\nclass A:\r\n    def __setattr__(self, key, value):\r\n        print(f\"{key}: {value}\")\r\n```\r\n\r\nIn 19.3.0:\r\n\r\n```python\r\n>>> A().a = 3\r\na: 3\r\n```\r\n\r\nIn 20.1.0:\r\n\r\n```python\r\n>>> A().a = 3\r\nAttributeError: 'A' object has no attribute 'a'\r\n>>> A.__setattr__\r\n<slot wrapper '__setattr__' of 'object' objects>\r\n```\r\n\r\nWhen `slots=False`, the same thing does not occur.\n",
        "hints_text": "",
        "created_at": "2020-09-01T07:50:19Z",
        "version": "20.1"
    }
}