{
    "task_id": "python-attrs__attrs-563",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-563_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 563,
        "instance_id": "python-attrs__attrs-563",
        "issue_numbers": [
            "543"
        ],
        "base_commit": "8174b03b962165278dd65508bf0f947c98a1190a",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -912,20 +912,20 @@ def wrap(cls):\n             raise TypeError(\n                 \"Invalid value for hash.  Must be True, False, or None.\"\n             )\n-        elif hash is False or (hash is None and cmp is False):\n+        elif hash is False or (hash is None and cmp is False) or is_exc:\n+            # Don't do anything. Should fall back to __object__'s __hash__\n+            # which is by id.\n             if cache_hash:\n                 raise TypeError(\n                     \"Invalid value for cache_hash.  To use hash caching,\"\n                     \" hashing must be either explicitly or implicitly \"\n                     \"enabled.\"\n                 )\n-        elif (\n-            hash is True\n-            or (hash is None and cmp is True and frozen is True)\n-            and is_exc is False\n-        ):\n+        elif hash is True or (hash is None and cmp is True and frozen is True):\n+            # Build a __hash__ if told so, or if it's safe.\n             builder.add_hash()\n         else:\n+            # Raise TypeError on attempts to hash.\n             if cache_hash:\n                 raise TypeError(\n                     \"Invalid value for cache_hash.  To use hash caching,\"\n",
        "test_patch": "diff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -515,9 +515,8 @@ class C(object):\n     @pytest.mark.parametrize(\"frozen\", [True, False])\n     def test_auto_exc(self, slots, frozen):\n         \"\"\"\n-        Classes with auto_exc=True have a Exception-style __str__, are neither\n-        comparable nor hashable, and store the fields additionally in\n-        self.args.\n+        Classes with auto_exc=True have a Exception-style __str__, compare and\n+        hash by id, and store the fields additionally in self.args.\n         \"\"\"\n \n         @attr.s(auto_exc=True, slots=slots, frozen=frozen)\n@@ -545,21 +544,28 @@ class FooError(Exception):\n         assert FooErrorMade(1, \"foo\") != FooErrorMade(1, \"foo\")\n \n         for cls in (FooError, FooErrorMade):\n-            with pytest.raises(cls) as ei:\n+            with pytest.raises(cls) as ei1:\n                 raise cls(1, \"foo\")\n \n-            e = ei.value\n+            with pytest.raises(cls) as ei2:\n+                raise cls(1, \"foo\")\n+\n+            e1 = ei1.value\n+            e2 = ei2.value\n \n-            assert e is e\n-            assert e == e\n-            assert \"(1, 'foo')\" == str(e)\n-            assert (1, \"foo\") == e.args\n+            assert e1 is e1\n+            assert e1 == e1\n+            assert e2 == e2\n+            assert e1 != e2\n+            assert \"(1, 'foo')\" == str(e1) == str(e2)\n+            assert (1, \"foo\") == e1.args == e2.args\n \n-            with pytest.raises(TypeError):\n-                hash(e)\n+            hash(e1) == hash(e1)\n+            hash(e2) == hash(e2)\n \n             if not frozen:\n-                deepcopy(e)\n+                deepcopy(e1)\n+                deepcopy(e2)\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n     @pytest.mark.parametrize(\"frozen\", [True, False])\n",
        "problem_statement": "auto_exc's hashing behavior and its documentation do not match\nThe [documentation](https://github.com/python-attrs/attrs/blob/25a02bbc7b5309acebda20101125372d42c978db/src/attr/_make.py#L846) for `auto_exc` says:\r\n```\r\n  - the values for *cmp* and *hash* are ignored and the instances compare\r\n          and hash by the instance's ids (N.B. ``attrs`` will *not* remove\r\n          existing implementations of ``__hash__`` or the equality methods. It\r\n          just won't add own ones.),\r\n```\r\n\r\nHowever, the test for `auto_exc` [says](https://github.com/python-attrs/attrs/blob/25a02bbc7b5309acebda20101125372d42c978db/tests/test_dark_magic.py#L519):\r\n```\r\n    Classes with auto_exc=True have a Exception-style __str__, are neither\r\n        comparable nor hashable, and store the fields additionally in\r\n        self.args.\r\n```\r\n\r\nand [tests](https://github.com/python-attrs/attrs/blob/25a02bbc7b5309acebda20101125372d42c978db/tests/test_dark_magic.py#L558):\r\n\r\n```\r\n            with pytest.raises(TypeError):\r\n                hash(e)\r\n```\r\n\r\nThe documentation and the code should be made consistent.  I noticed this because `unittest` complained that the exception type was unhashable when thrown from a test and I see some [references to `logging` expecting hashable exceptions](https://github.com/schematics/schematics/issues/452), so the documented behavior is probably better than the implemented behavior.\n",
        "hints_text": "Oh god, are there any docs on Exception hashability? This looks bonkers:\r\n\r\n```python\r\nIn [7]: hash(Exception()) == hash(Exception())\r\nOut[7]: True\r\n\r\nIn [8]: hash(Exception(1)) == hash(Exception(1))\r\nOut[8]: True\r\n\r\nIn [9]: hash(Exception(1)) == hash(Exception(2))\r\nOut[9]: True\r\n\r\nIn [10]: hash(TypeError(1)) == hash(TypeError(2))\r\nOut[10]: True\r\n```\n@hynek: This confused me for quite a while, but I think I have tracked it down, helped by some further investigation by @berquist.\r\n\r\nNote you don't get the same error if you first assign the exceptions to variables before doing the comparison.  I think what is going on is:\r\n\r\n1. `Exception` and `TypeError` have hash and equality by `id()`.\r\n2.  The the first exception is created and its hash is taken from its memory location.  Then it is no longer referenced, so it is deleted from memory.  The second exception is created in the same memory location formerly occupied by the first exception and therefore has an identical `id()`.  See https://github.com/satwikkansal/wtfpython#-deep-down-were-all-the-same- .\r\n\r\nFor the life of me I can't find any documentation of the requirements or conventions for `__eq__` and `__hash__` with respect to exceptions.   There is definitely nothing about it in [the obvious](https://docs.python.org/3.7/tutorial/errors.html) [places](https://docs.python.org/3.7/library/exceptions.html) in the Python documentation.  This is unfortunately an extremely difficult thing to Google for, and I can't turn up anything else useful.  Also, what appears to be [the tests for the base exception classes in CPython](https://github.com/python/cpython/blob/8f4ef3b019ce380022018587571b0f970e668de3/Lib/test/test_exceptions.py) have no tests related to either hashing or equality. \r\n\r\nThe actual behavior of the built-in exceptions seems to match what the `attrs` documentation says it will do (hashing and equality by `id()`), so it seems reasonable to switch the implementation to match the documentation.\r\n",
        "created_at": "2019-08-18T06:46:16Z",
        "version": "19.1"
    }
}