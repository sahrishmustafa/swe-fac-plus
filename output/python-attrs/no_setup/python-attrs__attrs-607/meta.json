{
    "task_id": "python-attrs__attrs-607",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-607_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 607,
        "instance_id": "python-attrs__attrs-607",
        "issue_numbers": [
            "324"
        ],
        "base_commit": "94ad4f39172929a9696670eb03a9151feda63e03",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -218,7 +218,7 @@ def attrib(\n     .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n     .. versionadded:: 19.2.0 *eq* and *order*\n     \"\"\"\n-    eq, order = _determine_eq_order(cmp, eq, order)\n+    eq, order = _determine_eq_order(cmp, eq, order, True)\n \n     if hash is not None and hash is not True and hash is not False:\n         raise TypeError(\n@@ -308,20 +308,32 @@ def _is_class_var(annot):\n     return str(annot).startswith(_classvar_prefixes)\n \n \n-def _get_annotations(cls):\n+def _has_own_attribute(cls, attrib_name):\n     \"\"\"\n-    Get annotations for *cls*.\n+    Check whether *cls* defines *attrib_name* (and doesn't just inherit it).\n+\n+    Requires Python 3.\n     \"\"\"\n-    anns = getattr(cls, \"__annotations__\", None)\n-    if anns is None:\n-        return {}\n+    attr = getattr(cls, attrib_name, _sentinel)\n+    if attr is _sentinel:\n+        return False\n \n-    # Verify that the annotations aren't merely inherited.\n     for base_cls in cls.__mro__[1:]:\n-        if anns is getattr(base_cls, \"__annotations__\", None):\n-            return {}\n+        a = getattr(base_cls, attrib_name, None)\n+        if attr is a:\n+            return False\n+\n+    return True\n+\n+\n+def _get_annotations(cls):\n+    \"\"\"\n+    Get annotations for *cls*.\n+    \"\"\"\n+    if _has_own_attribute(cls, \"__annotations__\"):\n+        return cls.__annotations__\n \n-    return anns\n+    return {}\n \n \n def _counter_getter(e):\n@@ -754,10 +766,10 @@ def _add_method_dunders(self, method):\n )\n \n \n-def _determine_eq_order(cmp, eq, order):\n+def _determine_eq_order(cmp, eq, order, default_eq):\n     \"\"\"\n     Validate the combination of *cmp*, *eq*, and *order*. Derive the effective\n-    values of eq and order.\n+    values of eq and order.  If *eq* is None, set it to *default_eq*.\n     \"\"\"\n     if cmp is not None and any((eq is not None, order is not None)):\n         raise ValueError(\"Don't mix `cmp` with `eq' and `order`.\")\n@@ -768,9 +780,10 @@ def _determine_eq_order(cmp, eq, order):\n \n         return cmp, cmp\n \n-    # If left None, equality is on and ordering mirrors equality.\n+    # If left None, equality is set to the specified default and ordering\n+    # mirrors equality.\n     if eq is None:\n-        eq = True\n+        eq = default_eq\n \n     if order is None:\n         order = eq\n@@ -781,14 +794,38 @@ def _determine_eq_order(cmp, eq, order):\n     return eq, order\n \n \n+def _determine_whether_to_implement(cls, flag, auto_detect, dunders):\n+    \"\"\"\n+    Check whether we should implement a set of methods for *cls*.\n+\n+    *flag* is the argument passed into @attr.s like 'init', *auto_detect* the\n+    same as passed into @attr.s and *dunders* is a tuple of attribute names\n+    whose presence signal that the user has implemented it themselves.\n+\n+    auto_detect must be False on Python 2.\n+    \"\"\"\n+    if flag is True or flag is None and auto_detect is False:\n+        return True\n+\n+    if flag is False:\n+        return False\n+\n+    # Logically, flag is None and auto_detect is True here.\n+    for dunder in dunders:\n+        if _has_own_attribute(cls, dunder):\n+            return False\n+\n+    return True\n+\n+\n def attrs(\n     maybe_cls=None,\n     these=None,\n     repr_ns=None,\n-    repr=True,\n+    repr=None,\n     cmp=None,\n     hash=None,\n-    init=True,\n+    init=None,\n     slots=False,\n     frozen=False,\n     weakref_slot=True,\n@@ -799,6 +836,7 @@ def attrs(\n     auto_exc=False,\n     eq=None,\n     order=None,\n+    auto_detect=False,\n ):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -823,6 +861,32 @@ def attrs(\n     :param str repr_ns: When using nested classes, there's no way in Python 2\n         to automatically detect that.  Therefore it's possible to set the\n         namespace explicitly for a more meaningful ``repr`` output.\n+    :param bool auto_detect: Instead of setting the *init*, *repr*, *eq*,\n+        *order*, and *hash* arguments explicitly, assume they are set to\n+        ``True`` **unless any** of the involved methods for one of the\n+        arguments is implemented in the *current* class (i.e. it is *not*\n+        inherited from some base class).\n+\n+        So for example by implementing ``__eq__`` on a class yourself,\n+        ``attrs`` will deduce ``eq=False`` and won't create *neither*\n+        ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible\n+        ``__ne__`` by default, so it *should* be enough to only implement\n+        ``__eq__`` in most cases).\n+\n+        .. warning::\n+\n+           If you prevent ``attrs`` from creating the ordering methods for you\n+           (``order=False``, e.g. by implementing ``__le__``), it becomes\n+           *your* responsibility to make sure its ordering is sound. The best\n+           way is to use the `functools.total_ordering` decorator.\n+\n+\n+        Passing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,\n+        *cmp*, or *hash* overrides whatever *auto_detect* would determine.\n+\n+        *auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises\n+        a `PythonTooOldError`.\n+\n     :param bool repr: Create a ``__repr__`` method with a human readable\n         representation of ``attrs`` attributes..\n     :param bool str: Create a ``__str__`` method that is identical to\n@@ -891,8 +955,8 @@ def attrs(\n \n     :param bool weakref_slot: Make instances weak-referenceable.  This has no\n         effect unless ``slots`` is also enabled.\n-    :param bool auto_attribs: If True, collect `PEP 526`_-annotated attributes\n-        (Python 3.6 and later only) from the class body.\n+    :param bool auto_attribs: If ``True``, collect `PEP 526`_-annotated\n+        attributes (Python 3.6 and later only) from the class body.\n \n         In this case, you **must** annotate every field.  If ``attrs``\n         encounters a field that is set to an `attr.ib` but lacks a type\n@@ -957,8 +1021,15 @@ def attrs(\n     .. versionadded:: 19.1.0 *auto_exc*\n     .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n     .. versionadded:: 19.2.0 *eq* and *order*\n+    .. versionadded:: 20.1.0 *auto_detect*\n     \"\"\"\n-    eq, order = _determine_eq_order(cmp, eq, order)\n+    if auto_detect and PY2:\n+        raise PythonTooOldError(\n+            \"auto_detect only works on Python 3 and later.\"\n+        )\n+\n+    eq_, order_ = _determine_eq_order(cmp, eq, order, None)\n+    hash_ = hash  # workaround the lack of nonlocal\n \n     def wrap(cls):\n \n@@ -978,16 +1049,31 @@ def wrap(cls):\n             cache_hash,\n             is_exc,\n         )\n-\n-        if repr is True:\n+        if _determine_whether_to_implement(\n+            cls, repr, auto_detect, (\"__repr__\",)\n+        ):\n             builder.add_repr(repr_ns)\n         if str is True:\n             builder.add_str()\n-        if eq is True and not is_exc:\n+\n+        eq = _determine_whether_to_implement(\n+            cls, eq_, auto_detect, (\"__eq__\", \"__ne__\")\n+        )\n+        if not is_exc and eq is True:\n             builder.add_eq()\n-        if order is True and not is_exc:\n+        if not is_exc and _determine_whether_to_implement(\n+            cls, order_, auto_detect, (\"__lt__\", \"__le__\", \"__gt__\", \"__ge__\")\n+        ):\n             builder.add_order()\n \n+        if (\n+            hash_ is None\n+            and auto_detect is True\n+            and _has_own_attribute(cls, \"__hash__\")\n+        ):\n+            hash = False\n+        else:\n+            hash = hash_\n         if hash is not True and hash is not False and hash is not None:\n             # Can't use `hash in` because 1 == True for example.\n             raise TypeError(\n@@ -1015,7 +1101,9 @@ def wrap(cls):\n                 )\n             builder.make_unhashable()\n \n-        if init is True:\n+        if _determine_whether_to_implement(\n+            cls, init, auto_detect, (\"__init__\",)\n+        ):\n             builder.add_init()\n         else:\n             if cache_hash:\n@@ -1832,7 +1920,7 @@ def __init__(\n         eq=None,\n         order=None,\n     ):\n-        eq, order = _determine_eq_order(cmp, eq, order)\n+        eq, order = _determine_eq_order(cmp, eq, order, True)\n \n         # Cache this descriptor here to speed things up later.\n         bound_setattr = _obj_setattr.__get__(self, Attribute)\n@@ -2178,7 +2266,10 @@ def make_class(name, attrs, bases=(object,), **attributes_arguments):\n         attributes_arguments[\"eq\"],\n         attributes_arguments[\"order\"],\n     ) = _determine_eq_order(\n-        cmp, attributes_arguments.get(\"eq\"), attributes_arguments.get(\"order\")\n+        cmp,\n+        attributes_arguments.get(\"eq\"),\n+        attributes_arguments.get(\"order\"),\n+        True,\n     )\n \n     return _attrs(these=cls_dict, **attributes_arguments)(type_)\ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\n--- a/src/attr/exceptions.py\n+++ b/src/attr/exceptions.py\n@@ -51,7 +51,8 @@ class UnannotatedAttributeError(RuntimeError):\n \n class PythonTooOldError(RuntimeError):\n     \"\"\"\n-    An ``attrs`` feature requiring a more recent python version has been used.\n+    It was attempted to use an ``attrs`` feature that requires a newer Python\n+    version.\n \n     .. versionadded:: 18.2.0\n     \"\"\"\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -5,6 +5,7 @@\n from __future__ import absolute_import, division, print_function\n \n import copy\n+import functools\n import gc\n import inspect\n import itertools\n@@ -29,6 +30,7 @@\n     _ClassBuilder,\n     _CountingAttr,\n     _determine_eq_order,\n+    _determine_whether_to_implement,\n     _transform_attrs,\n     and_,\n     fields,\n@@ -1588,16 +1590,16 @@ class B(A):\n class TestDetermineEqOrder(object):\n     def test_default(self):\n         \"\"\"\n-        If all are set to None, do the default: True, True\n+        If all are set to None, set both eq and order to the passed default.\n         \"\"\"\n-        assert (True, True) == _determine_eq_order(None, None, None)\n+        assert (42, 42) == _determine_eq_order(None, None, None, 42)\n \n     @pytest.mark.parametrize(\"eq\", [True, False])\n     def test_order_mirrors_eq_by_default(self, eq):\n         \"\"\"\n         If order is None, it mirrors eq.\n         \"\"\"\n-        assert (eq, eq) == _determine_eq_order(None, eq, None)\n+        assert (eq, eq) == _determine_eq_order(None, eq, None, True)\n \n     def test_order_without_eq(self):\n         \"\"\"\n@@ -1606,7 +1608,7 @@ def test_order_without_eq(self):\n         with pytest.raises(\n             ValueError, match=\"`order` can only be True if `eq` is True too.\"\n         ):\n-            _determine_eq_order(None, False, True)\n+            _determine_eq_order(None, False, True, True)\n \n     @given(cmp=booleans(), eq=optional_bool, order=optional_bool)\n     def test_mix(self, cmp, eq, order):\n@@ -1618,7 +1620,7 @@ def test_mix(self, cmp, eq, order):\n         with pytest.raises(\n             ValueError, match=\"Don't mix `cmp` with `eq' and `order`.\"\n         ):\n-            _determine_eq_order(cmp, eq, order)\n+            _determine_eq_order(cmp, eq, order, True)\n \n     def test_cmp_deprecated(self):\n         \"\"\"\n@@ -1669,3 +1671,346 @@ class A(object):\n                 A.__qualname__\n             )\n             assert expected == method.__doc__\n+\n+\n+@pytest.mark.skipif(not PY2, reason=\"Needs to be only caught on Python 2.\")\n+def test_auto_detect_raises_on_py2():\n+    \"\"\"\n+    Trying to pass auto_detect=True to attr.s raises PythonTooOldError.\n+    \"\"\"\n+    with pytest.raises(PythonTooOldError):\n+        attr.s(auto_detect=True)\n+\n+\n+class BareC(object):\n+    pass\n+\n+\n+class BareSlottedC(object):\n+    __slots__ = ()\n+\n+\n+@pytest.mark.skipif(PY2, reason=\"Auto-detection is Python 3-only.\")\n+class TestAutoDetect:\n+    @pytest.mark.parametrize(\"C\", (BareC, BareSlottedC))\n+    def test_determine_detects_non_presence_correctly(self, C):\n+        \"\"\"\n+        On an empty class, nothing should be detected.\n+        \"\"\"\n+        assert True is _determine_whether_to_implement(\n+            C, None, True, (\"__init__\",)\n+        )\n+        assert True is _determine_whether_to_implement(\n+            C, None, True, (\"__repr__\",)\n+        )\n+        assert True is _determine_whether_to_implement(\n+            C, None, True, (\"__eq__\", \"__ne__\")\n+        )\n+        assert True is _determine_whether_to_implement(\n+            C, None, True, (\"__le__\", \"__lt__\", \"__ge__\", \"__gt__\")\n+        )\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_make_all_by_default(self, slots, frozen):\n+        \"\"\"\n+        If nothing is there to be detected, imply init=True, repr=True,\n+        hash=None, eq=True, order=True.\n+        \"\"\"\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+        i = C(1)\n+        o = object()\n+\n+        assert i.__init__ is not o.__init__\n+        assert i.__repr__ is not o.__repr__\n+        assert i.__eq__ is not o.__eq__\n+        assert i.__ne__ is not o.__ne__\n+        assert i.__le__ is not o.__le__\n+        assert i.__lt__ is not o.__lt__\n+        assert i.__ge__ is not o.__ge__\n+        assert i.__gt__ is not o.__gt__\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_detect_auto_init(self, slots, frozen):\n+        \"\"\"\n+        If auto_detect=True and an __init__ exists, don't write one.\n+        \"\"\"\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class CI(object):\n+            x = attr.ib()\n+\n+            def __init__(self):\n+                object.__setattr__(self, \"x\", 42)\n+\n+        assert 42 == CI().x\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_detect_auto_repr(self, slots, frozen):\n+        \"\"\"\n+        If auto_detect=True and an __repr__ exists, don't write one.\n+        \"\"\"\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+            def __repr__(self):\n+                return \"hi\"\n+\n+        assert \"hi\" == repr(C(42))\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_detect_auto_hash(self, slots, frozen):\n+        \"\"\"\n+        If auto_detect=True and an __hash__ exists, don't write one.\n+        \"\"\"\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+            def __hash__(self):\n+                return 0xC0FFEE\n+\n+        assert 0xC0FFEE == hash(C(42))\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_detect_auto_eq(self, slots, frozen):\n+        \"\"\"\n+        If auto_detect=True and an __eq__ or an __ne__, exist, don't write one.\n+        \"\"\"\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+            def __eq__(self, o):\n+                raise ValueError(\"worked\")\n+\n+        with pytest.raises(ValueError, match=\"worked\"):\n+            C(1) == C(1)\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class D(object):\n+            x = attr.ib()\n+\n+            def __ne__(self, o):\n+                raise ValueError(\"worked\")\n+\n+        with pytest.raises(ValueError, match=\"worked\"):\n+            D(1) != D(1)\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_detect_auto_order(self, slots, frozen):\n+        \"\"\"\n+        If auto_detect=True and an __ge__, __gt__, __le__, or and __lt__ exist,\n+        don't write one.\n+\n+        It's surprisingly difficult to test this programmatically, so we do it\n+        by hand.\n+        \"\"\"\n+\n+        def assert_not_set(cls, ex, meth_name):\n+            __tracebackhide__ = True\n+\n+            a = getattr(cls, meth_name)\n+            if meth_name == ex:\n+                assert a == 42\n+            else:\n+                assert a is getattr(object, meth_name)\n+\n+        def assert_none_set(cls, ex):\n+            __tracebackhide__ = True\n+\n+            for m in (\"le\", \"lt\", \"ge\", \"gt\"):\n+                assert_not_set(cls, ex, \"__\" + m + \"__\")\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class LE(object):\n+            __le__ = 42\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class LT(object):\n+            __lt__ = 42\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class GE(object):\n+            __ge__ = 42\n+\n+        @attr.s(auto_detect=True, slots=slots, frozen=frozen)\n+        class GT(object):\n+            __gt__ = 42\n+\n+        assert_none_set(LE, \"__le__\")\n+        assert_none_set(LT, \"__lt__\")\n+        assert_none_set(GE, \"__ge__\")\n+        assert_none_set(GT, \"__gt__\")\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_override_init(self, slots, frozen):\n+        \"\"\"\n+        If init=True is passed, ignore __init__.\n+        \"\"\"\n+\n+        @attr.s(init=True, auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+            def __init__(self):\n+                pytest.fail(\"should not be called\")\n+\n+        assert C(1) == C(1)\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_override_repr(self, slots, frozen):\n+        \"\"\"\n+        If repr=True is passed, ignore __repr__.\n+        \"\"\"\n+\n+        @attr.s(repr=True, auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+            def __repr__(self):\n+                pytest.fail(\"should not be called\")\n+\n+        assert \"C(x=1)\" == repr(C(1))\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_override_hash(self, slots, frozen):\n+        \"\"\"\n+        If hash=True is passed, ignore __hash__.\n+        \"\"\"\n+\n+        @attr.s(hash=True, auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+            def __hash__(self):\n+                pytest.fail(\"should not be called\")\n+\n+        assert hash(C(1))\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    def test_override_eq(self, slots, frozen):\n+        \"\"\"\n+        If eq=True is passed, ignore __eq__ and __ne__.\n+        \"\"\"\n+\n+        @attr.s(eq=True, auto_detect=True, slots=slots, frozen=frozen)\n+        class C(object):\n+            x = attr.ib()\n+\n+            def __eq__(self, o):\n+                pytest.fail(\"should not be called\")\n+\n+            def __ne__(self, o):\n+                pytest.fail(\"should not be called\")\n+\n+        assert C(1) == C(1)\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"frozen\", [True, False])\n+    @pytest.mark.parametrize(\n+        \"eq,order,cmp\",\n+        [\n+            (True, None, None),\n+            (True, True, None),\n+            (None, True, None),\n+            (None, None, True),\n+        ],\n+    )\n+    def test_override_order(self, slots, frozen, eq, order, cmp, recwarn):\n+        \"\"\"\n+        If order=True is passed, ignore __le__, __lt__, __gt__, __ge__.\n+\n+        eq=True and cmp=True both imply order=True so test it too.\n+        \"\"\"\n+\n+        def meth(self, o):\n+            pytest.fail(\"should not be called\")\n+\n+        @attr.s(\n+            cmp=cmp,\n+            order=order,\n+            eq=eq,\n+            auto_detect=True,\n+            slots=slots,\n+            frozen=frozen,\n+        )\n+        class C(object):\n+            x = attr.ib()\n+            __le__ = __lt__ = __gt__ = __ge__ = meth\n+\n+        assert C(1) < C(2)\n+        assert C(1) <= C(2)\n+        assert C(2) > C(1)\n+        assert C(2) >= C(1)\n+\n+        if cmp:\n+            assert 1 == len(recwarn.list)\n+        else:\n+            assert 0 == len(recwarn.list)\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    @pytest.mark.parametrize(\"first\", [True, False])\n+    def test_total_ordering(self, slots, first):\n+        \"\"\"\n+        functools.total_ordering works as expected if an order method and an eq\n+        method are detected.\n+\n+        Ensure the order doesn't matter.\n+        \"\"\"\n+\n+        class C(object):\n+            x = attr.ib()\n+            own_eq_called = attr.ib(default=False)\n+            own_le_called = attr.ib(default=False)\n+\n+            def __eq__(self, o):\n+                self.own_eq_called = True\n+                return self.x == o.x\n+\n+            def __le__(self, o):\n+                self.own_le_called = True\n+                return self.x <= o.x\n+\n+        if first:\n+            C = functools.total_ordering(\n+                attr.s(auto_detect=True, slots=slots)(C)\n+            )\n+        else:\n+            C = attr.s(auto_detect=True, slots=slots)(\n+                functools.total_ordering(C)\n+            )\n+\n+        c1, c2 = C(1), C(2)\n+\n+        assert c1 < c2\n+        assert c1.own_le_called\n+\n+        c1, c2 = C(1), C(2)\n+\n+        assert c2 > c1\n+        assert c2.own_le_called\n+\n+        c1, c2 = C(1), C(2)\n+\n+        assert c2 != c1\n+        assert c1 == c1\n+\n+        assert c1.own_eq_called\ndiff --git a/tests/typing_example.py b/tests/typing_example.py\n--- a/tests/typing_example.py\n+++ b/tests/typing_example.py\n@@ -183,3 +183,13 @@ class WithCustomRepr:\n class OrderFlags:\n     a = attr.ib(eq=False, order=False)\n     b = attr.ib(eq=True, order=True)\n+\n+\n+# Auto-detect\n+# XXX: needs support in mypy\n+# @attr.s(auto_detect=True)\n+# class AutoDetect:\n+#     x: int\n+\n+#     def __init__(self, x: int):\n+#         self.x = x\n",
        "problem_statement": "Auto-detect user-written methods\nCurrently, if you want to implement a method yourself, you have to remember to do two things:\r\n\r\n```python\r\n@attr.s(repr=False)\r\nclass C:\r\n    def __repr__(self):\r\n        return \"whatever\"\r\n```\r\n\r\nI\u2019ve seen quite a few people be confused/frustrated by that.\r\n\r\n***\r\n\r\nI think unless `these` is set, it would be kind of cool if we detected that the current class (and not some super class) has a user-written method and set the flag to false automatically such that\r\n\r\n```python\r\n@attr.s\r\nclass C:\r\n    def __repr__(self):\r\n        return \"whatever\"\r\n```\r\n\r\ndoes what you\u2019d expect.\r\n\r\nOpinions?\n",
        "hints_text": "\ud83d\udc4d \nSame with `__init__`?  (I ask because the mypy plugin will have to deal with that too.)\nThe idea is to support it for all of them.  It gets a bit hairy when we get to comparison because it\u2019s several ones.  Would we stop completely?  Or just not replace one of them?\nWith comparison methods, perhaps [total_ordering](https://docs.python.org/3/library/functools.html#functools.total_ordering) could provide guidance; if you provide enough for `total_ordering` to work, we apply it or do something similar?\r\n\r\nIt's a bit of feature creep, but it feels in line with the developer doing as little work related to attributes as necessary and we take care of the rest.\nThe more I think about it the more I think we should just skip methods that have been defined and be done with it.  That allows people to customise their classes even better.",
        "created_at": "2020-01-03T13:24:16Z",
        "version": "19.3"
    }
}