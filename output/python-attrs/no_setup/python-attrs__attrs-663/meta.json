{
    "task_id": "python-attrs__attrs-663",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-663_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 663,
        "instance_id": "python-attrs__attrs-663",
        "issue_numbers": [
            "661"
        ],
        "base_commit": "e554373d16a000c6b022ef3f46b7607f704f4e8b",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -557,6 +557,7 @@ class _ClassBuilder(object):\n         \"_on_setattr\",\n         \"_slots\",\n         \"_weakref_slot\",\n+        \"_has_own_setattr\",\n     )\n \n     def __init__(\n@@ -573,6 +574,7 @@ def __init__(\n         is_exc,\n         collect_by_mro,\n         on_setattr,\n+        has_custom_setattr,\n     ):\n         attrs, base_attrs, base_map = _transform_attrs(\n             cls, these, auto_attribs, kw_only, collect_by_mro,\n@@ -585,7 +587,7 @@ def __init__(\n         self._base_attr_map = base_map\n         self._attr_names = tuple(a.name for a in attrs)\n         self._slots = slots\n-        self._frozen = frozen or _has_frozen_base_class(cls)\n+        self._frozen = frozen\n         self._weakref_slot = weakref_slot\n         self._cache_hash = cache_hash\n         self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\n@@ -593,12 +595,16 @@ def __init__(\n         self._is_exc = is_exc\n         self._on_setattr = on_setattr\n \n+        self._has_own_setattr = has_custom_setattr\n+\n         self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n \n         if frozen:\n             self._cls_dict[\"__setattr__\"] = _frozen_setattrs\n             self._cls_dict[\"__delattr__\"] = _frozen_delattrs\n \n+            self._has_own_setattr = True\n+\n         if getstate_setstate:\n             (\n                 self._cls_dict[\"__getstate__\"],\n@@ -645,6 +651,13 @@ def _patch_original_class(self):\n         for name, value in self._cls_dict.items():\n             setattr(cls, name, value)\n \n+        # If we've inherited an attrs __setattr__ and don't write our own,\n+        # reset it to object's.\n+        if not self._has_own_setattr and getattr(\n+            cls, \"__attrs_own_setattr__\", False\n+        ):\n+            cls.__setattr__ = object.__setattr__\n+\n         return cls\n \n     def _create_slots_class(self):\n@@ -658,14 +671,24 @@ def _create_slots_class(self):\n             if k not in tuple(self._attr_names) + (\"__dict__\", \"__weakref__\")\n         }\n \n+        # Traverse the MRO to check for an existing __weakref__ and\n+        # __setattr__.\n+        custom_setattr_inherited = False\n         weakref_inherited = False\n-\n-        # Traverse the MRO to check for an existing __weakref__.\n         for base_cls in self._cls.__mro__[1:-1]:\n-            if \"__weakref__\" in getattr(base_cls, \"__dict__\", ()):\n-                weakref_inherited = True\n+            d = getattr(base_cls, \"__dict__\", {})\n+\n+            weakref_inherited = weakref_inherited or \"__weakref__\" in d\n+            custom_setattr_inherited = custom_setattr_inherited or not (\n+                d.get(\"__attrs_own_setattr__\", False)\n+            )\n+\n+            if weakref_inherited and custom_setattr_inherited:\n                 break\n \n+        if not self._has_own_setattr and not custom_setattr_inherited:\n+            cd[\"__setattr__\"] = object.__setattr__\n+\n         names = self._attr_names\n         if (\n             self._weakref_slot\n@@ -836,7 +859,20 @@ def add_setattr(self):\n         if not sa_attrs:\n             return self\n \n+        if self._has_own_setattr:\n+            # We need to write a __setattr__ but there already is one!\n+            raise ValueError(\n+                \"Can't combine custom __setattr__ with on_setattr hooks.\"\n+            )\n+\n+        cls = self._cls\n+\n         def __setattr__(self, name, val):\n+            \"\"\"\n+            Method generated by attrs for class %s.\n+            \"\"\" % (\n+                cls.__name__,\n+            )\n             try:\n                 a, hook = sa_attrs[name]\n             except KeyError:\n@@ -846,7 +882,9 @@ def __setattr__(self, name, val):\n \n             _obj_setattr(self, name, nval)\n \n+        self._cls_dict[\"__attrs_own_setattr__\"] = True\n         self._cls_dict[\"__setattr__\"] = self._add_method_dunders(__setattr__)\n+        self._has_own_setattr = True\n \n         return self\n \n@@ -1076,6 +1114,8 @@ def attrs(\n                circumvent that limitation by using\n                ``object.__setattr__(self, \"attribute_name\", value)``.\n \n+            5. Subclasses of a frozen class are frozen too.\n+\n     :param bool weakref_slot: Make instances weak-referenceable.  This has no\n         effect unless ``slots`` is also enabled.\n     :param bool auto_attribs: If ``True``, collect `PEP 526`_-annotated\n@@ -1200,13 +1240,20 @@ def wrap(cls):\n         if getattr(cls, \"__class__\", None) is None:\n             raise TypeError(\"attrs only works with new-style classes.\")\n \n+        is_frozen = frozen or _has_frozen_base_class(cls)\n         is_exc = auto_exc is True and issubclass(cls, BaseException)\n+        has_own_setattr = auto_detect and _has_own_attribute(\n+            cls, \"__setattr__\"\n+        )\n+\n+        if has_own_setattr and is_frozen:\n+            raise ValueError(\"Can't freeze a class with a custom __setattr__.\")\n \n         builder = _ClassBuilder(\n             cls,\n             these,\n             slots,\n-            frozen,\n+            is_frozen,\n             weakref_slot,\n             _determine_whether_to_implement(\n                 cls,\n@@ -1221,6 +1268,7 @@ def wrap(cls):\n             is_exc,\n             collect_by_mro,\n             on_setattr,\n+            has_own_setattr,\n         )\n         if _determine_whether_to_implement(\n             cls, repr, auto_detect, (\"__repr__\",)\n@@ -1263,7 +1311,9 @@ def wrap(cls):\n                     \" hashing must be either explicitly or implicitly \"\n                     \"enabled.\"\n                 )\n-        elif hash is True or (hash is None and eq is True and frozen is True):\n+        elif hash is True or (\n+            hash is None and eq is True and is_frozen is True\n+        ):\n             # Build a __hash__ if told so, or if it's safe.\n             builder.add_hash()\n         else:\n",
        "test_patch": "diff --git a/tests/test_functional.py b/tests/test_functional.py\n--- a/tests/test_functional.py\n+++ b/tests/test_functional.py\n@@ -16,11 +16,9 @@\n \n import attr\n \n-from attr import setters\n from attr._compat import PY2, TYPE\n from attr._make import NOTHING, Attribute\n-from attr.exceptions import FrozenAttributeError, FrozenInstanceError\n-from attr.validators import instance_of, matches_re\n+from attr.exceptions import FrozenInstanceError\n \n from .strategies import optional_bool\n \n@@ -112,9 +110,9 @@ class WithMetaSlots(object):\n FromMakeClass = attr.make_class(\"FromMakeClass\", [\"x\"])\n \n \n-class TestDarkMagic(object):\n+class TestFunctional(object):\n     \"\"\"\n-    Integration tests.\n+    Functional tests.\n     \"\"\"\n \n     @pytest.mark.parametrize(\"cls\", [C2, C2Slots])\n@@ -320,6 +318,7 @@ def test_pickle_object(self, cls, protocol):\n             obj = cls(123, 456)\n         else:\n             obj = cls(123)\n+\n         assert repr(obj) == repr(pickle.loads(pickle.dumps(obj, protocol)))\n \n     def test_subclassing_frozen_gives_frozen(self):\n@@ -332,6 +331,9 @@ def test_subclassing_frozen_gives_frozen(self):\n         assert i.x == \"foo\"\n         assert i.y == \"bar\"\n \n+        with pytest.raises(FrozenInstanceError):\n+            i.x = \"baz\"\n+\n     @pytest.mark.parametrize(\"cls\", [WithMeta, WithMetaSlots])\n     def test_metaclass_preserved(self, cls):\n         \"\"\"\n@@ -683,183 +685,3 @@ class C(object):\n             \"2021-06-01.  Please use `eq` and `order` instead.\"\n             == w.message.args[0]\n         )\n-\n-\n-class TestSetAttr(object):\n-    def test_change(self):\n-        \"\"\"\n-        The return value of a hook overwrites the value. But they are not run\n-        on __init__.\n-        \"\"\"\n-\n-        def hook(*a, **kw):\n-            return \"hooked!\"\n-\n-        @attr.s\n-        class Hooked(object):\n-            x = attr.ib(on_setattr=hook)\n-            y = attr.ib()\n-\n-        h = Hooked(\"x\", \"y\")\n-\n-        assert \"x\" == h.x\n-        assert \"y\" == h.y\n-\n-        h.x = \"xxx\"\n-        h.y = \"yyy\"\n-\n-        assert \"yyy\" == h.y\n-        assert \"hooked!\" == h.x\n-\n-    def test_frozen_attribute(self):\n-        \"\"\"\n-        Frozen attributes raise FrozenAttributeError, others are not affected.\n-        \"\"\"\n-\n-        @attr.s\n-        class PartiallyFrozen(object):\n-            x = attr.ib(on_setattr=setters.frozen)\n-            y = attr.ib()\n-\n-        pf = PartiallyFrozen(\"x\", \"y\")\n-\n-        pf.y = \"yyy\"\n-\n-        assert \"yyy\" == pf.y\n-\n-        with pytest.raises(FrozenAttributeError):\n-            pf.x = \"xxx\"\n-\n-        assert \"x\" == pf.x\n-\n-    @pytest.mark.parametrize(\n-        \"on_setattr\",\n-        [setters.validate, [setters.validate], setters.pipe(setters.validate)],\n-    )\n-    def test_validator(self, on_setattr):\n-        \"\"\"\n-        Validators are run and they don't alter the value.\n-        \"\"\"\n-\n-        @attr.s(on_setattr=on_setattr)\n-        class ValidatedAttribute(object):\n-            x = attr.ib()\n-            y = attr.ib(validator=[instance_of(str), matches_re(\"foo.*qux\")])\n-\n-        va = ValidatedAttribute(42, \"foobarqux\")\n-\n-        with pytest.raises(TypeError) as ei:\n-            va.y = 42\n-\n-        assert \"foobarqux\" == va.y\n-\n-        assert ei.value.args[0].startswith(\"'y' must be <\")\n-\n-        with pytest.raises(ValueError) as ei:\n-            va.y = \"quxbarfoo\"\n-\n-        assert ei.value.args[0].startswith(\"'y' must match regex '\")\n-\n-        assert \"foobarqux\" == va.y\n-\n-        va.y = \"foobazqux\"\n-\n-        assert \"foobazqux\" == va.y\n-\n-    def test_pipe(self):\n-        \"\"\"\n-        Multiple hooks are possible, in that case the last return value is\n-        used. They can be supplied using the pipe functions or by passing a\n-        list to on_setattr.\n-        \"\"\"\n-\n-        s = [setters.convert, lambda _, __, nv: nv + 1]\n-\n-        @attr.s\n-        class Piped(object):\n-            x1 = attr.ib(converter=int, on_setattr=setters.pipe(*s))\n-            x2 = attr.ib(converter=int, on_setattr=s)\n-\n-        p = Piped(\"41\", \"22\")\n-\n-        assert 41 == p.x1\n-        assert 22 == p.x2\n-\n-        p.x1 = \"41\"\n-        p.x2 = \"22\"\n-\n-        assert 42 == p.x1\n-        assert 23 == p.x2\n-\n-    def test_make_class(self):\n-        \"\"\"\n-        on_setattr of make_class gets forwarded.\n-        \"\"\"\n-        C = attr.make_class(\"C\", {\"x\": attr.ib()}, on_setattr=setters.frozen)\n-\n-        c = C(1)\n-\n-        with pytest.raises(FrozenAttributeError):\n-            c.x = 2\n-\n-    def test_no_validator_no_converter(self):\n-        \"\"\"\n-        validate and convert tolerate missing validators and converters.\n-        \"\"\"\n-\n-        @attr.s(on_setattr=[setters.convert, setters.validate])\n-        class C(object):\n-            x = attr.ib()\n-\n-        c = C(1)\n-\n-        c.x = 2\n-\n-    def test_validate_respects_run_validators_config(self):\n-        \"\"\"\n-        If run validators is off, validate doesn't run them.\n-        \"\"\"\n-\n-        @attr.s(on_setattr=setters.validate)\n-        class C(object):\n-            x = attr.ib(validator=attr.validators.instance_of(int))\n-\n-        c = C(1)\n-\n-        attr.set_run_validators(False)\n-\n-        c.x = \"1\"\n-\n-        assert \"1\" == c.x\n-\n-        attr.set_run_validators(True)\n-\n-        with pytest.raises(TypeError) as ei:\n-            c.x = \"1\"\n-\n-        assert ei.value.args[0].startswith(\"'x' must be <\")\n-\n-    def test_frozen_on_setattr_class_is_caught(self):\n-        \"\"\"\n-        @attr.s(on_setattr=X, frozen=True) raises an ValueError.\n-        \"\"\"\n-        with pytest.raises(ValueError) as ei:\n-\n-            @attr.s(frozen=True, on_setattr=setters.validate)\n-            class C(object):\n-                x = attr.ib()\n-\n-        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\n-\n-    def test_frozen_on_setattr_attribute_is_caught(self):\n-        \"\"\"\n-        attr.ib(on_setattr=X) on a frozen class raises an ValueError.\n-        \"\"\"\n-\n-        with pytest.raises(ValueError) as ei:\n-\n-            @attr.s(frozen=True)\n-            class C(object):\n-                x = attr.ib(on_setattr=setters.validate)\n-\n-        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1466,6 +1466,7 @@ class C(object):\n             False,\n             True,\n             None,\n+            False,\n         )\n \n         assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n@@ -1491,6 +1492,7 @@ class C(object):\n             False,\n             True,\n             None,\n+            False,\n         )\n \n         cls = (\n@@ -1568,6 +1570,7 @@ class C(object):\n             cache_hash=False,\n             collect_by_mro=True,\n             on_setattr=None,\n+            has_custom_setattr=False,\n         )\n         b._cls = {}  # no __module__; no __qualname__\n \ndiff --git a/tests/test_setattr.py b/tests/test_setattr.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/test_setattr.py\n@@ -0,0 +1,347 @@\n+from __future__ import absolute_import, division, print_function\n+\n+import pickle\n+\n+import pytest\n+\n+import attr\n+\n+from attr import setters\n+from attr._compat import PY2\n+from attr.exceptions import FrozenAttributeError\n+from attr.validators import instance_of, matches_re\n+\n+\n+@attr.s(frozen=True)\n+class Frozen(object):\n+    x = attr.ib()\n+\n+\n+@attr.s\n+class WithOnSetAttrHook(object):\n+    x = attr.ib(on_setattr=lambda *args: None)\n+\n+\n+class TestSetAttr(object):\n+    def test_change(self):\n+        \"\"\"\n+        The return value of a hook overwrites the value. But they are not run\n+        on __init__.\n+        \"\"\"\n+\n+        def hook(*a, **kw):\n+            return \"hooked!\"\n+\n+        @attr.s\n+        class Hooked(object):\n+            x = attr.ib(on_setattr=hook)\n+            y = attr.ib()\n+\n+        h = Hooked(\"x\", \"y\")\n+\n+        assert \"x\" == h.x\n+        assert \"y\" == h.y\n+\n+        h.x = \"xxx\"\n+        h.y = \"yyy\"\n+\n+        assert \"yyy\" == h.y\n+        assert \"hooked!\" == h.x\n+\n+    def test_frozen_attribute(self):\n+        \"\"\"\n+        Frozen attributes raise FrozenAttributeError, others are not affected.\n+        \"\"\"\n+\n+        @attr.s\n+        class PartiallyFrozen(object):\n+            x = attr.ib(on_setattr=setters.frozen)\n+            y = attr.ib()\n+\n+        pf = PartiallyFrozen(\"x\", \"y\")\n+\n+        pf.y = \"yyy\"\n+\n+        assert \"yyy\" == pf.y\n+\n+        with pytest.raises(FrozenAttributeError):\n+            pf.x = \"xxx\"\n+\n+        assert \"x\" == pf.x\n+\n+    @pytest.mark.parametrize(\n+        \"on_setattr\",\n+        [setters.validate, [setters.validate], setters.pipe(setters.validate)],\n+    )\n+    def test_validator(self, on_setattr):\n+        \"\"\"\n+        Validators are run and they don't alter the value.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=on_setattr)\n+        class ValidatedAttribute(object):\n+            x = attr.ib()\n+            y = attr.ib(validator=[instance_of(str), matches_re(\"foo.*qux\")])\n+\n+        va = ValidatedAttribute(42, \"foobarqux\")\n+\n+        with pytest.raises(TypeError) as ei:\n+            va.y = 42\n+\n+        assert \"foobarqux\" == va.y\n+\n+        assert ei.value.args[0].startswith(\"'y' must be <\")\n+\n+        with pytest.raises(ValueError) as ei:\n+            va.y = \"quxbarfoo\"\n+\n+        assert ei.value.args[0].startswith(\"'y' must match regex '\")\n+\n+        assert \"foobarqux\" == va.y\n+\n+        va.y = \"foobazqux\"\n+\n+        assert \"foobazqux\" == va.y\n+\n+    def test_pipe(self):\n+        \"\"\"\n+        Multiple hooks are possible, in that case the last return value is\n+        used. They can be supplied using the pipe functions or by passing a\n+        list to on_setattr.\n+        \"\"\"\n+\n+        s = [setters.convert, lambda _, __, nv: nv + 1]\n+\n+        @attr.s\n+        class Piped(object):\n+            x1 = attr.ib(converter=int, on_setattr=setters.pipe(*s))\n+            x2 = attr.ib(converter=int, on_setattr=s)\n+\n+        p = Piped(\"41\", \"22\")\n+\n+        assert 41 == p.x1\n+        assert 22 == p.x2\n+\n+        p.x1 = \"41\"\n+        p.x2 = \"22\"\n+\n+        assert 42 == p.x1\n+        assert 23 == p.x2\n+\n+    def test_make_class(self):\n+        \"\"\"\n+        on_setattr of make_class gets forwarded.\n+        \"\"\"\n+        C = attr.make_class(\"C\", {\"x\": attr.ib()}, on_setattr=setters.frozen)\n+\n+        c = C(1)\n+\n+        with pytest.raises(FrozenAttributeError):\n+            c.x = 2\n+\n+    def test_no_validator_no_converter(self):\n+        \"\"\"\n+        validate and convert tolerate missing validators and converters.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=[setters.convert, setters.validate])\n+        class C(object):\n+            x = attr.ib()\n+\n+        c = C(1)\n+\n+        c.x = 2\n+\n+        assert 2 == c.x\n+\n+    def test_validate_respects_run_validators_config(self):\n+        \"\"\"\n+        If run validators is off, validate doesn't run them.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=setters.validate)\n+        class C(object):\n+            x = attr.ib(validator=attr.validators.instance_of(int))\n+\n+        c = C(1)\n+\n+        attr.set_run_validators(False)\n+\n+        c.x = \"1\"\n+\n+        assert \"1\" == c.x\n+\n+        attr.set_run_validators(True)\n+\n+        with pytest.raises(TypeError) as ei:\n+            c.x = \"1\"\n+\n+        assert ei.value.args[0].startswith(\"'x' must be <\")\n+\n+    def test_frozen_on_setattr_class_is_caught(self):\n+        \"\"\"\n+        @attr.s(on_setattr=X, frozen=True) raises an ValueError.\n+        \"\"\"\n+        with pytest.raises(ValueError) as ei:\n+\n+            @attr.s(frozen=True, on_setattr=setters.validate)\n+            class C(object):\n+                x = attr.ib()\n+\n+        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\n+\n+    def test_frozen_on_setattr_attribute_is_caught(self):\n+        \"\"\"\n+        attr.ib(on_setattr=X) on a frozen class raises an ValueError.\n+        \"\"\"\n+\n+        with pytest.raises(ValueError) as ei:\n+\n+            @attr.s(frozen=True)\n+            class C(object):\n+                x = attr.ib(on_setattr=setters.validate)\n+\n+        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_setattr_reset_if_no_custom_setattr(self, slots):\n+        \"\"\"\n+        If a class with an active setattr is subclassed and no new setattr\n+        is generated, the __setattr__ is set to object.__setattr__.\n+\n+        We do the double test because of Python 2.\n+        \"\"\"\n+\n+        def boom(*args):\n+            pytest.fail(\"Must not be called.\")\n+\n+        @attr.s\n+        class Hooked(object):\n+            x = attr.ib(on_setattr=boom)\n+\n+        @attr.s(slots=slots)\n+        class NoHook(WithOnSetAttrHook):\n+            x = attr.ib()\n+\n+        if not PY2:\n+            assert NoHook.__setattr__ == object.__setattr__\n+\n+        assert 1 == NoHook(1).x\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_setattr_inherited_do_not_reset(self, slots):\n+        \"\"\"\n+        If we inherit a __setattr__ that has been written by the user, we must\n+        not reset it unless necessary.\n+        \"\"\"\n+\n+        class A(object):\n+            \"\"\"\n+            Not an attrs class on purpose to prevent accidental resets that\n+            would render the asserts meaningless.\n+            \"\"\"\n+\n+            def __setattr__(self, *args):\n+                pass\n+\n+        @attr.s(slots=slots)\n+        class B(A):\n+            pass\n+\n+        assert B.__setattr__ == A.__setattr__\n+\n+        @attr.s(slots=slots)\n+        class C(B):\n+            pass\n+\n+        assert C.__setattr__ == A.__setattr__\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_pickling_retains_attrs_own(self, slots):\n+        \"\"\"\n+        Pickling/Unpickling does not lose ownership information about\n+        __setattr__.\n+        \"\"\"\n+        i = WithOnSetAttrHook(1)\n+\n+        assert True is i.__attrs_own_setattr__\n+\n+        i2 = pickle.loads(pickle.dumps(i))\n+\n+        assert True is i2.__attrs_own_setattr__\n+\n+        WOSAH = pickle.loads(pickle.dumps(WithOnSetAttrHook))\n+\n+        assert True is WOSAH.__attrs_own_setattr__\n+\n+\n+@pytest.mark.skipif(PY2, reason=\"Python 3-only.\")\n+class TestSetAttrNoPy2(object):\n+    \"\"\"\n+    __setattr__ tests for Py3+ to avoid the skip repetition.\n+    \"\"\"\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_setattr_auto_detect_if_no_custom_setattr(self, slots):\n+        \"\"\"\n+        It's possible to remove the on_setattr hook from an attribute and\n+        therefore write a custom __setattr__.\n+        \"\"\"\n+        assert 1 == WithOnSetAttrHook(1).x\n+\n+        @attr.s(auto_detect=True, slots=slots)\n+        class RemoveNeedForOurSetAttr(WithOnSetAttrHook):\n+            x = attr.ib()\n+\n+            def __setattr__(self, name, val):\n+                object.__setattr__(self, name, val * 2)\n+\n+        i = RemoveNeedForOurSetAttr(1)\n+\n+        assert 2 == i.x\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_setattr_restore_respects_auto_detect(self, slots):\n+        \"\"\"\n+        If __setattr__ should be restored but the user supplied its own and\n+        set auto_detect, leave is alone.\n+        \"\"\"\n+\n+        @attr.s(auto_detect=True, slots=slots)\n+        class CustomSetAttr:\n+            def __setattr__(self, _, __):\n+                pass\n+\n+        assert CustomSetAttr.__setattr__ != object.__setattr__\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_setattr_auto_detect_frozen(self, slots):\n+        \"\"\"\n+        frozen=True together with a detected custom __setattr__ are rejected.\n+        \"\"\"\n+        with pytest.raises(\n+            ValueError, match=\"Can't freeze a class with a custom __setattr__.\"\n+        ):\n+\n+            @attr.s(auto_detect=True, slots=slots, frozen=True)\n+            class CustomSetAttr(Frozen):\n+                def __setattr__(self, _, __):\n+                    pass\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_setattr_auto_detect_on_setattr(self, slots):\n+        \"\"\"\n+        on_setattr attributes together with a detected custom __setattr__ are\n+        rejected.\n+        \"\"\"\n+        with pytest.raises(\n+            ValueError,\n+            match=\"Can't combine custom __setattr__ with on_setattr hooks.\",\n+        ):\n+\n+            @attr.s(auto_detect=True, slots=slots)\n+            class HookAndCustomSetAttr(object):\n+                x = attr.ib(on_setattr=lambda *args: None)\n+\n+                def __setattr__(self, _, __):\n+                    pass\n",
        "problem_statement": "Restore __setattr__ when subclassing and we didn't write a new __setattr__\nCurrently if you do this:\r\n\r\n```python\r\n@attr.s(frozen=True)\r\nclass A:\r\n    a = attr.ib()\r\n\r\n@attr.s\r\nclass B(A):\r\n    b = attr.ib()\r\n```\r\n\r\nB is frozen too, because we don't write a new `__setattr__` to overwrite the old one. Once #660 is merged, this will become an even bigger problem.\r\n\r\nWe have to restore `__setattr__` to `object.__setattr__` if we don't have a reason to overwrite the existing one ourselves.\r\n\r\n`auto_detect=True` should be considered.\n",
        "hints_text": "OK turns out, the inheritance of frozeness is on purpose #128. Whether or not that was a good idea I'm not sure, but it's not something I'm willing to break.",
        "created_at": "2020-08-04T13:54:59Z",
        "version": "19.3"
    }
}