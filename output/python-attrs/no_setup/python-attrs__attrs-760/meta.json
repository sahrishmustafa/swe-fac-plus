{
    "task_id": "python-attrs__attrs-760",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-760_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 760,
        "instance_id": "python-attrs__attrs-760",
        "issue_numbers": [
            "593"
        ],
        "base_commit": "78335e9b49eff2eaf2dc31d0bcc3caa0169cfc60",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -286,6 +286,36 @@ def attrib(\n     )\n \n \n+def _compile_and_eval(script, globs, locs=None, filename=\"\"):\n+    \"\"\"\n+    \"Exec\" the script with the given global (globs) and local (locs) variables.\n+    \"\"\"\n+    bytecode = compile(script, filename, \"exec\")\n+    eval(bytecode, globs, locs)\n+\n+\n+def _make_method(name, script, filename, globs=None):\n+    \"\"\"\n+    Create the method with the script given and return the method object.\n+    \"\"\"\n+    locs = {}\n+    if globs is None:\n+        globs = {}\n+\n+    _compile_and_eval(script, globs, locs, filename)\n+\n+    # In order of debuggers like PDB being able to step through the code,\n+    # we add a fake linecache entry.\n+    linecache.cache[filename] = (\n+        len(script),\n+        None,\n+        script.splitlines(True),\n+        filename,\n+    )\n+\n+    return locs[name]\n+\n+\n def _make_attr_tuple_class(cls_name, attr_names):\n     \"\"\"\n     Create a tuple subclass to hold `Attribute`s for an `attrs` class.\n@@ -309,8 +339,7 @@ class MyClassAttributes(tuple):\n     else:\n         attr_class_template.append(\"    pass\")\n     globs = {\"_attrs_itemgetter\": itemgetter, \"_attrs_property\": property}\n-    eval(compile(\"\\n\".join(attr_class_template), \"\", \"exec\"), globs)\n-\n+    _compile_and_eval(\"\\n\".join(attr_class_template), globs)\n     return globs[attr_class_name]\n \n \n@@ -1591,21 +1620,7 @@ def append_hash_computation_lines(prefix, indent):\n         append_hash_computation_lines(\"return \", tab)\n \n     script = \"\\n\".join(method_lines)\n-    globs = {}\n-    locs = {}\n-    bytecode = compile(script, unique_filename, \"exec\")\n-    eval(bytecode, globs, locs)\n-\n-    # In order of debuggers like PDB being able to step through the code,\n-    # we add a fake linecache entry.\n-    linecache.cache[unique_filename] = (\n-        len(script),\n-        None,\n-        script.splitlines(True),\n-        unique_filename,\n-    )\n-\n-    return locs[\"__hash__\"]\n+    return _make_method(\"__hash__\", script, unique_filename)\n \n \n def _add_hash(cls, attrs):\n@@ -1661,20 +1676,7 @@ def _make_eq(cls, attrs):\n         lines.append(\"    return True\")\n \n     script = \"\\n\".join(lines)\n-    globs = {}\n-    locs = {}\n-    bytecode = compile(script, unique_filename, \"exec\")\n-    eval(bytecode, globs, locs)\n-\n-    # In order of debuggers like PDB being able to step through the code,\n-    # we add a fake linecache entry.\n-    linecache.cache[unique_filename] = (\n-        len(script),\n-        None,\n-        script.splitlines(True),\n-        unique_filename,\n-    )\n-    return locs[\"__eq__\"]\n+    return _make_method(\"__eq__\", script, unique_filename)\n \n \n def _make_order(cls, attrs):\n@@ -1949,8 +1951,10 @@ def _make_init(\n         has_global_on_setattr,\n         attrs_init,\n     )\n-    locs = {}\n-    bytecode = compile(script, unique_filename, \"exec\")\n+    if cls.__module__ in sys.modules:\n+        # This makes typing.get_type_hints(CLS.__init__) resolve string types.\n+        globs.update(sys.modules[cls.__module__].__dict__)\n+\n     globs.update({\"NOTHING\": NOTHING, \"attr_dict\": attr_dict})\n \n     if needs_cached_setattr:\n@@ -1958,18 +1962,12 @@ def _make_init(\n         # setattr hooks.\n         globs[\"_cached_setattr\"] = _obj_setattr\n \n-    eval(bytecode, globs, locs)\n-\n-    # In order of debuggers like PDB being able to step through the code,\n-    # we add a fake linecache entry.\n-    linecache.cache[unique_filename] = (\n-        len(script),\n-        None,\n-        script.splitlines(True),\n+    init = _make_method(\n+        \"__attrs_init__\" if attrs_init else \"__init__\",\n+        script,\n         unique_filename,\n+        globs,\n     )\n-\n-    init = locs[\"__attrs_init__\"] if attrs_init else locs[\"__init__\"]\n     init.__annotations__ = annotations\n \n     return init\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -578,3 +578,32 @@ class B:\n \n         assert typing.List[B] == attr.fields(A).a.type\n         assert A == attr.fields(B).a.type\n+\n+    def test_init_type_hints(self):\n+        \"\"\"\n+        Forward references in __init__ can be automatically resolved.\n+        \"\"\"\n+\n+        @attr.s\n+        class C:\n+            x = attr.ib(type=\"typing.List[int]\")\n+\n+        assert typing.get_type_hints(C.__init__) == {\n+            \"return\": type(None),\n+            \"x\": typing.List[int],\n+        }\n+\n+    def test_init_type_hints_fake_module(self):\n+        \"\"\"\n+        If you somehow set the __module__ to something that doesn't exist\n+        you'll lose __init__ resolution.\n+        \"\"\"\n+\n+        class C:\n+            x = attr.ib(type=\"typing.List[int]\")\n+\n+        C.__module__ = \"totally fake\"\n+        C = attr.s(C)\n+\n+        with pytest.raises(NameError):\n+            typing.get_type_hints(C.__init__)\n",
        "problem_statement": "Deferred type annotations are evaluated in the wrong execution context\nTo reproduce, run the following program:\r\n```python\r\nimport attr\r\nfrom typing import List, get_type_hints\r\n\r\n@attr.s\r\nclass C:\r\n    x = attr.ib(type='List[int]')\r\n\r\nprint(get_type_hints(C.__init__))\r\n```\r\n\r\n#### Expected result\r\n```\r\n{'return': <class 'NoneType'>, 'x': typing.List[int]}\r\n```\r\n\r\n#### Actual result\r\n```\r\nTraceback (most recent call last):\r\n  File \"example.py\", line 8, in <module>\r\n    print(get_type_hints(C.__init__))\r\n  File \"C:\\Python37\\lib\\typing.py\", line 1001, in get_type_hints\r\n    value = _eval_type(value, globalns, localns)\r\n  File \"C:\\Python37\\lib\\typing.py\", line 260, in _eval_type\r\n    return t._evaluate(globalns, localns)\r\n  File \"C:\\Python37\\lib\\typing.py\", line 464, in _evaluate\r\n    eval(self.__forward_code__, globalns, localns),\r\n  File \"<string>\", line 1, in <module>\r\nNameError: name 'List' is not defined\r\n```\r\n\r\nThis annotation should be evaluated in the context of the module where it's defined, where `List` is in globals.\r\n\r\n#### Version info\r\n```\r\nattrs 19.3.0\r\nPython 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32\r\n```\n",
        "hints_text": "I'm not sure that's something we can achieve TBH.\nI'm having the same problem. Is there any workaround in which the original `__init__.__globals__` can be accessed somehow? \r\n\r\nAlso, is there any way to know if a `__init__` method was created by `attrs`? (i.e. `is_attrs_init(C.__innit_)`)\r\n\r\n\nPS. You can workaround it with:\r\n\r\n```\r\n get_type_hints(C.__init__, sys.modules[C.__module__].__dict__)\r\n```\r\nor \r\n\r\n```\r\nget_type_hints(C.__init__, globalns=globals())\r\n```\r\n\nThanks @euresti for the proposals :+1: . Unfortunately, I think they won't work for me:\r\n\r\n**First proposal**:\r\n```py\r\n get_type_hints(C.__init__, sys.modules[C.__module__].__dict__)\r\n```\r\nI need to obtain the hints only from the `__init__` method so unless I can obtain the class from the method `__init__` this solution won't work for me. Do you know if there is any way to obtain the class from the `__init__` method? I mean, is possible to implement the method `get_cls_from_attrs_init` such that:\r\n```py\r\nassert get_cls_from_attrs_init(C.__init__) == C\r\n```\r\n\r\n**Second proposal**\r\n```py\r\nget_type_hints(C.__init__, globalns=globals())\r\n``` \r\nThe problem with this proposal is that the globals obtained from `globals()` are from a different module than `C.__init__` module in my case, so it is not working. \r\n\r\nThank you!\nYou don't need the class. You only need the module:\r\n```\r\ndef hints(method):\r\n     return get_type_hints(method, sys.modules[method.__module__].__dict__)\r\n```\r\n\r\n\nThanks, @euresti :+1: . That is very helpful, serves for most of my cases, thanks. But it is not working for the case of classes defined within functions. The following fails with `NameError: name 'B' is not defined`:\r\n```py\r\nimport sys\r\nfrom typing import get_type_hints\r\nimport attr\r\n\r\ndef hints(method):\r\n    return get_type_hints(method, sys.modules[method.__module__].__dict__)\r\n\r\ndef resolve():\r\n    @attr.s(auto_attribs=True)\r\n    class A:\r\n        b: 'B'\r\n\r\n    @attr.s(auto_attribs=True)\r\n    class B:\r\n        pass\r\n\r\n    return hints(A.__init__)\r\n\r\nresolve()\r\n```\r\nAny idea if there is any workaround for that?\r\n\r\nBy the other hand, I have discovered that this issue will get worse in future python 4.0, where [posponed evaluation of annotations](https://docs.python.org/3/whatsnew/3.7.html#pep-563-postponed-evaluation-of-annotations) will be the default. \r\n\r\nThe following fails with `NameError: name 'B' is not defined` on Python 3.7. But it works if `from __future__ import annotations` is commented. And then it will fail by default in the upcoming Python 4.0. \r\n```py\r\nfrom __future__ import annotations\r\n\r\nfrom typing import get_type_hints\r\n\r\nimport attr\r\n\r\nclass B:\r\n    pass\r\n\r\n@attr.s(auto_attribs=True)\r\nclass A:\r\n    b: B\r\n\r\nget_type_hints(A.__init__)\r\n``` \r\n\r\nHope this is hepful. \nLocal scopes are very hard to remember.  Do you need to pass around `__init__` methods?  One should not be calling those anyway.  Maybe your code can accept the `B` for these cases.  (Full disclosure I have no idea what your code is doing)\r\n\r\n> this issue will get worse in future python 4.0, where posponed evaluation of annotations will be the default.\r\n\r\nThat's because in python 4 this\r\n```\r\n@attr.s(auto_attribs=True)\r\nclass A:\r\n    b: B\r\n```\r\nis actually \r\n```\r\n@attr.s(auto_attribs=True)\r\nclass A:\r\n    b: \"B\"\r\n```\r\n\r\n\n> Local scopes are very hard to remember. Do you need to pass around __init__ methods? One should not be calling those anyway. Maybe your code can accept the B for these cases. (Full disclosure I have no idea what your code is doing)\r\n\r\n@euresti some context: a library inspects signature of functions (`__init__` method in this case, for classes), and does dependency injection based on type annotations. \r\n\r\nSo if we have `__init__(self, a: A)`, we'd create an instance of A and pass it to `__init__`. \r\n\r\nFor this it needs to be able to retrieve typing information reliably, at runtime; this breaks for attr.s classes.\r\n\r\n\nSo there are 2 places where these values are stored.  `cls.__annotations__`  of in `field.type`.  If you plan to use `get_type_hints` then you could do something like this to \"resolve\" the ForwardRefs\r\n```\r\ndef foo():\r\n   @dataclass\r\n   class Foo:\r\n      x: \"Optional[Foo]\"\r\n\r\n   print(Foo.__annotations__)\r\n   Foo.__annotations__ = get_type_hints(Foo, localns=locals())\r\n\r\n   return Foo\r\n\r\nX = foo()\r\nprint(get_type_hints(X))\r\n```\r\n\r\nOtherwise you have to do something like this:\r\n```\r\n   hints = get_type_hints(cls, localns=locals())\r\n   for field in attr.fields(cls):\r\n      if field.name in hints:\r\n         # field is a FrozenInstance. The only way to update it is using object.__setattr__\r\n         object.__setattr__(field, \"type\", hints[field.name])\r\n```\r\n\r\nIn the end we just decided the simplest solution was to enforce that all classes are created at module scope and then `get_type_hints(cls)` is guaranteed to work. \nTo clarify using your example:\r\n```\r\nimport sys\r\nfrom typing import get_type_hints\r\nimport attr\r\n\r\ndef hints(method, localns):\r\n    return get_type_hints(method, sys.modules[method.__module__].__dict__, localns=localns)\r\n\r\ndef resolve():\r\n    @attr.s(auto_attribs=True)\r\n    class A:\r\n        b: 'B'\r\n\r\n    @attr.s(auto_attribs=True)\r\n    class B:\r\n        pass\r\n\r\n    return hints(A.__init__, localns=locals())\r\n\r\nprint(resolve())\r\n```\r\n\r\nYou could even use `inspect.currentframe().f_back` in your `hints` method to get the globals and locals at the call site.\nI learned today that `dataclasses` fixed this issue (`get_type_hints(C.__init__)`) by passing the correct `globals` into the `exec` call.\r\n\r\nhttps://github.com/python/cpython/pull/9518\r\n\r\nBasically on class creation they save the class module dict,  `globals = sys.modules[cls.__module__].__dict__` and then pass it in to exec.  I don't know if that would work for attrs though.\r\n\r\n\n> I don't know if that would work for attrs though.\r\n\r\nIs that a gut feeling or do you see blockers?\nI haven't looked deep at the attrs code. I notice that dataclasses just uses exec whereas attrs uses compile + eval.  Basically since the code is not identical I couldn't say that it would 100% work to do the same as dataclasses.\nHmhm. FWIW, we used to use compile/exec until\u2026this happened https://github.com/python-attrs/attrs/pull/87#issuecomment-246111177.\nIt would be nice to move this forward because we are already in Python 3.10 alpha 5 and our possibilities to change something big are limited in beta releases.",
        "created_at": "2021-02-16T17:13:15Z",
        "version": "20.3"
    }
}