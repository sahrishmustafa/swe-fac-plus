{
    "task_id": "python-attrs__attrs-286",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-286_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 286,
        "instance_id": "python-attrs__attrs-286",
        "issue_numbers": [
            "284"
        ],
        "base_commit": "7501cecf0f4313c3b2597d03ac0853cca1659065",
        "patch": "diff --git a/src/attr/_compat.py b/src/attr/_compat.py\n--- a/src/attr/_compat.py\n+++ b/src/attr/_compat.py\n@@ -3,6 +3,7 @@\n import platform\n import sys\n import types\n+import warnings\n \n \n PY2 = sys.version_info[0] == 2\n@@ -85,11 +86,54 @@ def iteritems(d):\n     def metadata_proxy(d):\n         return types.MappingProxyType(dict(d))\n \n-if PYPY:  # pragma: no cover\n-    def set_closure_cell(cell, value):\n-        cell.__setstate__((value,))\n+\n+def import_ctypes():  # pragma: nocover\n+    \"\"\"\n+    Moved into a function for testability.\n+    \"\"\"\n+    try:\n+        import ctypes\n+        return ctypes\n+    except ImportError:\n+        return None\n+\n+\n+if not PY2:\n+    def just_warn(*args, **kw):\n+        \"\"\"\n+        We only warn on Python 3 because we are not aware of any concrete\n+        consequences of not setting the cell on Python 2.\n+        \"\"\"\n+        warnings.warn(\n+            \"Missing ctypes.  Some features like bare super() or accessing \"\n+            \"__class__ will not work with slots classes.\",\n+            RuntimeWarning,\n+            stacklevel=2,\n+        )\n else:\n-    import ctypes\n-    set_closure_cell = ctypes.pythonapi.PyCell_Set\n-    set_closure_cell.argtypes = (ctypes.py_object, ctypes.py_object)\n-    set_closure_cell.restype = ctypes.c_int\n+    def just_warn(*args, **kw):  # pragma: nocover\n+        \"\"\"\n+        We only warn on Python 3 because we are not aware of any concrete\n+        consequences of not setting the cell on Python 2.\n+        \"\"\"\n+\n+\n+def make_set_closure_cell():\n+    \"\"\"\n+    Moved into a function for testability.\n+    \"\"\"\n+    if PYPY:  # pragma: no cover\n+        def set_closure_cell(cell, value):\n+            cell.__setstate__((value,))\n+    else:\n+        ctypes = import_ctypes()\n+        if ctypes is not None:\n+            set_closure_cell = ctypes.pythonapi.PyCell_Set\n+            set_closure_cell.argtypes = (ctypes.py_object, ctypes.py_object)\n+            set_closure_cell.restype = ctypes.c_int\n+        else:\n+            set_closure_cell = just_warn\n+    return set_closure_cell\n+\n+\n+set_closure_cell = make_set_closure_cell()\n",
        "test_patch": "diff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -13,7 +13,7 @@\n \n import attr\n \n-from attr._compat import PY2\n+from attr._compat import PY2, PYPY, just_warn, make_set_closure_cell\n \n \n @attr.s\n@@ -325,76 +325,98 @@ class C2(C1Bare):\n \n \n @pytest.mark.skipif(PY2, reason=\"closure cell rewriting is PY3-only.\")\n-def test_closure_cell_rewriting():\n-    \"\"\"\n-    Slot classes support proper closure cell rewriting.\n-\n-    This affects features like `__class__` and the no-arg super().\n-    \"\"\"\n-    non_slot_instance = C1(x=1, y=\"test\")\n-    slot_instance = C1Slots(x=1, y=\"test\")\n-\n-    assert non_slot_instance.my_class() is C1\n-    assert slot_instance.my_class() is C1Slots\n-\n-    # Just assert they return something, and not an exception.\n-    assert non_slot_instance.my_super()\n-    assert slot_instance.my_super()\n-\n-\n-@pytest.mark.skipif(PY2, reason=\"closure cell rewriting is PY3-only.\")\n-def test_closure_cell_rewriting_inheritance():\n-    \"\"\"\n-    Slot classes support proper closure cell rewriting when inheriting.\n-\n-    This affects features like `__class__` and the no-arg super().\n-    \"\"\"\n-    @attr.s\n-    class C2(C1):\n-        def my_subclass(self):\n-            return __class__  # NOQA: F821\n-\n-    @attr.s\n-    class C2Slots(C1Slots):\n-        def my_subclass(self):\n-            return __class__  # NOQA: F821\n-\n-    non_slot_instance = C2(x=1, y=\"test\")\n-    slot_instance = C2Slots(x=1, y=\"test\")\n-\n-    assert non_slot_instance.my_class() is C1\n-    assert slot_instance.my_class() is C1Slots\n-\n-    # Just assert they return something, and not an exception.\n-    assert non_slot_instance.my_super()\n-    assert slot_instance.my_super()\n-\n-    assert non_slot_instance.my_subclass() is C2\n-    assert slot_instance.my_subclass() is C2Slots\n-\n-\n-@pytest.mark.skipif(PY2, reason=\"closure cell rewriting is PY3-only.\")\n-@pytest.mark.parametrize(\"slots\", [True, False])\n-def test_closure_cell_rewriting_cls_static(slots):\n-    \"\"\"\n-    Slot classes support proper closure cell rewriting for class- and static\n-    methods.\n-    \"\"\"\n-    # Python can reuse closure cells, so we create new classes just for\n-    # this test.\n-\n-    @attr.s(slots=slots)\n-    class C:\n-        @classmethod\n-        def clsmethod(cls):\n-            return __class__  # noqa: F821\n-\n-    assert C.clsmethod() is C\n-\n-    @attr.s(slots=slots)\n-    class D:\n-        @staticmethod\n-        def statmethod():\n-            return __class__  # noqa: F821\n-\n-    assert D.statmethod() is D\n+class TestClosureCellRewriting(object):\n+    def test_closure_cell_rewriting(self):\n+        \"\"\"\n+        Slot classes support proper closure cell rewriting.\n+\n+        This affects features like `__class__` and the no-arg super().\n+        \"\"\"\n+        non_slot_instance = C1(x=1, y=\"test\")\n+        slot_instance = C1Slots(x=1, y=\"test\")\n+\n+        assert non_slot_instance.my_class() is C1\n+        assert slot_instance.my_class() is C1Slots\n+\n+        # Just assert they return something, and not an exception.\n+        assert non_slot_instance.my_super()\n+        assert slot_instance.my_super()\n+\n+    def test_inheritance(self):\n+        \"\"\"\n+        Slot classes support proper closure cell rewriting when inheriting.\n+\n+        This affects features like `__class__` and the no-arg super().\n+        \"\"\"\n+        @attr.s\n+        class C2(C1):\n+            def my_subclass(self):\n+                return __class__  # NOQA: F821\n+\n+        @attr.s\n+        class C2Slots(C1Slots):\n+            def my_subclass(self):\n+                return __class__  # NOQA: F821\n+\n+        non_slot_instance = C2(x=1, y=\"test\")\n+        slot_instance = C2Slots(x=1, y=\"test\")\n+\n+        assert non_slot_instance.my_class() is C1\n+        assert slot_instance.my_class() is C1Slots\n+\n+        # Just assert they return something, and not an exception.\n+        assert non_slot_instance.my_super()\n+        assert slot_instance.my_super()\n+\n+        assert non_slot_instance.my_subclass() is C2\n+        assert slot_instance.my_subclass() is C2Slots\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_cls_static(self, slots):\n+        \"\"\"\n+        Slot classes support proper closure cell rewriting for class- and\n+        static methods.\n+        \"\"\"\n+        # Python can reuse closure cells, so we create new classes just for\n+        # this test.\n+\n+        @attr.s(slots=slots)\n+        class C:\n+            @classmethod\n+            def clsmethod(cls):\n+                return __class__  # noqa: F821\n+\n+        assert C.clsmethod() is C\n+\n+        @attr.s(slots=slots)\n+        class D:\n+            @staticmethod\n+            def statmethod():\n+                return __class__  # noqa: F821\n+\n+        assert D.statmethod() is D\n+\n+    @pytest.mark.skipif(\n+        PYPY,\n+        reason=\"ctypes are used only on CPython\"\n+    )\n+    def test_missing_ctypes(self, monkeypatch):\n+        \"\"\"\n+        Keeps working if ctypes is missing.\n+\n+        A warning is emitted that points to the actual code.\n+        \"\"\"\n+        monkeypatch.setattr(attr._compat, \"import_ctypes\", lambda: None)\n+        func = make_set_closure_cell()\n+\n+        with pytest.warns(RuntimeWarning) as wr:\n+            func()\n+\n+        w = wr.pop()\n+        assert __file__ == w.filename\n+        assert (\n+            \"Missing ctypes.  Some features like bare super() or accessing \"\n+            \"__class__ will not work with slots classes.\",\n+        ) == w.message.args\n+\n+        assert just_warn is func\n",
        "problem_statement": "Allow using attrs without ctypes\n#226 introduced the use of `ctypes`. I use attrs in a Google App Engine application. The app runs in a sandbox which limits the use of certain modules. `ctypes` is one of those libraries.\r\n\r\nI can peg my app to use only attrs 17.2.0, but it would be nice to have a fail-gently approach where, if ctypes is unavailable, attrs keeps working, though the behavior allowed by #226 of course would not work.\n",
        "hints_text": "Now, that\u2019s unfortunate!  Making the support unconditional is gonna be easy, the big question is how to document/communicate the behavior it to the user. \ud83e\udd14\nProbably log a warning? Hopefully in a way that's visible.\nAlso, we won't need ctypes in CPython 3.7 right?",
        "created_at": "2017-11-09T10:33:37Z",
        "version": "17.3"
    }
}