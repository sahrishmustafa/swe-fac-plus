{
    "task_id": "python-attrs__attrs-316",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-316_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 316,
        "instance_id": "python-attrs__attrs-316",
        "issue_numbers": [
            "309"
        ],
        "base_commit": "bc0b437e58cf5a9c60143909c93cb0d727b15300",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -491,17 +491,22 @@ def slots_setstate(self, state):\n         return cls\n \n     def add_repr(self, ns):\n-        self._cls_dict[\"__repr__\"] = _make_repr(self._attrs, ns=ns)\n+        self._cls_dict[\"__repr__\"] = self._add_method_dunders(\n+            _make_repr(self._attrs, ns=ns)\n+        )\n         return self\n \n     def add_str(self):\n-        repr_ = self._cls_dict.get(\"__repr__\")\n-        if repr_ is None:\n+        repr = self._cls_dict.get(\"__repr__\")\n+        if repr is None:\n             raise ValueError(\n                 \"__str__ can only be generated if a __repr__ exists.\"\n             )\n \n-        self._cls_dict[\"__str__\"] = repr_\n+        def __str__(self):\n+            return self.__repr__()\n+\n+        self._cls_dict[\"__str__\"] = self._add_method_dunders(__str__)\n         return self\n \n     def make_unhashable(self):\n@@ -509,25 +514,52 @@ def make_unhashable(self):\n         return self\n \n     def add_hash(self):\n-        self._cls_dict[\"__hash__\"] = _make_hash(self._attrs)\n+        self._cls_dict[\"__hash__\"] = self._add_method_dunders(\n+            _make_hash(self._attrs)\n+        )\n+\n         return self\n \n     def add_init(self):\n-        self._cls_dict[\"__init__\"] = _make_init(\n-            self._attrs,\n-            self._has_post_init,\n-            self._frozen,\n+        self._cls_dict[\"__init__\"] = self._add_method_dunders(\n+            _make_init(\n+                self._attrs,\n+                self._has_post_init,\n+                self._frozen,\n+            )\n         )\n+\n         return self\n \n     def add_cmp(self):\n         cd = self._cls_dict\n \n         cd[\"__eq__\"], cd[\"__ne__\"], cd[\"__lt__\"], cd[\"__le__\"], cd[\"__gt__\"], \\\n-            cd[\"__ge__\"] = _make_cmp(self._attrs)\n+            cd[\"__ge__\"] = (\n+                self._add_method_dunders(meth)\n+                for meth in _make_cmp(self._attrs)\n+            )\n \n         return self\n \n+    def _add_method_dunders(self, method):\n+        \"\"\"\n+        Add __module__ and __qualname__ to a *method* if possible.\n+        \"\"\"\n+        try:\n+            method.__module__ = self._cls.__module__\n+        except AttributeError:\n+            pass\n+\n+        try:\n+            method.__qualname__ = \".\".join(\n+                (self._cls.__qualname__, method.__name__,)\n+            )\n+        except AttributeError:\n+            pass\n+\n+        return method\n+\n \n def attrs(maybe_cls=None, these=None, repr_ns=None,\n           repr=True, cmp=True, hash=None, init=True,\n@@ -753,7 +785,7 @@ def _add_hash(cls, attrs):\n     return cls\n \n \n-def _ne(self, other):\n+def __ne__(self, other):\n     \"\"\"\n     Check equality and either forward a NotImplemented or return the result\n     negated.\n@@ -807,7 +839,7 @@ def _make_cmp(attrs):\n         unique_filename,\n     )\n     eq = locs[\"__eq__\"]\n-    ne = _ne\n+    ne = __ne__\n \n     def attrs_to_tuple(obj):\n         \"\"\"\n@@ -815,7 +847,7 @@ def attrs_to_tuple(obj):\n         \"\"\"\n         return _attrs_to_tuple(obj, attrs)\n \n-    def lt(self, other):\n+    def __lt__(self, other):\n         \"\"\"\n         Automatically created by attrs.\n         \"\"\"\n@@ -824,7 +856,7 @@ def lt(self, other):\n         else:\n             return NotImplemented\n \n-    def le(self, other):\n+    def __le__(self, other):\n         \"\"\"\n         Automatically created by attrs.\n         \"\"\"\n@@ -833,7 +865,7 @@ def le(self, other):\n         else:\n             return NotImplemented\n \n-    def gt(self, other):\n+    def __gt__(self, other):\n         \"\"\"\n         Automatically created by attrs.\n         \"\"\"\n@@ -842,7 +874,7 @@ def gt(self, other):\n         else:\n             return NotImplemented\n \n-    def ge(self, other):\n+    def __ge__(self, other):\n         \"\"\"\n         Automatically created by attrs.\n         \"\"\"\n@@ -851,7 +883,7 @@ def ge(self, other):\n         else:\n             return NotImplemented\n \n-    return eq, ne, lt, le, gt, ge\n+    return eq, ne, __lt__, __le__, __gt__, __ge__\n \n \n def _add_cmp(cls, attrs=None):\n@@ -877,7 +909,7 @@ def _make_repr(attrs, ns):\n         if a.repr\n     )\n \n-    def repr_(self):\n+    def __repr__(self):\n         \"\"\"\n         Automatically created by attrs.\n         \"\"\"\n@@ -898,7 +930,7 @@ def repr_(self):\n                 for name in attr_names\n             )\n         )\n-    return repr_\n+    return __repr__\n \n \n def _add_repr(cls, ns=None, attrs=None):\n@@ -908,8 +940,7 @@ def _add_repr(cls, ns=None, attrs=None):\n     if attrs is None:\n         attrs = cls.__attrs_attrs__\n \n-    repr_ = _make_repr(attrs, ns)\n-    cls.__repr__ = repr_\n+    cls.__repr__ = _make_repr(attrs, ns)\n     return cls\n \n \n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -997,3 +997,49 @@ class C(object):\n             .build_class()\n \n         assert \"ns.C(x=1)\" == repr(cls(1))\n+\n+    @pytest.mark.parametrize(\"meth_name\", [\n+        \"__init__\", \"__hash__\", \"__repr__\", \"__str__\",\n+        \"__eq__\", \"__ne__\", \"__lt__\", \"__le__\", \"__gt__\", \"__ge__\",\n+    ])\n+    def test_attaches_meta_dunders(self, meth_name):\n+        \"\"\"\n+        Generated methods have correct __module__, __name__, and __qualname__\n+        attributes.\n+        \"\"\"\n+        @attr.s(hash=True, str=True)\n+        class C(object):\n+            def organic(self):\n+                pass\n+\n+        meth = getattr(C, meth_name)\n+\n+        assert meth_name == meth.__name__\n+        assert C.organic.__module__ == meth.__module__\n+        if not PY2:\n+            organic_prefix = C.organic.__qualname__.rsplit(\".\", 1)[0]\n+            assert organic_prefix + \".\" + meth_name == meth.__qualname__\n+\n+    def test_handles_missing_meta_on_class(self):\n+        \"\"\"\n+        If the class hasn't a __module__ or __qualname__, the method hasn't\n+        either.\n+        \"\"\"\n+        class C(object):\n+            pass\n+\n+        b = _ClassBuilder(\n+            C, these=None, slots=False, frozen=False, auto_attribs=False,\n+        )\n+        b._cls = {}  # no __module__; no __qualname__\n+\n+        def fake_meth(self):\n+            pass\n+\n+        fake_meth.__module__ = \"42\"\n+        fake_meth.__qualname__ = \"23\"\n+\n+        rv = b._add_method_dunders(fake_meth)\n+\n+        assert \"42\" == rv.__module__ == fake_meth.__module__\n+        assert \"23\" == rv.__qualname__ == fake_meth.__qualname__\n",
        "problem_statement": "Generated methods like __init__ lack the __module__ attribute\nThis issue was initially reported in https://github.com/Stewori/pytypes/issues/18.\r\nApplying ``__module__`` on e.g. the ``__init__`` function generated by attrs raises a ``KeyError``. For more information please refer to the link above.\r\n\r\nBeing able to retrieve the module for a given function/method is relevant to locate the function or method in the class hierarchy from perspective of a decorator or profiler. Searching a module top-down for a function/method is often the only way to access its enclosing class, including nesting structure of classes.\r\n\r\nA workaround that sometimes worked but not in this case is to get the module via ``__code__.co_filename``. However, any valid approach for identifying the corresponding module and/or location in class hierarchy for a generated function would be fine.\r\n\r\nPlease apologize if I should overlook some approach that is already viable.\n",
        "hints_text": "We probably should try to set it to the module where the class is defined?\r\n\r\nThis problem will also appear with `__eq__` and `__hash__` with the next release.\n> We probably should try to set it to the module where the class is defined?\r\n\r\nYes that's right.\r\nDoes the generated method show up as member of a class if the class is inspected using ``dir`` or the ``inspect`` module or ``__dict__``? If not, it would be good to insert ``__qualname__`` as well, if that's not already done. (Sorry I don't know attrs well, so apologize if the ``__qualname__`` thing is already resolved. I'm just trying to early-prevent then next issue on this path...)\n@hynek Already spent a good amount of time learning how _make fits together.  With make.py:_make_init could add a 4th argument (cls) and then inside copy cls.__module__ to globs.  Either there or just setattr after  _make_init?\r\n\r\ncode reference\r\nhttps://github.com/python-attrs/attrs/blob/master/src/attr/_make.py#L905",
        "created_at": "2017-12-17T17:41:27Z",
        "version": "17.3"
    }
}