{
    "task_id": "python-attrs__attrs-315",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-315_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 315,
        "instance_id": "python-attrs__attrs-315",
        "issue_numbers": [
            "307"
        ],
        "base_commit": "b3861d109bd7ad779877a230927d6a4e34d8a7e7",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -3,6 +3,7 @@\n import hashlib\n import linecache\n import sys\n+import warnings\n \n from operator import itemgetter\n \n@@ -16,7 +17,7 @@\n \n # This is used at least twice, so cache it here.\n _obj_setattr = object.__setattr__\n-_init_convert_pat = \"__attr_convert_{}\"\n+_init_converter_pat = \"__attr_converter_{}\"\n _init_factory_pat = \"__attr_factory_{}\"\n _tuple_property_pat = \"    {attr_name} = property(itemgetter({index}))\"\n _empty_metadata_singleton = metadata_proxy({})\n@@ -55,7 +56,7 @@ def __hash__(self):\n \n def attrib(default=NOTHING, validator=None,\n            repr=True, cmp=True, hash=None, init=True,\n-           convert=None, metadata=None, type=None):\n+           convert=None, metadata=None, type=None, converter=None):\n     \"\"\"\n     Create a new attribute on a class.\n \n@@ -111,8 +112,8 @@ def attrib(default=NOTHING, validator=None,\n         method.  It is possible to set this to ``False`` and set a default\n         value.  In that case this attributed is unconditionally initialized\n         with the specified default value or factory.\n-    :param callable convert: :func:`callable` that is called by\n-        ``attrs``-generated ``__init__`` methods to convert attribute's value\n+    :param callable converter: :func:`callable` that is called by\n+        ``attrs``-generated ``__init__`` methods to converter attribute's value\n         to the desired format.  It is given the passed-in value, and the\n         returned value will be used as the new value of the attribute.  The\n         value is converted before being passed to the validator, if any.\n@@ -125,17 +126,37 @@ def attrib(default=NOTHING, validator=None,\n         Regardless of the approach used, the type will be stored on\n         ``Attribute.type``.\n \n+    .. versionadded:: 15.2.0 *convert*\n+    .. versionadded:: 16.3.0 *metadata*\n     ..  versionchanged:: 17.1.0 *validator* can be a ``list`` now.\n     ..  versionchanged:: 17.1.0\n         *hash* is ``None`` and therefore mirrors *cmp* by default.\n     ..  versionadded:: 17.3.0 *type*\n+    ..  deprecated:: 17.4.0 *convert*\n+    ..  versionadded:: 17.4.0 *converter* as a replacement for the deprecated\n+        *convert* to achieve consistency with other noun-based arguments.\n     \"\"\"\n     if hash is not None and hash is not True and hash is not False:\n         raise TypeError(\n             \"Invalid value for hash.  Must be True, False, or None.\"\n         )\n+\n+    if convert is not None:\n+        if converter is not None:\n+            raise RuntimeError(\n+                \"Can't pass both `convert` and `converter`.  \"\n+                \"Please use `converter` only.\"\n+            )\n+        warnings.warn(\n+            \"The `convert` argument is deprecated in favor of `converter`.  \"\n+            \"It will be removed after 2019/01.\",\n+            DeprecationWarning, stacklevel=2\n+        )\n+        converter = convert\n+\n     if metadata is None:\n         metadata = {}\n+\n     return _CountingAttr(\n         default=default,\n         validator=validator,\n@@ -143,7 +164,7 @@ def attrib(default=NOTHING, validator=None,\n         cmp=cmp,\n         hash=hash,\n         init=init,\n-        convert=convert,\n+        converter=converter,\n         metadata=metadata,\n         type=type,\n     )\n@@ -1017,7 +1038,7 @@ def fmt_setter(attr_name, value_var):\n             }\n \n         def fmt_setter_with_converter(attr_name, value_var):\n-            conv_name = _init_convert_pat.format(attr_name)\n+            conv_name = _init_converter_pat.format(attr_name)\n             return \"_setattr('%(attr_name)s', %(conv)s(%(value_var)s))\" % {\n                 \"attr_name\": attr_name,\n                 \"value_var\": value_var,\n@@ -1031,7 +1052,7 @@ def fmt_setter(attr_name, value):\n             }\n \n         def fmt_setter_with_converter(attr_name, value_var):\n-            conv_name = _init_convert_pat.format(attr_name)\n+            conv_name = _init_converter_pat.format(attr_name)\n             return \"self.%(attr_name)s = %(conv)s(%(value_var)s)\" % {\n                 \"attr_name\": attr_name,\n                 \"value_var\": value_var,\n@@ -1058,12 +1079,12 @@ def fmt_setter_with_converter(attr_name, value_var):\n         if a.init is False:\n             if has_factory:\n                 init_factory_name = _init_factory_pat.format(a.name)\n-                if a.convert is not None:\n+                if a.converter is not None:\n                     lines.append(fmt_setter_with_converter(\n                         attr_name,\n                         init_factory_name + \"({0})\".format(maybe_self)))\n-                    conv_name = _init_convert_pat.format(a.name)\n-                    names_for_globals[conv_name] = a.convert\n+                    conv_name = _init_converter_pat.format(a.name)\n+                    names_for_globals[conv_name] = a.converter\n                 else:\n                     lines.append(fmt_setter(\n                         attr_name,\n@@ -1071,14 +1092,14 @@ def fmt_setter_with_converter(attr_name, value_var):\n                     ))\n                 names_for_globals[init_factory_name] = a.default.factory\n             else:\n-                if a.convert is not None:\n+                if a.converter is not None:\n                     lines.append(fmt_setter_with_converter(\n                         attr_name,\n                         \"attr_dict['{attr_name}'].default\"\n                         .format(attr_name=attr_name)\n                     ))\n-                    conv_name = _init_convert_pat.format(a.name)\n-                    names_for_globals[conv_name] = a.convert\n+                    conv_name = _init_converter_pat.format(a.name)\n+                    names_for_globals[conv_name] = a.converter\n                 else:\n                     lines.append(fmt_setter(\n                         attr_name,\n@@ -1092,9 +1113,11 @@ def fmt_setter_with_converter(attr_name, value_var):\n                     attr_name=attr_name,\n                 )\n             )\n-            if a.convert is not None:\n+            if a.converter is not None:\n                 lines.append(fmt_setter_with_converter(attr_name, arg_name))\n-                names_for_globals[_init_convert_pat.format(a.name)] = a.convert\n+                names_for_globals[_init_converter_pat.format(a.name)] = (\n+                    a.converter\n+                )\n             else:\n                 lines.append(fmt_setter(attr_name, arg_name))\n         elif has_factory:\n@@ -1102,15 +1125,18 @@ def fmt_setter_with_converter(attr_name, value_var):\n             lines.append(\"if {arg_name} is not NOTHING:\"\n                          .format(arg_name=arg_name))\n             init_factory_name = _init_factory_pat.format(a.name)\n-            if a.convert is not None:\n-                lines.append(\"    \" + fmt_setter_with_converter(attr_name,\n-                                                                arg_name))\n+            if a.converter is not None:\n+                lines.append(\"    \" + fmt_setter_with_converter(\n+                    attr_name, arg_name\n+                ))\n                 lines.append(\"else:\")\n                 lines.append(\"    \" + fmt_setter_with_converter(\n                     attr_name,\n                     init_factory_name + \"({0})\".format(maybe_self)\n                 ))\n-                names_for_globals[_init_convert_pat.format(a.name)] = a.convert\n+                names_for_globals[_init_converter_pat.format(a.name)] = (\n+                    a.converter\n+                )\n             else:\n                 lines.append(\"    \" + fmt_setter(attr_name, arg_name))\n                 lines.append(\"else:\")\n@@ -1121,9 +1147,11 @@ def fmt_setter_with_converter(attr_name, value_var):\n             names_for_globals[init_factory_name] = a.default.factory\n         else:\n             args.append(arg_name)\n-            if a.convert is not None:\n+            if a.converter is not None:\n                 lines.append(fmt_setter_with_converter(attr_name, arg_name))\n-                names_for_globals[_init_convert_pat.format(a.name)] = a.convert\n+                names_for_globals[_init_converter_pat.format(a.name)] = (\n+                    a.converter\n+                )\n             else:\n                 lines.append(fmt_setter(attr_name, arg_name))\n \n@@ -1156,17 +1184,34 @@ class Attribute(object):\n     :attribute name: The name of the attribute.\n \n     Plus *all* arguments of :func:`attr.ib`.\n+\n+    For the version history of the fields, see :func:`attr.ib`.\n     \"\"\"\n     __slots__ = (\n         \"name\", \"default\", \"validator\", \"repr\", \"cmp\", \"hash\", \"init\",\n-        \"convert\", \"metadata\", \"type\"\n+        \"metadata\", \"type\", \"converter\",\n     )\n \n     def __init__(self, name, default, validator, repr, cmp, hash, init,\n-                 convert=None, metadata=None, type=None):\n+                 convert=None, metadata=None, type=None, converter=None):\n         # Cache this descriptor here to speed things up later.\n         bound_setattr = _obj_setattr.__get__(self, Attribute)\n \n+        # Despite the big red warning, people *do* instantiate `Attribute`\n+        # themselves.\n+        if convert is not None:\n+            if converter is not None:\n+                raise RuntimeError(\n+                    \"Can't pass both `convert` and `converter`.  \"\n+                    \"Please use `converter` only.\"\n+                )\n+            warnings.warn(\n+                \"The `convert` argument is deprecated in favor of `converter`.\"\n+                \"  It will be removed after 2019/01.\",\n+                DeprecationWarning, stacklevel=2\n+            )\n+            converter = convert\n+\n         bound_setattr(\"name\", name)\n         bound_setattr(\"default\", default)\n         bound_setattr(\"validator\", validator)\n@@ -1174,14 +1219,25 @@ def __init__(self, name, default, validator, repr, cmp, hash, init,\n         bound_setattr(\"cmp\", cmp)\n         bound_setattr(\"hash\", hash)\n         bound_setattr(\"init\", init)\n-        bound_setattr(\"convert\", convert)\n-        bound_setattr(\"metadata\", (metadata_proxy(metadata) if metadata\n-                                   else _empty_metadata_singleton))\n+        bound_setattr(\"converter\", converter)\n+        bound_setattr(\"metadata\", (\n+            metadata_proxy(metadata) if metadata\n+            else _empty_metadata_singleton\n+        ))\n         bound_setattr(\"type\", type)\n \n     def __setattr__(self, name, value):\n         raise FrozenInstanceError()\n \n+    @property\n+    def convert(self):\n+        warnings.warn(\n+            \"The `convert` attribute is deprecated in favor of `converter`.  \"\n+            \"It will be removed after 2019/01.\",\n+            DeprecationWarning, stacklevel=2,\n+        )\n+        return self.converter\n+\n     @classmethod\n     def from_counting_attr(cls, name, ca, type=None):\n         # type holds the annotated value. deal with conflicts:\n@@ -1196,11 +1252,13 @@ def from_counting_attr(cls, name, ca, type=None):\n             for k\n             in Attribute.__slots__\n             if k not in (\n-                \"name\", \"validator\", \"default\", \"type\"\n-            )  # exclude methods\n+                \"name\", \"validator\", \"default\", \"type\", \"convert\",\n+            )  # exclude methods and deprecated alias\n         }\n-        return cls(name=name, validator=ca._validator, default=ca._default,\n-                   type=type, **inst_dict)\n+        return cls(\n+            name=name, validator=ca._validator, default=ca._default, type=type,\n+            **inst_dict\n+        )\n \n     # Don't use _add_pickle since fields(Attribute) doesn't work\n     def __getstate__(self):\n@@ -1224,9 +1282,12 @@ def __setstate__(self, state):\n                               _empty_metadata_singleton)\n \n \n-_a = [Attribute(name=name, default=NOTHING, validator=None,\n-                repr=True, cmp=True, hash=(name != \"metadata\"), init=True)\n-      for name in Attribute.__slots__]\n+_a = [\n+    Attribute(name=name, default=NOTHING, validator=None,\n+              repr=True, cmp=True, hash=(name != \"metadata\"), init=True)\n+    for name in Attribute.__slots__\n+    if name != \"convert\"  # XXX: remove once `convert` is gone\n+]\n \n Attribute = _add_hash(\n     _add_cmp(_add_repr(Attribute, attrs=_a), attrs=_a),\n@@ -1243,7 +1304,7 @@ class _CountingAttr(object):\n     likely the result of a bug like a forgotten `@attr.s` decorator.\n     \"\"\"\n     __slots__ = (\"counter\", \"_default\", \"repr\", \"cmp\", \"hash\", \"init\",\n-                 \"metadata\", \"_validator\", \"convert\", \"type\")\n+                 \"metadata\", \"_validator\", \"converter\", \"type\")\n     __attrs_attrs__ = tuple(\n         Attribute(name=name, default=NOTHING, validator=None,\n                   repr=True, cmp=True, hash=True, init=True)\n@@ -1255,7 +1316,7 @@ class _CountingAttr(object):\n     )\n     cls_counter = 0\n \n-    def __init__(self, default, validator, repr, cmp, hash, init, convert,\n+    def __init__(self, default, validator, repr, cmp, hash, init, converter,\n                  metadata, type):\n         _CountingAttr.cls_counter += 1\n         self.counter = _CountingAttr.cls_counter\n@@ -1269,7 +1330,7 @@ def __init__(self, default, validator, repr, cmp, hash, init, convert,\n         self.cmp = cmp\n         self.hash = hash\n         self.init = init\n-        self.convert = convert\n+        self.converter = converter\n         self.metadata = metadata\n         self.type = type\n \n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -121,6 +121,66 @@ def f(self):\n         assert Factory(f, True) == a._default\n \n \n+class TestAttribute(object):\n+    \"\"\"\n+    Tests for `attr.Attribute`.\n+    \"\"\"\n+    def test_deprecated_convert_argument(self):\n+        \"\"\"\n+        Using *convert* raises a DeprecationWarning and sets the converter\n+        field.\n+        \"\"\"\n+        def conv(v):\n+            return v\n+\n+        with pytest.warns(DeprecationWarning) as wi:\n+            a = Attribute(\n+                \"a\", True, True, True, True, True, True, convert=conv\n+            )\n+        w = wi.pop()\n+\n+        assert conv == a.converter\n+        assert (\n+            \"The `convert` argument is deprecated in favor of `converter`.  \"\n+            \"It will be removed after 2019/01.\",\n+        ) == w.message.args\n+        assert __file__ == w.filename\n+\n+    def test_deprecated_convert_attribute(self):\n+        \"\"\"\n+        If Attribute.convert is accessed, a DeprecationWarning is raised.\n+        \"\"\"\n+        def conv(v):\n+            return v\n+\n+        a = simple_attr(\"a\", converter=conv)\n+        with pytest.warns(DeprecationWarning) as wi:\n+            convert = a.convert\n+        w = wi.pop()\n+\n+        assert conv is convert is a.converter\n+        assert (\n+            \"The `convert` attribute is deprecated in favor of `converter`.  \"\n+            \"It will be removed after 2019/01.\",\n+        ) == w.message.args\n+        assert __file__ == w.filename\n+\n+    def test_convert_converter(self):\n+        \"\"\"\n+        A TypeError is raised if both *convert* and *converter* are passed.\n+        \"\"\"\n+        with pytest.raises(RuntimeError) as ei:\n+            Attribute(\n+                \"a\", True, True, True, True, True, True,\n+                convert=lambda v: v, converter=lambda v: v,\n+            )\n+\n+        assert (\n+            \"Can't pass both `convert` and `converter`.  \"\n+            \"Please use `converter` only.\",\n+        ) == ei.value.args\n+\n+\n def make_tc():\n     class TransformC(object):\n         z = attr.ib()\n@@ -188,8 +248,8 @@ class C(object):\n             \"No mandatory attributes allowed after an attribute with a \"\n             \"default value or factory.  Attribute in question: Attribute\"\n             \"(name='y', default=NOTHING, validator=None, repr=True, \"\n-            \"cmp=True, hash=None, init=True, convert=None, \"\n-            \"metadata=mappingproxy({}), type=None)\",\n+            \"cmp=True, hash=None, init=True, metadata=mappingproxy({}), \"\n+            \"type=None, converter=None)\",\n         ) == e.value.args\n \n     def test_these(self):\n@@ -578,16 +638,16 @@ def test_fields_properties(self, C):\n             assert getattr(fields(C), attribute.name) is attribute\n \n \n-class TestConvert(object):\n+class TestConverter(object):\n     \"\"\"\n     Tests for attribute conversion.\n     \"\"\"\n     def test_convert(self):\n         \"\"\"\n-        Return value of convert is used as the attribute's value.\n+        Return value of converter is used as the attribute's value.\n         \"\"\"\n         C = make_class(\"C\", {\n-            \"x\": attr.ib(convert=lambda v: v + 1),\n+            \"x\": attr.ib(converter=lambda v: v + 1),\n             \"y\": attr.ib(),\n         })\n         c = C(1, 2)\n@@ -602,7 +662,7 @@ def test_convert_property(self, val, init):\n         \"\"\"\n         C = make_class(\"C\", {\n             \"y\": attr.ib(),\n-            \"x\": attr.ib(init=init, default=val, convert=lambda v: v + 1),\n+            \"x\": attr.ib(init=init, default=val, converter=lambda v: v + 1),\n         })\n         c = C(2)\n \n@@ -619,7 +679,7 @@ def test_convert_factory_property(self, val, init):\n             \"x\": attr.ib(\n                 init=init,\n                 default=Factory(lambda: val),\n-                convert=lambda v: v + 1),\n+                converter=lambda v: v + 1),\n         })\n         c = C(2)\n \n@@ -654,7 +714,7 @@ def validator(inst, attr, val):\n             raise RuntimeError(\"foo\")\n         C = make_class(\n             \"C\", {\n-                \"x\": attr.ib(validator=validator, convert=lambda v: 1 / 0),\n+                \"x\": attr.ib(validator=validator, converter=lambda v: 1 / 0),\n                 \"y\": attr.ib(),\n             })\n         with pytest.raises(ZeroDivisionError):\n@@ -665,10 +725,49 @@ def test_frozen(self):\n         Converters circumvent immutability.\n         \"\"\"\n         C = make_class(\"C\", {\n-            \"x\": attr.ib(convert=lambda v: int(v)),\n+            \"x\": attr.ib(converter=lambda v: int(v)),\n         }, frozen=True)\n         C(\"1\")\n \n+    def test_deprecated_convert(self):\n+        \"\"\"\n+        Using *convert* raises a DeprecationWarning and sets the converter\n+        field.\n+        \"\"\"\n+        def conv(v):\n+            return v\n+\n+        with pytest.warns(DeprecationWarning) as wi:\n+            @attr.s\n+            class C(object):\n+                x = attr.ib(convert=conv)\n+\n+            convert = fields(C).x.convert\n+\n+        assert 2 == len(wi.list)\n+        w = wi.pop()\n+\n+        assert conv == fields(C).x.converter == convert\n+        assert (\n+            \"The `convert` argument is deprecated in favor of `converter`.  \"\n+            \"It will be removed after 2019/01.\",\n+        ) == w.message.args\n+        assert __file__ == w.filename\n+\n+    def test_convert_converter(self):\n+        \"\"\"\n+        A TypeError is raised if both *convert* and *converter* are passed.\n+        \"\"\"\n+        with pytest.raises(RuntimeError) as ei:\n+            @attr.s\n+            class C(object):\n+                x = attr.ib(convert=lambda v: v, converter=lambda v: v)\n+\n+        assert (\n+            \"Can't pass both `convert` and `converter`.  \"\n+            \"Please use `converter` only.\",\n+        ) == ei.value.args\n+\n \n class TestValidate(object):\n     \"\"\"\ndiff --git a/tests/utils.py b/tests/utils.py\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -30,13 +30,13 @@ def simple_class(cmp=False, repr=False, hash=False, str=False, slots=False,\n \n \n def simple_attr(name, default=NOTHING, validator=None, repr=True,\n-                cmp=True, hash=None, init=True):\n+                cmp=True, hash=None, init=True, converter=None):\n     \"\"\"\n     Return an attribute with a name and no other bells and whistles.\n     \"\"\"\n     return Attribute(\n         name=name, default=default, validator=validator, repr=repr,\n-        cmp=cmp, hash=hash, init=init\n+        cmp=cmp, hash=hash, init=init, converter=converter,\n     )\n \n \n@@ -167,9 +167,17 @@ def simple_attrs_with_metadata(draw):\n     metadata = draw(st.dictionaries(\n         keys=keys, values=vals, min_size=1, max_size=5))\n \n-    return attr.ib(c_attr._default, c_attr._validator, c_attr.repr,\n-                   c_attr.cmp, c_attr.hash, c_attr.init, c_attr.convert,\n-                   metadata)\n+    return attr.ib(\n+        default=c_attr._default,\n+        validator=c_attr._validator,\n+        repr=c_attr.repr,\n+        cmp=c_attr.cmp,\n+        hash=c_attr.hash,\n+        init=c_attr.init,\n+        metadata=metadata,\n+        type=None,\n+        converter=c_attr.converter,\n+    )\n \n \n simple_attrs = simple_attrs_without_metadata | simple_attrs_with_metadata()\n",
        "problem_statement": "convert should be converter\nWe use proper nouns everywhere else too and this is kind of a sore thumb to me.  `attr.ib(convert=int)` should be deprecated and replaced by `attr.ib(converter=int)`.\n",
        "hints_text": "",
        "created_at": "2017-12-16T07:00:42Z",
        "version": "17.3"
    }
}