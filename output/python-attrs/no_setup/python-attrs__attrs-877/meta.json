{
    "task_id": "python-attrs__attrs-877",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-877_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 877,
        "instance_id": "python-attrs__attrs-877",
        "issue_numbers": [
            "875"
        ],
        "base_commit": "fe19f4b341dbba5cda14b11d6a184105891c67e5",
        "patch": "diff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -14,6 +14,12 @@\n from .exceptions import NotCallableError\n \n \n+try:\n+    Pattern = re.Pattern\n+except AttributeError:  # Python <3.7 lacks a Pattern type.\n+    Pattern = type(re.compile(\"\"))\n+\n+\n __all__ = [\n     \"and_\",\n     \"deep_iterable\",\n@@ -129,8 +135,7 @@ def instance_of(type):\n \n @attrs(repr=False, frozen=True, slots=True)\n class _MatchesReValidator(object):\n-    regex = attrib()\n-    flags = attrib()\n+    pattern = attrib()\n     match_func = attrib()\n \n     def __call__(self, inst, attr, value):\n@@ -139,18 +144,18 @@ def __call__(self, inst, attr, value):\n         \"\"\"\n         if not self.match_func(value):\n             raise ValueError(\n-                \"'{name}' must match regex {regex!r}\"\n+                \"'{name}' must match regex {pattern!r}\"\n                 \" ({value!r} doesn't)\".format(\n-                    name=attr.name, regex=self.regex.pattern, value=value\n+                    name=attr.name, pattern=self.pattern.pattern, value=value\n                 ),\n                 attr,\n-                self.regex,\n+                self.pattern,\n                 value,\n             )\n \n     def __repr__(self):\n-        return \"<matches_re validator for pattern {regex!r}>\".format(\n-            regex=self.regex\n+        return \"<matches_re validator for pattern {pattern!r}>\".format(\n+            pattern=self.pattern\n         )\n \n \n@@ -159,7 +164,7 @@ def matches_re(regex, flags=0, func=None):\n     A validator that raises `ValueError` if the initializer is called\n     with a string that doesn't match *regex*.\n \n-    :param str regex: a regex string to match against\n+    :param regex: a regex string or precompiled pattern to match against\n     :param int flags: flags that will be passed to the underlying re function\n         (default 0)\n     :param callable func: which underlying `re` function to call (options\n@@ -169,34 +174,44 @@ def matches_re(regex, flags=0, func=None):\n         but on a pre-`re.compile`\\ ed pattern.\n \n     .. versionadded:: 19.2.0\n+    .. versionchanged:: 21.3.0 *regex* can be a pre-compiled pattern.\n     \"\"\"\n     fullmatch = getattr(re, \"fullmatch\", None)\n     valid_funcs = (fullmatch, None, re.search, re.match)\n     if func not in valid_funcs:\n         raise ValueError(\n-            \"'func' must be one of %s.\"\n-            % (\n+            \"'func' must be one of {}.\".format(\n                 \", \".join(\n                     sorted(\n                         e and e.__name__ or \"None\" for e in set(valid_funcs)\n                     )\n-                ),\n+                )\n             )\n         )\n \n-    pattern = re.compile(regex, flags)\n+    if isinstance(regex, Pattern):\n+        if flags:\n+            raise TypeError(\n+                \"'flags' can only be used with a string pattern; \"\n+                \"pass flags to re.compile() instead\"\n+            )\n+        pattern = regex\n+    else:\n+        pattern = re.compile(regex, flags)\n+\n     if func is re.match:\n         match_func = pattern.match\n     elif func is re.search:\n         match_func = pattern.search\n-    else:\n-        if fullmatch:\n-            match_func = pattern.fullmatch\n-        else:\n-            pattern = re.compile(r\"(?:{})\\Z\".format(regex), flags)\n-            match_func = pattern.match\n+    elif fullmatch:\n+        match_func = pattern.fullmatch\n+    else:  # Python 2 fullmatch emulation (https://bugs.python.org/issue16203)\n+        pattern = re.compile(\n+            r\"(?:{})\\Z\".format(pattern.pattern), pattern.flags\n+        )\n+        match_func = pattern.match\n \n-    return _MatchesReValidator(pattern, flags, match_func)\n+    return _MatchesReValidator(pattern, match_func)\n \n \n @attrs(repr=False, slots=True, hash=True)\n",
        "test_patch": "diff --git a/tests/test_validators.py b/tests/test_validators.py\n--- a/tests/test_validators.py\n+++ b/tests/test_validators.py\n@@ -176,9 +176,9 @@ def test_match(self):\n \n         @attr.s\n         class ReTester(object):\n-            str_match = attr.ib(validator=matches_re(\"a\"))\n+            str_match = attr.ib(validator=matches_re(\"a|ab\"))\n \n-        ReTester(\"a\")  # shouldn't raise exceptions\n+        ReTester(\"ab\")  # shouldn't raise exceptions\n         with pytest.raises(TypeError):\n             ReTester(1)\n         with pytest.raises(ValueError):\n@@ -197,6 +197,29 @@ class MatchTester(object):\n \n         MatchTester(\"A1\")  # test flags and using re.match\n \n+    def test_precompiled_pattern(self):\n+        \"\"\"\n+        Pre-compiled patterns are accepted.\n+        \"\"\"\n+        pattern = re.compile(\"a\")\n+\n+        @attr.s\n+        class RePatternTester(object):\n+            val = attr.ib(validator=matches_re(pattern))\n+\n+        RePatternTester(\"a\")\n+\n+    def test_precompiled_pattern_no_flags(self):\n+        \"\"\"\n+        A pre-compiled pattern cannot be combined with a 'flags' argument.\n+        \"\"\"\n+        pattern = re.compile(\"\")\n+\n+        with pytest.raises(\n+            TypeError, match=\"can only be used with a string pattern\"\n+        ):\n+            matches_re(pattern, flags=re.IGNORECASE)\n+\n     def test_different_func(self):\n         \"\"\"\n         Changing the match functions works.\ndiff --git a/tests/typing_example.py b/tests/typing_example.py\n--- a/tests/typing_example.py\n+++ b/tests/typing_example.py\n@@ -167,7 +167,7 @@ class Validated:\n             attr.validators.instance_of(C), attr.validators.instance_of(D)\n         ),\n     )\n-    e: str = attr.ib(validator=attr.validators.matches_re(r\"foo\"))\n+    e: str = attr.ib(validator=attr.validators.matches_re(re.compile(r\"foo\")))\n     f: str = attr.ib(\n         validator=attr.validators.matches_re(r\"foo\", flags=42, func=re.search)\n     )\n",
        "problem_statement": "matches_re() should accept re.Pattern in addition to str\n`attr.validators.matches_re()` does not accept precompiled regular expressions, and instead requires a `str` pattern (and optional flags).\r\n\r\nthis is not ideal when using existing compiled regular expressions, which already can have flags etc.\r\n\r\nit would be a nice addition if the same helper accepts `re.Pattern` (py37+) or `typing.Pattern` for those living in the past.\r\n\r\nopen questions:\r\n\r\n- would `flags=` be allowed if a `re.Pattern` is passed? compiled patterns cannot be \u2018reinterpreted\u2019 safely with different flags (e.g. `re.VERBOSE` changes many semantics). that means options are a) reject by raising an exception or b) ignore. my preference is raising.\r\n- in general any reason not to do this?\n",
        "hints_text": "(oh and i can take care of pull request etc)\nsure, go for it and raise if the alternative is not safe",
        "created_at": "2021-11-29T17:59:55Z",
        "version": "21.2"
    }
}