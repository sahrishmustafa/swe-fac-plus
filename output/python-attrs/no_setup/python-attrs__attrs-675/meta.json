{
    "task_id": "python-attrs__attrs-675",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-675_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 675,
        "instance_id": "python-attrs__attrs-675",
        "issue_numbers": [
            "673"
        ],
        "base_commit": "d02b76de16fbb011004e16106e63ac1896018e6c",
        "patch": "diff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -50,9 +50,9 @@ def define(\n     .. versionadded:: 20.1.0\n     \"\"\"\n \n-    def do_it(auto_attribs):\n+    def do_it(cls, auto_attribs):\n         return attrs(\n-            maybe_cls=maybe_cls,\n+            maybe_cls=cls,\n             these=these,\n             repr=repr,\n             hash=hash,\n@@ -74,12 +74,21 @@ def do_it(auto_attribs):\n         )\n \n     if auto_attribs is not None:\n-        return do_it(auto_attribs)\n-\n-    try:\n-        return do_it(True)\n-    except UnannotatedAttributeError:\n-        return do_it(False)\n+        return do_it(maybe_cls, auto_attribs)\n+\n+    def wrap(cls):\n+        # Making this a wrapper ensures this code runs during class creation.\n+        try:\n+            return do_it(cls, True)\n+        except UnannotatedAttributeError:\n+            return do_it(cls, False)\n+\n+    # maybe_cls's type depends on the usage of the decorator.  It's a class\n+    # if it's used as `@attrs` but ``None`` if used as `@attrs()`.\n+    if maybe_cls is None:\n+        return wrap\n+    else:\n+        return wrap(maybe_cls)\n \n \n mutable = define\n",
        "test_patch": "diff --git a/tests/test_next_gen.py b/tests/test_next_gen.py\n--- a/tests/test_next_gen.py\n+++ b/tests/test_next_gen.py\n@@ -101,6 +101,31 @@ class OldSchool:\n \n         assert OldSchool(1) == OldSchool(1)\n \n+        # Test with maybe_cls = None\n+        @attr.define()\n+        class OldSchool2:\n+            x = attr.field()\n+\n+        assert OldSchool2(1) == OldSchool2(1)\n+\n+    def test_auto_attribs_detect_annotations(self):\n+        \"\"\"\n+        define correctly detects if a class has type annotations.\n+        \"\"\"\n+\n+        @attr.define\n+        class NewSchool:\n+            x: int\n+\n+        assert NewSchool(1) == NewSchool(1)\n+\n+        # Test with maybe_cls = None\n+        @attr.define()\n+        class NewSchool2:\n+            x: int\n+\n+        assert NewSchool2(1) == NewSchool2(1)\n+\n     def test_exception(self):\n         \"\"\"\n         Exceptions are detected and correctly handled.\n",
        "problem_statement": "Hybrid behavior doesn't work when maybe_cls=None and no annotations\nThe doc says:\r\n```\r\n    :param Optional[bool] auto_attribs: If set to `True` or `False`, it behaves\r\n       exactly like `attr.s`. If left `None`, `attr.s` will try to guess:\r\n\r\n       1. If all attributes are annotated and no `attr.ib` is found, it assumes\r\n          *auto_attribs=True*.\r\n       2. Otherwise it assumes *auto_attribs=False* and tries to collect\r\n          `attr.ib`\\ s.\r\n```\r\n\r\nSadly it doesn't exactly work.\r\n```\r\nimport attr\r\n\r\n@attr.define()\r\nclass Trigger:\r\n    a = attr.field()\r\n```\r\n\r\nThe code does this:\r\n```\r\n    try:\r\n        return do_it(True)\r\n    except UnannotatedAttributeError:\r\n        return do_it(False)\r\n```\r\n\r\nBut do_it itself won't raise `UnannotatedAttributeError` until the decorator is applied to the class.\n",
        "hints_text": "Ah yikes it\u2019s about the `()`. I\u2019m afk for now but any ideas how to make it work? \ud83e\udd14 \nThis seems to work but is not fully tested:\r\n```\r\ndef define(\r\n    maybe_cls=None,\r\n    *,\r\n   ...\r\n):\r\n    def wrap(cls):\r\n        def do_it(auto_attribs):\r\n            return attrs(\r\n                maybe_cls=cls,\r\n                these=these,\r\n                repr=repr,\r\n                hash=hash,\r\n                init=init,\r\n                slots=slots,\r\n                frozen=frozen,\r\n                weakref_slot=weakref_slot,\r\n                str=str,\r\n                auto_attribs=auto_attribs,\r\n                kw_only=kw_only,\r\n                cache_hash=cache_hash,\r\n                auto_exc=auto_exc,\r\n                eq=eq,\r\n                order=order,\r\n                auto_detect=auto_detect,\r\n                collect_by_mro=True,\r\n                getstate_setstate=getstate_setstate,\r\n                on_setattr=on_setattr,\r\n            )\r\n\r\n        if auto_attribs is not None:\r\n            return do_it(auto_attribs)\r\n\r\n        try:\r\n            return do_it(True)\r\n        except UnannotatedAttributeError:\r\n            return do_it(False)\r\n\r\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\r\n    # if it's used as `@attrs` but ``None`` if used as `@attrs()`.\r\n    if maybe_cls is None:\r\n        return wrap\r\n    else:\r\n        return wrap(maybe_cls)\r\n```\r\n\r\nEdit: Fixed the code a bit.",
        "created_at": "2020-08-23T03:24:34Z",
        "version": "20.1"
    }
}