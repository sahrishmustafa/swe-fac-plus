{
    "task_id": "python-attrs__attrs-349",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-349_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 349,
        "instance_id": "python-attrs__attrs-349",
        "issue_numbers": [
            "290"
        ],
        "base_commit": "f5298627e6d2bd4fd2afa11140dffd508af74c9d",
        "patch": "diff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -6,7 +6,8 @@\n from ._config import get_run_validators, set_run_validators\n from ._funcs import asdict, assoc, astuple, evolve, has\n from ._make import (\n-    NOTHING, Attribute, Factory, attrib, attrs, fields, make_class, validate\n+    NOTHING, Attribute, Factory, attrib, attrs, fields, fields_dict,\n+    make_class, validate\n )\n \n \n@@ -43,6 +44,7 @@\n     \"evolve\",\n     \"exceptions\",\n     \"fields\",\n+    \"fields_dict\",\n     \"filters\",\n     \"get_run_validators\",\n     \"has\",\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -1042,7 +1042,7 @@ def _add_init(cls, frozen):\n \n def fields(cls):\n     \"\"\"\n-    Returns the tuple of ``attrs`` attributes for a class.\n+    Return the tuple of ``attrs`` attributes for a class.\n \n     The tuple also allows accessing the fields by their names (see below for\n     examples).\n@@ -1068,6 +1068,34 @@ def fields(cls):\n     return attrs\n \n \n+def fields_dict(cls):\n+    \"\"\"\n+    Return an ordered dictionary of ``attrs`` attributes for a class, whose\n+    keys are the attribute names.\n+\n+    :param type cls: Class to introspect.\n+\n+    :raise TypeError: If *cls* is not a class.\n+    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+        class.\n+\n+    :rtype: an ordered dict where keys are attribute names and values are\n+        :class:`attr.Attribute`\\ s. This will be a :class:`dict` if it's\n+        naturally ordered like on Python 3.6+ or an\n+        :class:`~collections.OrderedDict` otherwise.\n+\n+    .. versionadded:: 18.1.0\n+    \"\"\"\n+    if not isclass(cls):\n+        raise TypeError(\"Passed object must be a class.\")\n+    attrs = getattr(cls, \"__attrs_attrs__\", None)\n+    if attrs is None:\n+        raise NotAnAttrsClassError(\n+            \"{cls!r} is not an attrs-decorated class.\".format(cls=cls)\n+        )\n+    return ordered_dict(((a.name, a) for a in attrs))\n+\n+\n def validate(inst):\n     \"\"\"\n     Validate all attributes on *inst* that have a validator.\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -22,7 +22,8 @@\n from attr._compat import PY2, ordered_dict\n from attr._make import (\n     Attribute, Factory, _AndValidator, _Attributes, _ClassBuilder,\n-    _CountingAttr, _transform_attrs, and_, fields, make_class, validate\n+    _CountingAttr, _transform_attrs, and_, fields, fields_dict, make_class,\n+    validate\n )\n from attr.exceptions import DefaultAlreadySetError, NotAnAttrsClassError\n \n@@ -656,6 +657,7 @@ def test_handler_non_attrs_class(self, C):\n         \"\"\"\n         with pytest.raises(NotAnAttrsClassError) as e:\n             fields(object)\n+\n         assert (\n             \"{o!r} is not an attrs-decorated class.\".format(o=object)\n         ) == e.value.args[0]\n@@ -676,6 +678,42 @@ def test_fields_properties(self, C):\n             assert getattr(fields(C), attribute.name) is attribute\n \n \n+class TestFieldsDict(object):\n+    \"\"\"\n+    Tests for `fields_dict`.\n+    \"\"\"\n+    def test_instance(self, C):\n+        \"\"\"\n+        Raises `TypeError` on non-classes.\n+        \"\"\"\n+        with pytest.raises(TypeError) as e:\n+            fields_dict(C(1, 2))\n+\n+        assert \"Passed object must be a class.\" == e.value.args[0]\n+\n+    def test_handler_non_attrs_class(self, C):\n+        \"\"\"\n+        Raises `ValueError` if passed a non-``attrs`` instance.\n+        \"\"\"\n+        with pytest.raises(NotAnAttrsClassError) as e:\n+            fields_dict(object)\n+\n+        assert (\n+            \"{o!r} is not an attrs-decorated class.\".format(o=object)\n+        ) == e.value.args[0]\n+\n+    @given(simple_classes())\n+    def test_fields_dict(self, C):\n+        \"\"\"\n+        Returns an ordered dict of ``{attribute_name: Attribute}``.\n+        \"\"\"\n+        d = fields_dict(C)\n+\n+        assert isinstance(d, ordered_dict)\n+        assert list(fields(C)) == list(d.values())\n+        assert [a.name for a in fields(C)] == [field_name for field_name in d]\n+\n+\n class TestConverter(object):\n     \"\"\"\n     Tests for attribute conversion.\n",
        "problem_statement": "Possible to add a \"field_names\" helper function?\nIn a specific use case, I need to get all field names that are defined in an attrs class, which is as simple as\r\n```\r\n[f.name for f in attr.fields(MyClass)]\r\n```\r\nDo you think it's OK to add a public API for this?\n",
        "hints_text": "Hm, I was rather thinking about exposing fields as a dict, because I needed string access to attributes.\r\n\r\nThat would give us:\r\n\r\n- `attr.fields_dict(MyClass)[name]` for me\r\n- and `attr.fields_dict(MyClass).keys()` for you\nThat sounds good to me.",
        "created_at": "2018-02-27T07:43:38Z",
        "version": "17.4"
    }
}