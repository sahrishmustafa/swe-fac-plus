{
    "task_id": "python-attrs__attrs-272",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-272_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 272,
        "instance_id": "python-attrs__attrs-272",
        "issue_numbers": [
            "269"
        ],
        "base_commit": "5c5677b72b385753a189b8a3d2d769c5d6a454e9",
        "patch": "diff --git a/conftest.py b/conftest.py\n--- a/conftest.py\n+++ b/conftest.py\n@@ -21,4 +21,7 @@ class C(object):\n \n collect_ignore = []\n if sys.version_info[:2] < (3, 6):\n-    collect_ignore.append(\"tests/test_annotations.py\")\n+    collect_ignore.extend([\n+        \"tests/test_annotations.py\",\n+        \"tests/test_init_subclass.py\",\n+    ])\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -181,22 +181,27 @@ class MyClassAttributes(tuple):\n     return globs[attr_class_name]\n \n \n+# Tuple class for extracted attributes from a class definition.\n+# `super_attrs` is a subset of `attrs`.\n+_Attributes = _make_attr_tuple_class(\"_Attributes\", [\n+    \"attrs\",        # all attributes to build dunder methods for\n+    \"super_attrs\",  # attributes that have been inherited from super classes\n+])\n+\n+\n def _transform_attrs(cls, these):\n     \"\"\"\n-    Transform all `_CountingAttr`s on a class into `Attribute`s and save the\n-    list in `__attrs_attrs__` while potentially deleting them from *cls*.\n+    Transform all `_CountingAttr`s on a class into `Attribute`s.\n \n     If *these* is passed, use that and don't look for them on the class.\n \n-    Return a list of tuples of (attribute name, attribute).\n+    Return an `_Attributes`.\n     \"\"\"\n     if these is None:\n         ca_list = [(name, attr)\n                    for name, attr\n                    in cls.__dict__.items()\n                    if isinstance(attr, _CountingAttr)]\n-        for name, _ in ca_list:\n-            delattr(cls, name)\n     else:\n         ca_list = [(name, ca)\n                    for name, ca\n@@ -206,35 +211,53 @@ def _transform_attrs(cls, these):\n     ann = getattr(cls, \"__annotations__\", {})\n \n     non_super_attrs = [\n-        Attribute.from_counting_attr(name=attr_name, ca=ca,\n-                                     type=ann.get(attr_name))\n+        Attribute.from_counting_attr(\n+            name=attr_name,\n+            ca=ca,\n+            type=ann.get(attr_name),\n+        )\n         for attr_name, ca\n         in ca_list\n     ]\n \n-    super_cls = []\n-    non_super_names = set(a.name for a in non_super_attrs)\n-    for c in reversed(cls.__mro__[1:-1]):\n-        sub_attrs = getattr(c, \"__attrs_attrs__\", None)\n+    # Walk *down* the MRO for attributes.  While doing so, we collect the names\n+    # of attributes we've seen in `take_attr_names` and ignore their\n+    # redefinitions deeper in the hierarchy.\n+    super_attrs = []\n+    taken_attr_names = set(a.name for a in non_super_attrs)\n+    for super_cls in cls.__mro__[1:-1]:\n+        sub_attrs = getattr(super_cls, \"__attrs_attrs__\", None)\n         if sub_attrs is not None:\n-            super_cls.extend(\n-                a for a in sub_attrs\n-                if a not in super_cls and a.name not in non_super_names\n-            )\n+            # We iterate over sub_attrs backwards so we can reverse the whole\n+            # list in the end and get all attributes in the order they have\n+            # been defined.\n+            for a in reversed(sub_attrs):\n+                if a.name not in taken_attr_names:\n+                    super_attrs.append(a)\n+                    taken_attr_names.add(a.name)\n \n-    attr_names = [a.name for a in super_cls + non_super_attrs]\n+    # Now reverse the list, such that the attributes are sorted by *descending*\n+    # age.  IOW: the oldest attribute definition is at the head of the list.\n+    super_attrs.reverse()\n+\n+    attr_names = [a.name for a in super_attrs + non_super_attrs]\n \n     AttrsClass = _make_attr_tuple_class(cls.__name__, attr_names)\n \n-    cls.__attrs_attrs__ = AttrsClass(super_cls + [\n-        Attribute.from_counting_attr(name=attr_name, ca=ca,\n-                                     type=ann.get(attr_name))\n-        for attr_name, ca\n-        in ca_list\n-    ])\n+    attrs = AttrsClass(\n+        super_attrs + [\n+            Attribute.from_counting_attr(\n+                name=attr_name,\n+                ca=ca,\n+                type=ann.get(attr_name)\n+            )\n+            for attr_name, ca\n+            in ca_list\n+        ]\n+    )\n \n     had_default = False\n-    for a in cls.__attrs_attrs__:\n+    for a in attrs:\n         if had_default is True and a.default is NOTHING and a.init is True:\n             raise ValueError(\n                 \"No mandatory attributes allowed after an attribute with a \"\n@@ -246,7 +269,7 @@ def _transform_attrs(cls, these):\n                 a.init is not False:\n             had_default = True\n \n-    return ca_list\n+    return _Attributes((attrs, super_attrs))\n \n \n def _frozen_setattrs(self, name, value):\n@@ -263,6 +286,177 @@ def _frozen_delattrs(self, name):\n     raise FrozenInstanceError()\n \n \n+class _ClassBuilder(object):\n+    \"\"\"\n+    Iteratively build *one* class.\n+    \"\"\"\n+    __slots__ = (\n+        \"_cls\", \"_cls_dict\", \"_attrs\", \"_super_names\", \"_attr_names\", \"_slots\",\n+        \"_frozen\", \"_has_post_init\",\n+    )\n+\n+    def __init__(self, cls, these, slots, frozen):\n+        attrs, super_attrs = _transform_attrs(cls, these)\n+\n+        self._cls = cls\n+        self._cls_dict = dict(cls.__dict__) if slots else {}\n+        self._attrs = attrs\n+        self._super_names = set(a.name for a in super_attrs)\n+        self._attr_names = tuple(a.name for a in attrs)\n+        self._slots = slots\n+        self._frozen = frozen or _has_frozen_superclass(cls)\n+        self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\n+\n+        self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n+\n+        if frozen:\n+            self._cls_dict[\"__setattr__\"] = _frozen_setattrs\n+            self._cls_dict[\"__delattr__\"] = _frozen_delattrs\n+\n+    def __repr__(self):\n+        return \"<_ClassBuilder(cls={cls})>\".format(cls=self._cls.__name__)\n+\n+    def build_class(self):\n+        \"\"\"\n+        Finalize class based on the accumulated configuration.\n+\n+        Builder cannot be used anymore after calling this method.\n+        \"\"\"\n+        if self._slots is True:\n+            return self._create_slots_class()\n+        else:\n+            return self._patch_original_class()\n+\n+    def _patch_original_class(self):\n+        \"\"\"\n+        Apply accumulated methods and return the class.\n+        \"\"\"\n+        cls = self._cls\n+        super_names = self._super_names\n+\n+        # Clean class of attribute definitions (`attr.ib()`s).\n+        for name in self._attr_names:\n+            if name not in super_names and \\\n+                    getattr(cls, name, None) is not None:\n+                delattr(cls, name)\n+\n+        # Attach our dunder methods.\n+        for name, value in self._cls_dict.items():\n+            setattr(cls, name, value)\n+\n+        return cls\n+\n+    def _create_slots_class(self):\n+        \"\"\"\n+        Build and return a new class with a `__slots__` attribute.\n+        \"\"\"\n+        super_names = self._super_names\n+        cd = {\n+            k: v\n+            for k, v in iteritems(self._cls_dict)\n+            if k not in tuple(self._attr_names) + (\"__dict__\",)\n+        }\n+\n+        # We only add the names of attributes that aren't inherited.\n+        # Settings __slots__ to inherited attributes wastes memory.\n+        cd[\"__slots__\"] = tuple(\n+            name\n+            for name in self._attr_names\n+            if name not in super_names\n+        )\n+\n+        qualname = getattr(self._cls, \"__qualname__\", None)\n+        if qualname is not None:\n+            cd[\"__qualname__\"] = qualname\n+\n+        attr_names = tuple(self._attr_names)\n+\n+        def slots_getstate(self):\n+            \"\"\"\n+            Automatically created by attrs.\n+            \"\"\"\n+            return tuple(getattr(self, name) for name in attr_names)\n+\n+        def slots_setstate(self, state):\n+            \"\"\"\n+            Automatically created by attrs.\n+            \"\"\"\n+            __bound_setattr = _obj_setattr.__get__(self, Attribute)\n+            for name, value in zip(attr_names, state):\n+                __bound_setattr(name, value)\n+\n+        # slots and frozen require __getstate__/__setstate__ to work\n+        cd[\"__getstate__\"] = slots_getstate\n+        cd[\"__setstate__\"] = slots_setstate\n+\n+        # Create new class based on old class and our methods.\n+        cls = type(self._cls)(\n+            self._cls.__name__,\n+            self._cls.__bases__,\n+            cd,\n+        )\n+\n+        # The following is a fix for\n+        # https://github.com/python-attrs/attrs/issues/102.  On Python 3,\n+        # if a method mentions `__class__` or uses the no-arg super(), the\n+        # compiler will bake a reference to the class in the method itself\n+        # as `method.__closure__`.  Since we replace the class with a\n+        # clone, we rewrite these references so it keeps working.\n+        for item in cls.__dict__.values():\n+            if isinstance(item, (classmethod, staticmethod)):\n+                # Class- and staticmethods hide their functions inside.\n+                # These might need to be rewritten as well.\n+                closure_cells = getattr(item.__func__, \"__closure__\", None)\n+            else:\n+                closure_cells = getattr(item, \"__closure__\", None)\n+\n+            if not closure_cells:  # Catch None or the empty list.\n+                continue\n+            for cell in closure_cells:\n+                if cell.cell_contents is self._cls:\n+                    set_closure_cell(cell, cls)\n+\n+        return cls\n+\n+    def add_repr(self, ns):\n+        self._cls_dict[\"__repr__\"] = _make_repr(self._attrs, ns=ns)\n+        return self\n+\n+    def add_str(self):\n+        repr_ = self._cls_dict.get(\"__repr__\")\n+        if repr_ is None:\n+            raise ValueError(\n+                \"__str__ can only be generated if a __repr__ exists.\"\n+            )\n+\n+        self._cls_dict[\"__str__\"] = repr_\n+        return self\n+\n+    def make_unhashable(self):\n+        self._cls_dict[\"__hash__\"] = None\n+        return self\n+\n+    def add_hash(self):\n+        self._cls_dict[\"__hash__\"] = _make_hash(self._attrs)\n+        return self\n+\n+    def add_init(self):\n+        self._cls_dict[\"__init__\"] = _make_init(\n+            self._attrs,\n+            self._has_post_init,\n+            self._frozen,\n+        )\n+        return self\n+\n+    def add_cmp(self):\n+        cd = self._cls_dict\n+\n+        cd[\"__eq__\"], cd[\"__ne__\"], cd[\"__lt__\"], cd[\"__le__\"], cd[\"__gt__\"], \\\n+            cd[\"__ge__\"] = _make_cmp(self._attrs)\n+\n+        return self\n+\n+\n def attrs(maybe_cls=None, these=None, repr_ns=None,\n           repr=True, cmp=True, hash=None, init=True,\n           slots=False, frozen=False, str=False):\n@@ -339,7 +533,7 @@ def attrs(maybe_cls=None, these=None, repr_ns=None,\n                circumvent that limitation by using\n                ``object.__setattr__(self, \"attribute_name\", value)``.\n \n-        ..  _slots: https://docs.python.org/3.5/reference/datamodel.html#slots\n+        ..  _slots: https://docs.python.org/3/reference/datamodel.html#slots\n \n     ..  versionadded:: 16.0.0 *slots*\n     ..  versionadded:: 16.1.0 *frozen*\n@@ -352,70 +546,31 @@ def wrap(cls):\n         if getattr(cls, \"__class__\", None) is None:\n             raise TypeError(\"attrs only works with new-style classes.\")\n \n-        if repr is False and str is True:\n-            raise ValueError(\n-                \"__str__ can only be generated if a __repr__ exists.\"\n-            )\n-\n-        ca_list = _transform_attrs(cls, these)\n+        builder = _ClassBuilder(cls, these, slots, frozen)\n \n-        # Can't just re-use frozen name because Python's scoping. :(\n-        # Can't compare function objects because Python 2 is terrible. :(\n-        effectively_frozen = _has_frozen_superclass(cls) or frozen\n         if repr is True:\n-            cls = _add_repr(cls, ns=repr_ns, str=str)\n+            builder.add_repr(repr_ns)\n+        if str is True:\n+            builder.add_str()\n         if cmp is True:\n-            cls = _add_cmp(cls)\n+            builder.add_cmp()\n \n         if hash is not True and hash is not False and hash is not None:\n+            # Can't use `hash in` because 1 == True for example.\n             raise TypeError(\n                 \"Invalid value for hash.  Must be True, False, or None.\"\n             )\n         elif hash is False or (hash is None and cmp is False):\n             pass\n         elif hash is True or (hash is None and cmp is True and frozen is True):\n-            cls = _add_hash(cls)\n+            builder.add_hash()\n         else:\n-            cls.__hash__ = None\n+            builder.make_unhashable()\n \n         if init is True:\n-            cls = _add_init(cls, effectively_frozen)\n-        if effectively_frozen is True:\n-            cls.__setattr__ = _frozen_setattrs\n-            cls.__delattr__ = _frozen_delattrs\n-            if slots is True:\n-                # slots and frozen require __getstate__/__setstate__ to work\n-                cls = _add_pickle(cls)\n-        if slots is True:\n-            cls_dict = dict(cls.__dict__)\n-            attr_names = tuple(t[0] for t in ca_list)\n-            cls_dict[\"__slots__\"] = attr_names\n-            for ca_name in attr_names:\n-                # It might not actually be in there, e.g. if using 'these'.\n-                cls_dict.pop(ca_name, None)\n-            cls_dict.pop(\"__dict__\", None)\n-            old_cls = cls\n-\n-            qualname = getattr(cls, \"__qualname__\", None)\n-            cls = type(cls)(cls.__name__, cls.__bases__, cls_dict)\n-            if qualname is not None:\n-                cls.__qualname__ = qualname\n-\n-            # The following is a fix for\n-            # https://github.com/python-attrs/attrs/issues/102.  On Python 3,\n-            # if a method mentions `__class__` or uses the no-arg super(), the\n-            # compiler will bake a reference to the class in the method itself\n-            # as `method.__closure__`.  Since we replace the class with a\n-            # clone, we rewrite these references so it keeps working.\n-            for item in cls.__dict__.values():\n-                closure_cells = getattr(item, \"__closure__\", None)\n-                if not closure_cells:  # Catch None or the empty list.\n-                    continue\n-                for cell in closure_cells:\n-                    if cell.cell_contents is old_cls:\n-                        set_closure_cell(cell, cls)\n+            builder.add_init()\n \n-        return cls\n+        return builder.build_class()\n \n     # maybe_cls's type depends on the usage of the decorator.  It's a class\n     # if it's used as `@attrs` but ``None`` if used as `@attrs()`.\n@@ -460,14 +615,12 @@ def _attrs_to_tuple(obj, attrs):\n     return tuple(getattr(obj, a.name) for a in attrs)\n \n \n-def _add_hash(cls, attrs=None):\n-    \"\"\"\n-    Add a hash method to *cls*.\n-    \"\"\"\n-    if attrs is None:\n-        attrs = [a\n-                 for a in cls.__attrs_attrs__\n-                 if a.hash is True or (a.hash is None and a.cmp is True)]\n+def _make_hash(attrs):\n+    attrs = tuple(\n+        a\n+        for a in attrs\n+        if a.hash is True or (a.hash is None and a.cmp is True)\n+    )\n \n     def hash_(self):\n         \"\"\"\n@@ -475,16 +628,19 @@ def hash_(self):\n         \"\"\"\n         return hash(_attrs_to_tuple(self, attrs))\n \n-    cls.__hash__ = hash_\n-    return cls\n+    return hash_\n \n \n-def _add_cmp(cls, attrs=None):\n+def _add_hash(cls, attrs):\n     \"\"\"\n-    Add comparison methods to *cls*.\n+    Add a hash method to *cls*.\n     \"\"\"\n-    if attrs is None:\n-        attrs = [a for a in cls.__attrs_attrs__ if a.cmp]\n+    cls.__hash__ = _make_hash(attrs)\n+    return cls\n+\n+\n+def _make_cmp(attrs):\n+    attrs = [a for a in attrs if a.cmp]\n \n     def attrs_to_tuple(obj):\n         \"\"\"\n@@ -547,22 +703,31 @@ def ge(self, other):\n         else:\n             return NotImplemented\n \n-    cls.__eq__ = eq\n-    cls.__ne__ = ne\n-    cls.__lt__ = lt\n-    cls.__le__ = le\n-    cls.__gt__ = gt\n-    cls.__ge__ = ge\n+    return eq, ne, lt, le, gt, ge\n+\n+\n+def _add_cmp(cls, attrs=None):\n+    \"\"\"\n+    Add comparison methods to *cls*.\n+    \"\"\"\n+    if attrs is None:\n+        attrs = cls.__attrs_attrs__\n+\n+    cls.__eq__, cls.__ne__, cls.__lt__, cls.__le__, cls.__gt__, cls.__ge__ = \\\n+        _make_cmp(attrs)\n \n     return cls\n \n \n-def _add_repr(cls, ns=None, attrs=None, str=False):\n+def _make_repr(attrs, ns):\n     \"\"\"\n-    Add a repr method to *cls*. If *str* is True, also add __str__.\n+    Make a repr method for *attr_names* adding *ns* to the full name.\n     \"\"\"\n-    if attrs is None:\n-        attrs = [a for a in cls.__attrs_attrs__ if a.repr]\n+    attr_names = tuple(\n+        a.name\n+        for a in attrs\n+        if a.repr\n+    )\n \n     def repr_(self):\n         \"\"\"\n@@ -580,21 +745,32 @@ def repr_(self):\n \n         return \"{0}({1})\".format(\n             class_name,\n-            \", \".join(a.name + \"=\" + repr(getattr(self, a.name))\n-                      for a in attrs)\n+            \", \".join(\n+                name + \"=\" + repr(getattr(self, name))\n+                for name in attr_names\n+            )\n         )\n-    cls.__repr__ = repr_\n-    if str is True:\n-        cls.__str__ = repr_\n-    return cls\n+    return repr_\n \n \n-def _add_init(cls, frozen):\n+def _add_repr(cls, ns=None, attrs=None):\n     \"\"\"\n-    Add a __init__ method to *cls*.  If *frozen* is True, make it immutable.\n+    Add a repr method to *cls*.\n     \"\"\"\n-    attrs = [a for a in cls.__attrs_attrs__\n-             if a.init or a.default is not NOTHING]\n+    if attrs is None:\n+        attrs = cls.__attrs_attrs__\n+\n+    repr_ = _make_repr(attrs, ns)\n+    cls.__repr__ = repr_\n+    return cls\n+\n+\n+def _make_init(attrs, post_init, frozen):\n+    attrs = [\n+        a\n+        for a in attrs\n+        if a.init or a.default is not NOTHING\n+    ]\n \n     # We cache the generated init methods for the same kinds of attributes.\n     sha1 = hashlib.sha1()\n@@ -606,7 +782,7 @@ def _add_init(cls, frozen):\n     script, globs = _attrs_to_script(\n         attrs,\n         frozen,\n-        getattr(cls, \"__attrs_post_init__\", False),\n+        post_init,\n     )\n     locs = {}\n     bytecode = compile(script, unique_filename, \"exec\")\n@@ -630,30 +806,19 @@ def _add_init(cls, frozen):\n         script.splitlines(True),\n         unique_filename\n     )\n-    cls.__init__ = init\n-    return cls\n+\n+    return init\n \n \n-def _add_pickle(cls):\n+def _add_init(cls, frozen):\n     \"\"\"\n-    Add pickle helpers, needed for frozen and slotted classes\n+    Add a __init__ method to *cls*.  If *frozen* is True, make it immutable.\n     \"\"\"\n-    def _slots_getstate__(obj):\n-        \"\"\"\n-        Play nice with pickle.\n-        \"\"\"\n-        return tuple(getattr(obj, a.name) for a in fields(obj.__class__))\n-\n-    def _slots_setstate__(obj, state):\n-        \"\"\"\n-        Play nice with pickle.\n-        \"\"\"\n-        __bound_setattr = _obj_setattr.__get__(obj, Attribute)\n-        for a, value in zip(fields(obj.__class__), state):\n-            __bound_setattr(a.name, value)\n-\n-    cls.__getstate__ = _slots_getstate__\n-    cls.__setstate__ = _slots_setstate__\n+    cls.__init__ = _make_init(\n+        cls.__attrs_attrs__,\n+        getattr(cls, \"__attrs_post_init__\", False),\n+        frozen,\n+    )\n     return cls\n \n \n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -1,13 +1,15 @@\n \"\"\"\n Tests for PEP-526 type annotations.\n+\n+Python 3.6+ only.\n \"\"\"\n \n+import typing\n+\n import pytest\n \n import attr\n \n-import typing\n-\n \n class TestAnnotations:\n     \"\"\"\ndiff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -1,3 +1,7 @@\n+\"\"\"\n+End-to-end tests.\n+\"\"\"\n+\n from __future__ import absolute_import, division, print_function\n \n import pickle\n@@ -283,3 +287,91 @@ class SubOverwrite(Super):\n             x = attr.ib(default=attr.Factory(list))\n \n         assert SubOverwrite([]) == SubOverwrite()\n+\n+    def test_dict_patch_class(self):\n+        \"\"\"\n+        dict-classes are never replaced.\n+        \"\"\"\n+        class C(object):\n+            x = attr.ib()\n+\n+        C_new = attr.s(C)\n+\n+        assert C_new is C\n+\n+    def test_hash_by_id(self):\n+        \"\"\"\n+        With dict classes, hashing by ID is active for hash=False even on\n+        Python 3.  This is incorrect behavior but we have to retain it for\n+        backward compatibility.\n+        \"\"\"\n+        @attr.s(hash=False)\n+        class HashByIDBackwardCompat(object):\n+            x = attr.ib()\n+\n+        assert (\n+            hash(HashByIDBackwardCompat(1)) != hash(HashByIDBackwardCompat(1))\n+        )\n+\n+        @attr.s(hash=False, cmp=False)\n+        class HashByID(object):\n+            x = attr.ib()\n+\n+        assert hash(HashByID(1)) != hash(HashByID(1))\n+\n+        @attr.s(hash=True)\n+        class HashByValues(object):\n+            x = attr.ib()\n+\n+        assert hash(HashByValues(1)) == hash(HashByValues(1))\n+\n+    def test_handles_different_defaults(self):\n+        \"\"\"\n+        Unhashable defaults + subclassing values work.\n+        \"\"\"\n+        @attr.s\n+        class Unhashable(object):\n+            pass\n+\n+        @attr.s\n+        class C(object):\n+            x = attr.ib(default=Unhashable())\n+\n+        @attr.s\n+        class D(C):\n+            pass\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_hash_false_cmp_false(self, slots):\n+        \"\"\"\n+        hash=False and cmp=False make a class hashable by ID.\n+        \"\"\"\n+        @attr.s(hash=False, cmp=False, slots=slots)\n+        class C(object):\n+            pass\n+\n+        assert hash(C()) != hash(C())\n+\n+    def test_overwrite_super(self):\n+        \"\"\"\n+        Super classes can overwrite each other and the attributes are added\n+        in the order they are defined.\n+        \"\"\"\n+        @attr.s\n+        class C(object):\n+            c = attr.ib(default=100)\n+            x = attr.ib(default=1)\n+            b = attr.ib(default=23)\n+\n+        @attr.s\n+        class D(C):\n+            a = attr.ib(default=42)\n+            x = attr.ib(default=2)\n+            d = attr.ib(default=3.14)\n+\n+        @attr.s\n+        class E(D):\n+            y = attr.ib(default=3)\n+            z = attr.ib(default=4)\n+\n+        assert \"E(c=100, b=23, a=42, x=2, d=3.14, y=3, z=4)\" == repr(E())\ndiff --git a/tests/test_init_subclass.py b/tests/test_init_subclass.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/test_init_subclass.py\n@@ -0,0 +1,44 @@\n+\"\"\"\n+Tests for `__init_subclass__` related tests.\n+\n+Python 3.6+ only.\n+\"\"\"\n+\n+import pytest\n+\n+import attr\n+\n+\n+@pytest.mark.parametrize(\"slots\", [True, False])\n+def test_init_subclass_vanilla(slots):\n+    \"\"\"\n+    `super().__init_subclass__` can be used if the subclass is not an attrs\n+    class both with dict and slots classes.\n+    \"\"\"\n+    @attr.s(slots=slots)\n+    class Base:\n+        def __init_subclass__(cls, param, **kw):\n+            super().__init_subclass__(**kw)\n+            cls.param = param\n+\n+    class Vanilla(Base, param=\"foo\"):\n+        pass\n+\n+    assert \"foo\" == Vanilla().param\n+\n+\n+def test_init_subclass_attrs():\n+    \"\"\"\n+    `__init_subclass__` works with attrs classes as long as slots=False.\n+    \"\"\"\n+    @attr.s(slots=False)\n+    class Base:\n+        def __init_subclass__(cls, param, **kw):\n+            super().__init_subclass__(**kw)\n+            cls.param = param\n+\n+    @attr.s\n+    class Attrs(Base, param=\"foo\"):\n+        pass\n+\n+    assert \"foo\" == Attrs().param\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -21,6 +21,8 @@\n     Attribute,\n     Factory,\n     _AndValidator,\n+    _Attributes,\n+    _ClassBuilder,\n     _CountingAttr,\n     _transform_attrs,\n     and_,\n@@ -136,13 +138,23 @@ class TestTransformAttrs(object):\n     \"\"\"\n     Tests for `_transform_attrs`.\n     \"\"\"\n+    def test_no_modifications(self):\n+        \"\"\"\n+        Doesn't attach __attrs_attrs__ to the class anymore.\n+        \"\"\"\n+        C = make_tc()\n+        _transform_attrs(C, None)\n+\n+        assert None is getattr(C, \"__attrs_attrs__\", None)\n+\n     def test_normal(self):\n         \"\"\"\n         Transforms every `_CountingAttr` and leaves others (a) be.\n         \"\"\"\n         C = make_tc()\n-        _transform_attrs(C, None)\n-        assert [\"z\", \"y\", \"x\"] == [a.name for a in C.__attrs_attrs__]\n+        attrs, _, = _transform_attrs(C, None)\n+\n+        assert [\"z\", \"y\", \"x\"] == [a.name for a in attrs]\n \n     def test_empty(self):\n         \"\"\"\n@@ -152,23 +164,18 @@ def test_empty(self):\n         class C(object):\n             pass\n \n-        _transform_attrs(C, None)\n-\n-        assert () == C.__attrs_attrs__\n+        assert _Attributes(((), [])) == _transform_attrs(C, None)\n \n-    @pytest.mark.parametrize(\"attribute\", [\n-        \"z\",\n-        \"y\",\n-        \"x\",\n-    ])\n-    def test_transforms_to_attribute(self, attribute):\n+    def test_transforms_to_attribute(self):\n         \"\"\"\n         All `_CountingAttr`s are transformed into `Attribute`s.\n         \"\"\"\n         C = make_tc()\n-        _transform_attrs(C, None)\n+        attrs, super_attrs = _transform_attrs(C, None)\n \n-        assert isinstance(getattr(fields(C), attribute), Attribute)\n+        assert [] == super_attrs\n+        assert 3 == len(attrs)\n+        assert all(isinstance(a, Attribute) for a in attrs)\n \n     def test_conflicting_defaults(self):\n         \"\"\"\n@@ -191,50 +198,20 @@ class C(object):\n \n     def test_these(self):\n         \"\"\"\n-        If these is passed, use it and ignore body.\n+        If these is passed, use it and ignore body and super classes.\n         \"\"\"\n-        class C(object):\n-            y = attr.ib()\n-\n-        _transform_attrs(C, {\"x\": attr.ib()})\n-        assert (\n-            simple_attr(\"x\"),\n-        ) == C.__attrs_attrs__\n-        assert isinstance(C.y, _CountingAttr)\n-\n-    def test_recurse(self):\n-        \"\"\"\n-        Collect attributes from all sub-classes.\n-        \"\"\"\n-        class A(object):\n-            a = None\n-\n-        class B(A):\n-            b = attr.ib()\n-\n-        _transform_attrs(B, None)\n-\n-        class C(B):\n-            c = attr.ib()\n-\n-        _transform_attrs(C, None)\n-\n-        class D(C):\n-            d = attr.ib()\n-\n-        _transform_attrs(D, None)\n+        class Base(object):\n+            z = attr.ib()\n \n-        class E(D):\n-            e = attr.ib()\n+        class C(Base):\n+            y = attr.ib()\n \n-        _transform_attrs(E, None)\n+        attrs, super_attrs = _transform_attrs(C, {\"x\": attr.ib()})\n \n+        assert [] == super_attrs\n         assert (\n-            simple_attr(\"b\"),\n-            simple_attr(\"c\"),\n-            simple_attr(\"d\"),\n-            simple_attr(\"e\"),\n-        ) == E.__attrs_attrs__\n+            simple_attr(\"x\"),\n+        ) == attrs\n \n \n class TestAttributes(object):\n@@ -250,6 +227,7 @@ def test_catches_old_style(self):\n             @attr.s\n             class C:\n                 pass\n+\n         assert (\"attrs only works with new-style classes.\",) == e.value.args\n \n     def test_sets_attrs(self):\n@@ -259,6 +237,7 @@ def test_sets_attrs(self):\n         @attr.s\n         class C(object):\n             x = attr.ib()\n+\n         assert \"x\" == C.__attrs_attrs__[0].name\n         assert all(isinstance(a, Attribute) for a in C.__attrs_attrs__)\n \n@@ -269,6 +248,7 @@ def test_empty(self):\n         @attr.s\n         class C3(object):\n             pass\n+\n         assert \"C3()\" == repr(C3())\n         assert C3() == C3()\n \n@@ -798,3 +778,45 @@ def test_empty_metadata_singleton(self, list_of_attrs):\n         C = make_class(\"C\", dict(zip(gen_attr_names(), list_of_attrs)))\n         for a in fields(C)[1:]:\n             assert a.metadata is fields(C)[0].metadata\n+\n+\n+class TestClassBuilder(object):\n+    \"\"\"\n+    Tests for `_ClassBuilder`.\n+    \"\"\"\n+    def test_repr_str(self):\n+        \"\"\"\n+        Trying to add a `__str__` without having a `__repr__` raises a\n+        ValueError.\n+        \"\"\"\n+        with pytest.raises(ValueError) as ei:\n+            make_class(\"C\", {}, repr=False, str=True)\n+\n+        assert (\n+            \"__str__ can only be generated if a __repr__ exists.\",\n+        ) == ei.value.args\n+\n+    def test_repr(self):\n+        \"\"\"\n+        repr of builder itself makes sense.\n+        \"\"\"\n+        class C(object):\n+            pass\n+\n+        b = _ClassBuilder(C, None, True, True)\n+\n+        assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n+\n+    def test_returns_self(self):\n+        \"\"\"\n+        All methods return the builder for chaining.\n+        \"\"\"\n+        class C(object):\n+            x = attr.ib()\n+\n+        b = _ClassBuilder(C, None, True, True)\n+\n+        cls = b.add_cmp().add_hash().add_init().add_repr(\"ns\").add_str() \\\n+            .build_class()\n+\n+        assert \"ns.C(x=1)\" == repr(cls(1))\ndiff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -8,7 +8,7 @@\n try:\n     from pympler.asizeof import asizeof\n     has_pympler = True\n-except:  # Won't be an import error.\n+except BaseException:  # Won't be an import error.\n     has_pympler = False\n \n import attr\n@@ -129,10 +129,13 @@ class C2Slots(C1):\n         z = attr.ib()\n \n     c2 = C2Slots(x=1, y=2, z=\"test\")\n+\n     assert 1 == c2.x\n     assert 2 == c2.y\n     assert \"test\" == c2.z\n+\n     c2.t = \"test\"  # This will work, using the base class.\n+\n     assert \"test\" == c2.t\n \n     assert 1 == c2.method()\n@@ -142,8 +145,11 @@ class C2Slots(C1):\n     assert set([\"z\"]) == set(C2Slots.__slots__)\n \n     c3 = C2Slots(x=1, y=3, z=\"test\")\n+\n     assert c3 > c2\n+\n     c2_ = C2Slots(x=1, y=2, z=\"test\")\n+\n     assert c2 == c2_\n \n     assert \"C2Slots(x=1, y=2, z='test')\" == repr(c2)\n@@ -365,3 +371,30 @@ def my_subclass(self):\n \n     assert non_slot_instance.my_subclass() is C2\n     assert slot_instance.my_subclass() is C2Slots\n+\n+\n+@pytest.mark.skipif(PY2, reason=\"closure cell rewriting is PY3-only.\")\n+@pytest.mark.parametrize(\"slots\", [True, False])\n+def test_closure_cell_rewriting_cls_static(slots):\n+    \"\"\"\n+    Slot classes support proper closure cell rewriting for class- and static\n+    methods.\n+    \"\"\"\n+    # Python can reuse closure cells, so we create new classes just for\n+    # this test.\n+\n+    @attr.s(slots=slots)\n+    class C:\n+        @classmethod\n+        def clsmethod(cls):\n+            return __class__  # noqa: F821\n+\n+    assert C.clsmethod() is C\n+\n+    @attr.s(slots=slots)\n+    class D:\n+        @staticmethod\n+        def statmethod():\n+            return __class__  # noqa: F821\n+\n+    assert D.statmethod() is D\ndiff --git a/tests/utils.py b/tests/utils.py\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -218,8 +218,13 @@ class HypClass:\n         def post_init(self):\n             pass\n         cls_dict[\"__attrs_post_init__\"] = post_init\n-    return make_class(\"HypClass\", cls_dict,\n-                      slots=slots_flag, frozen=frozen_flag)\n+\n+    return make_class(\n+        \"HypClass\",\n+        cls_dict,\n+        slots=slots_flag,\n+        frozen=frozen_flag,\n+    )\n \n \n # st.recursive works by taking a base strategy (in this case, simple_classes)\n",
        "problem_statement": "slots=True do not play nice with __init_subclass__\nA class annotated with `attr.s(slots=True)` can't call `super().__init__subclass__` within its own `__init_subclass__` method - a `TypeError: super(type, obj): obj must be an instance or subtype of type` is raised.\r\n\r\nReproducible example (tested on 16.3.0, 17.2.0 and f7f53d4) is here: https://repl.it/Mmkb/0\n",
        "hints_text": "",
        "created_at": "2017-10-19T14:42:06Z",
        "version": "17.2"
    }
}