{
    "task_id": "python-attrs__attrs-304",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-304_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 304,
        "instance_id": "python-attrs__attrs-304",
        "issue_numbers": [
            "298"
        ],
        "base_commit": "2c20c0f199bc3d4b52bf478e00417ea41111f30a",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -264,7 +264,7 @@ def _transform_attrs(cls, these, auto_attribs):\n             if isinstance(attr, _CountingAttr)\n         ), key=lambda e: e[1].counter)\n \n-    non_super_attrs = [\n+    own_attrs = [\n         Attribute.from_counting_attr(\n             name=attr_name,\n             ca=ca,\n@@ -274,34 +274,22 @@ def _transform_attrs(cls, these, auto_attribs):\n         in ca_list\n     ]\n \n-    # Walk *down* the MRO for attributes.  While doing so, we collect the names\n-    # of attributes we've seen in `take_attr_names` and ignore their\n-    # redefinitions deeper in the hierarchy.\n     super_attrs = []\n-    taken_attr_names = {a.name: a for a in non_super_attrs}\n+    taken_attr_names = {a.name: a for a in own_attrs}\n+\n+    # Traverse the MRO and collect attributes.\n     for super_cls in cls.__mro__[1:-1]:\n         sub_attrs = getattr(super_cls, \"__attrs_attrs__\", None)\n         if sub_attrs is not None:\n-            # We iterate over sub_attrs backwards so we can reverse the whole\n-            # list in the end and get all attributes in the order they have\n-            # been defined.\n-            for a in reversed(sub_attrs):\n+            for a in sub_attrs:\n                 prev_a = taken_attr_names.get(a.name)\n+                # Only add an attribute if it hasn't been defined before.  This\n+                # allows for overwriting attribute definitions by subclassing.\n                 if prev_a is None:\n                     super_attrs.append(a)\n                     taken_attr_names[a.name] = a\n-                elif prev_a == a:\n-                    # This happens thru multiple inheritance.  We don't want\n-                    # to favor attributes that are further down in the tree\n-                    # so we move them to the back.\n-                    super_attrs.remove(a)\n-                    super_attrs.append(a)\n-\n-    # Now reverse the list, such that the attributes are sorted by *descending*\n-    # age.  IOW: the oldest attribute definition is at the head of the list.\n-    super_attrs.reverse()\n \n-    attr_names = [a.name for a in super_attrs + non_super_attrs]\n+    attr_names = [a.name for a in super_attrs + own_attrs]\n \n     AttrsClass = _make_attr_tuple_class(cls.__name__, attr_names)\n \n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -235,7 +235,7 @@ class D(A):\n             d2 = attr.ib(default=\"d2\")\n \n         @attr.s\n-        class E(D, C):\n+        class E(C, D):\n             e1 = attr.ib(default=\"e1\")\n             e2 = attr.ib(default=\"e2\")\n \n",
        "problem_statement": "order of attributes is 'backwards' in case of multiple inheritance\nconsider following code.  I also added a dummy method `m` to show that precedence is \"correct\"ly follows for a basic method\r\n\r\n```python\r\nfrom attr import attributes, attr\r\n\r\n@attributes\r\nclass A(object):\r\n    a = attr()\r\n    def m(self):\r\n        print(\"A.m\")\r\n\r\n@attributes\r\nclass B(object):\r\n    b = attr()\r\n    def m(self):\r\n        print(\"B.m\")\r\n\r\n@attributes\r\nclass C(A, B):\r\n    c = attr()\r\n\r\n    def m(self):\r\n        super(C, self).m()\r\n\r\n    @classmethod\r\n    def supers(cls):\r\n        return cls.__bases__\r\n\r\nc = C(1, 2, 3)\r\n\r\nprint(c)\r\nc.m()\r\nprint(\"supers=%s\" % str(c.supers()))\r\n```\r\nrunning it results in \r\n```\r\nC(b=1, a=2, c=3)\r\nA.m\r\nsupers=(<class '__main__.A'>, <class '__main__.B'>)\r\n```\r\nso the first argument is (IMHO) incorrectly assigned to attribute b not a, and then 2nd one to a...\r\n\r\nBefore recent 3040bdabbc627fc6a4d151a9cb2e6f9d4177b6f2  quick and dirty (and possibly incomplete) fix was to remove `reversed` around mro within src/attr/_make.py  but neither I have looked yet into how logic should be adjusted in the current state of affairs, nor I analyzed for why reversed was needed to start with\n",
        "hints_text": "Sorry I didn't get around this any earlier, but I wanted to have a weekend so I can wrap my head around it.\r\n\r\nYou\u2019re right, we\u2019ve been traversing the MRO wrongly until recently.  I have a fix similar to yours, I\u2019m just not 100% sure how to proceed.  It seems that this bug is rather old and fixing it is technically breaking backward compatibility.\r\n\r\nI\u2019m tending to rip of the bandaid tho, since it\u2019s clearly behaving wrongly.",
        "created_at": "2017-12-03T07:19:36Z",
        "version": "17.3"
    }
}