{
    "task_id": "python-attrs__attrs-302",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-302_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 302,
        "instance_id": "python-attrs__attrs-302",
        "issue_numbers": [
            "265"
        ],
        "base_commit": "3c9830f340535b663f2ceaca2d52d363bbf70df6",
        "patch": "diff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -14,6 +14,7 @@\n     fields,\n     fields_dict,\n     make_class,\n+    resolve_types,\n     validate,\n )\n from ._version_info import VersionInfo\n@@ -61,6 +62,7 @@\n     \"has\",\n     \"ib\",\n     \"make_class\",\n+    \"resolve_types\",\n     \"s\",\n     \"set_run_validators\",\n     \"setters\",\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -1707,6 +1707,45 @@ def fields_dict(cls):\n     return ordered_dict(((a.name, a) for a in attrs))\n \n \n+def resolve_types(cls, globalns=None, localns=None):\n+    \"\"\"\n+    Resolve any strings and forward annotations in type annotations.\n+\n+    With no arguments, names will be looked up in the module in which the class\n+    was created.  If this is incorrect, e.g. if the name only exists inside a\n+    method, you may pass globalns or localns to specify other dictionaries in\n+    which to look up these names. See the docs of `typing.get_type_hints` for\n+    more details.\n+\n+    :param type cls: Class to resolve.\n+    :param globalns: Dictionary containing global variables, if needed.\n+    :param localns: Dictionary containing local variables, if needed.\n+\n+    :raise TypeError: If *cls* is not a class.\n+    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+        class.\n+    :raise NameError: If types cannot be resolved because of missing variables.\n+\n+    ..  versionadded:: 19.4.0\n+    \"\"\"\n+    try:\n+        # Since calling get_type_hints is expensive we cache whether we've\n+        # done it already.\n+        cls.__attrs_types_resolved__\n+    except AttributeError:\n+        import typing\n+\n+        hints = typing.get_type_hints(cls, globalns=globalns, localns=localns)\n+        for field in fields(cls):\n+            if field.name in hints:\n+                # Since fields have been frozen we must work around it.\n+                _obj_setattr(field, \"type\", hints[field.name])\n+        cls.__attrs_types_resolved__ = True\n+\n+    # Return the class so you can use it as a decorator too.\n+    return cls\n+\n+\n def validate(inst):\n     \"\"\"\n     Validate all attributes on *inst* that have a validator.\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -297,3 +297,107 @@ def __eq__(self, other):\n         @attr.s(auto_attribs=True)\n         class C:\n             x: typing.Any = NonComparable()\n+\n+    def test_basic_resolve(self):\n+        \"\"\"\n+        Resolve the `Attribute.type` attr from basic type annotations.\n+        Unannotated types are ignored.\n+        \"\"\"\n+\n+        @attr.s\n+        class C:\n+            x: \"int\" = attr.ib()\n+            y = attr.ib(type=str)\n+            z = attr.ib()\n+\n+        assert \"int\" == attr.fields(C).x.type\n+        assert str is attr.fields(C).y.type\n+        assert None is attr.fields(C).z.type\n+\n+        attr.resolve_types(C)\n+\n+        assert int is attr.fields(C).x.type\n+        assert str is attr.fields(C).y.type\n+        assert None is attr.fields(C).z.type\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_resolve_types_auto_attrib(self, slots):\n+        \"\"\"\n+        Types can be resolved even when strings are involved.\n+        \"\"\"\n+\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class A:\n+            a: typing.List[int]\n+            b: typing.List[\"int\"]\n+            c: \"typing.List[int]\"\n+\n+        assert typing.List[int] == attr.fields(A).a.type\n+        assert typing.List[\"int\"] == attr.fields(A).b.type\n+        assert \"typing.List[int]\" == attr.fields(A).c.type\n+\n+        # Note: I don't have to pass globals and locals here because\n+        # int is a builtin and will be available in any scope.\n+        attr.resolve_types(A)\n+\n+        assert typing.List[int] == attr.fields(A).a.type\n+        assert typing.List[int] == attr.fields(A).b.type\n+        assert typing.List[int] == attr.fields(A).c.type\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_resolve_types_decorator(self, slots):\n+        \"\"\"\n+        Types can be resolved using it as a decorator.\n+        \"\"\"\n+\n+        @attr.resolve_types\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class A:\n+            a: typing.List[int]\n+            b: typing.List[\"int\"]\n+            c: \"typing.List[int]\"\n+\n+        assert typing.List[int] == attr.fields(A).a.type\n+        assert typing.List[int] == attr.fields(A).b.type\n+        assert typing.List[int] == attr.fields(A).c.type\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_self_reference(self, slots):\n+        \"\"\"\n+        References to self class using quotes can be resolved.\n+        \"\"\"\n+\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class A:\n+            a: \"A\"\n+            b: typing.Optional[\"A\"]  # noqa: will resolve below\n+\n+        assert \"A\" == attr.fields(A).a.type\n+        assert typing.Optional[\"A\"] == attr.fields(A).b.type\n+\n+        attr.resolve_types(A, globals(), locals())\n+\n+        assert A == attr.fields(A).a.type\n+        assert typing.Optional[A] == attr.fields(A).b.type\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_forward_reference(self, slots):\n+        \"\"\"\n+        Forward references can be resolved.\n+        \"\"\"\n+\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class A:\n+            a: typing.List[\"B\"]  # noqa: will resolve below\n+\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class B:\n+            a: A\n+\n+        assert typing.List[\"B\"] == attr.fields(A).a.type\n+        assert A == attr.fields(B).a.type\n+\n+        attr.resolve_types(A, globals(), locals())\n+\n+        assert typing.List[B] == attr.fields(A).a.type\n+        assert A == attr.fields(B).a.type\n",
        "problem_statement": "Forward references\nHello, there's some food for thought. Imagine a class referencing itself.\r\n\r\n```\r\n@attr.s\r\nclass A:\r\n    a: 'A' = attr.ib()\r\n```\r\n\r\nThis is the proper way of doing this as per mypy. In the case of attrs though:\r\n\r\n```\r\n>>> attr.fields(A).a\r\nAttribute(name='a', default=NOTHING, validator=None, repr=True, cmp=True, hash=None, init=True, convert=None, metadata=mappingproxy({}), type='A')\r\n```\r\n\r\nThe string just gets copied into the type attribute. `A.__annotations__` has the same problem. Ideally the type would be the actual class object. Mypy deals with this by having more than one pass when parsing.\r\n\r\nThe first question to answer if whether we should deal with this here, in attrs, or let code making use of the type attribute deal with it. Maybe instead of expecting higher levels to deal with this, Python itself should handle it (although good luck waiting for this :). I think it's worth trying to deal with this problem in attrs, to make it easier for others.\r\n\r\nDealing with just a class referencing itself is very doable. Now imagine circular references.\r\n\r\n```\r\n@attr.s\r\nclass A:\r\n    b: 'B' = attr.ib()\r\n\r\n@attr.s\r\nclass B:\r\n    a: A = attr.ib()\r\n```\r\n\r\nNot really sure what to do here.\n",
        "hints_text": "This issue was initially motivated by https://github.com/Tinche/cattrs/issues/13.\nGitHub doesn't have enough Emojis for this one.",
        "created_at": "2017-11-29T21:18:26Z",
        "version": "19.3"
    }
}