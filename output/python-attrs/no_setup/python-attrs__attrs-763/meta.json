{
    "task_id": "python-attrs__attrs-763",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-763_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 763,
        "instance_id": "python-attrs__attrs-763",
        "issue_numbers": [
            "716"
        ],
        "base_commit": "44ac46114603f8fa7c1142dd338da16c5373d8df",
        "patch": "diff --git a/conftest.py b/conftest.py\n--- a/conftest.py\n+++ b/conftest.py\n@@ -23,3 +23,10 @@ def pytest_configure(config):\n             \"tests/test_next_gen.py\",\n         ]\n     )\n+if sys.version_info[:2] >= (3, 10):\n+    collect_ignore.extend(\n+        [\n+            \"tests/test_mypy.yml\",\n+            \"tests/test_hooks.py\",\n+        ]\n+    )\ndiff --git a/setup.py b/setup.py\n--- a/setup.py\n+++ b/setup.py\n@@ -36,6 +36,7 @@\n     \"Programming Language :: Python :: 3.7\",\n     \"Programming Language :: Python :: 3.8\",\n     \"Programming Language :: Python :: 3.9\",\n+    \"Programming Language :: Python :: 3.10\",\n     \"Programming Language :: Python :: Implementation :: CPython\",\n     \"Programming Language :: Python :: Implementation :: PyPy\",\n     \"Topic :: Software Development :: Libraries :: Python Modules\",\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -384,7 +384,13 @@ def _is_class_var(annot):\n     annotations which would put attrs-based classes at a performance\n     disadvantage compared to plain old classes.\n     \"\"\"\n-    return str(annot).startswith(_classvar_prefixes)\n+    annot = str(annot)\n+\n+    # Annotation can be quoted.\n+    if annot.startswith((\"'\", '\"')) and annot.endswith((\"'\", '\"')):\n+        annot = annot[1:-1]\n+\n+    return annot.startswith(_classvar_prefixes)\n \n \n def _has_own_attribute(cls, attrib_name):\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -4,6 +4,7 @@\n Python 3.6+ only.\n \"\"\"\n \n+import sys\n import types\n import typing\n \n@@ -11,10 +12,21 @@\n \n import attr\n \n-from attr._make import _classvar_prefixes\n+from attr._make import _is_class_var\n from attr.exceptions import UnannotatedAttributeError\n \n \n+def assert_init_annotations(cls, **annotations):\n+    \"\"\"\n+    Assert cls.__init__ has the correct annotations.\n+    \"\"\"\n+    __tracebackhide__ = True\n+\n+    annotations[\"return\"] = type(None)\n+\n+    assert annotations == typing.get_type_hints(cls.__init__)\n+\n+\n class TestAnnotations:\n     \"\"\"\n     Tests for types derived from variable annotations (PEP-526).\n@@ -25,6 +37,7 @@ def test_basic_annotations(self):\n         Sets the `Attribute.type` attr from basic type annotations.\n         \"\"\"\n \n+        @attr.resolve_types\n         @attr.s\n         class C:\n             x: int = attr.ib()\n@@ -34,11 +47,7 @@ class C:\n         assert int is attr.fields(C).x.type\n         assert str is attr.fields(C).y.type\n         assert None is attr.fields(C).z.type\n-        assert C.__init__.__annotations__ == {\n-            \"x\": int,\n-            \"y\": str,\n-            \"return\": None,\n-        }\n+        assert_init_annotations(C, x=int, y=str)\n \n     def test_catches_basic_type_conflict(self):\n         \"\"\"\n@@ -59,6 +68,7 @@ def test_typing_annotations(self):\n         Sets the `Attribute.type` attr from typing annotations.\n         \"\"\"\n \n+        @attr.resolve_types\n         @attr.s\n         class C:\n             x: typing.List[int] = attr.ib()\n@@ -66,27 +76,21 @@ class C:\n \n         assert typing.List[int] is attr.fields(C).x.type\n         assert typing.Optional[str] is attr.fields(C).y.type\n-        assert C.__init__.__annotations__ == {\n-            \"x\": typing.List[int],\n-            \"y\": typing.Optional[str],\n-            \"return\": None,\n-        }\n+        assert_init_annotations(C, x=typing.List[int], y=typing.Optional[str])\n \n     def test_only_attrs_annotations_collected(self):\n         \"\"\"\n         Annotations that aren't set to an attr.ib are ignored.\n         \"\"\"\n \n+        @attr.resolve_types\n         @attr.s\n         class C:\n             x: typing.List[int] = attr.ib()\n             y: int\n \n         assert 1 == len(attr.fields(C))\n-        assert C.__init__.__annotations__ == {\n-            \"x\": typing.List[int],\n-            \"return\": None,\n-        }\n+        assert_init_annotations(C, x=typing.List[int])\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_auto_attribs(self, slots):\n@@ -111,6 +115,8 @@ class C:\n         assert \"a\" in attr_names  # just double check that the set works\n         assert \"cls_var\" not in attr_names\n \n+        attr.resolve_types(C)\n+\n         assert int == attr.fields(C).a.type\n \n         assert attr.Factory(list) == attr.fields(C).x.default\n@@ -135,14 +141,14 @@ class C:\n             i.y = 23\n             assert 23 == i.y\n \n-        assert C.__init__.__annotations__ == {\n-            \"a\": int,\n-            \"x\": typing.List[int],\n-            \"y\": int,\n-            \"z\": int,\n-            \"foo\": typing.Any,\n-            \"return\": None,\n-        }\n+        assert_init_annotations(\n+            C,\n+            a=int,\n+            x=typing.List[int],\n+            y=int,\n+            z=int,\n+            foo=typing.Optional[typing.Any],\n+        )\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_auto_attribs_unannotated(self, slots):\n@@ -171,28 +177,26 @@ def test_auto_attribs_subclassing(self, slots):\n         Ref #291\n         \"\"\"\n \n+        @attr.resolve_types\n         @attr.s(slots=slots, auto_attribs=True)\n         class A:\n             a: int = 1\n \n+        @attr.resolve_types\n         @attr.s(slots=slots, auto_attribs=True)\n         class B(A):\n             b: int = 2\n \n+        @attr.resolve_types\n         @attr.s(slots=slots, auto_attribs=True)\n         class C(A):\n             pass\n \n         assert \"B(a=1, b=2)\" == repr(B())\n         assert \"C(a=1)\" == repr(C())\n-\n-        assert A.__init__.__annotations__ == {\"a\": int, \"return\": None}\n-        assert B.__init__.__annotations__ == {\n-            \"a\": int,\n-            \"b\": int,\n-            \"return\": None,\n-        }\n-        assert C.__init__.__annotations__ == {\"a\": int, \"return\": None}\n+        assert_init_annotations(A, a=int)\n+        assert_init_annotations(B, a=int, b=int)\n+        assert_init_annotations(C, a=int)\n \n     def test_converter_annotations(self):\n         \"\"\"\n@@ -207,7 +211,7 @@ def int2str(x: int) -> str:\n         class A:\n             a = attr.ib(converter=int2str)\n \n-        assert A.__init__.__annotations__ == {\"a\": int, \"return\": None}\n+        assert_init_annotations(A, a=int)\n \n         def int2str_(x: int, y: str = \"\"):\n             return str(x)\n@@ -216,7 +220,7 @@ def int2str_(x: int, y: str = \"\"):\n         class A:\n             a = attr.ib(converter=int2str_)\n \n-        assert A.__init__.__annotations__ == {\"a\": int, \"return\": None}\n+        assert_init_annotations(A, a=int)\n \n     def test_converter_attrib_annotations(self):\n         \"\"\"\n@@ -232,11 +236,7 @@ class A:\n             a: str = attr.ib(converter=int2str)\n             b = attr.ib(converter=int2str, type=str)\n \n-        assert A.__init__.__annotations__ == {\n-            \"a\": int,\n-            \"b\": int,\n-            \"return\": None,\n-        }\n+        assert_init_annotations(A, a=int, b=int)\n \n     def test_non_introspectable_converter(self):\n         \"\"\"\n@@ -382,30 +382,41 @@ def noop():\n \n         assert attr.converters.optional(noop).__annotations__ == {}\n \n+    @pytest.mark.xfail(\n+        sys.version_info[:2] == (3, 6), reason=\"Does not work on 3.6.\"\n+    )\n     @pytest.mark.parametrize(\"slots\", [True, False])\n-    @pytest.mark.parametrize(\"classvar\", _classvar_prefixes)\n-    def test_annotations_strings(self, slots, classvar):\n+    def test_annotations_strings(self, slots):\n         \"\"\"\n         String annotations are passed into __init__ as is.\n+\n+        It fails on 3.6 due to a bug in Python.\n         \"\"\"\n+        import typing as t\n+\n+        from typing import ClassVar\n \n         @attr.s(auto_attribs=True, slots=slots)\n         class C:\n-            cls_var: classvar + \"[int]\" = 23\n+            cls_var1: \"typing.ClassVar[int]\" = 23\n+            cls_var2: \"ClassVar[int]\" = 23\n+            cls_var3: \"t.ClassVar[int]\" = 23\n             a: \"int\"\n             x: \"typing.List[int]\" = attr.Factory(list)\n             y: \"int\" = 2\n             z: \"int\" = attr.ib(default=3)\n             foo: \"typing.Any\" = None\n \n-        assert C.__init__.__annotations__ == {\n-            \"a\": \"int\",\n-            \"x\": \"typing.List[int]\",\n-            \"y\": \"int\",\n-            \"z\": \"int\",\n-            \"foo\": \"typing.Any\",\n-            \"return\": None,\n-        }\n+        attr.resolve_types(C, locals(), globals())\n+\n+        assert_init_annotations(\n+            C,\n+            a=int,\n+            x=typing.List[int],\n+            y=int,\n+            z=int,\n+            foo=typing.Optional[typing.Any],\n+        )\n \n     def test_keyword_only_auto_attribs(self):\n         \"\"\"\n@@ -487,10 +498,6 @@ class C:\n             y = attr.ib(type=str)\n             z = attr.ib()\n \n-        assert \"int\" == attr.fields(C).x.type\n-        assert str is attr.fields(C).y.type\n-        assert None is attr.fields(C).z.type\n-\n         attr.resolve_types(C)\n \n         assert int is attr.fields(C).x.type\n@@ -509,10 +516,6 @@ class A:\n             b: typing.List[\"int\"]\n             c: \"typing.List[int]\"\n \n-        assert typing.List[int] == attr.fields(A).a.type\n-        assert typing.List[\"int\"] == attr.fields(A).b.type\n-        assert \"typing.List[int]\" == attr.fields(A).c.type\n-\n         # Note: I don't have to pass globals and locals here because\n         # int is a builtin and will be available in any scope.\n         attr.resolve_types(A)\n@@ -549,9 +552,6 @@ class A:\n             a: \"A\"\n             b: typing.Optional[\"A\"]  # noqa: will resolve below\n \n-        assert \"A\" == attr.fields(A).a.type\n-        assert typing.Optional[\"A\"] == attr.fields(A).b.type\n-\n         attr.resolve_types(A, globals(), locals())\n \n         assert A == attr.fields(A).a.type\n@@ -571,10 +571,11 @@ class A:\n         class B:\n             a: A\n \n-        assert typing.List[\"B\"] == attr.fields(A).a.type\n-        assert A == attr.fields(B).a.type\n-\n         attr.resolve_types(A, globals(), locals())\n+        attr.resolve_types(B, globals(), locals())\n+\n+        assert typing.List[B] == attr.fields(A).a.type\n+        assert A == attr.fields(B).a.type\n \n         assert typing.List[B] == attr.fields(A).a.type\n         assert A == attr.fields(B).a.type\n@@ -588,10 +589,7 @@ def test_init_type_hints(self):\n         class C:\n             x = attr.ib(type=\"typing.List[int]\")\n \n-        assert typing.get_type_hints(C.__init__) == {\n-            \"return\": type(None),\n-            \"x\": typing.List[int],\n-        }\n+        assert_init_annotations(C, x=typing.List[int])\n \n     def test_init_type_hints_fake_module(self):\n         \"\"\"\n@@ -607,3 +605,19 @@ class C:\n \n         with pytest.raises(NameError):\n             typing.get_type_hints(C.__init__)\n+\n+\n+@pytest.mark.parametrize(\n+    \"annot\",\n+    [\n+        typing.ClassVar,\n+        \"typing.ClassVar\",\n+        \"'typing.ClassVar[dict]'\",\n+        \"t.ClassVar[int]\",\n+    ],\n+)\n+def test_is_class_var(annot):\n+    \"\"\"\n+    ClassVars are detected, even if they're a string or quoted.\n+    \"\"\"\n+    assert _is_class_var(annot)\ndiff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -729,9 +729,8 @@ def test_init(self, slots, frozen):\n         with pytest.raises(TypeError) as e:\n             C(a=1, b=2)\n \n-        assert (\n+        assert e.value.args[0].endswith(\n             \"__init__() got an unexpected keyword argument 'a'\"\n-            == e.value.args[0]\n         )\n \n     @given(booleans(), booleans())\ndiff --git a/tests/test_funcs.py b/tests/test_funcs.py\n--- a/tests/test_funcs.py\n+++ b/tests/test_funcs.py\n@@ -552,7 +552,7 @@ def test_unknown(self, C):\n         else:\n             expected = \"__init__() got an unexpected keyword argument 'aaaa'\"\n \n-        assert (expected,) == e.value.args\n+        assert e.value.args[0].endswith(expected)\n \n     def test_validator_failure(self):\n         \"\"\"\n",
        "problem_statement": "Python 3.10 compatibility\nHello.\r\n\r\nWe have already started testing RPM packages in Fedora with Python 3.10a2 and attrs is currently not compatible.\r\n\r\nThe problem is caused by the implementation of [PEP 563](https://www.python.org/dev/peps/pep-0563/#abstract) \u2014 type annotations are now stored as strings which cause asserts like this one to fail:\r\n\r\n```python\r\nclass TestAnnotations:\r\n    \"\"\"\r\n    Tests for types derived from variable annotations (PEP-526).\r\n    \"\"\"\r\n\r\n    def test_basic_annotations(self):\r\n        \"\"\"\r\n        Sets the `Attribute.type` attr from basic type annotations.\r\n        \"\"\"\r\n\r\n        @attr.s\r\n        class C:\r\n            x: int = attr.ib()\r\n            y = attr.ib(type=str)\r\n            z = attr.ib()\r\n\r\n        assert int is attr.fields(C).x.type\r\n```\r\n\r\nThe value stored in `attr.fields(C).x.type` is a string \"int\" instead of a class int.\r\n\r\nIt seems it was discussed before in https://github.com/python-attrs/attrs/issues/424\n",
        "hints_text": "Do we need to call `attr.resolve_types` first in the test?\nDo I understand it correctly that we are waiting for https://github.com/python-attrs/attrs/issues/593 here?\nYes. :(\nFTR, when issue 593 is fixed now, I can use `attr.resolve_types(C)` in the `test_basic_annotations` and that makes the previously mentioned `assert int is attr.fields(C).x.type` pass but the last assert in the test:\r\n\r\n```python\r\nassert C.__init__.__annotations__ == {\r\n    \"x\": int,\r\n    \"y\": str,\r\n    \"return\": None,\r\n}\r\n```\r\n\r\nstill complains about `{'x': 'int'} != {'x': <class 'int'>}`. I'm not sure how much you want to make the attrs behave the same under Python 3.10. If that's the goal, we should probably keep tests untouched.\nThe test needs to be changed to get_type_hints I'm afraid. There's a bunch more stuff breaking that I'm working on rn.",
        "created_at": "2021-02-19T10:58:43Z",
        "version": "20.3"
    }
}