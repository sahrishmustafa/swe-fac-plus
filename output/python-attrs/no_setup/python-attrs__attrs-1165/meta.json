{
    "task_id": "python-attrs__attrs-1165",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1165_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1165,
        "instance_id": "python-attrs__attrs-1165",
        "issue_numbers": [
            "1164"
        ],
        "base_commit": "a37b556f7d762b7a6229b1fbf985965539571cd2",
        "patch": "diff --git a/src/attr/_funcs.py b/src/attr/_funcs.py\n--- a/src/attr/_funcs.py\n+++ b/src/attr/_funcs.py\n@@ -72,19 +72,25 @@ def asdict(\n                 )\n             elif isinstance(v, (tuple, list, set, frozenset)):\n                 cf = v.__class__ if retain_collection_types is True else list\n-                rv[a.name] = cf(\n-                    [\n-                        _asdict_anything(\n-                            i,\n-                            is_key=False,\n-                            filter=filter,\n-                            dict_factory=dict_factory,\n-                            retain_collection_types=retain_collection_types,\n-                            value_serializer=value_serializer,\n-                        )\n-                        for i in v\n-                    ]\n-                )\n+                items = [\n+                    _asdict_anything(\n+                        i,\n+                        is_key=False,\n+                        filter=filter,\n+                        dict_factory=dict_factory,\n+                        retain_collection_types=retain_collection_types,\n+                        value_serializer=value_serializer,\n+                    )\n+                    for i in v\n+                ]\n+                try:\n+                    rv[a.name] = cf(items)\n+                except TypeError:\n+                    if not issubclass(cf, tuple):\n+                        raise\n+                    # Workaround for TypeError: cf.__new__() missing 1 required\n+                    # positional argument (which appears, for a namedturle)\n+                    rv[a.name] = cf(*items)\n             elif isinstance(v, dict):\n                 df = dict_factory\n                 rv[a.name] = df(\n@@ -241,22 +247,26 @@ def astuple(\n                 )\n             elif isinstance(v, (tuple, list, set, frozenset)):\n                 cf = v.__class__ if retain is True else list\n-                rv.append(\n-                    cf(\n-                        [\n-                            astuple(\n-                                j,\n-                                recurse=True,\n-                                filter=filter,\n-                                tuple_factory=tuple_factory,\n-                                retain_collection_types=retain,\n-                            )\n-                            if has(j.__class__)\n-                            else j\n-                            for j in v\n-                        ]\n+                items = [\n+                    astuple(\n+                        j,\n+                        recurse=True,\n+                        filter=filter,\n+                        tuple_factory=tuple_factory,\n+                        retain_collection_types=retain,\n                     )\n-                )\n+                    if has(j.__class__)\n+                    else j\n+                    for j in v\n+                ]\n+                try:\n+                    rv.append(cf(items))\n+                except TypeError:\n+                    if not issubclass(cf, tuple):\n+                        raise\n+                    # Workaround for TypeError: cf.__new__() missing 1 required\n+                    # positional argument (which appears, for a namedturle)\n+                    rv.append(cf(*items))\n             elif isinstance(v, dict):\n                 df = v.__class__ if retain is True else dict\n                 rv.append(\n",
        "test_patch": "diff --git a/tests/test_funcs.py b/tests/test_funcs.py\n--- a/tests/test_funcs.py\n+++ b/tests/test_funcs.py\n@@ -4,9 +4,10 @@\n Tests for `attr._funcs`.\n \"\"\"\n \n+import re\n \n from collections import OrderedDict\n-from typing import Generic, TypeVar\n+from typing import Generic, NamedTuple, TypeVar\n \n import pytest\n \n@@ -232,6 +233,52 @@ class A:\n \n         assert {\"a\": {(1,): 1}} == attr.asdict(instance)\n \n+    def test_named_tuple_retain_type(self):\n+        \"\"\"\n+        Namedtuples can be serialized if retain_collection_types is True.\n+\n+        See #1164\n+        \"\"\"\n+\n+        class Coordinates(NamedTuple):\n+            lat: float\n+            lon: float\n+\n+        @attr.s\n+        class A:\n+            coords: Coordinates = attr.ib()\n+\n+        instance = A(Coordinates(50.419019, 30.516225))\n+\n+        assert {\"coords\": Coordinates(50.419019, 30.516225)} == attr.asdict(\n+            instance, retain_collection_types=True\n+        )\n+\n+    def test_type_error_with_retain_type(self):\n+        \"\"\"\n+        Serialization that fails with TypeError leaves the error through if\n+        they're not tuples.\n+\n+        See #1164\n+        \"\"\"\n+\n+        message = \"__new__() missing 1 required positional argument (asdict)\"\n+\n+        class Coordinates(list):\n+            def __init__(self, first, *rest):\n+                if isinstance(first, list):\n+                    raise TypeError(message)\n+                super().__init__([first, *rest])\n+\n+        @attr.s\n+        class A:\n+            coords: Coordinates = attr.ib()\n+\n+        instance = A(Coordinates(50.419019, 30.516225))\n+\n+        with pytest.raises(TypeError, match=re.escape(message)):\n+            attr.asdict(instance, retain_collection_types=True)\n+\n \n class TestAsTuple:\n     \"\"\"\n@@ -390,6 +437,52 @@ def test_sets_no_retain(self, C, set_type):\n \n         assert (1, [1, 2, 3]) == d\n \n+    def test_named_tuple_retain_type(self):\n+        \"\"\"\n+        Namedtuples can be serialized if retain_collection_types is True.\n+\n+        See #1164\n+        \"\"\"\n+\n+        class Coordinates(NamedTuple):\n+            lat: float\n+            lon: float\n+\n+        @attr.s\n+        class A:\n+            coords: Coordinates = attr.ib()\n+\n+        instance = A(Coordinates(50.419019, 30.516225))\n+\n+        assert (Coordinates(50.419019, 30.516225),) == attr.astuple(\n+            instance, retain_collection_types=True\n+        )\n+\n+    def test_type_error_with_retain_type(self):\n+        \"\"\"\n+        Serialization that fails with TypeError leaves the error through if\n+        they're not tuples.\n+\n+        See #1164\n+        \"\"\"\n+\n+        message = \"__new__() missing 1 required positional argument (astuple)\"\n+\n+        class Coordinates(list):\n+            def __init__(self, first, *rest):\n+                if isinstance(first, list):\n+                    raise TypeError(message)\n+                super().__init__([first, *rest])\n+\n+        @attr.s\n+        class A:\n+            coords: Coordinates = attr.ib()\n+\n+        instance = A(Coordinates(50.419019, 30.516225))\n+\n+        with pytest.raises(TypeError, match=re.escape(message)):\n+            attr.astuple(instance, retain_collection_types=True)\n+\n \n class TestHas:\n     \"\"\"\n",
        "problem_statement": "NamedTuple serialization fails to work\nMRE:\r\n```python\r\nimport attrs\r\nfrom typing import NamedTuple\r\nclass MyNamedTuple(NamedTuple):\r\n    one: str\r\n    two: int\r\n@attrs.define\r\nclass MyAttrsClass:\r\n    inner: MyNamedTuple\r\nprint(attrs.asdict(MyAttrsClass(MyNamedTuple(\"Hello!\", 0))))\r\n```\r\nExpected output:\r\n```\r\n{'inner': MyNamedTuple(one='Hello!', two=0)}\r\n```\r\nor at least even a\r\n```\r\n{'inner': ('Hello!', 0)}\r\n```\r\nInstead we get \r\n```\r\nFile ~/.local/pipx/venvs/jupyter/lib/python3.11/site-packages/attr/_funcs.py:75, in asdict(inst, recurse, filter, dict_factory, retain_collection_types, value_serializer)\r\n     73 elif isinstance(v, (tuple, list, set, frozenset)):\r\n     74     cf = v.__class__ if retain_collection_types is True else list\r\n---> 75     rv[a.name] = cf(\r\n     76         [\r\n     77             _asdict_anything(\r\n     78                 i,\r\n     79                 is_key=False,\r\n     80                 filter=filter,\r\n     81                 dict_factory=dict_factory,\r\n     82                 retain_collection_types=retain_collection_types,\r\n     83                 value_serializer=value_serializer,\r\n     84             )\r\n     85             for i in v\r\n     86         ]\r\n     87     )\r\n     88 elif isinstance(v, dict):\r\n     89     df = dict_factory\r\n\r\nTypeError: MyNamedTuple.__new__() missing 1 required positional argument: 'two'\r\n```\r\n\r\nPython: 3.11.0\r\nAttrs: 23.1.0\n",
        "hints_text": "",
        "created_at": "2023-07-19T17:37:24Z",
        "version": "23.1"
    }
}