{
    "task_id": "python-attrs__attrs-660",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-660_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 660,
        "instance_id": "python-attrs__attrs-660",
        "issue_numbers": [
            "645"
        ],
        "base_commit": "428bbcf0d3901b83f96951157351e3716df3a04f",
        "patch": "diff --git a/setup.py b/setup.py\n--- a/setup.py\n+++ b/setup.py\n@@ -50,9 +50,6 @@\n EXTRAS_REQUIRE[\"dev\"] = (\n     EXTRAS_REQUIRE[\"tests\"] + EXTRAS_REQUIRE[\"docs\"] + [\"pre-commit\"]\n )\n-EXTRAS_REQUIRE[\"azure-pipelines\"] = EXTRAS_REQUIRE[\"tests\"] + [\n-    \"pytest-azurepipelines\"\n-]\n \n ###############################################################################\n \ndiff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -2,7 +2,7 @@\n \n from functools import partial\n \n-from . import converters, exceptions, filters, validators\n+from . import converters, exceptions, filters, setters, validators\n from ._config import get_run_validators, set_run_validators\n from ._funcs import asdict, assoc, astuple, evolve, has\n from ._make import (\n@@ -63,6 +63,7 @@\n     \"make_class\",\n     \"s\",\n     \"set_run_validators\",\n+    \"setters\",\n     \"validate\",\n     \"validators\",\n ]\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -9,7 +9,7 @@\n \n from operator import itemgetter\n \n-from . import _config\n+from . import _config, setters\n from ._compat import (\n     PY2,\n     isclass,\n@@ -29,7 +29,7 @@\n \n # This is used at least twice, so cache it here.\n _obj_setattr = object.__setattr__\n-_init_converter_pat = \"__attr_converter_{}\"\n+_init_converter_pat = \"__attr_converter_%s\"\n _init_factory_pat = \"__attr_factory_{}\"\n _tuple_property_pat = (\n     \"    {attr_name} = _attrs_property(_attrs_itemgetter({index}))\"\n@@ -109,6 +109,7 @@ def attrib(\n     kw_only=False,\n     eq=None,\n     order=None,\n+    on_setattr=None,\n ):\n     \"\"\"\n     Create a new attribute on a class.\n@@ -126,7 +127,7 @@ def attrib(\n         used to construct a new value (useful for mutable data types like lists\n         or dicts).\n \n-        If a default is not set (or set manually to ``attr.NOTHING``), a value\n+        If a default is not set (or set manually to `attr.NOTHING`), a value\n         *must* be supplied when instantiating; otherwise a `TypeError`\n         will be raised.\n \n@@ -200,6 +201,12 @@ def attrib(\n     :param kw_only: Make this attribute keyword-only (Python 3+)\n         in the generated ``__init__`` (if ``init`` is ``False``, this\n         parameter is ignored).\n+    :param on_setattr: Allows to overwrite the *on_setattr* setting from\n+        `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.\n+        Set to `attr.setters.NO_OP` to run **no** `setattr` hooks for this\n+        attribute -- regardless of the setting in `attr.s`.\n+    :type on_setattr: `callable`, or a list of callables, or `None`, or\n+        `attr.setters.NO_OP`\n \n     .. versionadded:: 15.2.0 *convert*\n     .. versionadded:: 16.3.0 *metadata*\n@@ -217,6 +224,7 @@ def attrib(\n     .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.\n     .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n     .. versionadded:: 19.2.0 *eq* and *order*\n+    .. versionadded:: 20.1.0 *on_setattr*\n     \"\"\"\n     eq, order = _determine_eq_order(cmp, eq, order, True)\n \n@@ -238,6 +246,16 @@ def attrib(\n     if metadata is None:\n         metadata = {}\n \n+    # Apply syntactic sugar by auto-wrapping.\n+    if isinstance(on_setattr, (list, tuple)):\n+        on_setattr = setters.pipe(*on_setattr)\n+\n+    if validator and isinstance(validator, (list, tuple)):\n+        validator = and_(*validator)\n+\n+    if converter and isinstance(converter, (list, tuple)):\n+        converter = chain(*converter)\n+\n     return _CountingAttr(\n         default=default,\n         validator=validator,\n@@ -251,6 +269,7 @@ def attrib(\n         kw_only=kw_only,\n         eq=eq,\n         order=order,\n+        on_setattr=on_setattr,\n     )\n \n \n@@ -524,19 +543,20 @@ class _ClassBuilder(object):\n     \"\"\"\n \n     __slots__ = (\n-        \"_cls\",\n-        \"_cls_dict\",\n+        \"_attr_names\",\n         \"_attrs\",\n+        \"_base_attr_map\",\n         \"_base_names\",\n-        \"_attr_names\",\n-        \"_slots\",\n-        \"_frozen\",\n-        \"_weakref_slot\",\n         \"_cache_hash\",\n-        \"_has_post_init\",\n+        \"_cls\",\n+        \"_cls_dict\",\n         \"_delete_attribs\",\n-        \"_base_attr_map\",\n+        \"_frozen\",\n+        \"_has_post_init\",\n         \"_is_exc\",\n+        \"_on_setattr\",\n+        \"_slots\",\n+        \"_weakref_slot\",\n     )\n \n     def __init__(\n@@ -552,6 +572,7 @@ def __init__(\n         cache_hash,\n         is_exc,\n         collect_by_mro,\n+        on_setattr,\n     ):\n         attrs, base_attrs, base_map = _transform_attrs(\n             cls, these, auto_attribs, kw_only, collect_by_mro,\n@@ -570,6 +591,7 @@ def __init__(\n         self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\n         self._delete_attribs = not bool(these)\n         self._is_exc = is_exc\n+        self._on_setattr = on_setattr\n \n         self._cls_dict[\"__attrs_attrs__\"] = self._attrs\n \n@@ -774,6 +796,8 @@ def add_init(self):\n                 self._cache_hash,\n                 self._base_attr_map,\n                 self._is_exc,\n+                self._on_setattr is not None\n+                and self._on_setattr is not setters.NO_OP,\n             )\n         )\n \n@@ -799,6 +823,33 @@ def add_order(self):\n \n         return self\n \n+    def add_setattr(self):\n+        if self._frozen:\n+            return self\n+\n+        sa_attrs = {}\n+        for a in self._attrs:\n+            on_setattr = a.on_setattr or self._on_setattr\n+            if on_setattr and on_setattr is not setters.NO_OP:\n+                sa_attrs[a.name] = a, on_setattr\n+\n+        if not sa_attrs:\n+            return self\n+\n+        def __setattr__(self, name, val):\n+            try:\n+                a, hook = sa_attrs[name]\n+            except KeyError:\n+                nval = val\n+            else:\n+                nval = hook(self, a, val)\n+\n+            _obj_setattr(self, name, nval)\n+\n+        self._cls_dict[\"__setattr__\"] = self._add_method_dunders(__setattr__)\n+\n+        return self\n+\n     def _add_method_dunders(self, method):\n         \"\"\"\n         Add __module__ and __qualname__ to a *method* if possible.\n@@ -816,8 +867,8 @@ def _add_method_dunders(self, method):\n             pass\n \n         try:\n-            method.__doc__ = \"Method generated by attrs for class {}.\".format(\n-                self._cls.__qualname__\n+            method.__doc__ = \"Method generated by attrs for class %s.\" % (\n+                self._cls.__qualname__,\n             )\n         except AttributeError:\n             pass\n@@ -908,6 +959,7 @@ def attrs(\n     auto_detect=False,\n     collect_by_mro=False,\n     getstate_setstate=None,\n+    on_setattr=None,\n ):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -1090,6 +1142,19 @@ def attrs(\n        on the class (i.e. not inherited), it is set to `False` (this is usually\n        what you want).\n \n+    :param on_setattr: A callable that is run whenever the user attempts to set\n+        an attribute (either by assignment like ``i.x = 42`` or by using\n+        `setattr` like ``setattr(i, \"x\", 42)``). It receives the same argument\n+        as validators: the instance, the attribute that is being modified, and\n+        the new value.\n+\n+        If no exception is raised, the attribute is set to the return value of\n+        the callable.\n+\n+        If a list of callables is passed, they're automatically wrapped in an\n+        `attr.setters.pipe`.\n+\n+\n     .. versionadded:: 16.0.0 *slots*\n     .. versionadded:: 16.1.0 *frozen*\n     .. versionadded:: 16.3.0 *str*\n@@ -1117,6 +1182,7 @@ def attrs(\n     .. versionadded:: 20.1.0 *auto_detect*\n     .. versionadded:: 20.1.0 *collect_by_mro*\n     .. versionadded:: 20.1.0 *getstate_setstate*\n+    .. versionadded:: 20.1.0 *on_setattr*\n     \"\"\"\n     if auto_detect and PY2:\n         raise PythonTooOldError(\n@@ -1126,6 +1192,9 @@ def attrs(\n     eq_, order_ = _determine_eq_order(cmp, eq, order, None)\n     hash_ = hash  # work around the lack of nonlocal\n \n+    if isinstance(on_setattr, (list, tuple)):\n+        on_setattr = setters.pipe(*on_setattr)\n+\n     def wrap(cls):\n \n         if getattr(cls, \"__class__\", None) is None:\n@@ -1151,6 +1220,7 @@ def wrap(cls):\n             cache_hash,\n             is_exc,\n             collect_by_mro,\n+            on_setattr,\n         )\n         if _determine_whether_to_implement(\n             cls, repr, auto_detect, (\"__repr__\",)\n@@ -1169,6 +1239,8 @@ def wrap(cls):\n         ):\n             builder.add_order()\n \n+        builder.add_setattr()\n+\n         if (\n             hash_ is None\n             and auto_detect is True\n@@ -1579,43 +1651,6 @@ def _add_repr(cls, ns=None, attrs=None):\n     return cls\n \n \n-def _make_init(\n-    cls, attrs, post_init, frozen, slots, cache_hash, base_attr_map, is_exc\n-):\n-    attrs = [a for a in attrs if a.init or a.default is not NOTHING]\n-\n-    unique_filename = _generate_unique_filename(cls, \"init\")\n-\n-    script, globs, annotations = _attrs_to_init_script(\n-        attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc\n-    )\n-    locs = {}\n-    bytecode = compile(script, unique_filename, \"exec\")\n-    attr_dict = dict((a.name, a) for a in attrs)\n-    globs.update({\"NOTHING\": NOTHING, \"attr_dict\": attr_dict})\n-\n-    if frozen is True:\n-        # Save the lookup overhead in __init__ if we need to circumvent\n-        # immutability.\n-        globs[\"_cached_setattr\"] = _obj_setattr\n-\n-    eval(bytecode, globs, locs)\n-\n-    # In order of debuggers like PDB being able to step through the code,\n-    # we add a fake linecache entry.\n-    linecache.cache[unique_filename] = (\n-        len(script),\n-        None,\n-        script.splitlines(True),\n-        unique_filename,\n-    )\n-\n-    __init__ = locs[\"__init__\"]\n-    __init__.__annotations__ = annotations\n-\n-    return __init__\n-\n-\n def fields(cls):\n     \"\"\"\n     Return the tuple of ``attrs`` attributes for a class.\n@@ -1700,8 +1735,134 @@ def _is_slot_attr(a_name, base_attr_map):\n     return a_name in base_attr_map and _is_slot_cls(base_attr_map[a_name])\n \n \n+def _make_init(\n+    cls,\n+    attrs,\n+    post_init,\n+    frozen,\n+    slots,\n+    cache_hash,\n+    base_attr_map,\n+    is_exc,\n+    has_global_on_setattr,\n+):\n+    if frozen and has_global_on_setattr:\n+        raise ValueError(\"Frozen classes can't use on_setattr.\")\n+\n+    needs_cached_setattr = cache_hash or frozen\n+    filtered_attrs = []\n+    attr_dict = {}\n+    for a in attrs:\n+        if not a.init and a.default is NOTHING:\n+            continue\n+\n+        filtered_attrs.append(a)\n+        attr_dict[a.name] = a\n+\n+        if a.on_setattr is not None:\n+            if frozen is True:\n+                raise ValueError(\"Frozen classes can't use on_setattr.\")\n+\n+            needs_cached_setattr = True\n+        elif (\n+            has_global_on_setattr and a.on_setattr is not setters.NO_OP\n+        ) or _is_slot_attr(a.name, base_attr_map):\n+            needs_cached_setattr = True\n+\n+    unique_filename = _generate_unique_filename(cls, \"init\")\n+\n+    script, globs, annotations = _attrs_to_init_script(\n+        filtered_attrs,\n+        frozen,\n+        slots,\n+        post_init,\n+        cache_hash,\n+        base_attr_map,\n+        is_exc,\n+        needs_cached_setattr,\n+        has_global_on_setattr,\n+    )\n+    locs = {}\n+    bytecode = compile(script, unique_filename, \"exec\")\n+    globs.update({\"NOTHING\": NOTHING, \"attr_dict\": attr_dict})\n+\n+    if needs_cached_setattr:\n+        # Save the lookup overhead in __init__ if we need to circumvent\n+        # setattr hooks.\n+        globs[\"_cached_setattr\"] = _obj_setattr\n+\n+    eval(bytecode, globs, locs)\n+\n+    # In order of debuggers like PDB being able to step through the code,\n+    # we add a fake linecache entry.\n+    linecache.cache[unique_filename] = (\n+        len(script),\n+        None,\n+        script.splitlines(True),\n+        unique_filename,\n+    )\n+\n+    __init__ = locs[\"__init__\"]\n+    __init__.__annotations__ = annotations\n+\n+    return __init__\n+\n+\n+def _setattr(attr_name, value_var, has_on_setattr):\n+    \"\"\"\n+    Use the cached object.setattr to set *attr_name* to *value_var*.\n+    \"\"\"\n+    return \"_setattr('%s', %s)\" % (attr_name, value_var,)\n+\n+\n+def _setattr_with_converter(attr_name, value_var, has_on_setattr):\n+    \"\"\"\n+    Use the cached object.setattr to set *attr_name* to *value_var*, but run\n+    its converter first.\n+    \"\"\"\n+    return \"_setattr('%s', %s(%s))\" % (\n+        attr_name,\n+        _init_converter_pat % (attr_name,),\n+        value_var,\n+    )\n+\n+\n+def _assign(attr_name, value, has_on_setattr):\n+    \"\"\"\n+    Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise\n+    relegate to _setattr.\n+    \"\"\"\n+    if has_on_setattr:\n+        return _setattr(attr_name, value, True)\n+\n+    return \"self.%s = %s\" % (attr_name, value,)\n+\n+\n+def _assign_with_converter(attr_name, value_var, has_on_setattr):\n+    \"\"\"\n+    Unless *attr_name* has an on_setattr hook, use normal assignment after\n+    conversion. Otherwise relegate to _setattr_with_converter.\n+    \"\"\"\n+    if has_on_setattr:\n+        return _setattr_with_converter(attr_name, value_var, True)\n+\n+    return \"self.%s = %s(%s)\" % (\n+        attr_name,\n+        _init_converter_pat % (attr_name,),\n+        value_var,\n+    )\n+\n+\n def _attrs_to_init_script(\n-    attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc\n+    attrs,\n+    frozen,\n+    slots,\n+    post_init,\n+    cache_hash,\n+    base_attr_map,\n+    is_exc,\n+    needs_cached_setattr,\n+    has_global_on_setattr,\n ):\n     \"\"\"\n     Return a script of an initializer for *attrs* and a dict of globals.\n@@ -1712,85 +1873,49 @@ def _attrs_to_init_script(\n     a cached ``object.__setattr__``.\n     \"\"\"\n     lines = []\n-    any_slot_ancestors = any(\n-        _is_slot_attr(a.name, base_attr_map) for a in attrs\n-    )\n+    if needs_cached_setattr:\n+        lines.append(\n+            # Circumvent the __setattr__ descriptor to save one lookup per\n+            # assignment.\n+            # Note _setattr will be used again below if cache_hash is True\n+            \"_setattr = _cached_setattr.__get__(self, self.__class__)\"\n+        )\n+\n     if frozen is True:\n         if slots is True:\n-            lines.append(\n-                # Circumvent the __setattr__ descriptor to save one lookup per\n-                # assignment.\n-                # Note _setattr will be used again below if cache_hash is True\n-                \"_setattr = _cached_setattr.__get__(self, self.__class__)\"\n-            )\n-\n-            def fmt_setter(attr_name, value_var):\n-                return \"_setattr('%(attr_name)s', %(value_var)s)\" % {\n-                    \"attr_name\": attr_name,\n-                    \"value_var\": value_var,\n-                }\n-\n-            def fmt_setter_with_converter(attr_name, value_var):\n-                conv_name = _init_converter_pat.format(attr_name)\n-                return \"_setattr('%(attr_name)s', %(conv)s(%(value_var)s))\" % {\n-                    \"attr_name\": attr_name,\n-                    \"value_var\": value_var,\n-                    \"conv\": conv_name,\n-                }\n-\n+            fmt_setter = _setattr\n+            fmt_setter_with_converter = _setattr_with_converter\n         else:\n             # Dict frozen classes assign directly to __dict__.\n             # But only if the attribute doesn't come from an ancestor slot\n             # class.\n             # Note _inst_dict will be used again below if cache_hash is True\n             lines.append(\"_inst_dict = self.__dict__\")\n-            if any_slot_ancestors:\n-                lines.append(\n-                    # Circumvent the __setattr__ descriptor to save one lookup\n-                    # per assignment.\n-                    \"_setattr = _cached_setattr.__get__(self, self.__class__)\"\n-                )\n \n-            def fmt_setter(attr_name, value_var):\n-                if _is_slot_attr(attr_name, base_attr_map):\n-                    res = \"_setattr('%(attr_name)s', %(value_var)s)\" % {\n-                        \"attr_name\": attr_name,\n-                        \"value_var\": value_var,\n-                    }\n-                else:\n-                    res = \"_inst_dict['%(attr_name)s'] = %(value_var)s\" % {\n-                        \"attr_name\": attr_name,\n-                        \"value_var\": value_var,\n-                    }\n-                return res\n-\n-            def fmt_setter_with_converter(attr_name, value_var):\n-                conv_name = _init_converter_pat.format(attr_name)\n+            def fmt_setter(attr_name, value_var, has_on_setattr):\n                 if _is_slot_attr(attr_name, base_attr_map):\n-                    tmpl = \"_setattr('%(attr_name)s', %(c)s(%(value_var)s))\"\n-                else:\n-                    tmpl = \"_inst_dict['%(attr_name)s'] = %(c)s(%(value_var)s)\"\n-                return tmpl % {\n-                    \"attr_name\": attr_name,\n-                    \"value_var\": value_var,\n-                    \"c\": conv_name,\n-                }\n+                    return _setattr(attr_name, value_var, has_on_setattr)\n+\n+                return \"_inst_dict['%s'] = %s\" % (attr_name, value_var,)\n+\n+            def fmt_setter_with_converter(\n+                attr_name, value_var, has_on_setattr\n+            ):\n+                if has_on_setattr or _is_slot_attr(attr_name, base_attr_map):\n+                    return _setattr_with_converter(\n+                        attr_name, value_var, has_on_setattr\n+                    )\n+\n+                return \"_inst_dict['%s'] = %s(%s)\" % (\n+                    attr_name,\n+                    _init_converter_pat % (attr_name,),\n+                    value_var,\n+                )\n \n     else:\n         # Not frozen.\n-        def fmt_setter(attr_name, value):\n-            return \"self.%(attr_name)s = %(value)s\" % {\n-                \"attr_name\": attr_name,\n-                \"value\": value,\n-            }\n-\n-        def fmt_setter_with_converter(attr_name, value_var):\n-            conv_name = _init_converter_pat.format(attr_name)\n-            return \"self.%(attr_name)s = %(conv)s(%(value_var)s)\" % {\n-                \"attr_name\": attr_name,\n-                \"value_var\": value_var,\n-                \"conv\": conv_name,\n-            }\n+        fmt_setter = _assign\n+        fmt_setter_with_converter = _assign_with_converter\n \n     args = []\n     kw_only_args = []\n@@ -1804,13 +1929,19 @@ def fmt_setter_with_converter(attr_name, value_var):\n     for a in attrs:\n         if a.validator:\n             attrs_to_validate.append(a)\n+\n         attr_name = a.name\n+        has_on_setattr = a.on_setattr is not None or (\n+            a.on_setattr is not setters.NO_OP and has_global_on_setattr\n+        )\n         arg_name = a.name.lstrip(\"_\")\n+\n         has_factory = isinstance(a.default, Factory)\n         if has_factory and a.default.takes_self:\n             maybe_self = \"self\"\n         else:\n             maybe_self = \"\"\n+\n         if a.init is False:\n             if has_factory:\n                 init_factory_name = _init_factory_pat.format(a.name)\n@@ -1818,16 +1949,18 @@ def fmt_setter_with_converter(attr_name, value_var):\n                     lines.append(\n                         fmt_setter_with_converter(\n                             attr_name,\n-                            init_factory_name + \"({0})\".format(maybe_self),\n+                            init_factory_name + \"(%s)\" % (maybe_self,),\n+                            has_on_setattr,\n                         )\n                     )\n-                    conv_name = _init_converter_pat.format(a.name)\n+                    conv_name = _init_converter_pat % (a.name,)\n                     names_for_globals[conv_name] = a.converter\n                 else:\n                     lines.append(\n                         fmt_setter(\n                             attr_name,\n-                            init_factory_name + \"({0})\".format(maybe_self),\n+                            init_factory_name + \"(%s)\" % (maybe_self,),\n+                            has_on_setattr,\n                         )\n                     )\n                 names_for_globals[init_factory_name] = a.default.factory\n@@ -1836,70 +1969,78 @@ def fmt_setter_with_converter(attr_name, value_var):\n                     lines.append(\n                         fmt_setter_with_converter(\n                             attr_name,\n-                            \"attr_dict['{attr_name}'].default\".format(\n-                                attr_name=attr_name\n-                            ),\n+                            \"attr_dict['%s'].default\" % (attr_name,),\n+                            has_on_setattr,\n                         )\n                     )\n-                    conv_name = _init_converter_pat.format(a.name)\n+                    conv_name = _init_converter_pat % (a.name,)\n                     names_for_globals[conv_name] = a.converter\n                 else:\n                     lines.append(\n                         fmt_setter(\n                             attr_name,\n-                            \"attr_dict['{attr_name}'].default\".format(\n-                                attr_name=attr_name\n-                            ),\n+                            \"attr_dict['%s'].default\" % (attr_name,),\n+                            has_on_setattr,\n                         )\n                     )\n         elif a.default is not NOTHING and not has_factory:\n-            arg = \"{arg_name}=attr_dict['{attr_name}'].default\".format(\n-                arg_name=arg_name, attr_name=attr_name\n-            )\n+            arg = \"%s=attr_dict['%s'].default\" % (arg_name, attr_name,)\n             if a.kw_only:\n                 kw_only_args.append(arg)\n             else:\n                 args.append(arg)\n+\n             if a.converter is not None:\n-                lines.append(fmt_setter_with_converter(attr_name, arg_name))\n+                lines.append(\n+                    fmt_setter_with_converter(\n+                        attr_name, arg_name, has_on_setattr,\n+                    )\n+                )\n                 names_for_globals[\n-                    _init_converter_pat.format(a.name)\n+                    _init_converter_pat % (a.name,)\n                 ] = a.converter\n             else:\n-                lines.append(fmt_setter(attr_name, arg_name))\n+                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n+\n         elif has_factory:\n-            arg = \"{arg_name}=NOTHING\".format(arg_name=arg_name)\n+            arg = \"%s=NOTHING\" % (arg_name,)\n             if a.kw_only:\n                 kw_only_args.append(arg)\n             else:\n                 args.append(arg)\n-            lines.append(\n-                \"if {arg_name} is not NOTHING:\".format(arg_name=arg_name)\n-            )\n+            lines.append(\"if %s is not NOTHING:\" % (arg_name,))\n+\n             init_factory_name = _init_factory_pat.format(a.name)\n             if a.converter is not None:\n                 lines.append(\n-                    \"    \" + fmt_setter_with_converter(attr_name, arg_name)\n+                    \"    \"\n+                    + fmt_setter_with_converter(\n+                        attr_name, arg_name, has_on_setattr\n+                    )\n                 )\n                 lines.append(\"else:\")\n                 lines.append(\n                     \"    \"\n                     + fmt_setter_with_converter(\n                         attr_name,\n-                        init_factory_name + \"({0})\".format(maybe_self),\n+                        init_factory_name + \"(\" + maybe_self + \")\",\n+                        has_on_setattr,\n                     )\n                 )\n                 names_for_globals[\n-                    _init_converter_pat.format(a.name)\n+                    _init_converter_pat % (a.name,)\n                 ] = a.converter\n             else:\n-                lines.append(\"    \" + fmt_setter(attr_name, arg_name))\n+                lines.append(\n+                    \"    \" + fmt_setter(attr_name, arg_name, has_on_setattr)\n+                )\n                 lines.append(\"else:\")\n                 lines.append(\n                     \"    \"\n                     + fmt_setter(\n                         attr_name,\n-                        init_factory_name + \"({0})\".format(maybe_self),\n+                        init_factory_name + \"(\" + maybe_self + \")\",\n+                        has_on_setattr,\n                     )\n                 )\n             names_for_globals[init_factory_name] = a.default.factory\n@@ -1908,13 +2049,18 @@ def fmt_setter_with_converter(attr_name, value_var):\n                 kw_only_args.append(arg_name)\n             else:\n                 args.append(arg_name)\n+\n             if a.converter is not None:\n-                lines.append(fmt_setter_with_converter(attr_name, arg_name))\n+                lines.append(\n+                    fmt_setter_with_converter(\n+                        attr_name, arg_name, has_on_setattr\n+                    )\n+                )\n                 names_for_globals[\n-                    _init_converter_pat.format(a.name)\n+                    _init_converter_pat % (a.name,)\n                 ] = a.converter\n             else:\n-                lines.append(fmt_setter(attr_name, arg_name))\n+                lines.append(fmt_setter(attr_name, arg_name, has_on_setattr))\n \n         if a.init is True and a.converter is None and a.type is not None:\n             annotations[arg_name] = a.type\n@@ -1923,13 +2069,14 @@ def fmt_setter_with_converter(attr_name, value_var):\n         names_for_globals[\"_config\"] = _config\n         lines.append(\"if _config._run_validators is True:\")\n         for a in attrs_to_validate:\n-            val_name = \"__attr_validator_{}\".format(a.name)\n-            attr_name = \"__attr_{}\".format(a.name)\n+            val_name = \"__attr_validator_\" + a.name\n+            attr_name = \"__attr_\" + a.name\n             lines.append(\n-                \"    {}(self, {}, self.{})\".format(val_name, attr_name, a.name)\n+                \"    %s(self, %s, self.%s)\" % (val_name, attr_name, a.name)\n             )\n             names_for_globals[val_name] = a.validator\n             names_for_globals[attr_name] = a\n+\n     if post_init:\n         lines.append(\"self.__attrs_post_init__()\")\n \n@@ -1992,6 +2139,7 @@ class Attribute(object):\n     which is only syntactic sugar for ``default=Factory(...)``.\n \n     .. versionadded:: 20.1.0 *inherited*\n+    .. versionadded:: 20.1.0 *on_setattr*\n \n     For the full version history of the fields, see `attr.ib`.\n     \"\"\"\n@@ -2010,6 +2158,7 @@ class Attribute(object):\n         \"converter\",\n         \"kw_only\",\n         \"inherited\",\n+        \"on_setattr\",\n     )\n \n     def __init__(\n@@ -2028,6 +2177,7 @@ def __init__(\n         kw_only=False,\n         eq=None,\n         order=None,\n+        on_setattr=None,\n     ):\n         eq, order = _determine_eq_order(cmp, eq, order, True)\n \n@@ -2056,6 +2206,7 @@ def __init__(\n         bound_setattr(\"type\", type)\n         bound_setattr(\"kw_only\", kw_only)\n         bound_setattr(\"inherited\", inherited)\n+        bound_setattr(\"on_setattr\", on_setattr)\n \n     def __setattr__(self, name, value):\n         raise FrozenInstanceError()\n@@ -2185,6 +2336,7 @@ class _CountingAttr(object):\n         \"converter\",\n         \"type\",\n         \"kw_only\",\n+        \"on_setattr\",\n     )\n     __attrs_attrs__ = tuple(\n         Attribute(\n@@ -2199,6 +2351,7 @@ class _CountingAttr(object):\n             eq=True,\n             order=False,\n             inherited=False,\n+            on_setattr=None,\n         )\n         for name in (\n             \"counter\",\n@@ -2208,6 +2361,7 @@ class _CountingAttr(object):\n             \"order\",\n             \"hash\",\n             \"init\",\n+            \"on_setattr\",\n         )\n     ) + (\n         Attribute(\n@@ -2222,6 +2376,7 @@ class _CountingAttr(object):\n             eq=True,\n             order=False,\n             inherited=False,\n+            on_setattr=None,\n         ),\n     )\n     cls_counter = 0\n@@ -2240,19 +2395,13 @@ def __init__(\n         kw_only,\n         eq,\n         order,\n+        on_setattr,\n     ):\n         _CountingAttr.cls_counter += 1\n         self.counter = _CountingAttr.cls_counter\n         self._default = default\n-        # If validator is a list/tuple, wrap it using helper validator.\n-        if validator and isinstance(validator, (list, tuple)):\n-            self._validator = and_(*validator)\n-        else:\n-            self._validator = validator\n-        if converter and isinstance(converter, (list, tuple)):\n-            self.converter = chain(*converter)\n-        else:\n-            self.converter = converter\n+        self._validator = validator\n+        self.converter = converter\n         self.repr = repr\n         self.eq = eq\n         self.order = order\n@@ -2261,6 +2410,7 @@ def __init__(\n         self.metadata = metadata\n         self.type = type\n         self.kw_only = kw_only\n+        self.on_setattr = on_setattr\n \n     def validator(self, meth):\n         \"\"\"\ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\n--- a/src/attr/exceptions.py\n+++ b/src/attr/exceptions.py\n@@ -1,20 +1,37 @@\n from __future__ import absolute_import, division, print_function\n \n \n-class FrozenInstanceError(AttributeError):\n+class FrozenError(AttributeError):\n     \"\"\"\n-    A frozen/immutable instance has been attempted to be modified.\n+    A frozen/immutable instance or attribute haave been attempted to be\n+    modified.\n \n     It mirrors the behavior of ``namedtuples`` by using the same error message\n     and subclassing `AttributeError`.\n \n-    .. versionadded:: 16.1.0\n+    .. versionadded:: 20.1.0\n     \"\"\"\n \n     msg = \"can't set attribute\"\n     args = [msg]\n \n \n+class FrozenInstanceError(FrozenError):\n+    \"\"\"\n+    A frozen instance has been attempted to be modified.\n+\n+    .. versionadded:: 16.1.0\n+    \"\"\"\n+\n+\n+class FrozenAttributeError(FrozenError):\n+    \"\"\"\n+    A frozen attribute has been attempted to be modified.\n+\n+    .. versionadded:: 20.1.0\n+    \"\"\"\n+\n+\n class AttrsAttributeNotFoundError(ValueError):\n     \"\"\"\n     An ``attrs`` function couldn't find an attribute that the user asked for.\ndiff --git a/src/attr/setters.py b/src/attr/setters.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attr/setters.py\n@@ -0,0 +1,77 @@\n+\"\"\"\n+Commonly used hooks for on_setattr.\n+\"\"\"\n+\n+from __future__ import absolute_import, division, print_function\n+\n+from . import _config\n+from .exceptions import FrozenAttributeError\n+\n+\n+def pipe(*setters):\n+    \"\"\"\n+    Run all *setters* and return the return value of the last one.\n+\n+    .. versionadded:: 20.1.0\n+    \"\"\"\n+\n+    def wrapped_pipe(instance, attrib, new_value):\n+        rv = new_value\n+\n+        for setter in setters:\n+            rv = setter(instance, attrib, rv)\n+\n+        return rv\n+\n+    return wrapped_pipe\n+\n+\n+def frozen(_, __, ___):\n+    \"\"\"\n+    Prevent an attribute to be modified.\n+\n+    .. versionadded:: 20.1.0\n+    \"\"\"\n+    raise FrozenAttributeError()\n+\n+\n+def validate(instance, attrib, new_value):\n+    \"\"\"\n+    Run *attrib*'s validator on *new_value* if it has one.\n+\n+    .. versionadded:: 20.1.0\n+    \"\"\"\n+    if _config._run_validators is False:\n+        return new_value\n+\n+    v = attrib.validator\n+    if not v:\n+        return new_value\n+\n+    v(instance, attrib, new_value)\n+\n+    return new_value\n+\n+\n+def convert(instance, attrib, new_value):\n+    \"\"\"\n+    Run *attrib*'s converter -- if it has one --  on *new_value* and return the\n+    result.\n+\n+    .. versionadded:: 20.1.0\n+    \"\"\"\n+    c = attrib.converter\n+    if c:\n+        return c(new_value)\n+\n+    return new_value\n+\n+\n+NO_OP = object()\n+\"\"\"\n+Sentinel for disabling class-wide *on_setattr* hooks for certain attributes.\n+\n+Does not work in `pipe` or within lists.\n+\n+.. versionadded:: 20.1.0\n+\"\"\"\ndiff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -67,7 +67,7 @@ def instance_of(type):\n     return _InstanceOfValidator(type)\n \n \n-@attrs(repr=False, frozen=True)\n+@attrs(repr=False, frozen=True, slots=True)\n class _MatchesReValidator(object):\n     regex = attrib()\n     flags = attrib()\n",
        "test_patch": "diff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -68,6 +68,7 @@ def _add_init(cls, frozen):\n         cache_hash=False,\n         base_attr_map={},\n         is_exc=False,\n+        has_global_on_setattr=False,\n     )\n     return cls\n \ndiff --git a/tests/test_functional.py b/tests/test_functional.py\n--- a/tests/test_functional.py\n+++ b/tests/test_functional.py\n@@ -16,9 +16,11 @@\n \n import attr\n \n+from attr import setters\n from attr._compat import PY2, TYPE\n from attr._make import NOTHING, Attribute\n-from attr.exceptions import FrozenInstanceError\n+from attr.exceptions import FrozenAttributeError, FrozenInstanceError\n+from attr.validators import instance_of, matches_re\n \n from .strategies import optional_bool\n \n@@ -681,3 +683,183 @@ class C(object):\n             \"2021-06-01.  Please use `eq` and `order` instead.\"\n             == w.message.args[0]\n         )\n+\n+\n+class TestSetAttr(object):\n+    def test_change(self):\n+        \"\"\"\n+        The return value of a hook overwrites the value. But they are not run\n+        on __init__.\n+        \"\"\"\n+\n+        def hook(*a, **kw):\n+            return \"hooked!\"\n+\n+        @attr.s\n+        class Hooked(object):\n+            x = attr.ib(on_setattr=hook)\n+            y = attr.ib()\n+\n+        h = Hooked(\"x\", \"y\")\n+\n+        assert \"x\" == h.x\n+        assert \"y\" == h.y\n+\n+        h.x = \"xxx\"\n+        h.y = \"yyy\"\n+\n+        assert \"yyy\" == h.y\n+        assert \"hooked!\" == h.x\n+\n+    def test_frozen_attribute(self):\n+        \"\"\"\n+        Frozen attributes raise FrozenAttributeError, others are not affected.\n+        \"\"\"\n+\n+        @attr.s\n+        class PartiallyFrozen(object):\n+            x = attr.ib(on_setattr=setters.frozen)\n+            y = attr.ib()\n+\n+        pf = PartiallyFrozen(\"x\", \"y\")\n+\n+        pf.y = \"yyy\"\n+\n+        assert \"yyy\" == pf.y\n+\n+        with pytest.raises(FrozenAttributeError):\n+            pf.x = \"xxx\"\n+\n+        assert \"x\" == pf.x\n+\n+    @pytest.mark.parametrize(\n+        \"on_setattr\",\n+        [setters.validate, [setters.validate], setters.pipe(setters.validate)],\n+    )\n+    def test_validator(self, on_setattr):\n+        \"\"\"\n+        Validators are run and they don't alter the value.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=on_setattr)\n+        class ValidatedAttribute(object):\n+            x = attr.ib()\n+            y = attr.ib(validator=[instance_of(str), matches_re(\"foo.*qux\")])\n+\n+        va = ValidatedAttribute(42, \"foobarqux\")\n+\n+        with pytest.raises(TypeError) as ei:\n+            va.y = 42\n+\n+        assert \"foobarqux\" == va.y\n+\n+        assert ei.value.args[0].startswith(\"'y' must be <\")\n+\n+        with pytest.raises(ValueError) as ei:\n+            va.y = \"quxbarfoo\"\n+\n+        assert ei.value.args[0].startswith(\"'y' must match regex '\")\n+\n+        assert \"foobarqux\" == va.y\n+\n+        va.y = \"foobazqux\"\n+\n+        assert \"foobazqux\" == va.y\n+\n+    def test_pipe(self):\n+        \"\"\"\n+        Multiple hooks are possible, in that case the last return value is\n+        used. They can be supplied using the pipe functions or by passing a\n+        list to on_setattr.\n+        \"\"\"\n+\n+        s = [setters.convert, lambda _, __, nv: nv + 1]\n+\n+        @attr.s\n+        class Piped(object):\n+            x1 = attr.ib(converter=int, on_setattr=setters.pipe(*s))\n+            x2 = attr.ib(converter=int, on_setattr=s)\n+\n+        p = Piped(\"41\", \"22\")\n+\n+        assert 41 == p.x1\n+        assert 22 == p.x2\n+\n+        p.x1 = \"41\"\n+        p.x2 = \"22\"\n+\n+        assert 42 == p.x1\n+        assert 23 == p.x2\n+\n+    def test_make_class(self):\n+        \"\"\"\n+        on_setattr of make_class gets forwarded.\n+        \"\"\"\n+        C = attr.make_class(\"C\", {\"x\": attr.ib()}, on_setattr=setters.frozen)\n+\n+        c = C(1)\n+\n+        with pytest.raises(FrozenAttributeError):\n+            c.x = 2\n+\n+    def test_no_validator_no_converter(self):\n+        \"\"\"\n+        validate and convert tolerate missing validators and converters.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=[setters.convert, setters.validate])\n+        class C(object):\n+            x = attr.ib()\n+\n+        c = C(1)\n+\n+        c.x = 2\n+\n+    def test_validate_respects_run_validators_config(self):\n+        \"\"\"\n+        If run validators is off, validate doesn't run them.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=setters.validate)\n+        class C(object):\n+            x = attr.ib(validator=attr.validators.instance_of(int))\n+\n+        c = C(1)\n+\n+        attr.set_run_validators(False)\n+\n+        c.x = \"1\"\n+\n+        assert \"1\" == c.x\n+\n+        attr.set_run_validators(True)\n+\n+        with pytest.raises(TypeError) as ei:\n+            c.x = \"1\"\n+\n+        assert ei.value.args[0].startswith(\"'x' must be <\")\n+\n+    def test_frozen_on_setattr_class_is_caught(self):\n+        \"\"\"\n+        @attr.s(on_setattr=X, frozen=True) raises an ValueError.\n+        \"\"\"\n+        with pytest.raises(ValueError) as ei:\n+\n+            @attr.s(frozen=True, on_setattr=setters.validate)\n+            class C(object):\n+                x = attr.ib()\n+\n+        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\n+\n+    def test_frozen_on_setattr_attribute_is_caught(self):\n+        \"\"\"\n+        attr.ib(on_setattr=X) on a frozen class raises an ValueError.\n+        \"\"\"\n+\n+        with pytest.raises(ValueError) as ei:\n+\n+            @attr.s(frozen=True)\n+            class C(object):\n+                x = attr.ib(on_setattr=setters.validate)\n+\n+        assert \"Frozen classes can't use on_setattr.\" == ei.value.args[0]\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -222,7 +222,7 @@ class C(object):\n             \"(name='y', default=NOTHING, validator=None, repr=True, \"\n             \"eq=True, order=True, hash=None, init=True, \"\n             \"metadata=mappingproxy({}), type=None, converter=None, \"\n-            \"kw_only=False, inherited=False)\",\n+            \"kw_only=False, inherited=False, on_setattr=None)\",\n         ) == e.value.args\n \n     def test_kw_only(self):\n@@ -1425,7 +1425,18 @@ class C(object):\n             pass\n \n         b = _ClassBuilder(\n-            C, None, True, True, False, False, False, False, False, False, True\n+            C,\n+            None,\n+            True,\n+            True,\n+            False,\n+            False,\n+            False,\n+            False,\n+            False,\n+            False,\n+            True,\n+            None,\n         )\n \n         assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n@@ -1439,7 +1450,18 @@ class C(object):\n             x = attr.ib()\n \n         b = _ClassBuilder(\n-            C, None, True, True, False, False, False, False, False, False, True\n+            C,\n+            None,\n+            True,\n+            True,\n+            False,\n+            False,\n+            False,\n+            False,\n+            False,\n+            False,\n+            True,\n+            None,\n         )\n \n         cls = (\n@@ -1516,6 +1538,7 @@ class C(object):\n             kw_only=False,\n             cache_hash=False,\n             collect_by_mro=True,\n+            on_setattr=None,\n         )\n         b._cls = {}  # no __module__; no __qualname__\n \ndiff --git a/tests/typing_example.py b/tests/typing_example.py\n--- a/tests/typing_example.py\n+++ b/tests/typing_example.py\n@@ -185,6 +185,20 @@ class OrderFlags:\n     b = attr.ib(eq=True, order=True)\n \n \n+# on_setattr hooks\n+@attr.s(on_setattr=attr.setters.validate)\n+class ValidatedSetter:\n+    a = attr.ib()\n+    b = attr.ib(on_setattr=attr.setters.NO_OP)\n+    c = attr.ib(on_setattr=attr.setters.frozen)\n+    d = attr.ib(on_setattr=[attr.setters.convert, attr.setters.validate])\n+    d = attr.ib(\n+        on_setattr=attr.setters.pipe(\n+            attr.setters.convert, attr.setters.validate\n+        )\n+    )\n+\n+\n # Auto-detect\n # XXX: needs support in mypy\n # @attr.s(auto_detect=True)\n",
        "problem_statement": "[RFC] __setattr__ hooks\nThere's two things that people keep asking for:\r\n\r\n1. validation on setting attributes\r\n2. freezing single attributes\r\n\r\nThose two features have something in common: they require `attrs` to write a `__setattr__` method.\r\n\r\nI actually had 1 done when I implemented validators but I took it out again, because I didn't want to tamper with `__setattr__` too. But it totally makes sense to expect that validators run there too.\r\n\r\nNow that argument has gone away thanks to frozen classes and `attrs` is in the `__setattr__` business. So it feels like the right thing to do, to implement it and make it default for _Operation `import attrs`_ (I hope this is legit the last part of the puzzle).\r\n\r\nTo allow for 2 too, I would suggest to add a hook called `on_setattr` (better names welcome) that takes a callable that is called with the instance, the attribute definition, and the new value.\r\n\r\nTo solve 2, the implementation would look like\r\n\r\n```python\r\ndef frozen(_, __, ___):\r\n    raise FrozenInstanceError\r\n```\r\n\r\n***\r\n\r\nOpen questions:\r\n\r\n- what to do about `on_setattr` attributes in a frozen class (incl inheritance)\r\n- what about converters? Maybe it should take a list/`and` like validator/converter do? They would need to work as a chain, returning values for the next one.\n",
        "hints_text": "I agree not doing validation on attribute set but doing them in `__init__` is probably not reasonable and should be changed.\r\n\r\nAs for the implementation, it'd be ideal if we generated a smart `__setattr__` like we generate a smart `__init__`. If I were doing it I'd write a function basically containing a chain of `if name == {attr0.name} elif name == {attr1.name}` and compile it; it's gnarly but probably the fastest approach (the things we do for speed :).\r\n\r\nNot really sure what you mean with the hook proposal. Don't we have basically two hook frameworks already (validators and converters)? Both of them seem inadequate for frozen attributes though, because they run on `__init__` too. Does it make sense to flesh this out more thoroughly?\nI mean, we could flesh out validators so they would know if they are being run in the `__init__` context or the `__setattr__` context. Then you could implement frozen attributes using a validator.\r\n\r\nIf I was designing this system right now, I'd probably want to use a middleware pattern (kind of like aiohttp's middleware, where it's a pipeline of functions).\n(1) When I first started using Attrs I found the lack of a validate-on-set option a bit strange but over time have become used to the validate-after-init approach ultimately still stopping execution when validators fail. So I, personally, dont have a strong preference.\r\n\r\n(2) This is a feature I would LOVE to have. To date I've been using my own kludge to get this more or less working but I'd much rather have this implemeted professionally.\r\n\r\nWould a class with all attributes frozen singly be functionally equivalent to a frozen class? Presumably not because you can add attributes to a nonfrozen class? _What I would really like to have is the ability to have a class functionally frozen with only attributes marked as not-frozen remaining mutable._\r\n\r\n\r\nPS: Thank you for this amazing package. Using Attrs has resulted in a step change in the quality and productivty of my Python coding.\n@Tinche the question really is how to expose the functionality without painting ourselves into a corner. Right now I can think of three reasons the user might want to tinker with `__setattr__`:\r\n\r\n- validation\r\n- conversion\r\n- freezing\r\n\r\nI guess that could be achieved using `frozen: bool, validate_on_set: bool, convert_on_set: bool` with some thing mutually excluding itself. I suspect tho that it might paint us into a corner (or force us adding dozens more of such arguments) so my suggestion is to approach from `on_setattr=pipe(convert, validate)` (that\u2019s how they run in `__init__` too) and allow people to do whatever they want on `on_setattr`. Hopefully coming up with creative ways we didn\u2019t think of. Freezing would become `on_setattr=explode`.\r\n\r\n***\r\n\r\nAs for the implementation itself I suspect there\u2019s a cut off point where a dict is faster than a long if-then-else but that remains to be benchmarked.\nAh #622 is an example. ",
        "created_at": "2020-07-10T05:48:56Z",
        "version": "19.3"
    }
}