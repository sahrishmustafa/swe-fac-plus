{
    "task_id": "python-attrs__attrs-1187",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1187_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1187,
        "instance_id": "python-attrs__attrs-1187",
        "issue_numbers": [
            "1102"
        ],
        "base_commit": "46a03dcef6d2698aa5934a1ee00d9523564dcd8c",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -3,6 +3,7 @@\n import contextlib\n import copy\n import enum\n+import inspect\n import linecache\n import sys\n import types\n@@ -624,6 +625,7 @@ class _ClassBuilder:\n         \"_delete_attribs\",\n         \"_frozen\",\n         \"_has_pre_init\",\n+        \"_pre_init_has_args\",\n         \"_has_post_init\",\n         \"_is_exc\",\n         \"_on_setattr\",\n@@ -670,6 +672,13 @@ def __init__(\n         self._weakref_slot = weakref_slot\n         self._cache_hash = cache_hash\n         self._has_pre_init = bool(getattr(cls, \"__attrs_pre_init__\", False))\n+        self._pre_init_has_args = False\n+        if self._has_pre_init:\n+            # Check if the pre init method has more arguments than just `self`\n+            # We want to pass arguments if pre init expects arguments\n+            pre_init_func = cls.__attrs_pre_init__\n+            pre_init_signature = inspect.signature(pre_init_func)\n+            self._pre_init_has_args = len(pre_init_signature.parameters) > 1\n         self._has_post_init = bool(getattr(cls, \"__attrs_post_init__\", False))\n         self._delete_attribs = not bool(these)\n         self._is_exc = is_exc\n@@ -974,6 +983,7 @@ def add_init(self):\n                 self._cls,\n                 self._attrs,\n                 self._has_pre_init,\n+                self._pre_init_has_args,\n                 self._has_post_init,\n                 self._frozen,\n                 self._slots,\n@@ -1000,6 +1010,7 @@ def add_attrs_init(self):\n                 self._cls,\n                 self._attrs,\n                 self._has_pre_init,\n+                self._pre_init_has_args,\n                 self._has_post_init,\n                 self._frozen,\n                 self._slots,\n@@ -1984,6 +1995,7 @@ def _make_init(\n     cls,\n     attrs,\n     pre_init,\n+    pre_init_has_args,\n     post_init,\n     frozen,\n     slots,\n@@ -2027,6 +2039,7 @@ def _make_init(\n         frozen,\n         slots,\n         pre_init,\n+        pre_init_has_args,\n         post_init,\n         cache_hash,\n         base_attr_map,\n@@ -2107,6 +2120,7 @@ def _attrs_to_init_script(\n     frozen,\n     slots,\n     pre_init,\n+    pre_init_has_args,\n     post_init,\n     cache_hash,\n     base_attr_map,\n@@ -2361,11 +2375,23 @@ def fmt_setter_with_converter(\n         lines.append(f\"BaseException.__init__(self, {vals})\")\n \n     args = \", \".join(args)\n+    pre_init_args = args\n     if kw_only_args:\n         args += \"%s*, %s\" % (\n             \", \" if args else \"\",  # leading comma\n             \", \".join(kw_only_args),  # kw_only args\n         )\n+        pre_init_kw_only_args = \", \".join(\n+            [\"%s=%s\" % (kw_arg, kw_arg) for kw_arg in kw_only_args]\n+        )\n+        pre_init_args += (\n+            \", \" if pre_init_args else \"\"\n+        )  # handle only kwargs and no regular args\n+        pre_init_args += pre_init_kw_only_args\n+\n+    if pre_init and pre_init_has_args:\n+        # If pre init method has arguments, pass same arguments as `__init__`\n+        lines[0] = \"self.__attrs_pre_init__(%s)\" % pre_init_args\n \n     return (\n         \"def %s(self, %s):\\n    %s\\n\"\n",
        "test_patch": "diff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -6,6 +6,7 @@\n \n \n import copy\n+import inspect\n import pickle\n \n import pytest\n@@ -84,10 +85,15 @@ def _add_init(cls, frozen):\n     This function used to be part of _make.  It wasn't used anymore however\n     the tests for it are still useful to test the behavior of _make_init.\n     \"\"\"\n+    has_pre_init = bool(getattr(cls, \"__attrs_pre_init__\", False))\n+\n     cls.__init__ = _make_init(\n         cls,\n         cls.__attrs_attrs__,\n-        getattr(cls, \"__attrs_pre_init__\", False),\n+        has_pre_init,\n+        len(inspect.signature(cls.__attrs_pre_init__).parameters) > 1\n+        if has_pre_init\n+        else False,\n         getattr(cls, \"__attrs_post_init__\", False),\n         frozen,\n         _is_slot_cls(cls),\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -613,21 +613,89 @@ class D:\n         assert C.D.__qualname__ == C.__qualname__ + \".D\"\n \n     @pytest.mark.parametrize(\"with_validation\", [True, False])\n-    def test_pre_init(self, with_validation, monkeypatch):\n+    def test_pre_init(self, with_validation):\n         \"\"\"\n         Verify that __attrs_pre_init__ gets called if defined.\n         \"\"\"\n-        monkeypatch.setattr(_config, \"_run_validators\", with_validation)\n \n         @attr.s\n         class C:\n             def __attrs_pre_init__(self2):\n                 self2.z = 30\n \n-        c = C()\n+        try:\n+            attr.validators.set_disabled(not with_validation)\n+            c = C()\n+        finally:\n+            attr.validators.set_disabled(False)\n \n         assert 30 == getattr(c, \"z\", None)\n \n+    @pytest.mark.parametrize(\"with_validation\", [True, False])\n+    def test_pre_init_args(self, with_validation):\n+        \"\"\"\n+        Verify that __attrs_pre_init__ gets called with extra args if defined.\n+        \"\"\"\n+\n+        @attr.s\n+        class C:\n+            x = attr.ib()\n+\n+            def __attrs_pre_init__(self2, x):\n+                self2.z = x + 1\n+\n+        try:\n+            attr.validators.set_disabled(not with_validation)\n+            c = C(x=10)\n+        finally:\n+            attr.validators.set_disabled(False)\n+\n+        assert 11 == getattr(c, \"z\", None)\n+\n+    @pytest.mark.parametrize(\"with_validation\", [True, False])\n+    def test_pre_init_kwargs(self, with_validation):\n+        \"\"\"\n+        Verify that __attrs_pre_init__ gets called with extra args and kwargs if defined.\n+        \"\"\"\n+\n+        @attr.s\n+        class C:\n+            x = attr.ib()\n+            y = attr.field(kw_only=True)\n+\n+            def __attrs_pre_init__(self2, x, y):\n+                self2.z = x + y + 1\n+\n+        try:\n+            attr.validators.set_disabled(not with_validation)\n+            c = C(10, y=11)\n+        finally:\n+            attr.validators.set_disabled(False)\n+\n+        assert 22 == getattr(c, \"z\", None)\n+\n+    @pytest.mark.parametrize(\"with_validation\", [True, False])\n+    def test_pre_init_kwargs_only(self, with_validation):\n+        \"\"\"\n+        Verify that __attrs_pre_init__ gets called with extra kwargs only if\n+        defined.\n+        \"\"\"\n+\n+        @attr.s\n+        class C:\n+            y = attr.field(kw_only=True)\n+\n+            def __attrs_pre_init__(self2, y):\n+                self2.z = y + 1\n+\n+        try:\n+            attr.validators.set_disabled(not with_validation)\n+            c = C(y=11)\n+        finally:\n+            attr.validators.set_disabled(False)\n+\n+        assert 12 == getattr(c, \"z\", None)\n+\n     @pytest.mark.parametrize(\"with_validation\", [True, False])\n     def test_post_init(self, with_validation, monkeypatch):\n         \"\"\"\n",
        "problem_statement": "Pass all args to `__attrs_pre_init__()`\nI am subclassing a class that I have no control over, which is written in standard Python.  The base class A has a number of arguments that I want to set.  Infact there are 3 classes.  C (attrs class) is a sublcass of B (attrs class) which is a subclass of A (non-attrs class).\r\n\r\nWhen I instantiate C, I want to pass arguments to B and A.\r\n\r\nI implemented class based factory functions (vai `@classmethod`), which works well for a single level inheritance, but I'm not sure how to use the classmethod of B from the classmethod of A.  I figured I'm stuck with duplicating of the B initialisation within the C classmethod and the instantiating class C by passing all the necessary arguments.\r\n\r\nAll this involves defining a custom `__init__()` method (https://www.attrs.org/en/stable/init.html#custom-init), but it seems to me that could be avoided by using `__attrs_pre_init__()`, but unfortunately it seems no arguments are passed to that (i.e. no `*args` or `**kwargs`).\r\n\r\nIs there a reason why arguments are not passed to `attrs_pre_init__()`, and only passed to `__init__()`?\r\n\r\nI think it makes sense to pass all arguments to `__attrs_pre_init__()` so the user can have the flexibility to do what is required (or nothing at all).\r\n\r\n```python\r\n\r\n    def __attrs_pre_init__(self, *args, **kwargs):\r\n        ...\r\n        super().__init__(*args, **kwargs)\r\n        ...\r\n```\r\n\r\nI can see why it is less relevant for `__attrs_post_init__()`, but I'm sure someone can think of a use-case where the arguments could be useful (e.g. for arguments that aren't stored as instanace attributes).\n",
        "hints_text": "Yeah in hindsight that seems an odd omission. I think the expectation was that you're gonna use a custom init for anything more complicated.\nI'm interested in implementing this feature but I'm not sure where to start. I see where the call to `__atrs_pre_init__` is being added in [`src/attr/_make.py`](https://github.com/python-attrs/attrs/blob/06b1bb414121bd21dd0781016a035ed1388aa136/src/attr/_make.py#L2105). Would I change this call to include the arguments being passed into the `__init__` method being generated?\nWithout looking closer, I suspect you\u2019ll have to inspect the `__attrs_pre_init__` method and call with with or without based on its arguments. For all I care: do nothing if it\u2019s only one argument (presumably self), pass them if it has more than one.",
        "created_at": "2023-09-21T18:22:53Z",
        "version": "23.1"
    }
}