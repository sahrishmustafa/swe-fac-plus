{
    "task_id": "python-attrs__attrs-1080",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1080_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1080,
        "instance_id": "python-attrs__attrs-1080",
        "issue_numbers": [
            "1077"
        ],
        "base_commit": "0de967d6ece1606234ac56d5fe58a800d1b0434f",
        "patch": "diff --git a/src/attr/_cmp.py b/src/attr/_cmp.py\n--- a/src/attr/_cmp.py\n+++ b/src/attr/_cmp.py\n@@ -20,22 +20,22 @@ def cmp_using(\n     class_name=\"Comparable\",\n ):\n     \"\"\"\n-    Create a class that can be passed into `attr.ib`'s ``eq``, ``order``, and\n-    ``cmp`` arguments to customize field comparison.\n-\n-    The resulting class will have a full set of ordering methods if\n-    at least one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n-\n-    :param Optional[callable] eq: `callable` used to evaluate equality\n-        of two objects.\n-    :param Optional[callable] lt: `callable` used to evaluate whether\n-        one object is less than another object.\n-    :param Optional[callable] le: `callable` used to evaluate whether\n-        one object is less than or equal to another object.\n-    :param Optional[callable] gt: `callable` used to evaluate whether\n-        one object is greater than another object.\n-    :param Optional[callable] ge: `callable` used to evaluate whether\n-        one object is greater than or equal to another object.\n+    Create a class that can be passed into `attrs.field`'s ``eq``, ``order``,\n+    and ``cmp`` arguments to customize field comparison.\n+\n+    The resulting class will have a full set of ordering methods if at least\n+    one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n+\n+    :param Optional[callable] eq: `callable` used to evaluate equality of two\n+        objects.\n+    :param Optional[callable] lt: `callable` used to evaluate whether one\n+        object is less than another object.\n+    :param Optional[callable] le: `callable` used to evaluate whether one\n+        object is less than or equal to another object.\n+    :param Optional[callable] gt: `callable` used to evaluate whether one\n+        object is greater than another object.\n+    :param Optional[callable] ge: `callable` used to evaluate whether one\n+        object is greater than or equal to another object.\n \n     :param bool require_same_type: When `True`, equality and ordering methods\n         will return `NotImplemented` if objects are not of the same type.\ndiff --git a/src/attr/_funcs.py b/src/attr/_funcs.py\n--- a/src/attr/_funcs.py\n+++ b/src/attr/_funcs.py\n@@ -16,13 +16,13 @@ def asdict(\n     value_serializer=None,\n ):\n     \"\"\"\n-    Return the ``attrs`` attribute values of *inst* as a dict.\n+    Return the *attrs* attribute values of *inst* as a dict.\n \n-    Optionally recurse into other ``attrs``-decorated classes.\n+    Optionally recurse into other *attrs*-decorated classes.\n \n-    :param inst: Instance of an ``attrs``-decorated class.\n+    :param inst: Instance of an *attrs*-decorated class.\n     :param bool recurse: Recurse into classes that are also\n-        ``attrs``-decorated.\n+        *attrs*-decorated.\n     :param callable filter: A callable whose return code determines whether an\n         attribute or element is included (``True``) or dropped (``False``).  Is\n         called with the `attrs.Attribute` as the first argument and the\n@@ -40,7 +40,7 @@ def asdict(\n \n     :rtype: return type of *dict_factory*\n \n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  versionadded:: 16.0.0 *dict_factory*\n@@ -195,13 +195,13 @@ def astuple(\n     retain_collection_types=False,\n ):\n     \"\"\"\n-    Return the ``attrs`` attribute values of *inst* as a tuple.\n+    Return the *attrs* attribute values of *inst* as a tuple.\n \n-    Optionally recurse into other ``attrs``-decorated classes.\n+    Optionally recurse into other *attrs*-decorated classes.\n \n-    :param inst: Instance of an ``attrs``-decorated class.\n+    :param inst: Instance of an *attrs*-decorated class.\n     :param bool recurse: Recurse into classes that are also\n-        ``attrs``-decorated.\n+        *attrs*-decorated.\n     :param callable filter: A callable whose return code determines whether an\n         attribute or element is included (``True``) or dropped (``False``).  Is\n         called with the `attrs.Attribute` as the first argument and the\n@@ -215,7 +215,7 @@ def astuple(\n \n     :rtype: return type of *tuple_factory*\n \n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  versionadded:: 16.2.0\n@@ -289,7 +289,7 @@ def astuple(\n \n def has(cls):\n     \"\"\"\n-    Check whether *cls* is a class with ``attrs`` attributes.\n+    Check whether *cls* is a class with *attrs* attributes.\n \n     :param type cls: Class to introspect.\n     :raise TypeError: If *cls* is not a class.\n@@ -303,14 +303,14 @@ def assoc(inst, **changes):\n     \"\"\"\n     Copy *inst* and apply *changes*.\n \n-    :param inst: Instance of a class with ``attrs`` attributes.\n+    :param inst: Instance of a class with *attrs* attributes.\n     :param changes: Keyword changes in the new copy.\n \n     :return: A copy of inst with *changes* incorporated.\n \n-    :raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn't\n-        be found on *cls*.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.AttrsAttributeNotFoundError: If *attr_name*\n+        couldn't be found on *cls*.\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  deprecated:: 17.1.0\n@@ -341,14 +341,14 @@ def evolve(inst, **changes):\n     \"\"\"\n     Create a new instance, based on *inst* with *changes* applied.\n \n-    :param inst: Instance of a class with ``attrs`` attributes.\n+    :param inst: Instance of a class with *attrs* attributes.\n     :param changes: Keyword changes in the new copy.\n \n     :return: A copy of inst with *changes* incorporated.\n \n     :raise TypeError: If *attr_name* couldn't be found in the class\n         ``__init__``.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     ..  versionadded:: 17.1.0\n@@ -385,10 +385,10 @@ def resolve_types(cls, globalns=None, localns=None, attribs=None):\n     :param Optional[dict] localns: Dictionary containing local variables.\n     :param Optional[list] attribs: List of attribs for the given class.\n         This is necessary when calling from inside a ``field_transformer``\n-        since *cls* is not an ``attrs`` class yet.\n+        since *cls* is not an *attrs* class yet.\n \n     :raise TypeError: If *cls* is not a class.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class and you didn't pass any attribs.\n     :raise NameError: If types cannot be resolved because of missing variables.\n \ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -109,9 +109,12 @@ def attrib(\n     ..  warning::\n \n         Does *not* do anything unless the class is also decorated with\n-        `attr.s`!\n+        `attr.s` / `attrs.define` / et cetera!\n \n-    :param default: A value that is used if an ``attrs``-generated ``__init__``\n+    Please consider using `attrs.field` in new code (``attr.ib`` will *never*\n+    go away, though).\n+\n+    :param default: A value that is used if an *attrs*-generated ``__init__``\n         is used and no value is passed while instantiating or the attribute is\n         excluded using ``init=False``.\n \n@@ -130,7 +133,7 @@ def attrib(\n     :param callable factory: Syntactic sugar for\n         ``default=attr.Factory(factory)``.\n \n-    :param validator: `callable` that is called by ``attrs``-generated\n+    :param validator: `callable` that is called by *attrs*-generated\n         ``__init__`` methods after the instance has been initialized.  They\n         receive the initialized instance, the :func:`~attrs.Attribute`, and the\n         passed value.\n@@ -142,7 +145,7 @@ def attrib(\n         all pass.\n \n         Validators can be globally disabled and re-enabled using\n-        `get_run_validators`.\n+        `attrs.validators.get_disabled` / `attrs.validators.set_disabled`.\n \n         The validator can also be set using decorator notation as shown below.\n \n@@ -184,7 +187,7 @@ def attrib(\n         value.  In that case this attributed is unconditionally initialized\n         with the specified default value or factory.\n     :param callable converter: `callable` that is called by\n-        ``attrs``-generated ``__init__`` methods to convert attribute's value\n+        *attrs*-generated ``__init__`` methods to convert attribute's value\n         to the desired format.  It is given the passed-in value, and the\n         returned value will be used as the new value of the attribute.  The\n         value is converted before being passed to the validator, if any.\n@@ -197,7 +200,7 @@ def attrib(\n         Regardless of the approach used, the type will be stored on\n         ``Attribute.type``.\n \n-        Please note that ``attrs`` doesn't do anything with this metadata by\n+        Please note that *attrs* doesn't do anything with this metadata by\n         itself. You can use it as part of your own code or for\n         `static type checking <types>`.\n     :param kw_only: Make this attribute keyword-only in the generated\n@@ -1211,12 +1214,15 @@ def attrs(\n     A class decorator that adds :term:`dunder methods` according to the\n     specified attributes using `attr.ib` or the *these* argument.\n \n+    Please consider using `attrs.define` / `attrs.frozen` in new code\n+    (``attr.s`` will *never* go away, though).\n+\n     :param these: A dictionary of name to `attr.ib` mappings.  This is\n         useful to avoid the definition of your attributes within the class body\n         because you can't (e.g. if you want to add ``__repr__`` methods to\n         Django models) or don't want to.\n \n-        If *these* is not ``None``, ``attrs`` will *not* search the class body\n+        If *these* is not ``None``, *attrs* will *not* search the class body\n         for attributes and will *not* remove any attributes from it.\n \n         The order is deduced from the order of the attributes inside *these*.\n@@ -1233,14 +1239,14 @@ def attrs(\n         inherited from some base class).\n \n         So for example by implementing ``__eq__`` on a class yourself,\n-        ``attrs`` will deduce ``eq=False`` and will create *neither*\n+        *attrs* will deduce ``eq=False`` and will create *neither*\n         ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible\n         ``__ne__`` by default, so it *should* be enough to only implement\n         ``__eq__`` in most cases).\n \n         .. warning::\n \n-           If you prevent ``attrs`` from creating the ordering methods for you\n+           If you prevent *attrs* from creating the ordering methods for you\n            (``order=False``, e.g. by implementing ``__le__``), it becomes\n            *your* responsibility to make sure its ordering is sound. The best\n            way is to use the `functools.total_ordering` decorator.\n@@ -1250,14 +1256,14 @@ def attrs(\n         *cmp*, or *hash* overrides whatever *auto_detect* would determine.\n \n     :param bool repr: Create a ``__repr__`` method with a human readable\n-        representation of ``attrs`` attributes..\n+        representation of *attrs* attributes..\n     :param bool str: Create a ``__str__`` method that is identical to\n         ``__repr__``.  This is usually not necessary except for\n         `Exception`\\ s.\n     :param Optional[bool] eq: If ``True`` or ``None`` (default), add ``__eq__``\n         and ``__ne__`` methods that check two instances for equality.\n \n-        They compare the instances as if they were tuples of their ``attrs``\n+        They compare the instances as if they were tuples of their *attrs*\n         attributes if and only if the types of both classes are *identical*!\n     :param Optional[bool] order: If ``True``, add ``__lt__``, ``__le__``,\n         ``__gt__``, and ``__ge__`` methods that behave like *eq* above and\n@@ -1268,7 +1274,7 @@ def attrs(\n     :param Optional[bool] unsafe_hash: If ``None`` (default), the ``__hash__``\n         method is generated according how *eq* and *frozen* are set.\n \n-        1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n+        1. If *both* are True, *attrs* will generate a ``__hash__`` for you.\n         2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n            None, marking it unhashable (which it is).\n         3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n@@ -1276,7 +1282,7 @@ def attrs(\n            ``object``, this means it will fall back to id-based hashing.).\n \n         Although not recommended, you can decide for yourself and force\n-        ``attrs`` to create one (e.g. if the class is immutable even though you\n+        *attrs* to create one (e.g. if the class is immutable even though you\n         didn't freeze it programmatically) by passing ``True`` or not.  Both of\n         these cases are rather special and should be used carefully.\n \n@@ -1287,7 +1293,7 @@ def attrs(\n     :param Optional[bool] hash: Alias for *unsafe_hash*. *unsafe_hash* takes\n         precedence.\n     :param bool init: Create a ``__init__`` method that initializes the\n-        ``attrs`` attributes. Leading underscores are stripped for the argument\n+        *attrs* attributes. Leading underscores are stripped for the argument\n         name. If a ``__attrs_pre_init__`` method exists on the class, it will\n         be called before the class is initialized. If a ``__attrs_post_init__``\n         method exists on the class, it will be called after the class is fully\n@@ -1303,7 +1309,7 @@ def attrs(\n         we encourage you to read the :term:`glossary entry <slotted classes>`.\n     :param bool frozen: Make instances immutable after initialization.  If\n         someone attempts to modify a frozen instance,\n-        `attr.exceptions.FrozenInstanceError` is raised.\n+        `attrs.exceptions.FrozenInstanceError` is raised.\n \n         .. note::\n \n@@ -1328,7 +1334,7 @@ def attrs(\n     :param bool auto_attribs: If ``True``, collect :pep:`526`-annotated\n         attributes from the class body.\n \n-        In this case, you **must** annotate every field.  If ``attrs``\n+        In this case, you **must** annotate every field.  If *attrs*\n         encounters a field that is set to an `attr.ib` but lacks a type\n         annotation, an `attr.exceptions.UnannotatedAttributeError` is\n         raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't\n@@ -1344,9 +1350,9 @@ def attrs(\n \n         .. warning::\n            For features that use the attribute name to create decorators (e.g.\n-           `validators <validators>`), you still *must* assign `attr.ib` to\n-           them. Otherwise Python will either not find the name or try to use\n-           the default value to call e.g. ``validator`` on it.\n+           :ref:`validators <validators>`), you still *must* assign `attr.ib`\n+           to them. Otherwise Python will either not find the name or try to\n+           use the default value to call e.g. ``validator`` on it.\n \n            These errors can be quite confusing and probably the most common bug\n            report on our bug tracker.\n@@ -1367,14 +1373,14 @@ def attrs(\n         class:\n \n         - the values for *eq*, *order*, and *hash* are ignored and the\n-          instances compare and hash by the instance's ids (N.B. ``attrs`` will\n+          instances compare and hash by the instance's ids (N.B. *attrs* will\n           *not* remove existing implementations of ``__hash__`` or the equality\n           methods. It just won't add own ones.),\n         - all attributes that are either passed into ``__init__`` or have a\n           default value are additionally available as a tuple in the ``args``\n           attribute,\n         - the value of *str* is ignored leaving ``__str__`` to base classes.\n-    :param bool collect_by_mro: Setting this to `True` fixes the way ``attrs``\n+    :param bool collect_by_mro: Setting this to `True` fixes the way *attrs*\n        collects attributes from base classes.  The default behavior is\n        incorrect in certain cases of multiple inheritance.  It should be on by\n        default but is kept off for backward-compatibility.\n@@ -1413,7 +1419,7 @@ def attrs(\n \n     :param Optional[callable] field_transformer:\n         A function that is called with the original class object and all\n-        fields right before ``attrs`` finalizes the class.  You can use\n+        fields right before *attrs* finalizes the class.  You can use\n         this, e.g., to automatically add converters or validators to\n         fields based on their types.  See `transform-fields` for more details.\n \n@@ -1891,7 +1897,7 @@ def _add_repr(cls, ns=None, attrs=None):\n \n def fields(cls):\n     \"\"\"\n-    Return the tuple of ``attrs`` attributes for a class.\n+    Return the tuple of *attrs* attributes for a class.\n \n     The tuple also allows accessing the fields by their names (see below for\n     examples).\n@@ -1899,13 +1905,13 @@ def fields(cls):\n     :param type cls: Class to introspect.\n \n     :raise TypeError: If *cls* is not a class.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     :rtype: tuple (with name accessors) of `attrs.Attribute`\n \n-    ..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n-        by name.\n+    .. versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n+       by name.\n     \"\"\"\n     if not isinstance(cls, type):\n         raise TypeError(\"Passed object must be a class.\")\n@@ -1917,13 +1923,13 @@ def fields(cls):\n \n def fields_dict(cls):\n     \"\"\"\n-    Return an ordered dictionary of ``attrs`` attributes for a class, whose\n+    Return an ordered dictionary of *attrs* attributes for a class, whose\n     keys are the attribute names.\n \n     :param type cls: Class to introspect.\n \n     :raise TypeError: If *cls* is not a class.\n-    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n+    :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n     :rtype: dict\n@@ -1944,7 +1950,7 @@ def validate(inst):\n \n     Leaves all exceptions through.\n \n-    :param inst: Instance of a class with ``attrs`` attributes.\n+    :param inst: Instance of a class with *attrs* attributes.\n     \"\"\"\n     if _config._run_validators is False:\n         return\n@@ -2382,6 +2388,10 @@ class Attribute:\n     \"\"\"\n     *Read-only* representation of an attribute.\n \n+    .. warning::\n+\n+       You should never instantiate this class yourself.\n+\n     The class has *all* arguments of `attr.ib` (except for ``factory``\n     which is only syntactic sugar for ``default=Factory(...)`` plus the\n     following:\n@@ -2527,13 +2537,13 @@ def from_counting_attr(cls, name, ca, type=None):\n             **inst_dict,\n         )\n \n-    # Don't use attr.evolve since fields(Attribute) doesn't work\n+    # Don't use attrs.evolve since fields(Attribute) doesn't work\n     def evolve(self, **changes):\n         \"\"\"\n         Copy *self* and apply *changes*.\n \n-        This works similarly to `attr.evolve` but that function does not work\n-        with ``Attribute``.\n+        This works similarly to `attrs.evolve` but that function does not work\n+        with `Attribute`.\n \n         It is mainly meant to be used for `transform-fields`.\n \n@@ -2768,10 +2778,6 @@ class Factory:\n     __slots__ = (\"factory\", \"takes_self\")\n \n     def __init__(self, factory, takes_self=False):\n-        \"\"\"\n-        `Factory` is part of the default machinery so if we want a default\n-        value here, we have to implement it ourselves.\n-        \"\"\"\n         self.factory = factory\n         self.takes_self = takes_self\n \ndiff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -46,7 +46,7 @@ def define(\n     match_args=True,\n ):\n     r\"\"\"\n-    Define an ``attrs`` class.\n+    Define an *attrs* class.\n \n     Differences to the classic `attr.s` that it uses underneath:\n \ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\n--- a/src/attr/exceptions.py\n+++ b/src/attr/exceptions.py\n@@ -34,7 +34,7 @@ class FrozenAttributeError(FrozenError):\n \n class AttrsAttributeNotFoundError(ValueError):\n     \"\"\"\n-    An ``attrs`` function couldn't find an attribute that the user asked for.\n+    An *attrs* function couldn't find an attribute that the user asked for.\n \n     .. versionadded:: 16.2.0\n     \"\"\"\n@@ -42,7 +42,7 @@ class AttrsAttributeNotFoundError(ValueError):\n \n class NotAnAttrsClassError(ValueError):\n     \"\"\"\n-    A non-``attrs`` class has been passed into an ``attrs`` function.\n+    A non-*attrs* class has been passed into an *attrs* function.\n \n     .. versionadded:: 16.2.0\n     \"\"\"\n@@ -50,7 +50,7 @@ class NotAnAttrsClassError(ValueError):\n \n class DefaultAlreadySetError(RuntimeError):\n     \"\"\"\n-    A default has been set using ``attr.ib()`` and is attempted to be reset\n+    A default has been set when defining the field and is attempted to be reset\n     using the decorator.\n \n     .. versionadded:: 17.1.0\n@@ -59,8 +59,7 @@ class DefaultAlreadySetError(RuntimeError):\n \n class UnannotatedAttributeError(RuntimeError):\n     \"\"\"\n-    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n-    annotation.\n+    A class with ``auto_attribs=True`` has a field without a type annotation.\n \n     .. versionadded:: 17.3.0\n     \"\"\"\n@@ -68,7 +67,7 @@ class UnannotatedAttributeError(RuntimeError):\n \n class PythonTooOldError(RuntimeError):\n     \"\"\"\n-    It was attempted to use an ``attrs`` feature that requires a newer Python\n+    It was attempted to use an *attrs* feature that requires a newer Python\n     version.\n \n     .. versionadded:: 18.2.0\n@@ -77,8 +76,8 @@ class PythonTooOldError(RuntimeError):\n \n class NotCallableError(TypeError):\n     \"\"\"\n-    A ``attr.ib()`` requiring a callable has been set with a value\n-    that is not callable.\n+    A field requiring a callable has been set with a value that is not\n+    callable.\n \n     .. versionadded:: 19.2.0\n     \"\"\"\ndiff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -359,13 +359,13 @@ def __repr__(self):\n \n def is_callable():\n     \"\"\"\n-    A validator that raises a `attr.exceptions.NotCallableError` if the\n+    A validator that raises a `attrs.exceptions.NotCallableError` if the\n     initializer is called with a value for this particular attribute\n     that is not callable.\n \n     .. versionadded:: 19.1.0\n \n-    :raises `attr.exceptions.NotCallableError`: With a human readable error\n+    :raises attrs.exceptions.NotCallableError: With a human readable error\n         message containing the attribute (`attrs.Attribute`) name,\n         and the value it got.\n     \"\"\"\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -1106,7 +1106,7 @@ def test_instance(self, C):\n \n     def test_handler_non_attrs_class(self):\n         \"\"\"\n-        Raises `ValueError` if passed a non-``attrs`` instance.\n+        Raises `ValueError` if passed a non-*attrs* instance.\n         \"\"\"\n         with pytest.raises(NotAnAttrsClassError) as e:\n             fields(object)\n@@ -1148,7 +1148,7 @@ def test_instance(self, C):\n \n     def test_handler_non_attrs_class(self):\n         \"\"\"\n-        Raises `ValueError` if passed a non-``attrs`` instance.\n+        Raises `ValueError` if passed a non-*attrs* instance.\n         \"\"\"\n         with pytest.raises(NotAnAttrsClassError) as e:\n             fields_dict(object)\n",
        "problem_statement": "Some API doc entries in objects.inv have double-attr module prefixes\ne.g. `attr.attr.cmp_using`\r\n\r\ncursory looking suggests it's autodoc vs manual.\n",
        "hints_text": "Ah, I missed the dedicated issue and left the comments @ https://github.com/python-attrs/attrs/issues/1073#issuecomment-1369072401 & https://github.com/python-attrs/attrs/issues/1073#issuecomment-1369077722.",
        "created_at": "2023-01-04T11:39:22Z",
        "version": "22.2"
    }
}