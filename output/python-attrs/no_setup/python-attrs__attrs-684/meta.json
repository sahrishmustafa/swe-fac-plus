{
    "task_id": "python-attrs__attrs-684",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-684_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 684,
        "instance_id": "python-attrs__attrs-684",
        "issue_numbers": [
            "682"
        ],
        "base_commit": "dfb2ee284d6229d8bffe6cba6be66a747116cd27",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -2185,6 +2185,8 @@ class Attribute(object):\n \n     .. versionadded:: 20.1.0 *inherited*\n     .. versionadded:: 20.1.0 *on_setattr*\n+    .. versionchanged:: 20.2.0 *inherited* is not taken into account for\n+        equality checks and hashing anymore.\n \n     For the full version history of the fields, see `attr.ib`.\n     \"\"\"\n@@ -2354,8 +2356,11 @@ def _setattrs(self, name_values_pairs):\n ]\n \n Attribute = _add_hash(\n-    _add_eq(_add_repr(Attribute, attrs=_a), attrs=_a),\n-    attrs=[a for a in _a if a.hash],\n+    _add_eq(\n+        _add_repr(Attribute, attrs=_a),\n+        attrs=[a for a in _a if a.name != \"inherited\"],\n+    ),\n+    attrs=[a for a in _a if a.hash and a.name != \"inherited\"],\n )\n \n \n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -691,6 +691,26 @@ def test_sugar_callable(self):\n             class C(object):\n                 x = attr.ib(factory=Factory(list))\n \n+    def test_inherited_does_not_affect_hashing_and_equality(self):\n+        \"\"\"\n+        Whether or not an Attribute has been inherited doesn't affect how it's\n+        hashed and compared.\n+        \"\"\"\n+\n+        @attr.s\n+        class BaseClass(object):\n+            x = attr.ib()\n+\n+        @attr.s\n+        class SubClass(BaseClass):\n+            pass\n+\n+        ba = attr.fields(BaseClass)[0]\n+        sa = attr.fields(SubClass)[0]\n+\n+        assert ba == sa\n+        assert hash(ba) == hash(sa)\n+\n \n @pytest.mark.skipif(PY2, reason=\"keyword-only arguments are PY3-only.\")\n class TestKeywordOnlyAttributes(object):\n",
        "problem_statement": "Inherited attributes of subclasses no longer compare equal to the equivalent attributes of base class\nA change between 19.3.0 \u2192 20.1.0 which doesn't seem to be deliberate, but may be related to #635 is that inherited attributes no longer compare equal to the attributes of the base class. Here is a MWE:\r\n\r\n```python\r\nimport attr\r\n\r\n@attr.s()\r\nclass BaseClass(object):\r\n    x = attr.ib()\r\n\r\n@attr.s()\r\nclass SubClass(BaseClass):\r\n    pass\r\n\r\nassert attr.fields(BaseClass)[0].name == attr.fields(SubClass)[0].name   # Succeeds in all versions\r\nassert attr.fields(BaseClass)[0] == attr.fields(SubClass)[0]  # Fails in 20.1.0\r\n```\r\n\r\nInterestingly, if you shadow the attribute, it works as expected:\r\n\r\n```python\r\nimport attr\r\n\r\n@attr.s()\r\nclass BaseClass(object):\r\n    x = attr.ib()\r\n\r\n@attr.s()\r\nclass SubClass(BaseClass):\r\n    x = attr.ib()\r\n\r\n# Works in all versions\r\nassert attr.fields(BaseClass)[0].name == attr.fields(SubClass)[0].name\r\nassert attr.fields(BaseClass)[0] == attr.fields(SubClass)[0]\r\n```\r\n\r\nI think the issue is that `inherited` is included in the calculation of whether two `Attribute`s are equal or not.\r\n\r\nI discovered this when upgrading some code that does something like this:\r\n\r\n```python\r\nimport attr\r\n\r\n@attr.s()\r\nclass BaseClass:\r\n    x = attr.ib()\r\n\r\n@attr.s()\r\nclass SubClass(BaseClass):\r\n    y = attr.ib()\r\n\r\ndef f(x) -> None:\r\n    print(x)\r\n\r\ndef my_function(obj : BaseClass) -> None:\r\n    kwargs = attr.asdict(obj, filter=attr.filters.include(*attr.fields(BaseClass)))\r\n    f(**kwargs)\r\n\r\nif __name__ == \"__main__\":\r\n    my_function(SubClass(1, 2))\r\n```\r\n\r\nThe idea there is that they want to pull out the subset of the structure that corresponds to the base class.\r\n\r\nIn this case, I can imagine working around it by pulling out the `name` attribute for each of the `Attribute`s (since in this case I _think_ they would want the subclass to pass along *any* attribute with the name of an attribute on the base class, not just ones that are configured the same way). I can imagine there might be other problems, though, if `attr.filters.include(*attr.fields(BaseClass))` is a common pattern.\n",
        "hints_text": "Yeah for all practical purposes, I think we've got it wrong ATM.  And I think hashing should also not take it into account. Technically it's wrong but in practice I think it makes it useless.",
        "created_at": "2020-09-02T05:54:30Z",
        "version": "20.1"
    }
}