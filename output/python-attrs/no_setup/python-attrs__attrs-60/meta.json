{
    "task_id": "python-attrs__attrs-60",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-60_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 60,
        "instance_id": "python-attrs__attrs-60",
        "issue_numbers": [
            "3"
        ],
        "base_commit": "5a1814f8d07e00d47d7d81274e4b4ee10dd83d41",
        "patch": "diff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -19,6 +19,7 @@\n     get_run_validators,\n     set_run_validators,\n )\n+from . import exceptions\n from . import filters\n from . import validators\n \n@@ -49,6 +50,7 @@\n     \"attrib\",\n     \"attributes\",\n     \"attrs\",\n+    \"exceptions\",\n     \"fields\",\n     \"filters\",\n     \"get_run_validators\",\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -3,8 +3,9 @@\n import hashlib\n import linecache\n \n-from ._compat import exec_, iteritems, isclass, iterkeys\n from . import _config\n+from ._compat import exec_, iteritems, isclass, iterkeys\n+from .exceptions import FrozenInstanceError\n \n \n class _Nothing(object):\n@@ -145,8 +146,16 @@ def _transform_attrs(cls, these):\n             had_default = True\n \n \n+def _frozen_setattrs(self, name, value):\n+    \"\"\"\n+    Attached to frozen classes as __setattr__.\n+    \"\"\"\n+    raise FrozenInstanceError()\n+\n+\n def attributes(maybe_cls=None, these=None, repr_ns=None,\n-               repr=True, cmp=True, hash=True, init=True, slots=False):\n+               repr=True, cmp=True, hash=True, init=True,\n+               slots=False, frozen=False):\n     \"\"\"\n     A class decorator that adds `dunder\n     <https://wiki.python.org/moin/DunderAlias>`_\\ -methods according to the\n@@ -161,33 +170,42 @@ def attributes(maybe_cls=None, these=None, repr_ns=None,\n         If *these* is not `None`, the class body is *ignored*.\n     :type these: :class:`dict` of :class:`str` to :func:`attr.ib`\n \n-    :param repr_ns: When using nested classes, there's no way in Python 2 to\n-        automatically detect that.  Therefore it's possible to set the\n+    :param str repr_ns: When using nested classes, there's no way in Python 2\n+        to automatically detect that.  Therefore it's possible to set the\n         namespace explicitly for a more meaningful ``repr`` output.\n-\n-    :param repr: Create a ``__repr__`` method with a human readable\n+    :param bool repr: Create a ``__repr__`` method with a human readable\n         represantation of ``attrs`` attributes..\n-    :type repr: bool\n-\n-    :param cmp: Create ``__eq__``, ``__ne__``, ``__lt__``, ``__le__``,\n+    :param bool cmp: Create ``__eq__``, ``__ne__``, ``__lt__``, ``__le__``,\n         ``__gt__``, and ``__ge__`` methods that compare the class as if it were\n         a tuple of its ``attrs`` attributes.  But the attributes are *only*\n         compared, if the type of both classes is *identical*!\n-    :type cmp: bool\n+    :param bool hash: Create a ``__hash__`` method that returns the\n+        :func:`hash` of a tuple of all ``attrs`` attribute values.\n+    :param bool init: Create a ``__init__`` method that initialiazes the\n+        ``attrs`` attributes.  Leading underscores are stripped for the\n+        argument name.\n+    :param bool slots: Create a slots_-style class that's more\n+        memory-efficient.  See :ref:`slots` for further ramifications.\n+    :param bool frozen: Make instances immutable after initialization.  If\n+        someone attempts to modify a frozen instance,\n+        :exc:`attr.exceptions.FrozenInstanceError` is raised.\n+\n+        Please note:\n \n-    :param hash: Create a ``__hash__`` method that returns the :func:`hash` of\n-        a tuple of all ``attrs`` attribute values.\n-    :type hash: bool\n+            1. This is achieved by installing a custom ``__setattr__`` method\n+               on your class so you can't implement an own one.\n \n-    :param init: Create a ``__init__`` method that initialiazes the ``attrs``\n-        attributes.  Leading underscores are stripped for the argument name.\n-    :type init: bool\n+            2. True immutability is impossible in Python.\n \n-    :param slots: Create a slots_-style class that's more memory-efficient.\n-        See :ref:`slots` for further ramifications.\n-    :type slots: bool\n+            3. This *does* have a minor a runtime performance impact when\n+               initializing new instances.  In other words: ``__init__`` is\n+               slightly slower with ``frozen=True``.\n \n-    .. _slots: https://docs.python.org/3.5/reference/datamodel.html#slots\n+        ..  _slots: https://docs.python.org/3.5/reference/datamodel.html#slots\n+\n+        ..  versionadded:: 16.0.0 *slots*\n+\n+        ..  versionadded:: 16.1.0 *frozen*\n     \"\"\"\n     def wrap(cls):\n         if getattr(cls, \"__class__\", None) is None:\n@@ -209,8 +227,10 @@ def wrap(cls):\n         if hash is True:\n             cls = _add_hash(cls)\n         if init is True:\n-            cls = _add_init(cls)\n-        if slots:\n+            cls = _add_init(cls, frozen)\n+        if frozen is True:\n+            cls.__setattr__ = _frozen_setattrs\n+        if slots is True:\n             cls_dict = dict(cls.__dict__)\n             cls_dict[\"__slots__\"] = tuple(ca_list)\n             for ca_name in ca_list:\n@@ -367,7 +387,10 @@ def repr_(self):\n     return cls\n \n \n-def _add_init(cls):\n+def _add_init(cls, frozen):\n+    \"\"\"\n+    Add a __init__ method to *cls*.  If *frozen* is True, make it immutable.\n+    \"\"\"\n     attrs = [a for a in cls.__attrs_attrs__\n              if a.init or a.default is not NOTHING]\n \n@@ -378,14 +401,21 @@ def _add_init(cls):\n         sha1.hexdigest()\n     )\n \n-    script = _attrs_to_script(attrs)\n+    script = _attrs_to_script(attrs, frozen)\n     locs = {}\n     bytecode = compile(script, unique_filename, \"exec\")\n     attr_dict = dict((a.name, a) for a in attrs)\n-    exec_(bytecode, {\"NOTHING\": NOTHING,\n-                     \"attr_dict\": attr_dict,\n-                     \"validate\": validate,\n-                     \"_convert\": _convert}, locs)\n+    globs = {\n+        \"NOTHING\": NOTHING,\n+        \"attr_dict\": attr_dict,\n+        \"validate\": validate,\n+        \"_convert\": _convert\n+    }\n+    if frozen is True:\n+        # Save the lookup overhead in __init__ if we need to circumvent\n+        # immutability.\n+        globs[\"_cached_setattr\"] = object.__setattr__\n+    exec_(bytecode, globs, locs)\n     init = locs[\"__init__\"]\n \n     # In order of debuggers like PDB being able to step through the code,\n@@ -450,11 +480,31 @@ def _convert(inst):\n             setattr(inst, a.name, a.convert(getattr(inst, a.name)))\n \n \n-def _attrs_to_script(attrs):\n+def _attrs_to_script(attrs, frozen):\n     \"\"\"\n     Return a valid Python script of an initializer for *attrs*.\n+\n+    If *frozen* is True, we cannot set the attributes directly so we use\n+    a cached ``object.__setattr__``.\n     \"\"\"\n     lines = []\n+    if frozen is True:\n+        lines.append(\n+            \"_setattr = _cached_setattr.__get__(self, self.__class__)\"\n+        )\n+\n+        def fmt_setter(attr_name, value):\n+            return \"_setattr('%(attr_name)s', %(value)s)\" % {\n+                \"attr_name\": attr_name,\n+                \"value\": value,\n+            }\n+    else:\n+        def fmt_setter(attr_name, value):\n+            return \"self.%(attr_name)s = %(value)s\" % {\n+                \"attr_name\": attr_name,\n+                \"value\": value,\n+            }\n+\n     args = []\n     has_validator = False\n     has_convert = False\n@@ -467,14 +517,16 @@ def _attrs_to_script(attrs):\n         arg_name = a.name.lstrip(\"_\")\n         if a.init is False:\n             if isinstance(a.default, Factory):\n-                lines.append(\"\"\"\\\n-self.{attr_name} = attr_dict[\"{attr_name}\"].default.factory()\"\"\".format(\n-                    attr_name=attr_name,\n+                lines.append(fmt_setter(\n+                    attr_name,\n+                    \"attr_dict['{attr_name}'].default.factory()\"\n+                    .format(attr_name=attr_name)\n                 ))\n             else:\n-                lines.append(\"\"\"\\\n-self.{attr_name} = attr_dict[\"{attr_name}\"].default\"\"\".format(\n-                    attr_name=attr_name,\n+                lines.append(fmt_setter(\n+                    attr_name,\n+                    \"attr_dict['{attr_name}'].default\"\n+                    .format(attr_name=attr_name)\n                 ))\n         elif a.default is not NOTHING and not isinstance(a.default, Factory):\n             args.append(\n@@ -483,26 +535,21 @@ def _attrs_to_script(attrs):\n                     attr_name=attr_name,\n                 )\n             )\n-            lines.append(\"self.{attr_name} = {arg_name}\".format(\n-                arg_name=arg_name,\n-                attr_name=attr_name,\n-            ))\n+            lines.append(fmt_setter(attr_name, arg_name))\n         elif a.default is not NOTHING and isinstance(a.default, Factory):\n             args.append(\"{arg_name}=NOTHING\".format(arg_name=arg_name))\n-            lines.extend(\"\"\"\\\n-if {arg_name} is not NOTHING:\n-    self.{attr_name} = {arg_name}\n-else:\n-    self.{attr_name} = attr_dict[\"{attr_name}\"].default.factory()\"\"\"\n-                         .format(attr_name=attr_name,\n-                                 arg_name=arg_name)\n-                         .split(\"\\n\"))\n+            lines.append(\"if {arg_name} is not NOTHING:\"\n+                         .format(arg_name=arg_name))\n+            lines.append(\"    \" + fmt_setter(attr_name, arg_name))\n+            lines.append(\"else:\")\n+            lines.append(\"    \" + fmt_setter(\n+                attr_name,\n+                \"attr_dict['{attr_name}'].default.factory()\"\n+                .format(attr_name=attr_name)\n+            ))\n         else:\n             args.append(arg_name)\n-            lines.append(\"self.{attr_name} = {arg_name}\".format(\n-                attr_name=attr_name,\n-                arg_name=arg_name,\n-            ))\n+            lines.append(fmt_setter(attr_name, arg_name))\n \n     if has_convert:\n         lines.append(\"_convert(self)\")\n@@ -511,10 +558,10 @@ def _attrs_to_script(attrs):\n \n     return \"\"\"\\\n def __init__(self, {args}):\n-    {setters}\n+    {lines}\n \"\"\".format(\n         args=\", \".join(args),\n-        setters=\"\\n    \".join(lines) if lines else \"pass\",\n+        lines=\"\\n    \".join(lines) if lines else \"pass\",\n     )\n \n \n@@ -544,7 +591,7 @@ def __init__(self, **kw):\n                     raise TypeError(\"Missing argument '{arg}'.\".format(arg=a))\n \n     def __setattr__(self, name, value):\n-        raise AttributeError(\"can't set attribute\")  # To mirror namedtuple.\n+        raise FrozenInstanceError()\n \n     @classmethod\n     def from_counting_attr(cls, name, ca):\ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attr/exceptions.py\n@@ -0,0 +1,12 @@\n+from __future__ import absolute_import, division, print_function\n+\n+\n+class FrozenInstanceError(AttributeError):\n+    \"\"\"\n+    A frozen/immutable instance has been attempted to be modified.\n+\n+    It mirrors the behavior of ``namedtuples`` by using the same error message\n+    and subclassing :exc:`AttributeError``.\n+    \"\"\"\n+    msg = \"can't set attribute\"\n+    args = [msg]\n",
        "test_patch": "diff --git a/tests/test_dark_magic.py b/tests/test_dark_magic.py\n--- a/tests/test_dark_magic.py\n+++ b/tests/test_dark_magic.py\n@@ -8,6 +8,7 @@\n \n from attr._compat import TYPE\n from attr._make import Attribute, NOTHING\n+from attr.exceptions import FrozenInstanceError\n \n \n @attr.s\n@@ -62,6 +63,11 @@ class SubSlots(SuperSlots):\n     y = attr.ib()\n \n \n+@attr.s(frozen=True, slots=True)\n+class Frozen(object):\n+    x = attr.ib()\n+\n+\n class TestDarkMagic(object):\n     \"\"\"\n     Integration tests.\n@@ -114,12 +120,12 @@ class C3(object):\n \n         assert \"C3(_x=1)\" == repr(C3(x=1))\n \n-    @given(booleans())\n-    def test_programmatic(self, slots):\n+    @given(booleans(), booleans())\n+    def test_programmatic(self, slots, frozen):\n         \"\"\"\n         `attr.make_class` works.\n         \"\"\"\n-        PC = attr.make_class(\"PC\", [\"a\", \"b\"], slots=slots)\n+        PC = attr.make_class(\"PC\", [\"a\", \"b\"], slots=slots, frozen=frozen)\n         assert (\n             Attribute(name=\"a\", default=NOTHING, validator=None,\n                       repr=True, cmp=True, hash=True, init=True),\n@@ -155,3 +161,19 @@ class Sub2(base):\n         i = Sub2(x=obj)\n         assert i.x is i.meth() is obj\n         assert \"Sub2(x={obj})\".format(obj=obj) == repr(i)\n+\n+    @pytest.mark.parametrize(\"frozen_class\", [\n+        Frozen,  # has slots=True\n+        attr.make_class(\"FrozenToo\", [\"x\"], slots=False, frozen=True),\n+    ])\n+    def test_frozen_instance(self, frozen_class):\n+        \"\"\"\n+        Frozen instances can't be modified (easily).\n+        \"\"\"\n+        frozen = frozen_class(1)\n+\n+        with pytest.raises(FrozenInstanceError) as e:\n+            frozen.x = 2\n+\n+        assert e.value.args[0] == \"can't set attribute\"\n+        assert 1 == frozen.x\ndiff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -35,7 +35,7 @@\n class InitC(object):\n     __attrs_attrs__ = [simple_attr(\"a\"), simple_attr(\"b\")]\n \n-InitC = _add_init(InitC)\n+InitC = _add_init(InitC, False)\n \n \n class TestAddCmp(object):\n@@ -219,12 +219,13 @@ class TestAddInit(object):\n     \"\"\"\n     Tests for `_add_init`.\n     \"\"\"\n-    @given(booleans())\n-    def test_init(self, slots):\n+    @given(booleans(), booleans())\n+    def test_init(self, slots, frozen):\n         \"\"\"\n         If `init` is False, ignore that attribute.\n         \"\"\"\n-        C = make_class(\"C\", {\"a\": attr(init=False), \"b\": attr()}, slots=slots)\n+        C = make_class(\"C\", {\"a\": attr(init=False), \"b\": attr()},\n+                       slots=slots, frozen=frozen)\n         with pytest.raises(TypeError) as e:\n             C(a=1, b=2)\n \n@@ -233,8 +234,8 @@ def test_init(self, slots):\n             e.value.args[0]\n         )\n \n-    @given(booleans())\n-    def test_no_init_default(self, slots):\n+    @given(booleans(), booleans())\n+    def test_no_init_default(self, slots, frozen):\n         \"\"\"\n         If `init` is False but a Factory is specified, don't allow passing that\n         argument but initialize it anyway.\n@@ -243,7 +244,7 @@ def test_no_init_default(self, slots):\n             \"_a\": attr(init=False, default=42),\n             \"_b\": attr(init=False, default=Factory(list)),\n             \"c\": attr()\n-        }, slots=slots)\n+        }, slots=slots, frozen=frozen)\n         with pytest.raises(TypeError):\n             C(a=1, c=2)\n         with pytest.raises(TypeError):\n@@ -252,8 +253,8 @@ def test_no_init_default(self, slots):\n         i = C(23)\n         assert (42, [], 23) == (i._a, i._b, i.c)\n \n-    @given(booleans())\n-    def test_no_init_order(self, slots):\n+    @given(booleans(), booleans())\n+    def test_no_init_order(self, slots, frozen):\n         \"\"\"\n         If an attribute is `init=False`, it's legal to come after a mandatory\n         attribute.\n@@ -261,7 +262,7 @@ def test_no_init_order(self, slots):\n         make_class(\"C\", {\n             \"a\": attr(default=Factory(list)),\n             \"b\": attr(init=False),\n-        }, slots=slots)\n+        }, slots=slots, frozen=frozen)\n \n     def test_sets_attributes(self):\n         \"\"\"\n@@ -282,7 +283,7 @@ class C(object):\n                 simple_attr(name=\"c\", default=None),\n             ]\n \n-        C = _add_init(C)\n+        C = _add_init(C, False)\n         i = C()\n         assert 2 == i.a\n         assert \"hallo\" == i.b\n@@ -300,7 +301,7 @@ class C(object):\n                 simple_attr(name=\"a\", default=Factory(list)),\n                 simple_attr(name=\"b\", default=Factory(D)),\n             ]\n-        C = _add_init(C)\n+        C = _add_init(C, False)\n         i = C()\n         assert [] == i.a\n         assert isinstance(i.b, D)\n@@ -363,7 +364,7 @@ def test_underscores(self):\n         class C(object):\n             __attrs_attrs__ = [simple_attr(\"_private\")]\n \n-        C = _add_init(C)\n+        C = _add_init(C, False)\n         i = C(private=42)\n         assert 42 == i._private\n \n",
        "problem_statement": "clean division between \"value\" and \"object\"\nObjects, as in object-oriented programming, are side-effecty, mutable state, whose methods ought to represent I/O.\n\nValues, as in functional programming, are immutable data, whose methods ought to represent computation.\n\nPython does not have as good a division between these very different sorts of beasts as it should, but it does have one critical distinction: the `__hash__` method.\n\n`characteristic` has this issue which crops up occasionally where you end up with objects that you can't put into a dictionary as a key, because one of its attributes is a dictionary.  Sometimes people expect to be able to do this because `characteristic` makes so many other things easy, and just expect dictionaries to suddenly be immutable; sometimes people expect hash-by-identity.\n\nI propose that attr provide a way to specifically create two types of objects with a distinct interface; one that creates a \"value\" and one that creates an \"object\", so that users can see issues around mutability far earlier in the process.\n\nSo, for example, the \"object\" type would:\n- not provide `__hash__` by default, provide an `__eq__` that does structural equality, and `__gt__`/`__lt__` that just raise exceptions\n- if asked, provide an identity-based `__hash__`, but then also switch to an identity-based `__eq__`\n\nand the 'value\" type would\n- call `hash()` on all of its arguments at construction time so it would fail immediately if it contained a mutable type\n- fail immediately at class-definition time if any validator is mutable\n- provide immutable descriptors for all its attributes\n\n",
        "hints_text": "How would that look API-wise?  Would something like `@attr.object` or `@attr.value` be presets for `@attr.s`?\n\nI'm not sure.  I'm trying to decide what I think the default for `attr.s` is; there's a strong case in my mind for both default-to-mutable or default-to-immutable.  `attr.s(mutable=True)`?\n\nThe default should be what most people (and I!) would expect it to do.  We\u2019re still on Python and don\u2019t have free COW structures etc.  Therefore any immutability gimmickry ought to be opt-in (but in place and simple to use).\n\nI think you're right; Python programmers are going to expect mutability by default, trying to turn that off would just be an ideological statement, not useful functionality.  So how about just having a `__hash__` that raises an exception which points you at `attr.value`, and `attr.s` is `object`?\n\nHi, I found this ticket because I was looking for an `immutable` argument to `@attr.s` like there was with characteristic :)\n\nALSO: on the subject of \"value types\", I would like to point out my new library [sumtypes](https://pypi.python.org/pypi/sumtypes) (honestly I didn't come here looking for a place to advertise, but it seems relevant). `immutable` would be great to have for it too (and I probably _would_ make it the default in that library).\n\nI\u2019m reluctant to implement immutable myself because it adds another method I have to highly invasively muck with (`__setattr__`).\n\n_But_ `attrs` [is extensible](https://attrs.readthedocs.org/en/stable/extending.html), so feel free to implement it yourself!\n\n@hynek I guess there's two separate aspects of immutability: making sure declared attributes are immutable, and making sure new attributes can't be dynamically assigned to. \n\nNeither of these actually require defining `__setattr__`. The former can be accomplished with the descriptor protocol, and the latter can be accomplished with `__slots__`. \n\nI assumed Attribute must have already implemented the descriptor protocol, but I see now I'm wrong, and, for example, mutating an attribute post-instantiation will allow setting it to a value that a validator wouldn't accept, because validators are not run on mutation. So maybe it would be best if Attribute instances do provide the descriptor protocol, both to support validating mutation as well as implementing immutability if it's requested?\n\nI kinda want to recommend setting up a performance test suite at this point, because while it seems to me like using the descriptor protocol _ought_ to be zero-cost on PyPy and \"fast enough\" on CPython, it also seems like it would be worth knowing that for sure.\n\n(Although I also assumed that attrs would validate on mutation and this is a slightly unpleasant surprise.  Hmm.)\n\nattrs had validation on mutation once but there were so many loopholes that I decided to take it out because the performance hit for _everyone_ simply wasn\u2019t worth it.\n\nI\u2019m pretty sure that using descriptors is measurably slower.  I\u2019ll happily be proven wrong with a benchmark. :)\n\nWhat do you mean \"so many loopholes\"?  Other than `__dict__.__setitem__` and `object.__setattr__` what else is there?\n\n@glyph well, there's also other methods on `__dict__` than `__setitem__`, so generalize that to \"`__dict__` mutation\"\n\nPersonally I think it's worth doing validation with the descriptor protocol even though someone could bypass with `__dict__` mutation. However! It would also be possible to make naive dict mutation ineffective, since Python always consults a descriptor before a `__dict__` entry. It might have other downsides, but you could have the descriptors store their actual data under a different name in the instance dict, so at least someone would really know they're bypassing validation when they're assigning something to `__dict__['__attrs_x']`.\n\nBut... yeah, that might be a bit too surprising/weird for people who do want to dig down into the representation. I mean, Pickling would still work just fine, but maybe there are some useful things that would break?\n\nAlso, as a follow-up to my previous mention of `__slots__`, I've hit a snag there: apparently the way `__slots__` works is by creating descriptors on the class. Which means you can't use your _own_ descriptors (or even non-descriptors -- you can't even use class variables to declare defaults for instances, for example). The result of trying to add `__slots__` to a `@attrib.s`-using class is this:\n\n```\n>>> @attr.s\n... class Foo(object):\n...  __slots__ = ('x', 'y')\n...  x = attr.ib()\n...  y = attr.ib()\n...\n>>> Foo(1, 2)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<attrs generated init a7439b12cdcdd2d603c04767f9a798adb8a0d944>\", line 2, in __init__\nAttributeError: 'Foo' object attribute 'x' is read-only\n```\n\nThere may be some clever trick I'm missing to still use `__slots__` (which actually would be nice to use on CPython if we could...), but I'm thinking @hynek is right and the only way to implement immutability would be by defining a `__setattr__` :-(\n\nOh, never mind. There is a way to use both slots and descriptors:\n\nhttp://stackoverflow.com/questions/4912499/using-python-descriptors-with-slots\n\nIt's just a matter of having the user's descriptor be named different from the slot.\n\nmost obvious loophole:  `instance.attribute.do_something_that_mutates_instance()`.\n\nI don\u2019t want to sound like an ass but adding features that are invasive but only interesting to a small fraction of people made `characteristic` what it is so I\u2019m much more conservative this time and rather made it extensible than implementing everything ppl shout at me.\n\nI\u2019m open to descriptor-based solutions that have no negative impact on performance though.\n\nMutability doesn't seem like a particularly obscure or minority concern :).\n\nThat said, I'm not sure what you're objecting to.  Doing validation on attributes by default?  Doing validation on attributes at all?  Or the actual topic of this bug, `@attr.value`, which would not be on by default anyway?\n\nEcho chamber. :)\n\nI\u2019m objecting the tangent of validating on assignment.  I don\u2019t object immutability but I feel it should be a separate decorator.  Maybe `@attr.value`? :)\n\nOK good. Let's have another issue to discuss that.\n\nFor the case of `@attr.value` specifically, we could just override `__setattr__` to raise `AttributeError` after initialization. Does that seem sufficient?\n\nYou mentioned not wanting to do it yourself, but nothing _except_ `value` would need to mess with it.\n\nJust to be clear: my main issue is not being lazy but wanting to keep attrs clean. :)  Moving settattr magic into a separate decorator seems a fair compromise to me.\n\nCool, thank you, I asked the question very awkwardly but that was exactly the form of answer I wanted :).\n\nSee also #50 ?\n",
        "created_at": "2016-08-16T14:35:17Z",
        "version": "16.0"
    }
}