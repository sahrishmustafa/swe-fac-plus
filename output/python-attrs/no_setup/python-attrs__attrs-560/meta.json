{
    "task_id": "python-attrs__attrs-560",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-560_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 560,
        "instance_id": "python-attrs__attrs-560",
        "issue_numbers": [
            "558"
        ],
        "base_commit": "ad33d87ca5bf3be54e65ca742997187ec3b8c1ed",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -1,10 +1,10 @@\n from __future__ import absolute_import, division, print_function\n \n import copy\n-import hashlib\n import linecache\n import sys\n import threading\n+import uuid\n import warnings\n \n from operator import itemgetter\n@@ -665,7 +665,10 @@ def make_unhashable(self):\n     def add_hash(self):\n         self._cls_dict[\"__hash__\"] = self._add_method_dunders(\n             _make_hash(\n-                self._attrs, frozen=self._frozen, cache_hash=self._cache_hash\n+                self._cls,\n+                self._attrs,\n+                frozen=self._frozen,\n+                cache_hash=self._cache_hash,\n             )\n         )\n \n@@ -674,6 +677,7 @@ def add_hash(self):\n     def add_init(self):\n         self._cls_dict[\"__init__\"] = self._add_method_dunders(\n             _make_init(\n+                self._cls,\n                 self._attrs,\n                 self._has_post_init,\n                 self._frozen,\n@@ -692,7 +696,8 @@ def add_cmp(self):\n         cd[\"__eq__\"], cd[\"__ne__\"], cd[\"__lt__\"], cd[\"__le__\"], cd[\n             \"__gt__\"\n         ], cd[\"__ge__\"] = (\n-            self._add_method_dunders(meth) for meth in _make_cmp(self._attrs)\n+            self._add_method_dunders(meth)\n+            for meth in _make_cmp(self._cls, self._attrs)\n         )\n \n         return self\n@@ -986,7 +991,37 @@ def _attrs_to_tuple(obj, attrs):\n     return tuple(getattr(obj, a.name) for a in attrs)\n \n \n-def _make_hash(attrs, frozen, cache_hash):\n+def _generate_unique_filename(cls, func_name):\n+    \"\"\"\n+    Create a \"filename\" suitable for a function being generated.\n+    \"\"\"\n+    unique_id = uuid.uuid4()\n+    extra = \"\"\n+    count = 1\n+\n+    while True:\n+        unique_filename = \"<attrs generated {0} {1}.{2}{3}>\".format(\n+            func_name,\n+            cls.__module__,\n+            getattr(cls, \"__qualname__\", cls.__name__),\n+            extra,\n+        )\n+        # To handle concurrency we essentially \"reserve\" our spot in\n+        # the linecache with a dummy line.  The caller can then\n+        # set this value correctly.\n+        cache_line = (1, None, (str(unique_id),), unique_filename)\n+        if (\n+            linecache.cache.setdefault(unique_filename, cache_line)\n+            == cache_line\n+        ):\n+            return unique_filename\n+\n+        # Looks like this spot is taken. Try again.\n+        count += 1\n+        extra = \"-{0}\".format(count)\n+\n+\n+def _make_hash(cls, attrs, frozen, cache_hash):\n     attrs = tuple(\n         a\n         for a in attrs\n@@ -995,10 +1030,7 @@ def _make_hash(attrs, frozen, cache_hash):\n \n     tab = \"        \"\n \n-    # We cache the generated hash methods for the same kinds of attributes.\n-    sha1 = hashlib.sha1()\n-    sha1.update(repr(attrs).encode(\"utf-8\"))\n-    unique_filename = \"<attrs generated hash %s>\" % (sha1.hexdigest(),)\n+    unique_filename = _generate_unique_filename(cls, \"hash\")\n     type_hash = hash(unique_filename)\n \n     method_lines = [\"def __hash__(self):\"]\n@@ -1055,7 +1087,7 @@ def _add_hash(cls, attrs):\n     \"\"\"\n     Add a hash method to *cls*.\n     \"\"\"\n-    cls.__hash__ = _make_hash(attrs, frozen=False, cache_hash=False)\n+    cls.__hash__ = _make_hash(cls, attrs, frozen=False, cache_hash=False)\n     return cls\n \n \n@@ -1077,13 +1109,10 @@ def __ne__(self, other):\n )\n \n \n-def _make_cmp(attrs):\n+def _make_cmp(cls, attrs):\n     attrs = [a for a in attrs if a.cmp]\n \n-    # We cache the generated eq methods for the same kinds of attributes.\n-    sha1 = hashlib.sha1()\n-    sha1.update(repr(attrs).encode(\"utf-8\"))\n-    unique_filename = \"<attrs generated eq %s>\" % (sha1.hexdigest(),)\n+    unique_filename = _generate_unique_filename(cls, \"eq\")\n     lines = [\n         \"def __eq__(self, other):\",\n         \"    if other.__class__ is not self.__class__:\",\n@@ -1188,7 +1217,7 @@ def _add_cmp(cls, attrs=None):\n         attrs = cls.__attrs_attrs__\n \n     cls.__eq__, cls.__ne__, cls.__lt__, cls.__le__, cls.__gt__, cls.__ge__ = _make_cmp(  # noqa\n-        attrs\n+        cls, attrs\n     )\n \n     return cls\n@@ -1258,14 +1287,11 @@ def _add_repr(cls, ns=None, attrs=None):\n \n \n def _make_init(\n-    attrs, post_init, frozen, slots, cache_hash, base_attr_map, is_exc\n+    cls, attrs, post_init, frozen, slots, cache_hash, base_attr_map, is_exc\n ):\n     attrs = [a for a in attrs if a.init or a.default is not NOTHING]\n \n-    # We cache the generated init methods for the same kinds of attributes.\n-    sha1 = hashlib.sha1()\n-    sha1.update(repr(attrs).encode(\"utf-8\"))\n-    unique_filename = \"<attrs generated init {0}>\".format(sha1.hexdigest())\n+    unique_filename = _generate_unique_filename(cls, \"init\")\n \n     script, globs, annotations = _attrs_to_init_script(\n         attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc\n",
        "test_patch": "diff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -58,6 +58,7 @@ def _add_init(cls, frozen):\n     the tests for it are still useful to test the behavior of _make_init.\n     \"\"\"\n     cls.__init__ = _make_init(\n+        cls,\n         cls.__attrs_attrs__,\n         getattr(cls, \"__attrs_post_init__\", False),\n         frozen,\n@@ -759,3 +760,48 @@ def test_eq(self):\n         assert _Nothing() == _Nothing() == NOTHING\n         assert not (_Nothing() != _Nothing())\n         assert 1 != _Nothing()\n+\n+\n+@attr.s(hash=True, cmp=True)\n+class C(object):\n+    pass\n+\n+\n+# Store this class so that we recreate it.\n+OriginalC = C\n+\n+\n+@attr.s(hash=True, cmp=True)\n+class C(object):\n+    pass\n+\n+\n+class TestFilenames(object):\n+    def test_filenames(self):\n+        \"\"\"\n+        The created dunder methods have a \"consistent\" filename.\n+        \"\"\"\n+        assert (\n+            OriginalC.__init__.__code__.co_filename\n+            == \"<attrs generated init tests.test_dunders.C>\"\n+        )\n+        assert (\n+            OriginalC.__eq__.__code__.co_filename\n+            == \"<attrs generated eq tests.test_dunders.C>\"\n+        )\n+        assert (\n+            OriginalC.__hash__.__code__.co_filename\n+            == \"<attrs generated hash tests.test_dunders.C>\"\n+        )\n+        assert (\n+            C.__init__.__code__.co_filename\n+            == \"<attrs generated init tests.test_dunders.C-2>\"\n+        )\n+        assert (\n+            C.__eq__.__code__.co_filename\n+            == \"<attrs generated eq tests.test_dunders.C-2>\"\n+        )\n+        assert (\n+            C.__hash__.__code__.co_filename\n+            == \"<attrs generated hash tests.test_dunders.C-2>\"\n+        )\n",
        "problem_statement": "init unique_filename is problematic for exception aggregation\nWe had a case where a custom converter was often failing due to an app issue.  The traceback will include a line with a unique ID based on the initial attr values in the class:\r\n\r\n```\r\nFile \"<attrs generated init 81db48c8801f50d1c320ad1b8d1e0028320432b2>\", line 3, in __init__\r\n```\r\n\r\nHaving a unique ID in the traceback in turn causes problems for exception fingerprinting (e.g. by Sentry).  I'm not thrilled about doing custom traceback filtering for such cases, and would like to explore other options.\r\n\r\nI wonder what the full rationale is for ensuring the unique filename, and whether it could be made optional.\r\n\r\nIncluding a hash of the attribute values is essentially like dumping the values of all attributes of a class instance as part of the traceback whenever there is a constructor error regarding a single attribute-- which is less than precise error reporting.\r\n\r\nhttps://github.com/python-attrs/attrs/blob/dc1b5a01e98a9ba49d45ad07ba6ae0ee2d9c1b8e/src/attr/_make.py#L1268\n",
        "hints_text": "> I wonder what the full rationale is for ensuring the unique filename, and whether it could be made optional.\n\nThe rationale is that we need a unique but fake file name to feed into linecache so you you pdb step through the generated methods.  I\u2019m very much open to change some of this behavior (there\u2019s been a few related issues) but debuggability of generated methods is a non-negotiable property.\nTo clarify, this problem came up when using a lambda for an attrib converter, causing every program session to end up with a different hash.\r\n\r\nWhat exactly is the uniqueness requirement in this case?  The hash should ideally reflect the source code (i.e. static, deterministic) and not beyond.  Would using `cls.__module__` and `cls.__qualname__` be sufficient?\n\n> To clarify, this problem came up when using a lambda for an attrib converter, causing each program to end up with a different hash.\n> \nAre you sure it\u2019s the _same_ class? I can\u2019t check right now but the hash should be over the definition of the method so it _should_ be stable? I would like to make it nicer/human readable, I just didn\u2019t get around to it.\nI see this whenever our server restarts.  And I've been wondering what causes it.  \r\n\r\nSo it's the **same** class but it ends up with a different hash because of the ids of the functions used. Here's a minimal example:\r\n\r\n```\r\nimport attr\r\n\r\ndef to_int(x):\r\n    return int(x)\r\n\r\n@attr.dataclass\r\nclass Foo:\r\n    x: int = attr.ib(converter=to_int)\r\n\r\n    def __attrs_post_init__(self) -> None:\r\n        raise Exception(\"Foo\")\r\n\r\nFoo(6)\r\n```\r\n\r\nOn each run you get a different traceback:\r\n```\r\nTraceback (most recent call last):\r\n  File \"foo.py\", line 16, in <module>\r\n    Foo(6)\r\n  File \"<attrs generated init ffbad27a615cd941c6e78e9521839574191a5a83>\", line 3, in __init__\r\n  File \"foo.py\", line 12, in __attrs_post_init__\r\n    raise Exception(\"Foo\")\r\nException: Foo\r\n```\r\n\r\nThe hash is generated from the `repr(attrs)` but in this case it changes:\r\n```\r\n[Attribute(name='x', default=NOTHING, validator=None, repr=True, cmp=True, hash=None, init=True, metadata=mappingproxy({}), type=<class 'int'>, converter=<function to_int at 0x1086cf0d0>, kw_only=False)]\r\n```\r\nAnd here's another run:\r\n```\r\n[Attribute(name='x', default=NOTHING, validator=None, repr=True, cmp=True, hash=None, init=True, metadata=mappingproxy({}), type=<class 'int'>, converter=<function to_int at 0x101f2f0d0>, kw_only=False)]\r\n```\r\n\r\n\r\n\r\n\nYeah should be definitely fixed then.\nI notice that in tracebacks the python interpreter will only show the names of functions, not the address.  Presumably Attribute repr needs to filter function values this way.\nSo just for posterity, this is the reason why we can't just use `__module__` and `__qualname__`:\r\n\r\n```python\r\nclass C:\r\n    pass\r\n\r\nD = C\r\n\r\nclass C:\r\n    pass\r\n\r\n\r\nprint(f\"{ D.__module__ }.{ D.__qualname__ }\")\r\nprint(f\"{ C.__module__ }.{ C.__qualname__ }\")\r\n```\r\n\r\nWhat we need is an id that is unequivocal per class, but stable over restarts. Removing the id from the function reprs doesn't help here, because of the same reason: it could be different functions with the same name.\r\n\r\nIdeas?\nWhich problem is worse: nondeterministic tracebacks, or some outlier case where all attrs are identical except for a function param with overloaded name, affecting pdb debugging?\nThat depends on your use-case. FWIW, one of the most common FUD arguments against `attrs` is/was that you can't properly debug generated code.\r\n\r\nI guess we could lower the probability by using qualnames/modules as part of the function repr?\nHere's a proposal:\r\n\r\nGenerate the filename from the qualified name (e.g. `__attrs__generated_{__module__}_{__qualname__}.py`. Check the `linecache` to see if that file exists.  If it does, then modify the filename (append a number e.g. \"`_2`\")  Repeat until you find an unused filename.\r\n\r\nTools like sentry might get confused if you rearrange this code.  But I believe having repeated classes like this might be rare enough that this is good enough.\r\n\r\nIf this sounds like a decent solution I can work on a PR.  \r\n\r\nOh and for the record it appears that sentry uses the following information to determine a \"fingerprint\"  \r\n\r\n>Depending on the information available, the following data can be used for each stack trace frame:\r\n> \r\n> * Module name\r\n> * Normalized filename (with revision hashes, etc. removed)\r\n> * Normalized context line (essentially a cleaned up version of the sourcecode of the affected line, if provided)\r\n\r\nFrom https://docs.sentry.io/data-management/rollups/?platform=python#grouping-by-stacktrace\r\n\nSounds great! I guess we have to take care about threadsafety here?\nI suspect `__qualname__` is sufficient for the common case-- and it's desirable for being the most readable and not subject to change when files are moved around in the project.\r\n\r\nPlease consider the variant where `__qualname__` is the default, and append `{__module__}_{n}` on collision.\nThat would lead to more unpredictable name churn though. I think it's quite common that you have the same classname in different packages/modules. Depending on import order and other randomness, the numbers could change wildly.\r\n\r\nMaking the module part of the file name is coherent with how it's work with non-attrs classes, so I think that's the best way forward overall.\nQuestion: What does this mean in the code:\r\n\r\n    # We cache the generated init methods for the same kinds of attributes.\r\n\r\nI can't find any cache aside from the linecache.  And we don't look up anything in that.\nI think it means the linecache, that it gets re-used for the identical class? I really want to get rid of all that crap, especially so we maybe can put the name of the class into the docstring.",
        "created_at": "2019-07-30T14:12:44Z",
        "version": "19.1"
    }
}