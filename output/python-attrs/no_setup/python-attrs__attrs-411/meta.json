{
    "task_id": "python-attrs__attrs-411",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-411_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 411,
        "instance_id": "python-attrs__attrs-411",
        "issue_numbers": [
            "106",
            "38"
        ],
        "base_commit": "3363bb35dc8680708bf82e2d87629d64dabc6c01",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -1,5 +1,6 @@\n from __future__ import absolute_import, division, print_function\n \n+import copy\n import hashlib\n import linecache\n import sys\n@@ -21,6 +22,7 @@\n     DefaultAlreadySetError,\n     FrozenInstanceError,\n     NotAnAttrsClassError,\n+    PythonTooOldError,\n     UnannotatedAttributeError,\n )\n \n@@ -79,6 +81,7 @@ def attrib(\n     type=None,\n     converter=None,\n     factory=None,\n+    kw_only=False,\n ):\n     \"\"\"\n     Create a new attribute on a class.\n@@ -151,6 +154,9 @@ def attrib(\n         This argument is provided for backward compatibility.\n         Regardless of the approach used, the type will be stored on\n         ``Attribute.type``.\n+    :param kw_only: Make this attribute keyword-only (Python 3+)\n+        in the generated ``__init__`` (if ``init`` is ``False``, this\n+        parameter is ignored).\n \n     .. versionadded:: 15.2.0 *convert*\n     .. versionadded:: 16.3.0 *metadata*\n@@ -163,6 +169,7 @@ def attrib(\n        *convert* to achieve consistency with other noun-based arguments.\n     .. versionadded:: 18.1.0\n        ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.\n+    .. versionadded:: 18.2.0 *kw_only*\n     \"\"\"\n     if hash is not None and hash is not True and hash is not False:\n         raise TypeError(\n@@ -206,6 +213,7 @@ def attrib(\n         converter=converter,\n         metadata=metadata,\n         type=type,\n+        kw_only=kw_only,\n     )\n \n \n@@ -285,7 +293,7 @@ def _counter_getter(e):\n     return e[1].counter\n \n \n-def _transform_attrs(cls, these, auto_attribs):\n+def _transform_attrs(cls, these, auto_attribs, kw_only):\n     \"\"\"\n     Transform all `_CountingAttr`s on a class into `Attribute`s.\n \n@@ -368,19 +376,22 @@ def _transform_attrs(cls, these, auto_attribs):\n \n     AttrsClass = _make_attr_tuple_class(cls.__name__, attr_names)\n \n-    attrs = AttrsClass(\n-        super_attrs\n-        + [\n-            Attribute.from_counting_attr(\n-                name=attr_name, ca=ca, type=anns.get(attr_name)\n-            )\n-            for attr_name, ca in ca_list\n-        ]\n-    )\n+    if kw_only:\n+        own_attrs = [a._assoc(kw_only=True) for a in own_attrs]\n+        super_attrs = [a._assoc(kw_only=True) for a in super_attrs]\n+\n+    attrs = AttrsClass(super_attrs + own_attrs)\n \n     had_default = False\n+    was_kw_only = False\n     for a in attrs:\n-        if had_default is True and a.default is NOTHING and a.init is True:\n+        if (\n+            was_kw_only is False\n+            and had_default is True\n+            and a.default is NOTHING\n+            and a.init is True\n+            and a.kw_only is False\n+        ):\n             raise ValueError(\n                 \"No mandatory attributes allowed after an attribute with a \"\n                 \"default value or factory.  Attribute in question: %r\" % (a,)\n@@ -389,8 +400,21 @@ def _transform_attrs(cls, these, auto_attribs):\n             had_default is False\n             and a.default is not NOTHING\n             and a.init is not False\n+            and\n+            # Keyword-only attributes without defaults can be specified\n+            # after keyword-only attributes with defaults.\n+            a.kw_only is False\n         ):\n             had_default = True\n+        if was_kw_only is True and a.kw_only is False:\n+            raise ValueError(\n+                \"Non keyword-only attributes are not allowed after a \"\n+                \"keyword-only attribute.  Attribute in question: {a!r}\".format(\n+                    a=a\n+                )\n+            )\n+        if was_kw_only is False and a.init is True and a.kw_only is True:\n+            was_kw_only = True\n \n     return _Attributes((attrs, super_attrs, super_attr_map))\n \n@@ -427,9 +451,9 @@ class _ClassBuilder(object):\n         \"_super_attr_map\",\n     )\n \n-    def __init__(self, cls, these, slots, frozen, auto_attribs):\n+    def __init__(self, cls, these, slots, frozen, auto_attribs, kw_only):\n         attrs, super_attrs, super_map = _transform_attrs(\n-            cls, these, auto_attribs\n+            cls, these, auto_attribs, kw_only\n         )\n \n         self._cls = cls\n@@ -639,6 +663,7 @@ def attrs(\n     frozen=False,\n     str=False,\n     auto_attribs=False,\n+    kw_only=False,\n ):\n     r\"\"\"\n     A class decorator that adds `dunder\n@@ -736,6 +761,10 @@ def attrs(\n         Attributes annotated as :data:`typing.ClassVar` are **ignored**.\n \n         .. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/\n+    :param bool kw_only: Make all attributes keyword-only (Python 3+)\n+        in the generated ``__init__`` (if ``init`` is ``False``, this\n+        parameter is ignored).\n+\n \n     .. versionadded:: 16.0.0 *slots*\n     .. versionadded:: 16.1.0 *frozen*\n@@ -752,13 +781,16 @@ def attrs(\n        :class:`DeprecationWarning` if the classes compared are subclasses of\n        each other. ``__eq`` and ``__ne__`` never tried to compared subclasses\n        to each other.\n+    .. versionadded:: 18.2.0 *kw_only*\n     \"\"\"\n \n     def wrap(cls):\n         if getattr(cls, \"__class__\", None) is None:\n             raise TypeError(\"attrs only works with new-style classes.\")\n \n-        builder = _ClassBuilder(cls, these, slots, frozen, auto_attribs)\n+        builder = _ClassBuilder(\n+            cls, these, slots, frozen, auto_attribs, kw_only\n+        )\n \n         if repr is True:\n             builder.add_repr(repr_ns)\n@@ -1298,6 +1330,7 @@ def fmt_setter_with_converter(attr_name, value_var):\n             }\n \n     args = []\n+    kw_only_args = []\n     attrs_to_validate = []\n \n     # This is a dictionary of names to validator and converter callables.\n@@ -1357,11 +1390,13 @@ def fmt_setter_with_converter(attr_name, value_var):\n                         )\n                     )\n         elif a.default is not NOTHING and not has_factory:\n-            args.append(\n-                \"{arg_name}=attr_dict['{attr_name}'].default\".format(\n-                    arg_name=arg_name, attr_name=attr_name\n-                )\n+            arg = \"{arg_name}=attr_dict['{attr_name}'].default\".format(\n+                arg_name=arg_name, attr_name=attr_name\n             )\n+            if a.kw_only:\n+                kw_only_args.append(arg)\n+            else:\n+                args.append(arg)\n             if a.converter is not None:\n                 lines.append(fmt_setter_with_converter(attr_name, arg_name))\n                 names_for_globals[\n@@ -1370,7 +1405,11 @@ def fmt_setter_with_converter(attr_name, value_var):\n             else:\n                 lines.append(fmt_setter(attr_name, arg_name))\n         elif has_factory:\n-            args.append(\"{arg_name}=NOTHING\".format(arg_name=arg_name))\n+            arg = \"{arg_name}=NOTHING\".format(arg_name=arg_name)\n+            if a.kw_only:\n+                kw_only_args.append(arg)\n+            else:\n+                args.append(arg)\n             lines.append(\n                 \"if {arg_name} is not NOTHING:\".format(arg_name=arg_name)\n             )\n@@ -1402,7 +1441,10 @@ def fmt_setter_with_converter(attr_name, value_var):\n                 )\n             names_for_globals[init_factory_name] = a.default.factory\n         else:\n-            args.append(arg_name)\n+            if a.kw_only:\n+                kw_only_args.append(arg_name)\n+            else:\n+                args.append(arg_name)\n             if a.converter is not None:\n                 lines.append(fmt_setter_with_converter(attr_name, arg_name))\n                 names_for_globals[\n@@ -1428,13 +1470,23 @@ def fmt_setter_with_converter(attr_name, value_var):\n     if post_init:\n         lines.append(\"self.__attrs_post_init__()\")\n \n+    args = \", \".join(args)\n+    if kw_only_args:\n+        if PY2:\n+            raise PythonTooOldError(\n+                \"Keyword-only arguments only work on Python 3 and later.\"\n+            )\n+\n+        args += \"{leading_comma}*, {kw_only_args}\".format(\n+            leading_comma=\", \" if args else \"\",\n+            kw_only_args=\", \".join(kw_only_args),\n+        )\n     return (\n         \"\"\"\\\n def __init__(self, {args}):\n     {lines}\n \"\"\".format(\n-            args=\", \".join(args),\n-            lines=\"\\n    \".join(lines) if lines else \"pass\",\n+            args=args, lines=\"\\n    \".join(lines) if lines else \"pass\"\n         ),\n         names_for_globals,\n         annotations,\n@@ -1463,6 +1515,7 @@ class Attribute(object):\n         \"metadata\",\n         \"type\",\n         \"converter\",\n+        \"kw_only\",\n     )\n \n     def __init__(\n@@ -1478,6 +1531,7 @@ def __init__(\n         metadata=None,\n         type=None,\n         converter=None,\n+        kw_only=False,\n     ):\n         # Cache this descriptor here to speed things up later.\n         bound_setattr = _obj_setattr.__get__(self, Attribute)\n@@ -1515,6 +1569,7 @@ def __init__(\n             ),\n         )\n         bound_setattr(\"type\", type)\n+        bound_setattr(\"kw_only\", kw_only)\n \n     def __setattr__(self, name, value):\n         raise FrozenInstanceError()\n@@ -1558,6 +1613,17 @@ def from_counting_attr(cls, name, ca, type=None):\n             **inst_dict\n         )\n \n+    # Don't use attr.assoc since fields(Attribute) doesn't work\n+    def _assoc(self, **changes):\n+        \"\"\"\n+        Copy *self* and apply *changes*.\n+        \"\"\"\n+        new = copy.copy(self)\n+\n+        new._setattrs(changes.items())\n+\n+        return new\n+\n     # Don't use _add_pickle since fields(Attribute) doesn't work\n     def __getstate__(self):\n         \"\"\"\n@@ -1572,8 +1638,11 @@ def __setstate__(self, state):\n         \"\"\"\n         Play nice with pickle.\n         \"\"\"\n+        self._setattrs(zip(self.__slots__, state))\n+\n+    def _setattrs(self, name_values_pairs):\n         bound_setattr = _obj_setattr.__get__(self, Attribute)\n-        for name, value in zip(self.__slots__, state):\n+        for name, value in name_values_pairs:\n             if name != \"metadata\":\n                 bound_setattr(name, value)\n             else:\n@@ -1625,6 +1694,7 @@ class _CountingAttr(object):\n         \"_validator\",\n         \"converter\",\n         \"type\",\n+        \"kw_only\",\n     )\n     __attrs_attrs__ = tuple(\n         Attribute(\n@@ -1635,6 +1705,7 @@ class _CountingAttr(object):\n             cmp=True,\n             hash=True,\n             init=True,\n+            kw_only=False,\n         )\n         for name in (\"counter\", \"_default\", \"repr\", \"cmp\", \"hash\", \"init\")\n     ) + (\n@@ -1646,6 +1717,7 @@ class _CountingAttr(object):\n             cmp=True,\n             hash=False,\n             init=True,\n+            kw_only=False,\n         ),\n     )\n     cls_counter = 0\n@@ -1661,6 +1733,7 @@ def __init__(\n         converter,\n         metadata,\n         type,\n+        kw_only,\n     ):\n         _CountingAttr.cls_counter += 1\n         self.counter = _CountingAttr.cls_counter\n@@ -1677,6 +1750,7 @@ def __init__(\n         self.converter = converter\n         self.metadata = metadata\n         self.type = type\n+        self.kw_only = kw_only\n \n     def validator(self, meth):\n         \"\"\"\ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\n--- a/src/attr/exceptions.py\n+++ b/src/attr/exceptions.py\n@@ -47,3 +47,11 @@ class UnannotatedAttributeError(RuntimeError):\n \n     .. versionadded:: 17.3.0\n     \"\"\"\n+\n+\n+class PythonTooOldError(RuntimeError):\n+    \"\"\"\n+    An ``attrs`` feature requiring a more recent python version has been used.\n+\n+    .. versionadded:: 18.2.0\n+    \"\"\"\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -229,3 +229,24 @@ class C:\n             \"foo\": \"typing.Any\",\n             \"return\": None,\n         }\n+\n+    def test_keyword_only_auto_attribs(self):\n+        \"\"\"\n+        `kw_only` propagates to attributes defined via `auto_attribs`.\n+        \"\"\"\n+\n+        @attr.s(auto_attribs=True, kw_only=True)\n+        class C:\n+            x: int\n+            y: int\n+\n+        with pytest.raises(TypeError):\n+            C(0, 1)\n+\n+        with pytest.raises(TypeError):\n+            C(x=0)\n+\n+        c = C(x=0, y=1)\n+\n+        assert c.x == 0\n+        assert c.y == 1\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -35,7 +35,11 @@\n     make_class,\n     validate,\n )\n-from attr.exceptions import DefaultAlreadySetError, NotAnAttrsClassError\n+from attr.exceptions import (\n+    DefaultAlreadySetError,\n+    NotAnAttrsClassError,\n+    PythonTooOldError,\n+)\n \n from .strategies import (\n     gen_attr_names,\n@@ -229,7 +233,7 @@ def test_no_modifications(self):\n         Doesn't attach __attrs_attrs__ to the class anymore.\n         \"\"\"\n         C = make_tc()\n-        _transform_attrs(C, None, False)\n+        _transform_attrs(C, None, False, False)\n \n         assert None is getattr(C, \"__attrs_attrs__\", None)\n \n@@ -238,7 +242,7 @@ def test_normal(self):\n         Transforms every `_CountingAttr` and leaves others (a) be.\n         \"\"\"\n         C = make_tc()\n-        attrs, _, _ = _transform_attrs(C, None, False)\n+        attrs, _, _ = _transform_attrs(C, None, False, False)\n \n         assert [\"z\", \"y\", \"x\"] == [a.name for a in attrs]\n \n@@ -251,14 +255,16 @@ def test_empty(self):\n         class C(object):\n             pass\n \n-        assert _Attributes(((), [], {})) == _transform_attrs(C, None, False)\n+        assert _Attributes(((), [], {})) == _transform_attrs(\n+            C, None, False, False\n+        )\n \n     def test_transforms_to_attribute(self):\n         \"\"\"\n         All `_CountingAttr`s are transformed into `Attribute`s.\n         \"\"\"\n         C = make_tc()\n-        attrs, super_attrs, _ = _transform_attrs(C, None, False)\n+        attrs, super_attrs, _ = _transform_attrs(C, None, False, False)\n \n         assert [] == super_attrs\n         assert 3 == len(attrs)\n@@ -275,15 +281,46 @@ class C(object):\n             y = attr.ib()\n \n         with pytest.raises(ValueError) as e:\n-            _transform_attrs(C, None, False)\n+            _transform_attrs(C, None, False, False)\n         assert (\n             \"No mandatory attributes allowed after an attribute with a \"\n             \"default value or factory.  Attribute in question: Attribute\"\n             \"(name='y', default=NOTHING, validator=None, repr=True, \"\n             \"cmp=True, hash=None, init=True, metadata=mappingproxy({}), \"\n-            \"type=None, converter=None)\",\n+            \"type=None, converter=None, kw_only=False)\",\n         ) == e.value.args\n \n+    def test_kw_only(self):\n+        \"\"\"\n+        Converts all attributes, including superclass attributes, if `kw_only`\n+        is provided. Therefore, `kw_only` allows attributes with defaults to\n+        preceed mandatory attributes.\n+\n+        Updates in the subclass *don't* affect the superclass attributes.\n+        \"\"\"\n+\n+        @attr.s\n+        class B(object):\n+            b = attr.ib()\n+\n+        for b_a in B.__attrs_attrs__:\n+            assert b_a.kw_only is False\n+\n+        class C(B):\n+            x = attr.ib(default=None)\n+            y = attr.ib()\n+\n+        attrs, super_attrs, _ = _transform_attrs(C, None, False, True)\n+\n+        assert len(attrs) == 3\n+        assert len(super_attrs) == 1\n+\n+        for a in attrs:\n+            assert a.kw_only is True\n+\n+        for b_a in B.__attrs_attrs__:\n+            assert b_a.kw_only is False\n+\n     def test_these(self):\n         \"\"\"\n         If these is passed, use it and ignore body and super classes.\n@@ -295,7 +332,9 @@ class Base(object):\n         class C(Base):\n             y = attr.ib()\n \n-        attrs, super_attrs, _ = _transform_attrs(C, {\"x\": attr.ib()}, False)\n+        attrs, super_attrs, _ = _transform_attrs(\n+            C, {\"x\": attr.ib()}, False, False\n+        )\n \n         assert [] == super_attrs\n         assert (simple_attr(\"x\"),) == attrs\n@@ -594,6 +633,182 @@ class C(object):\n                 x = attr.ib(factory=Factory(list))\n \n \n+@pytest.mark.skipif(PY2, reason=\"keyword-only arguments are PY3-only.\")\n+class TestKeywordOnlyAttributes(object):\n+    \"\"\"\n+    Tests for keyword-only attributes.\n+    \"\"\"\n+\n+    def test_adds_keyword_only_arguments(self):\n+        \"\"\"\n+        Attributes can be added as keyword-only.\n+        \"\"\"\n+\n+        @attr.s\n+        class C(object):\n+            a = attr.ib()\n+            b = attr.ib(default=2, kw_only=True)\n+            c = attr.ib(kw_only=True)\n+            d = attr.ib(default=attr.Factory(lambda: 4), kw_only=True)\n+\n+        c = C(1, c=3)\n+\n+        assert c.a == 1\n+        assert c.b == 2\n+        assert c.c == 3\n+        assert c.d == 4\n+\n+    def test_ignores_kw_only_when_init_is_false(self):\n+        \"\"\"\n+        Specifying ``kw_only=True`` when ``init=False`` is essentially a no-op.\n+        \"\"\"\n+\n+        @attr.s\n+        class C(object):\n+            x = attr.ib(init=False, default=0, kw_only=True)\n+            y = attr.ib()\n+\n+        c = C(1)\n+\n+        assert c.x == 0\n+        assert c.y == 1\n+\n+    def test_keyword_only_attributes_presence(self):\n+        \"\"\"\n+        Raises `TypeError` when keyword-only arguments are\n+        not specified.\n+        \"\"\"\n+\n+        @attr.s\n+        class C(object):\n+            x = attr.ib(kw_only=True)\n+\n+        with pytest.raises(TypeError) as e:\n+            C()\n+\n+        assert (\n+            \"missing 1 required keyword-only argument: 'x'\"\n+        ) in e.value.args[0]\n+\n+    def test_conflicting_keyword_only_attributes(self):\n+        \"\"\"\n+        Raises `ValueError` if keyword-only attributes are followed by\n+        regular (non keyword-only) attributes.\n+        \"\"\"\n+\n+        class C(object):\n+            x = attr.ib(kw_only=True)\n+            y = attr.ib()\n+\n+        with pytest.raises(ValueError) as e:\n+            _transform_attrs(C, None, False, False)\n+\n+        assert (\n+            \"Non keyword-only attributes are not allowed after a \"\n+            \"keyword-only attribute.  Attribute in question: Attribute\"\n+            \"(name='y', default=NOTHING, validator=None, repr=True, \"\n+            \"cmp=True, hash=None, init=True, metadata=mappingproxy({}), \"\n+            \"type=None, converter=None, kw_only=False)\",\n+        ) == e.value.args\n+\n+    def test_keyword_only_attributes_allow_subclassing(self):\n+        \"\"\"\n+        Subclass can define keyword-only attributed without defaults,\n+        when the base class has attributes with defaults.\n+        \"\"\"\n+\n+        @attr.s\n+        class Base(object):\n+            x = attr.ib(default=0)\n+\n+        @attr.s\n+        class C(Base):\n+            y = attr.ib(kw_only=True)\n+\n+        c = C(y=1)\n+\n+        assert c.x == 0\n+        assert c.y == 1\n+\n+    def test_keyword_only_class_level(self):\n+        \"\"\"\n+        `kw_only` can be provided at the attr.s level, converting all\n+        attributes to `kw_only.`\n+        \"\"\"\n+\n+        @attr.s(kw_only=True)\n+        class C:\n+            x = attr.ib()\n+            y = attr.ib(kw_only=True)\n+\n+        with pytest.raises(TypeError):\n+            C(0, y=1)\n+\n+        c = C(x=0, y=1)\n+\n+        assert c.x == 0\n+        assert c.y == 1\n+\n+    def test_keyword_only_class_level_subclassing(self):\n+        \"\"\"\n+        Subclass `kw_only` propagates to attrs inherited from the base,\n+        allowing non-default following default.\n+        \"\"\"\n+\n+        @attr.s\n+        class Base(object):\n+            x = attr.ib(default=0)\n+\n+        @attr.s(kw_only=True)\n+        class C(Base):\n+            y = attr.ib()\n+\n+        with pytest.raises(TypeError):\n+            C(1)\n+\n+        c = C(x=0, y=1)\n+\n+        assert c.x == 0\n+        assert c.y == 1\n+\n+\n+@pytest.mark.skipif(not PY2, reason=\"PY2-specific keyword-only error behavior\")\n+class TestKeywordOnlyAttributesOnPy2(object):\n+    \"\"\"\n+    Tests for keyword-only attribute behavior on py2.\n+    \"\"\"\n+\n+    def test_syntax_error(self):\n+        \"\"\"\n+        Keyword-only attributes raise Syntax error on ``__init__`` generation.\n+        \"\"\"\n+\n+        with pytest.raises(PythonTooOldError):\n+\n+            @attr.s(kw_only=True)\n+            class ClassLevel(object):\n+                a = attr.ib()\n+\n+        with pytest.raises(PythonTooOldError):\n+\n+            @attr.s()\n+            class AttrLevel(object):\n+                a = attr.ib(kw_only=True)\n+\n+    def test_no_init(self):\n+        \"\"\"\n+        Keyworld-only is a no-op, not any error, if ``init=false``.\n+        \"\"\"\n+\n+        @attr.s(kw_only=True, init=False)\n+        class ClassLevel(object):\n+            a = attr.ib()\n+\n+        @attr.s(init=False)\n+        class AttrLevel(object):\n+            a = attr.ib(kw_only=True)\n+\n+\n @attr.s\n class GC(object):\n     @attr.s\n@@ -1153,7 +1368,7 @@ def test_repr(self):\n         class C(object):\n             pass\n \n-        b = _ClassBuilder(C, None, True, True, False)\n+        b = _ClassBuilder(C, None, True, True, False, False)\n \n         assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n \n@@ -1165,7 +1380,7 @@ def test_returns_self(self):\n         class C(object):\n             x = attr.ib()\n \n-        b = _ClassBuilder(C, None, True, True, False)\n+        b = _ClassBuilder(C, None, True, True, False, False)\n \n         cls = (\n             b.add_cmp()\n@@ -1222,7 +1437,12 @@ class C(object):\n             pass\n \n         b = _ClassBuilder(\n-            C, these=None, slots=False, frozen=False, auto_attribs=False\n+            C,\n+            these=None,\n+            slots=False,\n+            frozen=False,\n+            auto_attribs=False,\n+            kw_only=False,\n         )\n         b._cls = {}  # no __module__; no __qualname__\n \ndiff --git a/tests/utils.py b/tests/utils.py\n--- a/tests/utils.py\n+++ b/tests/utils.py\n@@ -36,6 +36,7 @@ def simple_attr(\n     hash=None,\n     init=True,\n     converter=None,\n+    kw_only=False,\n ):\n     \"\"\"\n     Return an attribute with a name and no other bells and whistles.\n@@ -49,6 +50,7 @@ def simple_attr(\n         hash=hash,\n         init=init,\n         converter=converter,\n+        kw_only=False,\n     )\n \n \n",
        "problem_statement": "Add support for keyword only arguments\nThere was a suggestion in #38 that there be an option to make arguments keyword only. The suggested API was to have something like:\n\n``` python\n    @attr.s\n    class A:\n        a = attr.ib()\n        b = attr.ib(init='kwonly')\n\n        # __init__ signature is:\n        # def __init__(self, a, *, b):\n        #    pass\n```\n\nWould support for this be accepted? What about\n\n``` python\n    @attr.s(kwonly=True)\n    class A:\n        a = attr.ib()\n        b = attr.ib()\n\n        # __init__ signature is:\n        # def __init__(self, *, a, b):\n        #    pass\n```\n\nwhich may be nicer when subclassing?\n\nsubclass with mandatory attribute cannot be created when the base class has a factory based one\nfailing example\n\n```\nimport attr\n\ndef test_example():\n\n    @attr.s\n    class Base(object):\n        attr = attr.ib(default=False)\n\n    @attr.s\n    class Sub(Base):\n        needed = attr.ib()\n```\n\n",
        "hints_text": "This functionality would be nice for the \"big bag of configuration\" use case.  I don't really want to be able to pass my 19 different configuration items positionally.  It would be totally unreadable.\r\n\r\nCurrently I have to make sure to carefully order my attribute definitions to avoid running into limitations about what can have a default and what cannot.  If everything were keyword-only, this would go away.\r\n\r\nThis use-case would be better served by an API like the latter suggested above (so the setting doesn't have to be repeated 19 times).  The existence of both of the proposed APIs wouldn't hurt this use case, though.\nI can already use keywords arguments to build `attrs` objects. Why do you need a parameter to enforce it ? (i/e : disable positionnal arguments)\nKwonly attributes would have to have defaults, no? How does that work with with the class decorator approach?\r\n\r\n> Currently I have to make sure to carefully order my attribute definitions to avoid running into limitations about what can have a default and what cannot. If everything were keyword-only, this would go away.\r\n\r\nIf kwonly attributes must have defaults, this wouldn't solve anything for you. You can set defaults today on everything and not care about ordering attributes.\r\n\r\n> I don't really want to be able to pass my 19 different configuration items positionally. It would be totally unreadable.\r\n\r\nNot sure what you mean here, could you clarify? You'd like to disable positional arguments on your `__init__` altogether? I mean, that's fine, but you don't actually have to use this feature.\r\n\r\nI thought you might be disagreeing with having to carefully position arguments to `__init__`, but that's not really the case currently, or `C(**attr.asdict(C()))` wouldn't work.\nI want to be able to write this:\r\n\r\n```\r\n    @attr.s\r\n    class A(object):\r\n        a = attr.ib(default=\"abc\")\r\n        b = attr.ib()\r\n```\r\n\r\nThis is not currently possible because:\r\n\r\n```\r\nValueError: No mandatory attributes allowed after an attribute with a default value or factory.  Attribute in question: Attribute(name='b', default=NOTHING, validator=None, repr=True, cmp=True, hash=True, init=True, convert=None)\r\n```\r\n\r\nAs a work-around, I can re-arrange the attributes on my class every time I add or remove a default - but I'd much rather just say something like `@attr.s(positional=False)` and not worry about the order.\n@Tinche No, keyword only is different to having a default.\r\nDefault argument:\r\n```\r\ndef a(a=1):\r\n    pass\r\n```\r\nis different to keyword only with default:\r\n```\r\ndef a(*, a=1):\r\n    pass\r\n```\r\nis different to keyword only\r\n```\r\ndef a(*, a):\r\n    pass\r\n```\r\n\r\nMy original question was what should the API be?\nHuh, guess I learned something today. None of the examples in the PEP 3102 show a kw-only argument without a default, but the text mentions it (I just skimmed the text :).\r\n\r\nAnyway, continuing the discussion. Currently the definition order of attributes is the same as the order of the attributes in the generated `__init__`. This is strictly by @hynek's executive order and I personally agree with the rationale. If it wasn't intentional we would just sort the attributes and you wouldn't need to put arguments with defaults last. The order of definition is used in other places too: the `__repr__`, comparison methods, `attr.fields`.\r\n\r\nKeeping with this design decision, if your attributes were a mix of normal and kwonly attributes, you'd still need to define your kwonly attributes after the normal ones.\r\n\r\n```\r\n@attr.s\r\nclass A:\r\n    a = attr.ib()\r\n    b = attr.ib(init='kwonly')\r\n```\r\n\r\nThe idea all attributes could be marked as kwonly is also being floated around:\r\n\r\n```\r\n@attr.s(init='kwonly')\r\nclass A:\r\n    a = attr.ib(default=0)\r\n    b = attr.ib()\r\n```\r\n\r\nThe attribute-level kwonly needs support from `attrs` core. The class level could be handled by an additional decorator (that you can write yourself):\r\n\r\n```\r\n@attr.s\r\n@kwonly\r\nclass A:\r\n    a = attr.ib(default=0)\r\n    b = attr.ib()\r\n```\r\n\r\nI think this is where we are with the proposals, currently.\nFirst of all: as long as I breathe, there won\u2019t be any strings part of any API. :)\r\n\r\nSecondly, I guess we *could* implement kw-only so mixing is possible by moving default values into ``__init__`` as it used to be in `characteristic` and simply set all attributes to `NOTHING`.  Adding a `*,` on Py3 is more of a nifty goodie.\r\n\r\nPrecondition is that it must not have any performance implications for common use cases.\r\n\r\nThirdly, I\u2019m totally _not_ implementing it. :)\n@hynek \r\n```\r\nfrom enum import Enum\r\n\r\nclass InitType(Enum):\r\n    PRESENT = True\r\n    ABSENT = False\r\n    KWONLY = \"kwonly\"\r\n\r\nattr.ib(init=True) === attr.ib(init=InitType.PRESENT)\r\nattr.ib(init='kwonly') === attr.ib(init=InitType.KWONLY)\r\n```\r\nIt's backward compatible, and supports not using the enum when you don't feel like it (i.e. the REPL or using timeit).\r\n\r\n> Secondly, I guess we could implement kw-only so mixing is possible by moving default values into __init__ as it used to be in characteristic and simply set all attributes to NOTHING. Adding a *, on Py3 is more of a nifty goodie.\r\n\r\nIs this a response to the issue of having to order the attributes so attributes with defaults are last? I think a separate issue should be created for commenting on this, since it's almost orthogonal to kwonly arguments. (We could implement kwonly args without touching the rule, or the rule could be changed without implementing kwonly args at all, and kwonly args would be useful even if we change the rule.)\nI feel like kwonly is a red herring.  I don\u2019t see *any* reason to add *any* complexity just so people can\u2019t pass argument by order.\r\n\r\nOTOH being able to mix default with non-defaults is an actual use case that *might* be mitigated by a kwonly design.  But focusing on the former seems backward to me.\nI've used kw-only arguments pretty regularly since their addition.  My main reasons for doing so:\r\n\r\n- **raising the difficulty of calling code incorrectly** (it's not impossible to say `Foo(should_be_bar=quux, should_be_quux=bar)`, but it's more obvious in coding and review that that's wrong than if you're allowed to write `Foo(quux, bar)`)\r\n- **faster failure in error cases** (`Foo(quux, bar)` fails on call with a nice error, rather than having some logic/type error occur several calls later).  (yes, `Foo(bar, quux)` is 'correct' and also fails with kw-only args, but the gains from fast failure and obvious code outweigh this, IMO)\r\n- **readability/explicitness**.  yep, it's more to type, but it's also faster to comprehend.  You don't *need* kw-only args to init classes with keywords, but if using keywords for code clarity is important to the project, you want some kind of enforcement.  You could try to enforce that when doing code review or with static analysis, but those are never going to be as reliable as language-level support.\r\n\r\nYou don't have to agree, of course, but since nobody else responded after you said you don't see *any* reason, I thought I'd list the ones I find compelling in the projects/teams I've been working on.\r\n\r\nThere's also [the official python reason for including them](https://www.python.org/dev/peps/pep-3102/#rationale) in the language, which I also appreciate from time to time for functions, and actually isn't about preventing people from passing arguments by order - it's about allowing people to specify arguments by keyword after using varargs:\r\n\r\n\r\n> The current Python function-calling paradigm allows arguments to be specified either by position or by keyword. An argument can be filled in either explicitly by name, or implicitly by position.\r\n> \r\n> There are often cases where it is desirable for a function to take a variable number of arguments. The Python language supports this using the 'varargs' syntax ( *name ), which specifies that any 'left over' arguments be passed into the varargs parameter as a tuple.\r\n> \r\n> One limitation on this is that currently, all of the regular argument slots must be filled before the vararg slot can be.\r\n> \r\n> This is not always desirable. One can easily envision a function which takes a variable number of arguments, but also takes one or more 'options' in the form of keyword arguments. Currently, the only way to do this is to define both a varargs argument, and a 'keywords' argument ( **kwargs ), and then manually extract the desired keywords from the dictionary.\r\n\r\nWhile I appreciate that use case from time to time for functions... I don't know that I've ever actually wanted to do keywords after varargs in a class init, but `\u00af\\_(\u30c4)_/\u00af`.  \nFWIW there\u2019s two levels to it:\r\n\r\n1. are we gonna allow the user to make certain args kwonly and others not?  I find this introduces too much complexity for too little gain and we\u2019d regret it later.\r\n2. `@attr.s(init_kwonly=True)` that only works on Python 3 by adding a `*` after `self` is something I could get behind.  Although that leads to weirdness if you want to write cross-platform code.  So we\u2019d have to change the signature to `__init__(self, **kw)` and extract the arguments within __init__ which is also kind of tedious.  :|  I might merge a good PR for this one but I\u2019m not gonna write it.\nfwiw, a trick for py2 (who uses that anyway nowadays?) is to add a `_please_use_kwargs=None` arg as the first arg after `self`. i have seen this in the wild but cannot recall where.\nwhile one might think the extra \"marker arg\" is ugly, it actually gives much better info in `help()` output (and sphinx autoclass docs) than `**kwargs` does.\nI think I could live with such an hack on Python 2.\nI'm in favor of the class-wide `@attr.s(kwonly=True)` option for reasons similar to @exarkun.  I don't want reordering of attributes to be an API-incompatible change, but I have no good way to prevent called for using them positionally.\r\n\r\nThe per-attribute constraint seems like it might add more complexity than it's worth, but that may be simply because it's not a use case I have at the moment\u2026 perhaps as a compatibility thing where you have an existing class and you want all new attributes to be kwarg-only?\r\n\r\nBut I'd love to see the class-level constraint.\nI'd love to see this, too. And, while the granularity of the per-`attr.ib()` `kwonly` specification would be nice to have, the class-wide option would still be tremendously useful.\nThis has been reported before and I\u2019m not sure what to do about it.  putting mandatory always before optionals?  iow reordering?\n\nthey can always be given as keyword\n\nthe order should stay the same\n\nit should be possible to give them as keyword instead of a positional argument\n\nonce inheritance is involved it seems sensible to go towards keywords in any case\n\nbasically all mandatory arguments after a optional one can be primary keyword based\n\nbtw, i do in fact use them as keywords, but putting in a default of None seems the wrong way\n\nI kind of agree, but what\u2019s better?  having a sentinel and explode on it?\n\nnot quite sure what you mean by the sentinel\n\nfor the code in the example i posted i think that `Sub(needed='foo')` should work since all mandatory arguments where given\n\nwhat you sketched it results in\n\n``` python\ndef __init__(self, attr=False, needed):\n    pass\n```\n\nwhich is a syntax error.\n\nSo we need some default value for needed here.\n\ni see what you mean, in python3 its  `*,` and valid, for python2 there is need for a workaround in form of a sentinel object and exploding then\n\nI accidentally opened up a duplicate of this.\n\nMy personal opinion\u2122 is that we should just allow users to mark attributes as `init='kwonly'`. That will allow users to fix the problem themselves on Python 3 and consider upgrading on Python 2. \ud83d\ude3d\n\nFull example:\n\n```\n@attr.s\nclass A:\n    a = attr.ib()\n    b = attr.ib(init='kwonly', default=1)\n\n    # __init__ signature is:\n    def __init__(self, a, *, b=1):\n        pass\n\n@attr.s\nclass B(A):\n    c = attr.ib()\n\n    # __init__ signature is:\n    def __init__(self, a, c, *, b=1):\n        pass\n```\n\nAlso, in the case of the error we have now, a helpful error message can direct users to use `kwonly`.\n\nI ran into this problem as well and I have a slightly different take on it that I wanted to submit. A more natural solution to me would be to write something like:\r\n\r\n\timport attr\r\n\t\r\n\tdef test_example():\r\n\t\r\n\t    @attr.s\r\n\t    class Base(object):\r\n\t        attr = attr.ib(default=False)\r\n\t\r\n\t    @attr.s\r\n\t    class Sub(Base):\r\n\t        needed = attr.ib()\r\n\t        attr = attr.ib(default=False)\r\n\t        \r\nAt the cost of a very minor repetition of code, this lets the programmer explicitly control the order in which the attributes should appear for representation purposes or when converting to a tuple. However what I wrote obviously doesn't work in the current version of attr: because of the way inheritance is implemented, Sub receives two 'attr' attributes, which happens to break the \\_\\_init\\_\\_ method among other things. I do have a bit of beef with that and was both curious about why attributes don't get overridden in subclasses, and willing to do something about it -then I saw this issue and thought that would be a good starting point for my comment.\nhow about this: \r\n- add optional class-level var that defines the order of arguments (as list of strings?)\r\n- if some required argument encountered in the child, fail with error, requesting explicit order of attributes specified?\r\n- users can use required arguments in children but must provide order themselves explicitly\r\n\nsince this is starting to turn into a mirad of dozens and dozens of options i believe this should either not be supported for the sake of simplicity or be supported only by disabling positional constructor arguments in the complete inheritance tree\nI tend to agree.  I\u2019m thinking about an option to `@attr.s` that changes the mode of `__init__` from building a proper signature to `def __init__(x=NOTHING, y=NOTHING, z=42, a=NOTHING)` and so forth.  Then it checks at the beginning if there\u2019s a `NOTHING` in mandatory attributes.  It\u2019s slower but only for people who insist to subclass (I would add electro shocks if I could ;)).\nYea I run into this issue a lot when I have some common optional attributes that I want to share across many classes. e.g.\r\n\r\n```\r\n@attr.s()\r\nclass SmallOptions(object):\r\n    verbose = attr.ib(default=None)\r\n    other_option = attr.ib(default=None)\r\n\r\n@attr.s()\r\nclass Main(SmallOptions):\r\n     required = attr.ib()\r\n```\r\n\r\nI'm kinda inspired by go's embedded struct types:\r\n https://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html\r\nhttp://www.hydrogen18.com/blog/golang-embedding.html\r\n which I'd like to replicate that same sort of composability here. Instead of inheriting from SmallOptions, I'd want class Main to 'embed' SmallOptions instance. Maybe it would look something like so.\r\n\r\n```\r\n@attr.s()\r\nclass Main(object):\r\n     required = attr.ib()\r\n     __attrs_embedded__ = {'options': SmallOptions}\r\n```\r\n\r\nwith some __getattr__ generated functionality. There would be a SmallOptions instance embedded within Main instance that would be proxied, and can be accessed directly by Main().options as well. \r\n\r\n\nor like this\r\n```\r\n@attr.s()\r\nclass Main(object):\r\n     required = attr.ib()\r\n     options = attr.embed(SmallOptions)\r\n```",
        "created_at": "2018-07-24T08:36:30Z",
        "version": "18.1"
    }
}