{
    "task_id": "python-attrs__attrs-410",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-410_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 410,
        "instance_id": "python-attrs__attrs-410",
        "issue_numbers": [
            "407",
            "407"
        ],
        "base_commit": "6f3f4904bed568795c96c07579a7a6ebf9ca9062",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -493,7 +493,7 @@ def _create_slots_class(self):\n         cd = {\n             k: v\n             for k, v in iteritems(self._cls_dict)\n-            if k not in tuple(self._attr_names) + (\"__dict__\",)\n+            if k not in tuple(self._attr_names) + (\"__dict__\", \"__weakref__\")\n         }\n \n         # We only add the names of attributes that aren't inherited.\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -5,6 +5,7 @@\n from __future__ import absolute_import, division, print_function\n \n import copy\n+import gc\n import inspect\n import itertools\n import sys\n@@ -1250,6 +1251,25 @@ class C(object):\n \n         assert C() == copy.deepcopy(C())\n \n+    def test_no_references_to_original(self):\n+        \"\"\"\n+        When subclassing a slots class, there are no stray references to the\n+        original class.\n+        \"\"\"\n+\n+        @attr.s(slots=True)\n+        class C(object):\n+            pass\n+\n+        @attr.s(slots=True)\n+        class C2(C):\n+            pass\n+\n+        # The original C2 is in a reference cycle, so force a collect:\n+        gc.collect()\n+\n+        assert [C2] == C.__subclasses__()\n+\n \n class TestMakeCmp:\n     \"\"\"\n",
        "problem_statement": "Slots class holding a reference to the original version\nI have a class hierarchy implemented with slots enabled, like this:\r\n\r\nimport attr\r\n\r\n```python\r\n@attr.s(slots=True)\r\nclass BaseClass(object):\r\n    foo = attr.ib(default='foo')\r\n\r\n@attr.s(slots=True)\r\nclass SubClass(BaseClass):\r\n    bar = attr.ib(default='bar')\r\n```\r\n\r\nThis works fine until I wanted to introspect the class hierarchy:\r\n\r\n```python\r\nBaseClass.__subclasses__()  # returns [<class '__main__.SubClass'>, <class '__main__.SubClass'>]\r\n```\r\n\r\nOne of these is the original class, and the other is the new one created and returned by `attr.s`. This behavior manifests on both Python 3 and Python 2 (3.7.0 and 2.7.14, to be specific).\r\n\r\nMy understanding was that classes kept weak references to their subclasses to allow the `__subclasses__` method to work, and I know that attrs creates and returns a new class when `slots=True`, but it's not clear to me why the old class stays around. I don't see any obvious place where a strong reference to it is held.\r\n\r\nI guessed that there might be a reference cycle somewhere, so I tried adding a call to `gc.collect()` and checking `gc.garbage`, but that turned out to be incorrect.\r\n\r\nBecause I didn't see that the reference-counting mentioned [in this comment](https://github.com/python-attrs/attrs/issues/102#issuecomment-252526692) was ever addressed, I also guessed that this might be a leak due to the `__class__` closure cell fixup. I decided that this isn't the cause, either, because Python 2 does not have the `__class__` closure cell.\r\n\nSlots class holding a reference to the original version\nI have a class hierarchy implemented with slots enabled, like this:\r\n\r\nimport attr\r\n\r\n```python\r\n@attr.s(slots=True)\r\nclass BaseClass(object):\r\n    foo = attr.ib(default='foo')\r\n\r\n@attr.s(slots=True)\r\nclass SubClass(BaseClass):\r\n    bar = attr.ib(default='bar')\r\n```\r\n\r\nThis works fine until I wanted to introspect the class hierarchy:\r\n\r\n```python\r\nBaseClass.__subclasses__()  # returns [<class '__main__.SubClass'>, <class '__main__.SubClass'>]\r\n```\r\n\r\nOne of these is the original class, and the other is the new one created and returned by `attr.s`. This behavior manifests on both Python 3 and Python 2 (3.7.0 and 2.7.14, to be specific).\r\n\r\nMy understanding was that classes kept weak references to their subclasses to allow the `__subclasses__` method to work, and I know that attrs creates and returns a new class when `slots=True`, but it's not clear to me why the old class stays around. I don't see any obvious place where a strong reference to it is held.\r\n\r\nI guessed that there might be a reference cycle somewhere, so I tried adding a call to `gc.collect()` and checking `gc.garbage`, but that turned out to be incorrect.\r\n\r\nBecause I didn't see that the reference-counting mentioned [in this comment](https://github.com/python-attrs/attrs/issues/102#issuecomment-252526692) was ever addressed, I also guessed that this might be a leak due to the `__class__` closure cell fixup. I decided that this isn't the cause, either, because Python 2 does not have the `__class__` closure cell.\r\n\n",
        "hints_text": "When replacing the class in `slots=True` attrs has to make sure that the class hierarchy remains intact, therefore the returned class is a subclass of the original one. Does that answer your question?\nThat would answer the question, but I'm not convinced that it's true...\r\n\r\n```pycon\r\nPython 3.6.6 (default, Jun 27 2018, 13:11:40)\r\n[GCC 8.1.1 20180531] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import attr\r\n>>> @attr.s(slots=True)\r\n... class Foo: pass\r\n...\r\n>>> class Bar(Foo): pass\r\n...\r\n>>> AttrsBar = attr.s(slots=True)(Bar)\r\n>>> issubclass(AttrsBar, Bar)\r\nFalse\r\n```\nHm that might be due to how we create the class (by calling `type()` IIRC). Because OTOH:\r\n\r\n```pycon\r\n>>> import attr\r\n\r\n>>> class C: pass\r\n\r\n>>> C2 = attr.s(slots=True)(C)\r\n\r\n>>> C2.__mro__\r\n(<class '__main__.C'>, <class 'object'>)\r\n```\r\n\r\nSo the class is definitely there, it\u2019s just that Python subclass machinery doesn\u2019t know about it.\nI think you're being misled by the fact that the class generated by attrs still thinks its name is `C` despite being bound to `C2`:\r\n\r\n```pycon\r\n>>> import attr\r\n>>> class C: pass\r\n...\r\n>>> C2 = attr.s(slots=True)(C)\r\n>>> C2\r\n<class '__main__.C'>\r\n>>> C2.__mro__[0] is C\r\nFalse\r\n>>> C2.__mro__[0] is C2\r\nTrue\r\n```\r\n\r\nWhen the class [is created](https://github.com/python-attrs/attrs/blob/master/src/attr/_make.py#L533), it's using the original classes bases as the new bases, and I didn't see anywhere that the bases get modified...\nAh you\u2019re right, turns out we\u2019re more elaborate than I remembered:\r\n\r\nhttps://github.com/python-attrs/attrs/blob/35f7745ac22dab8ccfd82d7728623e9fdd5b76eb/src/attr/_make.py#L533\r\n\r\nSo I guess if we have a leak, `_ClassBuilder._create_slots_class()` would be the place to look? Have you tried something like https://mg.pov.lt/objgraph/?\nAh, no I hadn't thought of that...\r\n\r\n![attrs_slots_subclasses](https://user-images.githubusercontent.com/238853/42822571-5da1b2b8-89a9-11e8-926b-39917332edc2.png)\r\n\r\nI think that means the correct fix is to add `__weakref__` to the exception list here: https://github.com/python-attrs/attrs/blob/35f7745ac22dab8ccfd82d7728623e9fdd5b76eb/src/attr/_make.py#L493-L497\r\n\r\nWith that:\r\n\r\n```pycon\r\n>>> import attr\r\n>>> @attr.s(slots=True)\r\n... class C: pass\r\n...\r\n>>> @attr.s(slots=True)\r\n... class C2(C): pass\r\n...\r\n>>> import gc\r\n>>> gc.collect()\r\n11\r\n>>> C.__subclasses__()\r\n[<class '__main__.C2'>]\r\n```\r\n\r\nThe original class is left as a cyclic isolate when `attr.s` returns. I think that's as far as the attrs project needs to go to fix this; I'll call `gc.collect()` from my application. I'll write a test and open a PR today or tomorrow.\nWhen replacing the class in `slots=True` attrs has to make sure that the class hierarchy remains intact, therefore the returned class is a subclass of the original one. Does that answer your question?\nThat would answer the question, but I'm not convinced that it's true...\r\n\r\n```pycon\r\nPython 3.6.6 (default, Jun 27 2018, 13:11:40)\r\n[GCC 8.1.1 20180531] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import attr\r\n>>> @attr.s(slots=True)\r\n... class Foo: pass\r\n...\r\n>>> class Bar(Foo): pass\r\n...\r\n>>> AttrsBar = attr.s(slots=True)(Bar)\r\n>>> issubclass(AttrsBar, Bar)\r\nFalse\r\n```\nHm that might be due to how we create the class (by calling `type()` IIRC). Because OTOH:\r\n\r\n```pycon\r\n>>> import attr\r\n\r\n>>> class C: pass\r\n\r\n>>> C2 = attr.s(slots=True)(C)\r\n\r\n>>> C2.__mro__\r\n(<class '__main__.C'>, <class 'object'>)\r\n```\r\n\r\nSo the class is definitely there, it\u2019s just that Python subclass machinery doesn\u2019t know about it.\nI think you're being misled by the fact that the class generated by attrs still thinks its name is `C` despite being bound to `C2`:\r\n\r\n```pycon\r\n>>> import attr\r\n>>> class C: pass\r\n...\r\n>>> C2 = attr.s(slots=True)(C)\r\n>>> C2\r\n<class '__main__.C'>\r\n>>> C2.__mro__[0] is C\r\nFalse\r\n>>> C2.__mro__[0] is C2\r\nTrue\r\n```\r\n\r\nWhen the class [is created](https://github.com/python-attrs/attrs/blob/master/src/attr/_make.py#L533), it's using the original classes bases as the new bases, and I didn't see anywhere that the bases get modified...\nAh you\u2019re right, turns out we\u2019re more elaborate than I remembered:\r\n\r\nhttps://github.com/python-attrs/attrs/blob/35f7745ac22dab8ccfd82d7728623e9fdd5b76eb/src/attr/_make.py#L533\r\n\r\nSo I guess if we have a leak, `_ClassBuilder._create_slots_class()` would be the place to look? Have you tried something like https://mg.pov.lt/objgraph/?\nAh, no I hadn't thought of that...\r\n\r\n![attrs_slots_subclasses](https://user-images.githubusercontent.com/238853/42822571-5da1b2b8-89a9-11e8-926b-39917332edc2.png)\r\n\r\nI think that means the correct fix is to add `__weakref__` to the exception list here: https://github.com/python-attrs/attrs/blob/35f7745ac22dab8ccfd82d7728623e9fdd5b76eb/src/attr/_make.py#L493-L497\r\n\r\nWith that:\r\n\r\n```pycon\r\n>>> import attr\r\n>>> @attr.s(slots=True)\r\n... class C: pass\r\n...\r\n>>> @attr.s(slots=True)\r\n... class C2(C): pass\r\n...\r\n>>> import gc\r\n>>> gc.collect()\r\n11\r\n>>> C.__subclasses__()\r\n[<class '__main__.C2'>]\r\n```\r\n\r\nThe original class is left as a cyclic isolate when `attr.s` returns. I think that's as far as the attrs project needs to go to fix this; I'll call `gc.collect()` from my application. I'll write a test and open a PR today or tomorrow.",
        "created_at": "2018-07-18T00:08:38Z",
        "version": "18.1"
    }
}