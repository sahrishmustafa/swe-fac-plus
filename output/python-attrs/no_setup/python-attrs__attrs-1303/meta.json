{
    "task_id": "python-attrs__attrs-1303",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1303_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1303,
        "instance_id": "python-attrs__attrs-1303",
        "issue_numbers": [
            "1214"
        ],
        "base_commit": "37ac3ef0888bbd9235d17cbc6d284856f5276b44",
        "patch": "diff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -35,6 +35,7 @@\n     \"min_len\",\n     \"not_\",\n     \"optional\",\n+    \"or_\",\n     \"set_disabled\",\n ]\n \n@@ -614,3 +615,46 @@ def not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):\n     except TypeError:\n         exc_types = (exc_types,)\n     return _NotValidator(validator, msg, exc_types)\n+\n+\n+@attrs(repr=False, slots=True, hash=True)\n+class _OrValidator:\n+    validators = attrib()\n+\n+    def __call__(self, inst, attr, value):\n+        for v in self.validators:\n+            try:\n+                v(inst, attr, value)\n+            except Exception:  # noqa: BLE001, PERF203, S112\n+                continue\n+            else:\n+                return\n+\n+        msg = f\"None of {self.validators!r} satisfied for value {value!r}\"\n+        raise ValueError(msg)\n+\n+    def __repr__(self):\n+        return f\"<or validator wrapping {self.validators!r}>\"\n+\n+\n+def or_(*validators):\n+    \"\"\"\n+    A validator that composes multiple validators into one.\n+\n+    When called on a value, it runs all wrapped validators until one of them\n+    is satisfied.\n+\n+    :param ~collections.abc.Iterable[typing.Callable] validators: Arbitrary\n+        number of validators.\n+\n+    :raises ValueError: If no validator is satisfied. Raised with a\n+        human-readable error message listing all the wrapped validators and\n+        the value that failed all of them.\n+\n+    .. versionadded:: 24.1.0\n+    \"\"\"\n+    vals = []\n+    for v in validators:\n+        vals.extend(v.validators if isinstance(v, _OrValidator) else [v])\n+\n+    return _OrValidator(tuple(vals))\n",
        "test_patch": "diff --git a/tests/test_validators.py b/tests/test_validators.py\n--- a/tests/test_validators.py\n+++ b/tests/test_validators.py\n@@ -30,6 +30,7 @@\n     min_len,\n     not_,\n     optional,\n+    or_,\n )\n \n from .utils import simple_attr\n@@ -1261,3 +1262,38 @@ def test_bad_exception_args(self):\n             \"'exc_types' must be a subclass of <class 'Exception'> \"\n             \"(got <class 'str'>).\"\n         ) == e.value.args[0]\n+\n+\n+class TestOr:\n+    def test_in_all(self):\n+        \"\"\"\n+        Verify that this validator is in ``__all__``.\n+        \"\"\"\n+        assert or_.__name__ in validator_module.__all__\n+\n+    def test_success(self):\n+        \"\"\"\n+        Succeeds if at least one of wrapped validators succeed.\n+        \"\"\"\n+        v = or_(instance_of(str), always_pass)\n+\n+        v(None, simple_attr(\"test\"), 42)\n+\n+    def test_fail(self):\n+        \"\"\"\n+        Fails if all wrapped validators fail.\n+        \"\"\"\n+        v = or_(instance_of(str), always_fail)\n+\n+        with pytest.raises(ValueError):\n+            v(None, simple_attr(\"test\"), 42)\n+\n+    def test_repr(self):\n+        \"\"\"\n+        Returned validator has a useful `__repr__`.\n+        \"\"\"\n+        v = or_(instance_of(int), instance_of(str))\n+        assert (\n+            \"<or validator wrapping (<instance_of validator for type \"\n+            \"<class 'int'>>, <instance_of validator for type <class 'str'>>)>\"\n+        ) == repr(v)\n",
        "problem_statement": "Multiple alternatives validator\nI'd like to validate that a field can be of several types, one of which is an iterator.\r\n\r\n```py\r\nfrom attrs.validator import instance_of\r\n\r\n@define\r\nclass C:\r\n  x: A | B | tuple[int, ...] = field(validator=instance_of((A, B, tuple)))\r\n```\r\n\r\nI can use `instance_of` to check the outer type `tuple`, but I can't use `deep_iterable` to validate that they are indeed the element type `int`.\r\n\r\nSince we already have validators `and_` and `not_`, it may make sense to also add `or_`, so that I can represent this with\r\n\r\n```py\r\nfrom attrs.validator import instance_of, deep_iterable, or_\r\n\r\n@define\r\nclass C:\r\n  x: A | B | tuple[int, ...] = field(\r\n    validator=or_(\r\n      instance_of((A, B)),\r\n      deep_iterable(instance_of(int))))\r\n```\r\n\r\nFor comparison, this is how I'm writing a custom validator\r\n\r\n\r\n```py\r\nfrom attrs.validator import instance_of, deep_iterable\r\n\r\n@define\r\nclass C:\r\n  x: A | B | tuple[int, ...] = field()\r\n\r\n  @x.validator\r\n  def _validate_x(self, attr, value):\r\n    v1 = instance_of((A, B))\r\n    v2 = deep_iterable(instance_of(int))\r\n    try:\r\n      v1(self, attr, value)\r\n    except TypeError:\r\n      v2(self, attr, value)\r\n```\r\n\n",
        "hints_text": "FTR, it's already possible to do that using only `and_` and `not_`, thanks to [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws):\r\n\r\n```py\r\nfrom attrs.validator import instance_of, deep_iterable, and_, not_\r\n\r\n@define\r\nclass C:\r\n  x: A | B | tuple[int, ...] = field(\r\n    validator= not_(and_(\r\n      not_(instance_of((A, B))),\r\n      not_(deep_iterable(instance_of(int))))))\r\n```\r\n\r\nBut the error message is not very informative:\r\n\r\n```py\r\n>>> @define\r\n... class C:\r\n...   x = field(validator=not_( and_( not_( instance_of((A, B)) ), not_( deep_iterable(instance_of(int))  ) ) ))\r\n... \r\n>>> C(A())\r\nC(x=A())\r\n>>> C(B())\r\nC(x=B())\r\n>>> C(())\r\nC(x=())\r\n>>> C((1, 2, 3))\r\nC(x=(1, 2, 3))\r\n>>> C((1, 2, 3, '4'))\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"<attrs generated init __main__.C>\", line 5, in __init__\r\n  File \"<REDACTED>/lib/python3.12/site-packages/attr/validators.py\", line 670, in __call__\r\n    raise ValueError(\r\nValueError: (\"not_ validator child '_AndValidator(_validators=(<not_ validator wrapping <instance_of validator for type (<class '__main__.A'>, <class '__main__.B'>)>, capturing (<class 'ValueError'>, <class 'TypeError'>)>, <not_ validator wrapping <deep_iterable validator for iterables of <instance_of validator for type <class 'int'>>>, capturing (<class 'ValueError'>, <class 'TypeError'>)>))' did not raise a captured error\", Attribute(name='x', default=NOTHING, validator=<not_ validator wrapping _AndValidator(_validators=(<not_ validator wrapping <instance_of validator for type (<class '__main__.A'>, <class '__main__.B'>)>, capturing (<class 'ValueError'>, <class 'TypeError'>)>, <not_ validator wrapping <deep_iterable validator for iterables of <instance_of validator for type <class 'int'>>>, capturing (<class 'ValueError'>, <class 'TypeError'>)>)), capturing (<class 'ValueError'>, <class 'TypeError'>)>, repr=True, eq=True, eq_key=None, order=True, order_key=None, hash=None, init=True, metadata=mappingproxy({}), type=None, converter=None, kw_only=False, inherited=False, on_setattr=None, alias='x'), _AndValidator(_validators=(<not_ validator wrapping <instance_of validator for type (<class '__main__.A'>, <class '__main__.B'>)>, capturing (<class 'ValueError'>, <class 'TypeError'>)>, <not_ validator wrapping <deep_iterable validator for iterables of <instance_of validator for type <class 'int'>>>, capturing (<class 'ValueError'>, <class 'TypeError'>)>)), (1, 2, 3, '4'), (<class 'ValueError'>, <class 'TypeError'>))\r\n```",
        "created_at": "2024-07-14T15:03:00Z",
        "version": "23.2"
    }
}