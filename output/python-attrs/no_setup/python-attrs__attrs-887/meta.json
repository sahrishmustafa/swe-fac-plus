{
    "task_id": "python-attrs__attrs-887",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-887_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 887,
        "instance_id": "python-attrs__attrs-887",
        "issue_numbers": [
            "487",
            "705"
        ],
        "base_commit": "a23fe5f8c802e01190a2894ac33130c691b97358",
        "patch": "diff --git a/conftest.py b/conftest.py\n--- a/conftest.py\n+++ b/conftest.py\n@@ -1,10 +1,8 @@\n from __future__ import absolute_import, division, print_function\n \n-import sys\n-\n from hypothesis import HealthCheck, settings\n \n-from attr._compat import PY310\n+from attr._compat import PY36, PY310\n \n \n def pytest_configure(config):\n@@ -16,7 +14,7 @@ def pytest_configure(config):\n \n \n collect_ignore = []\n-if sys.version_info[:2] < (3, 6):\n+if not PY36:\n     collect_ignore.extend(\n         [\n             \"tests/test_annotations.py\",\ndiff --git a/src/attr/_config.py b/src/attr/_config.py\n--- a/src/attr/_config.py\n+++ b/src/attr/_config.py\n@@ -11,7 +11,7 @@ def set_run_validators(run):\n     Set whether or not validators are run.  By default, they are run.\n \n     .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n-        moved to new ``attrs`` namespace.  Use `attr.validators.set_disabled()`\n+        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n         instead.\n     \"\"\"\n     if not isinstance(run, bool):\n@@ -25,7 +25,7 @@ def get_run_validators():\n     Return whether or not validators are run.\n \n     .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n-        moved to new ``attrs`` namespace.  Use `attr.validators.get_disabled()`\n+        moved to new ``attrs`` namespace. Use `attrs.validators.get_disabled()`\n         instead.\n     \"\"\"\n     return _run_validators\ndiff --git a/src/attr/_funcs.py b/src/attr/_funcs.py\n--- a/src/attr/_funcs.py\n+++ b/src/attr/_funcs.py\n@@ -25,7 +25,7 @@ def asdict(\n         ``attrs``-decorated.\n     :param callable filter: A callable whose return code determines whether an\n         attribute or element is included (``True``) or dropped (``False``).  Is\n-        called with the `attr.Attribute` as the first argument and the\n+        called with the `attrs.Attribute` as the first argument and the\n         value as the second argument.\n     :param callable dict_factory: A callable to produce dictionaries from.  For\n         example, to produce ordered dictionaries instead of normal Python\n@@ -204,7 +204,7 @@ def astuple(\n         ``attrs``-decorated.\n     :param callable filter: A callable whose return code determines whether an\n         attribute or element is included (``True``) or dropped (``False``).  Is\n-        called with the `attr.Attribute` as the first argument and the\n+        called with the `attrs.Attribute` as the first argument and the\n         value as the second argument.\n     :param callable tuple_factory: A callable to produce tuples from.  For\n         example, to produce lists instead of tuples.\n@@ -314,7 +314,9 @@ def assoc(inst, **changes):\n         class.\n \n     ..  deprecated:: 17.1.0\n-        Use `evolve` instead.\n+        Use `attrs.evolve` instead if you can.\n+        This function will not be removed du to the slightly different approach\n+        compared to `attrs.evolve`.\n     \"\"\"\n     import warnings\n \n@@ -393,8 +395,8 @@ class and you didn't pass any attribs.\n     :raise NameError: If types cannot be resolved because of missing variables.\n \n     :returns: *cls* so you can use this function also as a class decorator.\n-        Please note that you have to apply it **after** `attr.s`. That means\n-        the decorator has to come in the line **before** `attr.s`.\n+        Please note that you have to apply it **after** `attrs.define`. That\n+        means the decorator has to come in the line **before** `attrs.define`.\n \n     ..  versionadded:: 20.1.0\n     ..  versionadded:: 21.1.0 *attribs*\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -147,11 +147,11 @@ def attrib(\n         is used and no value is passed while instantiating or the attribute is\n         excluded using ``init=False``.\n \n-        If the value is an instance of `Factory`, its callable will be\n+        If the value is an instance of `attrs.Factory`, its callable will be\n         used to construct a new value (useful for mutable data types like lists\n         or dicts).\n \n-        If a default is not set (or set manually to `attr.NOTHING`), a value\n+        If a default is not set (or set manually to `attrs.NOTHING`), a value\n         *must* be supplied when instantiating; otherwise a `TypeError`\n         will be raised.\n \n@@ -164,7 +164,7 @@ def attrib(\n \n     :param validator: `callable` that is called by ``attrs``-generated\n         ``__init__`` methods after the instance has been initialized.  They\n-        receive the initialized instance, the `Attribute`, and the\n+        receive the initialized instance, the :func:`~attrs.Attribute`, and the\n         passed value.\n \n         The return value is *not* inspected so the validator has to throw an\n@@ -237,10 +237,10 @@ def attrib(\n         parameter is ignored).\n     :param on_setattr: Allows to overwrite the *on_setattr* setting from\n         `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.\n-        Set to `attr.setters.NO_OP` to run **no** `setattr` hooks for this\n+        Set to `attrs.setters.NO_OP` to run **no** `setattr` hooks for this\n         attribute -- regardless of the setting in `attr.s`.\n     :type on_setattr: `callable`, or a list of callables, or `None`, or\n-        `attr.setters.NO_OP`\n+        `attrs.setters.NO_OP`\n \n     .. versionadded:: 15.2.0 *convert*\n     .. versionadded:: 16.3.0 *metadata*\n@@ -1286,7 +1286,7 @@ def attrs(\n         *cmp*, or *hash* overrides whatever *auto_detect* would determine.\n \n         *auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises\n-        a `PythonTooOldError`.\n+        an `attrs.exceptions.PythonTooOldError`.\n \n     :param bool repr: Create a ``__repr__`` method with a human readable\n         representation of ``attrs`` attributes..\n@@ -1373,7 +1373,7 @@ def attrs(\n \n         If you assign a value to those attributes (e.g. ``x: int = 42``), that\n         value becomes the default value like if it were passed using\n-        ``attr.ib(default=42)``.  Passing an instance of `Factory` also\n+        ``attr.ib(default=42)``.  Passing an instance of `attrs.Factory` also\n         works as expected in most cases (see warning below).\n \n         Attributes annotated as `typing.ClassVar`, and attributes that are\n@@ -1445,7 +1445,7 @@ def attrs(\n         the callable.\n \n         If a list of callables is passed, they're automatically wrapped in an\n-        `attr.setters.pipe`.\n+        `attrs.setters.pipe`.\n \n     :param Optional[callable] field_transformer:\n         A function that is called with the original class object and all\n@@ -2037,7 +2037,7 @@ def fields(cls):\n     :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n         class.\n \n-    :rtype: tuple (with name accessors) of `attr.Attribute`\n+    :rtype: tuple (with name accessors) of `attrs.Attribute`\n \n     ..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n         by name.\n@@ -2064,7 +2064,7 @@ def fields_dict(cls):\n         class.\n \n     :rtype: an ordered dict where keys are attribute names and values are\n-        `attr.Attribute`\\\\ s. This will be a `dict` if it's\n+        `attrs.Attribute`\\\\ s. This will be a `dict` if it's\n         naturally ordered like on Python 3.6+ or an\n         :class:`~collections.OrderedDict` otherwise.\n \n@@ -2951,7 +2951,7 @@ class Factory(object):\n     \"\"\"\n     Stores a factory callable.\n \n-    If passed as the default value to `attr.ib`, the factory is used to\n+    If passed as the default value to `attrs.field`, the factory is used to\n     generate a new value.\n \n     :param callable factory: A callable that takes either none or exactly one\ndiff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -3,11 +3,12 @@\n `attr.ib` with different default values.\n \"\"\"\n \n-from functools import partial\n \n-from attr.exceptions import UnannotatedAttributeError\n+from functools import partial\n \n from . import setters\n+from ._funcs import asdict as _asdict\n+from ._funcs import astuple as _astuple\n from ._make import (\n     NOTHING,\n     _frozen_setattrs,\n@@ -15,6 +16,7 @@\n     attrib,\n     attrs,\n )\n+from .exceptions import UnannotatedAttributeError\n \n \n def define(\n@@ -43,8 +45,23 @@ def define(\n     r\"\"\"\n     Define an ``attrs`` class.\n \n-    The behavioral differences to `attr.s` are the handling of the\n-    *auto_attribs* option:\n+    Differences to the classic `attr.s` that it uses underneath:\n+\n+    - Automatically detect whether or not *auto_attribs* should be `True`\n+      (c.f. *auto_attribs* parameter).\n+    - If *frozen* is `False`, run converters and validators when setting an\n+      attribute by default.\n+    - *slots=True* (see :term:`slotted classes` for potentially surprising\n+      behaviors)\n+    - *auto_exc=True*\n+    - *auto_detect=True*\n+    - *order=False*\n+    - *match_args=True*\n+    - Some options that were only relevant on Python 2 or were kept around for\n+      backwards-compatibility have been removed.\n+\n+    Please note that these are all defaults and you can change them as you\n+    wish.\n \n     :param Optional[bool] auto_attribs: If set to `True` or `False`, it behaves\n        exactly like `attr.s`. If left `None`, `attr.s` will try to guess:\n@@ -54,8 +71,7 @@ def define(\n        2. Otherwise it assumes *auto_attribs=False* and tries to collect\n           `attr.ib`\\ s.\n \n-    and that mutable classes (``frozen=False``) convert and validate on\n-    ``__setattr__``.\n+    For now, please refer to `attr.s` for the rest of the parameters.\n \n     .. versionadded:: 20.1.0\n     .. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.\n@@ -168,3 +184,31 @@ def field(\n         order=order,\n         on_setattr=on_setattr,\n     )\n+\n+\n+def asdict(inst, *, recurse=True, filter=None, value_serializer=None):\n+    \"\"\"\n+    Same as `attr.asdict`, except that collections types are always retained\n+    and dict is always used as *dict_factory*.\n+\n+    .. versionadded:: 21.3.0\n+    \"\"\"\n+    return _asdict(\n+        inst=inst,\n+        recurse=recurse,\n+        filter=filter,\n+        value_serializer=value_serializer,\n+        retain_collection_types=True,\n+    )\n+\n+\n+def astuple(inst, *, recurse=True, filter=None):\n+    \"\"\"\n+    Same as `attr.astuple`, except that collections types are always retained\n+    and `tuple` is always used as the *tuple_factory*.\n+\n+    .. versionadded:: 21.3.0\n+    \"\"\"\n+    return _astuple(\n+        inst=inst, recurse=recurse, filter=filter, retain_collection_types=True\n+    )\ndiff --git a/src/attr/converters.py b/src/attr/converters.py\n--- a/src/attr/converters.py\n+++ b/src/attr/converters.py\n@@ -14,9 +14,10 @@\n \n \n __all__ = [\n-    \"pipe\",\n-    \"optional\",\n     \"default_if_none\",\n+    \"optional\",\n+    \"pipe\",\n+    \"to_bool\",\n ]\n \n \n@@ -65,14 +66,14 @@ def default_if_none(default=NOTHING, factory=None):\n     result of *factory*.\n \n     :param default: Value to be used if ``None`` is passed. Passing an instance\n-       of `attr.Factory` is supported, however the ``takes_self`` option\n+       of `attrs.Factory` is supported, however the ``takes_self`` option\n        is *not*.\n     :param callable factory: A callable that takes no parameters whose result\n        is used if ``None`` is passed.\n \n     :raises TypeError: If **neither** *default* or *factory* is passed.\n     :raises TypeError: If **both** *default* and *factory* are passed.\n-    :raises ValueError: If an instance of `attr.Factory` is passed with\n+    :raises ValueError: If an instance of `attrs.Factory` is passed with\n        ``takes_self=True``.\n \n     .. versionadded:: 18.2.0\ndiff --git a/src/attr/filters.py b/src/attr/filters.py\n--- a/src/attr/filters.py\n+++ b/src/attr/filters.py\n@@ -23,7 +23,7 @@ def include(*what):\n     Include *what*.\n \n     :param what: What to include.\n-    :type what: `list` of `type` or `attr.Attribute`\\\\ s\n+    :type what: `list` of `type` or `attrs.Attribute`\\\\ s\n \n     :rtype: `callable`\n     \"\"\"\n@@ -40,7 +40,7 @@ def exclude(*what):\n     Exclude *what*.\n \n     :param what: What to exclude.\n-    :type what: `list` of classes or `attr.Attribute`\\\\ s.\n+    :type what: `list` of classes or `attrs.Attribute`\\\\ s.\n \n     :rtype: `callable`\n     \"\"\"\ndiff --git a/src/attr/validators.py b/src/attr/validators.py\n--- a/src/attr/validators.py\n+++ b/src/attr/validators.py\n@@ -127,7 +127,7 @@ def instance_of(type):\n     :type type: type or tuple of types\n \n     :raises TypeError: With a human readable error message, the attribute\n-        (of type `attr.Attribute`), the expected type, and the value it\n+        (of type `attrs.Attribute`), the expected type, and the value it\n         got.\n     \"\"\"\n     return _InstanceOfValidator(type)\n@@ -250,7 +250,7 @@ def provides(interface):\n     :type interface: ``zope.interface.Interface``\n \n     :raises TypeError: With a human readable error message, the attribute\n-        (of type `attr.Attribute`), the expected interface, and the\n+        (of type `attrs.Attribute`), the expected interface, and the\n         value it got.\n     \"\"\"\n     return _ProvidesValidator(interface)\n@@ -323,7 +323,7 @@ def in_(options):\n     :type options: list, tuple, `enum.Enum`, ...\n \n     :raises ValueError: With a human readable error message, the attribute (of\n-       type `attr.Attribute`), the expected options, and the value it\n+       type `attrs.Attribute`), the expected options, and the value it\n        got.\n \n     .. versionadded:: 17.1.0\n@@ -362,7 +362,7 @@ def is_callable():\n     .. versionadded:: 19.1.0\n \n     :raises `attr.exceptions.NotCallableError`: With a human readable error\n-        message containing the attribute (`attr.Attribute`) name,\n+        message containing the attribute (`attrs.Attribute`) name,\n         and the value it got.\n     \"\"\"\n     return _IsCallableValidator()\ndiff --git a/src/attrs/__init__.py b/src/attrs/__init__.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attrs/__init__.py\n@@ -0,0 +1,68 @@\n+from attr import (\n+    NOTHING,\n+    Attribute,\n+    Factory,\n+    __author__,\n+    __copyright__,\n+    __description__,\n+    __doc__,\n+    __email__,\n+    __license__,\n+    __title__,\n+    __url__,\n+    __version__,\n+    __version_info__,\n+    assoc,\n+    cmp_using,\n+    define,\n+    evolve,\n+    field,\n+    fields,\n+    fields_dict,\n+    frozen,\n+    has,\n+    make_class,\n+    mutable,\n+    resolve_types,\n+    validate,\n+)\n+from attr._next_gen import asdict, astuple\n+\n+from . import converters, exceptions, filters, setters, validators\n+\n+\n+__all__ = [\n+    \"__author__\",\n+    \"__copyright__\",\n+    \"__description__\",\n+    \"__doc__\",\n+    \"__email__\",\n+    \"__license__\",\n+    \"__title__\",\n+    \"__url__\",\n+    \"__version__\",\n+    \"__version_info__\",\n+    \"asdict\",\n+    \"assoc\",\n+    \"astuple\",\n+    \"Attribute\",\n+    \"cmp_using\",\n+    \"converters\",\n+    \"define\",\n+    \"evolve\",\n+    \"exceptions\",\n+    \"Factory\",\n+    \"field\",\n+    \"fields_dict\",\n+    \"fields\",\n+    \"filters\",\n+    \"frozen\",\n+    \"has\",\n+    \"make_class\",\n+    \"mutable\",\n+    \"NOTHING\",\n+    \"resolve_types\",\n+    \"setters\",\n+    \"validate\",\n+    \"validators\",\n+]\ndiff --git a/src/attrs/converters.py b/src/attrs/converters.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attrs/converters.py\n@@ -0,0 +1 @@\n+from attr.converters import *  # noqa\ndiff --git a/src/attrs/exceptions.py b/src/attrs/exceptions.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attrs/exceptions.py\n@@ -0,0 +1 @@\n+from attr.exceptions import *  # noqa\ndiff --git a/src/attrs/filters.py b/src/attrs/filters.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attrs/filters.py\n@@ -0,0 +1 @@\n+from attr.filters import *  # noqa\ndiff --git a/src/attrs/setters.py b/src/attrs/setters.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attrs/setters.py\n@@ -0,0 +1 @@\n+from attr.setters import *  # noqa\ndiff --git a/src/attrs/validators.py b/src/attrs/validators.py\nnew file mode 100644\n--- /dev/null\n+++ b/src/attrs/validators.py\n@@ -0,0 +1 @@\n+from attr.validators import *  # noqa\n",
        "test_patch": "diff --git a/tests/test_next_gen.py b/tests/test_next_gen.py\n--- a/tests/test_next_gen.py\n+++ b/tests/test_next_gen.py\n@@ -8,10 +8,11 @@\n \n import pytest\n \n-import attr\n+import attr as _attr  # don't use it by accident\n+import attrs\n \n \n-@attr.define\n+@attrs.define\n class C:\n     x: str\n     y: int\n@@ -29,7 +30,7 @@ def test_no_slots(self):\n         slots can be deactivated.\n         \"\"\"\n \n-        @attr.define(slots=False)\n+        @attrs.define(slots=False)\n         class NoSlots:\n             x: int\n \n@@ -42,9 +43,9 @@ def test_validates(self):\n         Validators at __init__ and __setattr__ work.\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class Validated:\n-            x: int = attr.field(validator=attr.validators.instance_of(int))\n+            x: int = attrs.field(validator=attrs.validators.instance_of(int))\n \n         v = Validated(1)\n \n@@ -61,7 +62,7 @@ def test_no_order(self):\n         with pytest.raises(TypeError):\n             C(\"1\", 2) < C(\"2\", 3)\n \n-        @attr.define(order=True)\n+        @attrs.define(order=True)\n         class Ordered:\n             x: int\n \n@@ -71,23 +72,23 @@ def test_override_auto_attribs_true(self):\n         \"\"\"\n         Don't guess if auto_attrib is set explicitly.\n \n-        Having an unannotated attr.ib/attr.field fails.\n+        Having an unannotated attrs.ib/attrs.field fails.\n         \"\"\"\n-        with pytest.raises(attr.exceptions.UnannotatedAttributeError):\n+        with pytest.raises(attrs.exceptions.UnannotatedAttributeError):\n \n-            @attr.define(auto_attribs=True)\n+            @attrs.define(auto_attribs=True)\n             class ThisFails:\n-                x = attr.field()\n+                x = attrs.field()\n                 y: int\n \n     def test_override_auto_attribs_false(self):\n         \"\"\"\n         Don't guess if auto_attrib is set explicitly.\n \n-        Annotated fields that don't carry an attr.ib are ignored.\n+        Annotated fields that don't carry an attrs.ib are ignored.\n         \"\"\"\n \n-        @attr.define(auto_attribs=False)\n+        @attrs.define(auto_attribs=False)\n         class NoFields:\n             x: int\n             y: int\n@@ -99,16 +100,16 @@ def test_auto_attribs_detect(self):\n         define correctly detects if a class lacks type annotations.\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class OldSchool:\n-            x = attr.field()\n+            x = attrs.field()\n \n         assert OldSchool(1) == OldSchool(1)\n \n         # Test with maybe_cls = None\n-        @attr.define()\n+        @attrs.define()\n         class OldSchool2:\n-            x = attr.field()\n+            x = attrs.field()\n \n         assert OldSchool2(1) == OldSchool2(1)\n \n@@ -117,10 +118,10 @@ def test_auto_attribs_detect_fields_and_annotations(self):\n         define infers auto_attribs=True if fields have type annotations\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class NewSchool:\n             x: int\n-            y: list = attr.field()\n+            y: list = attrs.field()\n \n             @y.validator\n             def _validate_y(self, attribute, value):\n@@ -130,14 +131,14 @@ def _validate_y(self, attribute, value):\n         assert NewSchool(1, 1) == NewSchool(1, 1)\n         with pytest.raises(ValueError):\n             NewSchool(1, -1)\n-        assert list(attr.fields_dict(NewSchool).keys()) == [\"x\", \"y\"]\n+        assert list(attrs.fields_dict(NewSchool).keys()) == [\"x\", \"y\"]\n \n     def test_auto_attribs_partially_annotated(self):\n         \"\"\"\n         define infers auto_attribs=True if any type annotations are found\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class NewSchool:\n             x: int\n             y: list\n@@ -145,7 +146,7 @@ class NewSchool:\n \n         # fields are defined for any annotated attributes\n         assert NewSchool(1, []) == NewSchool(1, [])\n-        assert list(attr.fields_dict(NewSchool).keys()) == [\"x\", \"y\"]\n+        assert list(attrs.fields_dict(NewSchool).keys()) == [\"x\", \"y\"]\n \n         # while the unannotated attributes are left as class vars\n         assert NewSchool.z == 10\n@@ -156,14 +157,14 @@ def test_auto_attribs_detect_annotations(self):\n         define correctly detects if a class has type annotations.\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class NewSchool:\n             x: int\n \n         assert NewSchool(1) == NewSchool(1)\n \n         # Test with maybe_cls = None\n-        @attr.define()\n+        @attrs.define()\n         class NewSchool2:\n             x: int\n \n@@ -174,7 +175,7 @@ def test_exception(self):\n         Exceptions are detected and correctly handled.\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class E(Exception):\n             msg: str\n             other: int\n@@ -190,16 +191,16 @@ class E(Exception):\n \n     def test_frozen(self):\n         \"\"\"\n-        attr.frozen freezes classes.\n+        attrs.frozen freezes classes.\n         \"\"\"\n \n-        @attr.frozen\n+        @attrs.frozen\n         class F:\n             x: str\n \n         f = F(1)\n \n-        with pytest.raises(attr.exceptions.FrozenInstanceError):\n+        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n             f.x = 2\n \n     def test_auto_detect_eq(self):\n@@ -209,7 +210,7 @@ def test_auto_detect_eq(self):\n         Regression test for #670.\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class C:\n             def __eq__(self, o):\n                 raise ValueError()\n@@ -219,35 +220,35 @@ def __eq__(self, o):\n \n     def test_subclass_frozen(self):\n         \"\"\"\n-        It's possible to subclass an `attr.frozen` class and the frozen-ness is\n-        inherited.\n+        It's possible to subclass an `attrs.frozen` class and the frozen-ness\n+        is inherited.\n         \"\"\"\n \n-        @attr.frozen\n+        @attrs.frozen\n         class A:\n             a: int\n \n-        @attr.frozen\n+        @attrs.frozen\n         class B(A):\n             b: int\n \n-        @attr.define(on_setattr=attr.setters.NO_OP)\n+        @attrs.define(on_setattr=attrs.setters.NO_OP)\n         class C(B):\n             c: int\n \n         assert B(1, 2) == B(1, 2)\n         assert C(1, 2, 3) == C(1, 2, 3)\n \n-        with pytest.raises(attr.exceptions.FrozenInstanceError):\n+        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n             A(1).a = 1\n \n-        with pytest.raises(attr.exceptions.FrozenInstanceError):\n+        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n             B(1, 2).a = 1\n \n-        with pytest.raises(attr.exceptions.FrozenInstanceError):\n+        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n             B(1, 2).b = 2\n \n-        with pytest.raises(attr.exceptions.FrozenInstanceError):\n+        with pytest.raises(attrs.exceptions.FrozenInstanceError):\n             C(1, 2, 3).c = 3\n \n     def test_catches_frozen_on_setattr(self):\n@@ -256,7 +257,7 @@ def test_catches_frozen_on_setattr(self):\n         immutability is inherited.\n         \"\"\"\n \n-        @attr.define(frozen=True)\n+        @attrs.define(frozen=True)\n         class A:\n             pass\n \n@@ -264,7 +265,7 @@ class A:\n             ValueError, match=\"Frozen classes can't use on_setattr.\"\n         ):\n \n-            @attr.define(frozen=True, on_setattr=attr.setters.validate)\n+            @attrs.define(frozen=True, on_setattr=attrs.setters.validate)\n             class B:\n                 pass\n \n@@ -276,17 +277,17 @@ class B:\n             ),\n         ):\n \n-            @attr.define(on_setattr=attr.setters.validate)\n+            @attrs.define(on_setattr=attrs.setters.validate)\n             class C(A):\n                 pass\n \n     @pytest.mark.parametrize(\n         \"decorator\",\n         [\n-            partial(attr.s, frozen=True, slots=True, auto_exc=True),\n-            attr.frozen,\n-            attr.define,\n-            attr.mutable,\n+            partial(_attr.s, frozen=True, slots=True, auto_exc=True),\n+            attrs.frozen,\n+            attrs.define,\n+            attrs.mutable,\n         ],\n     )\n     def test_discard_context(self, decorator):\n@@ -298,7 +299,7 @@ def test_discard_context(self, decorator):\n \n         @decorator\n         class MyException(Exception):\n-            x: str = attr.ib()\n+            x: str = attrs.field()\n \n         with pytest.raises(MyException) as ei:\n             try:\n@@ -314,9 +315,9 @@ def test_converts_and_validates_by_default(self):\n         If no on_setattr is set, assume setters.convert, setters.validate.\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class C:\n-            x: int = attr.field(converter=int)\n+            x: int = attrs.field(converter=int)\n \n             @x.validator\n             def _v(self, _, value):\n@@ -341,7 +342,7 @@ def test_mro_ng(self):\n         See #428\n         \"\"\"\n \n-        @attr.define\n+        @attrs.define\n         class A:\n \n             x: int = 10\n@@ -349,21 +350,89 @@ class A:\n             def xx(self):\n                 return 10\n \n-        @attr.define\n+        @attrs.define\n         class B(A):\n             y: int = 20\n \n-        @attr.define\n+        @attrs.define\n         class C(A):\n             x: int = 50\n \n             def xx(self):\n                 return 50\n \n-        @attr.define\n+        @attrs.define\n         class D(B, C):\n             pass\n \n         d = D()\n \n         assert d.x == d.xx()\n+\n+\n+class TestAsTuple:\n+    def test_smoke(self):\n+        \"\"\"\n+        `attrs.astuple` only changes defaults, so we just call it and compare.\n+        \"\"\"\n+        inst = C(\"foo\", 42)\n+\n+        assert attrs.astuple(inst) == _attr.astuple(inst)\n+\n+\n+class TestAsDict:\n+    def test_smoke(self):\n+        \"\"\"\n+        `attrs.asdict` only changes defaults, so we just call it and compare.\n+        \"\"\"\n+        inst = C(\"foo\", {(1,): 42})\n+\n+        assert attrs.asdict(inst) == _attr.asdict(\n+            inst, retain_collection_types=True\n+        )\n+\n+\n+class TestImports:\n+    \"\"\"\n+    Verify our re-imports and mirroring works.\n+    \"\"\"\n+\n+    def test_converters(self):\n+        \"\"\"\n+        Importing from attrs.converters works.\n+        \"\"\"\n+        from attrs.converters import optional\n+\n+        assert optional is _attr.converters.optional\n+\n+    def test_exceptions(self):\n+        \"\"\"\n+        Importing from attrs.exceptions works.\n+        \"\"\"\n+        from attrs.exceptions import FrozenError\n+\n+        assert FrozenError is _attr.exceptions.FrozenError\n+\n+    def test_filters(self):\n+        \"\"\"\n+        Importing from attrs.filters works.\n+        \"\"\"\n+        from attrs.filters import include\n+\n+        assert include is _attr.filters.include\n+\n+    def test_setters(self):\n+        \"\"\"\n+        Importing from attrs.setters works.\n+        \"\"\"\n+        from attrs.setters import pipe\n+\n+        assert pipe is _attr.setters.pipe\n+\n+    def test_validators(self):\n+        \"\"\"\n+        Importing from attrs.validators works.\n+        \"\"\"\n+        from attrs.validators import and_\n+\n+        assert and_ is _attr.validators.and_\ndiff --git a/tests/typing_example.py b/tests/typing_example.py\n--- a/tests/typing_example.py\n+++ b/tests/typing_example.py\n@@ -3,6 +3,7 @@\n from typing import Any, Dict, List, Tuple, Union\n \n import attr\n+import attrs\n \n \n # Typing via \"type\" Argument ---\n@@ -59,6 +60,14 @@ class FF:\n     z: Any = attr.ib()\n \n \n+@attrs.define\n+class FFF:\n+    z: int\n+\n+\n+FFF(1)\n+\n+\n # Inheritance --\n \n \n@@ -96,6 +105,19 @@ class Error(Exception):\n     str(e)\n \n \n+@attrs.define\n+class Error2(Exception):\n+    x: int\n+\n+\n+try:\n+    raise Error2(1)\n+except Error as e:\n+    e.x\n+    e.args\n+    str(e)\n+\n+\n # Converters\n # XXX: Currently converters can only be functions so none of this works\n # although the stubs should be correct.\n@@ -179,7 +201,7 @@ class Validated:\n         validator=attr.validators.instance_of((int, str))\n     )\n     k: Union[int, str, C] = attr.ib(\n-        validator=attr.validators.instance_of((int, C, str))\n+        validator=attrs.validators.instance_of((int, C, str))\n     )\n \n \n@@ -188,9 +210,17 @@ class Validated2:\n     num: int = attr.field(validator=attr.validators.ge(0))\n \n \n+@attrs.define\n+class Validated3:\n+    num: int = attr.field(validator=attr.validators.ge(0))\n+\n+\n with attr.validators.disabled():\n     Validated2(num=-1)\n \n+with attrs.validators.disabled():\n+    Validated3(num=-1)\n+\n try:\n     attr.validators.set_disabled(True)\n     Validated2(num=-1)\n@@ -207,6 +237,14 @@ class WithCustomRepr:\n     d: bool = attr.ib(repr=str)\n \n \n+@attrs.define\n+class WithCustomRepr2:\n+    a: int = attrs.field(repr=True)\n+    b: str = attrs.field(repr=False)\n+    c: str = attrs.field(repr=lambda value: \"c is for cookie\")\n+    d: bool = attrs.field(repr=str)\n+\n+\n # Check some of our own types\n @attr.s(eq=True, order=False)\n class OrderFlags:\n@@ -228,16 +266,43 @@ class ValidatedSetter:\n     )\n \n \n+@attrs.define(on_setattr=attr.setters.validate)\n+class ValidatedSetter2:\n+    a: int\n+    b: str = attrs.field(on_setattr=attrs.setters.NO_OP)\n+    c: bool = attrs.field(on_setattr=attrs.setters.frozen)\n+    d: int = attrs.field(\n+        on_setattr=[attrs.setters.convert, attrs.setters.validate]\n+    )\n+    e: bool = attrs.field(\n+        on_setattr=attrs.setters.pipe(\n+            attrs.setters.convert, attrs.setters.validate\n+        )\n+    )\n+\n+\n # field_transformer\n def ft_hook(cls: type, attribs: List[attr.Attribute]) -> List[attr.Attribute]:\n     return attribs\n \n \n+# field_transformer\n+def ft_hook2(\n+    cls: type, attribs: List[attrs.Attribute]\n+) -> List[attrs.Attribute]:\n+    return attribs\n+\n+\n @attr.s(field_transformer=ft_hook)\n class TransformedAttrs:\n     x: int\n \n \n+@attrs.define(field_transformer=ft_hook2)\n+class TransformedAttrs2:\n+    x: int\n+\n+\n # Auto-detect\n @attr.s(auto_detect=True)\n class AutoDetect:\n@@ -276,6 +341,11 @@ class NGFrozen:\n a.evolve(repr=False)\n \n \n+attrs.fields(NGFrozen).x.evolve(eq=False)\n+a = attrs.fields(NGFrozen).x\n+a.evolve(repr=False)\n+\n+\n @attr.s(collect_by_mro=True)\n class MRO:\n     pass\n@@ -288,6 +358,17 @@ class FactoryTest:\n     c: List[int] = attr.ib(default=attr.Factory((lambda s: s.a), True))\n \n \n+@attrs.define\n+class FactoryTest2:\n+    a: List[int] = attrs.field(default=attrs.Factory(list))\n+    b: List[Any] = attrs.field(default=attrs.Factory(list, False))\n+    c: List[int] = attrs.field(default=attrs.Factory((lambda s: s.a), True))\n+\n+\n+attrs.asdict(FactoryTest2())\n+attr.asdict(FactoryTest(), tuple_keys=True)\n+\n+\n # Check match_args stub\n @attr.s(match_args=False)\n class MatchArgs:\n@@ -297,3 +378,41 @@ class MatchArgs:\n \n attr.asdict(FactoryTest())\n attr.asdict(FactoryTest(), retain_collection_types=False)\n+\n+\n+# Check match_args stub\n+@attrs.define(match_args=False)\n+class MatchArgs2:\n+    a: int\n+    b: int\n+\n+\n+# NG versions of asdict/astuple\n+attrs.asdict(MatchArgs2(1, 2))\n+attrs.astuple(MatchArgs2(1, 2))\n+\n+\n+def importing_from_attr() -> None:\n+    \"\"\"\n+    Use a function to keep the ns clean.\n+    \"\"\"\n+    from attr.converters import optional\n+    from attr.exceptions import FrozenError\n+    from attr.filters import include\n+    from attr.setters import frozen\n+    from attr.validators import and_\n+\n+    assert optional and FrozenError and include and frozen and and_\n+\n+\n+def importing_from_attrs() -> None:\n+    \"\"\"\n+    Use a function to keep the ns clean.\n+    \"\"\"\n+    from attrs.converters import optional\n+    from attrs.exceptions import FrozenError\n+    from attrs.filters import include\n+    from attrs.setters import frozen\n+    from attrs.validators import and_\n+\n+    assert optional and FrozenError and include and frozen and and_\n",
        "problem_statement": "[RFC] Inconvenient defaults?\nAs part of \u201cProject`import attrs`\u201d (see also #408) we get a unique opportunity to change default options/behaviors that grew over the years but couldn't be fixed due to backward-compatibility restrictions.\r\n\r\nThe rough plan is create a new, friendlier API on top of `@attr.s` and `attr.ib()` that won't go anywhere.\r\n\r\nThe following is cast in stone:\r\n\r\n- `auto_attribs=True`\r\n- consistent (Python 3-style) hashing behavior on every Python version\r\n- #428 \r\n\r\nThe following would be really nice to have:\r\n\r\n- #368 but it might need too much thinking/research\r\n\r\nWhat else is bugging you?\r\n\r\n***\r\n\r\nOne thing that I just can't make up my mind is related to #223: should we make `slots=True` the default? I\u2019m quite confident that in 99,9% of cases it's the right thing to do and will guide people to write better classes.\r\n\r\nHowever on the other hand, our approach of rewriting classes breaks in certain scenarios, usually involving metaclasses.\r\n\r\nSo the question is, whether we want to tolerate a higher rate of bogus bug reports/help requests or make the default case nicer?\r\n\r\nI welcome your input.\r\n\r\n***\r\n\r\nFinally a controversial idea: we could make `import attrs` Python 3 only. There isn't much baggage we'd get rid of but there is _some_ and 2020 is less than a year ahead. It would also allow us to embrace enums as part of our API.\nBetter defaults for asdict/astuple\n- Would it be acceptable to change the default value for `retain_collection_types` to `True`? This would reduce the likelihood of this issue to appear unexpectedly. It is not a full fix though.\r\n\r\n- Would it be ok to use `tuple` as default collection type, when `retain_collection_types=False`? I would expect this to completely resolve the issue.\r\n\r\n_Originally posted by @tovrstra in https://github.com/python-attrs/attrs/issues/646#issuecomment-682167908_\n",
        "hints_text": "\"we could make import attrs Python 3 only.\" -> +1. \r\n\r\n\"It would also allow us to embrace enums as part of our API.\" -> That would be awesome.\r\n\nI absolutely agree with your point on `slots=True`, but I would recommend not making it the default. I'm always surprised by how many people have no idea that this amazing feature exists; you need to at the very least explain in the documentation what it is anyway, so it can be used to recommend its use and guide people to write better classes. :slightly_smiling_face: \r\n\r\nI'm also in favour of Python3-only `import attrs`.\r\n\r\n> What else is bugging you?\r\n\r\nA question: My main issue with `attrs` has always been its decorator-based syntax and inability to instantiate using `__init__`. To be clear, it's my personal preference and not a general opinion on How Things Should Be Done [TM], but I've always liked the subclassing approach found in e.g. `schematics`. Also, I've often explained the concept of data classes (regardless of the implementation) as \"ORM without the R\", as it maps nicely with people's experience with Django and others. So I just have to ask, it there a possibility to have an optional method of implementing `attrs` as a parent/abstract class and/or a mixin?\r\n\r\nThanks for all the amazing work!\n> So I just have to ask, it there a possibility to have an optional method of implementing `attrs` as a parent/abstract class and/or a mixin?\r\n\r\nNo, but you could probably use metaclasses and our programmatic interface (make_class) to build it yourself?\nIn a world of AWS Lambda and other RAM-second based billing systems, making \"slots=True\" the default will literally save people money (since it uses less RAM, and avoids pointless dict creation for each instance).\r\n\r\nIf it fails, then folks are likely to get noisy exceptions that a few asked-and-answered questions on Stack Overflow will teach them to resolve with \"slots=False\".\n> If it fails, then folks are likely to get noisy exceptions that a few asked-and-answered questions on Stack Overflow will teach them to resolve with \"slots=False\".\r\n\r\nCould even seed SO with a couple of self-answered Q&A covering common error cases where `slots=False` is the fix.\n> If it fails, then folks are likely to get noisy exceptions that a few asked-and-answered questions on Stack Overflow will teach them to resolve with \"slots=False\".\r\n\r\nI tend to agree; it just goes a bit against `attrs`\u2019s principle of \u201cjust adding some stuff\u201d to your classes.\r\n\nMy feelpinion: `frozen=True` should be the default. Probably the option should be renamed to `mutable`, so you say `mutable=True` for when you know what you are doing. \n> My feelpinion: `frozen=True` should be the default. Probably the option should be renamed to `mutable`, so you say `mutable=True` for when you know what you are doing.\r\n\r\nDisagree here. `frozen=True` only works for me in situations where (1) the entire contents of all instances will be known at instantiation-time in all cases, and (2) where no derived/calculated members will be needed (i.e., where `@property`s are sufficient for all derived members because the calculations are fast).\r\n\r\nI use attrs classes a lot in my data analysis work, and often I'll have something expensive I need to do with the arguments passed in at initialization. I absolutely want to do that expensive thing exactly once for each instance, and AFAIK I have to do it as something like:\r\n\r\n```\r\n@attr.s(slots=True)\r\nclass Foo:\r\n\r\n    input_var = attr.ib()\r\n    expensive_derived_var = attr.ib(init=False)\r\n\r\n    def __attrs_post_init__(self):\r\n        self.expensive_derived_var = self.calculate_expensive_thing()\r\n\r\n    def calculate_expensive_thing(self):\r\n        ...\r\n        {expensive stuff with self.input_var}\r\n        ...\r\n```\r\n\r\nWith `frozen=True`, I can't set `self.expensive_derived_var` in `__attrs_post_init__`.\r\n\r\nThat being said, I have no idea whether my needs here at all represent the majority of use-cases.\nI love myself some value types but `frozen=True` ain\u2019t happening. :)\r\n\r\nIt just doesn\u2019t fit Python too well. But IIRC we\u2019ve decided on an own function for it?\nI agree with `frozen=False` as the default, but kinda like using the term `mutable`, unless there is a significant difference between the meaning in `attrs` and Python in general. So I guess I would vote for the `mutable=True` as default.\r\n\r\nOh, and I think that @bskinn's argument against `frozen=True` equally applies to `slots=True`; I still think they should both be off by default. Unless I'm mistaken, `slots` applies to the attributes defined via `attrs` and no additional attributes can't be added, is that right?\n> No, but you could probably use metaclasses and our programmatic interface (make_class) to build it yourself?\r\n\r\nPossibly, will look into it.\nThe reason why it's called `frozen` is because that's how we call these things in Python (frozenset etc) and I don't want to open a new nomenclature out of purity. I've seen good things fail too often because of the stubbornness of its maintainers to be a good Python citizen.\r\n\r\nAnd yes, `slots=True` prevents new attributes and you really shouldn't add ad-hoc attributes so that's a feature. If you need it, you can always say `slots=False` and the class has a warning attached to itself, that the attribute list is not comprehensive.\n> we\u2019ve decided on an own function for it?\r\n\r\nDid we? Where can I read about that?\n> Where can I read about that?\r\n\r\nhttps://github.com/python-attrs/attrs/issues/408#issuecomment-442552322\r\n\r\nIt's gonna be `@attrs.define` and `@attrs.frozen`. Depending on https://hynek.me/about/#gratitude I might add an `attrs.mutable` alias for `define`. ;)\n> Depending on https://hynek.me/about/#a-name-gratitude-a-gratitude I might add an `attrs.mutable` alias for `define`. ;)\r\n\r\nIt\u2019s working \ud83d\ude31! Thank you so much @berislavlopac! \u2764\ufe0f\nKeep up the good work! :wink: \nI actually think `slots=True` has a useful proofreading function, and thus has more (albeit definitely not iron-clad) merit as a default as compared to `frozen`: `slots=True` guards against typos in external code that uses the class.\r\n\r\nI agree that a default `slots=True` has the potential to introduce confusing errors, but this at least might be mitigated by customizing the exception message... something like: \"... Either you have made a typo in accessing a member, or you should define this class with @attr.s(slots=False)\".\nJust a thought -- if we're using separate decorators for defining frozen and mutable classes, perhaps the former can have `slots=True` and the latter `slots=False`? :thinking: Just thinking out loud...\nDefinitely makes sense to me for `slots=True` to be default on `@attrs.frozen`. \n\nThat could be one distinction between (a possibly yet-again-renamed) `.define` and `.mutable`... `slots=True` on the former and `slots=False` on the latter...\nI also agree that `frozen=True` should not be the default for reasons @hynek gives above, but I wanted to note that @bskin's use-case above works fine for frozen classes with a small tweak. Rather than:\r\n\r\n```\r\n@attr.s(slots=True)\r\nclass Foo:\r\n\r\n    input_var = attr.ib()\r\n    expensive_derived_var = attr.ib(init=False)\r\n\r\n    def __attrs_post_init__(self):\r\n        self.expensive_derived_var = self.calculate_expensive_thing()\r\n\r\n    def calculate_expensive_thing(self):\r\n        ...\r\n        {expensive stuff with self.input_var}\r\n        ...\r\n```\r\n\r\ndo\r\n\r\n```\r\n@attr.s(slots=True, frozen=True)\r\nclass Foo:\r\n\r\n    input_var = attr.ib()\r\n    expensive_derived_var = attr.ib(init=False)\r\n\r\n    @expensive_derived_thing.default\r\n    def calculate_expensive_thing(self):\r\n        ...\r\n        {expensive stuff with self.input_var}\r\n        ...\r\n        return {computed value}\r\n```\r\n\r\nI wonder if this pattern is common enough to merit an example in the documentation.\r\n\r\nNote that these derived attributes still participate in hash, cmp, etc. unless you turn them off (https://github.com/python-attrs/attrs/issues/310).\n> That could be one distinction between (a possibly yet-again-renamed) .define and .mutable... slots=True on the former and slots=False on the latter...\r\n\r\nOn one hand, I like this approach, as it provides a number of different ways to skin this cat. On the other, I feel this goes against \"one obvious way to do it\", introducing simply too many combinations to keep in mind:\r\n\r\n- `define` with `slots=True` and `frozen=False`\r\n- `mutable` with `slots=False` and `frozen=False`\r\n- `frozen` with `slots=True` and `frozen=True`\r\n\r\nSo I'm not sure. :laughing: Overall, I think I'm leaning slightly towards simplicity:\r\n\r\n- `define` with `slots=False` and `frozen=False`\r\n- `frozen` with `slots=True` and `frozen=True`\r\n\r\nEspecially if there are more differences between the two methods than just the default values of `slots` and `frozen`. And I can live without the `mutable` alias.\nYeah.  I don't think `mutable` and `define` should be different.  The intent with that alias wasn't to complicate the matrix but to allow pedantic folks like me to be explicit about whether a class is mutable or frozen, as opposed to \"the usual sort\" or frozen.\nYeah there's not gonna be any more diversions. It's bad enough to have `attrs.frozen` and `attrs.define`. :)\nNot to derail an excellent conversation about mutability, but has `attrs` ever considered building in support for disallowing 'empty' values for attributes that are not assigned a default?\r\n\r\nFor instance, in my own little world, I can't think of a single case where, given the type\r\n\r\n```\r\n@attr.s(auto_attribs=True)\r\nclass MyDatabaseType:\r\n    username: str\r\n    firstname: str\r\n    email_addresses: List[str]\r\n\r\n    favorite_colors: List[str] = attr.Factory(list)\r\n    bio: str = ''\r\n```\r\n\r\nI would ever want to allow empty strings or lists for the attributes where I did not specifically provide a default. To me, making something optional is the same thing as providing a default, and vice-versa - under all other circumstances (well, at least for strings and collections types), an empty value is a sign of failure.\r\n\r\nObviously I can write validators for each of these items, but that ends up being at least 2 extra lines in the class definition for each attribute, or a single, very long line using `attr.ib` syntax, where previously the class definition was extremely clean.\r\n\r\nI am probably totally wrong about all this, and would love to have it explained to me why. But if I'm not, may I suggest adding a flag to the decorator that, if provided, enables this basic level of validation for all `str` and `list`/`set`/other collection types for which a default value is not provided?\r\n\r\nAgain, I apologize for jumping into this ongoing conversation about better defaults - this is probably a simple feature request. But as it seems like _default_ behavior to me, I couldn't resist.  Thanks for an incredible project that has made programming with classes/typing in Python literally 500% more pleasant!\n@petergaultney That sounds a bit off-topic for this thread, which is more about cleaning up the API around existing functionality.  You're asking for a new feature, which you've filed as #495; it'll be easier to track that conversation there.\nI just remembered another common \"pain\" point: equality & comparison. Equality should be on by default, ordering off. I think?\nAnother one: auto-detect methods that are defined on the current class (and the current class only): #324\n> I just remembered another common \"pain\" point: equality & comparison. Equality should be on by default, ordering off. I think?\r\n\r\n+100\r\n\r\nSounds like it's already captured but I personally have to type `@attr.s(hash=True)` for every attrs class, so that'd be great to change yeah.\r\n\r\n(I have to read the rest of this thread but I'm being lazy since I just saw this issue pinned :)\r\n\r\nAnd the other one that bugs me often is silently ignoring methods that are replaced. I.e.:\r\n\r\n```\r\n>>> @attr.s\r\n... class Foo(object):\r\n...     def __init__(self):\r\n...         print 12\r\n```\r\n\r\nshould IMO do something different than what it does today -- either the old characteristic behavior where that gets used as `attrs_post_init` or an error at class creation time.\n(Probably the latter, considering the same can't be done for someone defining `__repr__` with `repr=True`)\nI like the name `order=` instead of `cmp=`, as dataclasses does, since `cmp` is a bit opaque -- \"what is 'compare' anyway?\", and `order` sounds like [`functools.total_ordering`](https://docs.python.org/3/library/functools.html#functools.total_ordering) which is good.\r\n\r\nMaybe it's too late to change that though.\n> Maybe it's too late to change that though.\r\n\r\nIt's not for `import attrs`.\r\n\r\nI like `eq` and `order`!\nRegarding mutability/frozen in an `auto_attribs` setting. Python 3.8 now has a `typing.Final` type qualifier ([PEP 591](https://www.python.org/dev/peps/pep-0591/)), also available to older versions in `typing_extensions.Final`. This has some overlap with `frozen`:\r\n\r\nAt type checking time, `frozen` is equivalent to marking all fields `Final`. So `Final` is more flexible, since if just one field is mutable, all the others can still be marked `Final`. But it is less ergonomic, though maybe we can convince `typing` to add a decorator which flips the default `Final`ity.\r\n\r\nAt run time, attrs adds runtime checks that the fields are not mutated, while `Final` doesn't. But I suppose attrs can detect `Final`, and add the same checks? So that should be equivalent.\nThanks for this effort, great stuff. I would humbly submit https://github.com/python-attrs/attrs/issues/391 for consideration. Stripping private attrs should not happen by default and instead be configurable with `private_stripping=True` or something like that.\nWe are about to standardize on `from attr import dataclass` everywhere in our codebase so I'm just wondering if there's been any movement on this lately :)\nWell, I'm annoyed of typing `@attr.s(auto_attribs=True, auto_exc=True, slots=True)` as the next person.\r\n\r\nAnd I've been cranking out PRs to fix all things that I want fixed before `import attrs` (notably #642, #635, and #607) but sadly nobody was reviewing so I just merged after two weeks of silence. So that takes a while with all the timeouts.\r\n\r\nThe last big remaining thing are pre-attribute `on_setattr` hooks that allow for both freezing single attributes and force validation on setting attributes. Been procrastinating on the spec for a while now but `attr.ib(on_setattr=run_validator)` seems like the correct default value and it would be a shame to not include it.\n> Well, I'm annoyed of typing @attr.s(auto_attribs=True, auto_exc=True, slots=True) as the next person.\r\n\r\nPerhaps a solution might be a \"templating\" approach, e.g. with some kind of a `AttrsTemplate` class or namedtuple:\r\n\r\n```python\r\nmy_template_1 = AttrsTemplate(auto_attrib=True)\r\nmy_template_2 = AttrsTemplate(auto_attrib=True, auto_exc=True)\r\n\r\n@attr.s(template=my_template_1)\r\nclass Foo:\r\n   ...\r\n```\r\n\r\n> The last big remaining thing are pre-attribute `on_setattr` hooks that allow for both freezing single attributes and force validation on setting attributes\r\n\r\nOooh I just needed that recently, ended up using metadata to denote \"mutability\" of an attribute.\nWork has started in #645!\n@berislavlopac in theory the templating approach can be accomplished by meta-decorators, right?\r\n\r\n```\r\ndef my_template_1(cls=None, **kwargs):\r\n    def decorator(cls):\r\n        return attrs(cls, **kwargs, auto_attrib=True, auto_exc=True)\r\n    return decorator(cls) if cls else decorator\r\n```\r\n\r\nI wonder if either documenting this pattern or providing some sugar for it, e.g.\r\n\r\n```\r\ndef attrs_template(**template_kwargs):\r\n    def the_template(cls=None, **attrs_kwargs):\r\n        def decorator(cls):\r\n            merged_kwargs = {**attrs_kwargs, **template_kwargs}\r\n            return attrs(cls, **merged_kwargs)\r\n        return decorator(cls) if cls else decorator\r\n    return the_template\r\n\r\nmy_template_1 = attrs_template(auto_exc=True, auto_attribs=True)\r\n\r\n@my_template_1(frozen=True)\r\nclass Foo:\r\n    bar: int\r\n```\r\n\r\n\nExcellent point, haven't though of this approach -- it would definitely be useful to at least be documented if not implemented in this way.\n@berislavlopac @petergaultney I use this approach all the time (https://github.com/Tinche/flattrs/blob/master/src/flattr/_fb_attrs.py#L35). Note that it needs special boilerplate if you're using mypy, and mypy doesn't perfectly support it.\n> `attr.ib(on_setattr=run_validator)`\r\n\r\nPerhaps _attr.ib(on_setattr=validate)_ would be a little more concise?\r\n\n> > `attr.ib(on_setattr=run_validator)`\r\n> \r\n> Perhaps _attr.ib(on_setattr=validate)_ would be a little more concise?\r\n\r\nThat\u2019s not really an issue since it\u2019s gonna be the default in upcoming APIs. I don\u2019t think we need to pollute our APIs with any sugar for it in the meantime.\nYou can simply use `partial`:\r\n\r\n```python\r\n>>> from functools import partial\r\n>>>\r\n>>> auto = partial(attrs, auto_attribs=True, auto_exc=True)\r\n>>>\r\n>>> @auto(frozen=True)  # additional parameters\r\n... class Foo:\r\n...     foo: int\r\n...\r\n>>> @auto               # no parameters and no parentheses\r\n... class Bar:\r\n...     bar: str\r\n...\r\n>>> Foo?\r\nInit signature: Foo(foo: int) -> None\r\n  ...\r\n>>> Bar?\r\nInit signature: Bar(bar: str) -> None\r\n  ...\r\n```\r\n\r\nYou can even stack these:\r\n\r\n```python\r\n>>> frozen = partial(auto, frozen=True)\r\n```\r\n\r\nGiven how easy and readable and pythonic this is, I think having the least magical defaults is very reasonable. Perhaps with the exception of `cache_hash`, are there reasons to not enable this by default for frozen instances?\r\n\r\nMypy is the bigger problem here, as it currently doesn't understand `partial`, and doesn't even understand `auto = attrs; @auto; class ...`\r\n\r\n\r\nP.S. I personally would like to be able to drop parentheses on `attrib` like this:\r\n\r\n```python\r\n@attrs\r\nclass Foo:\r\n    foo = attrib\r\n```\nSadly the mypy angle ruined this approach that I used to use all the time. :(\n> Mypy is the bigger problem here, as it currently doesn't understand `partial`, and doesn't even understand `auto = attrs; @auto; class ...`\r\n\r\nThis partial application decorator-forwarding usecase can be managed with a micro-plugin for mypy - you basically need something that says:\r\n\r\n```\r\nimport typing as ty\r\nfrom mypy.plugin import Plugin, ClassDefContext\r\nfrom mypy.plugins.attrs import attrs_class_maker_callback\r\n\r\nMODULE_PATH_TO_YOUR_DECORATOR = \"your.module.path.autoattrs\"\r\n\r\nclass AutoAttrsDecoratorPlugin(Plugin):\r\n    def get_class_decorator_hook(\r\n        self, fullname: str\r\n    ) -> ty.Optional[ty.Callable[[ClassDefContext], None]]:\r\n        def fwd_auto(cls_def_ctx: ClassDefContext):\r\n            if fullname == MODULE_PATH_TO_YOUR_DECORATOR:\r\n                attr_class_maker_callback(cls_def_ctx, True)\r\n        if fullname == MODULE_PATH_TO_YOUR_DECORATOR:\r\n            return fwd_auto\r\n        return None\r\n\r\ndef plugin(_version):\r\n    return AutoAttrsDecoratorPlugin\r\n```\r\n\r\nWhat this doesn't support is things like frozen - however the mypy attrs plugin itself could be trivially rewritten to expose those parameters directly for these sorts of mypy plugins.\r\n\r\n@hynek do you think mypy would accept a PR to make the built-in plugin more directly reusable? This whole mess of plugin code could probably be rewritten to be a one-liner that 'registers' a decorator with the mypy plugin.\n> @hynek do you think mypy would accept a PR to make the built-in plugin more directly reusable? This whole mess of plugin code could probably be rewritten to be a one-liner that 'registers' a decorator with the mypy plugin.\r\n\r\nI've opened an issue asking for this almost two years ago: https://github.com/python/mypy/issues/5406\r\n\r\nFWIW, #650 is of interest here too.\n> doesn't even understand `auto = attrs`;\r\n\r\nby the way, while assignment doesn't make mypy happy, importing under a different name does:\r\n\r\n```python\r\nif TYPE_CHECKING:\r\n    from attr import attrs as slotted\r\nelse:\r\n    slotted = functools.partial(attrs, slots=True)\r\n```\none thing which breaks some functional programming stuff, is the fact you can't do bracketed lookup with attrs objects\r\n```\r\na = {\"name\": \"a\"} \r\na[\"name\"] \r\n# a\r\n\r\n@attrs\r\nclass Person:\r\n    name: str = attrib()\r\n\r\na = Person(name=\"a\")\r\na[\"name\"]\r\n# TypeError: 'Person' object is not subscriptable\r\n```\r\nmeans you can't do functional lenses, lookPath, assocPath, dissocPath, evolvePath, are all legit, makes me miss Ramda!\r\nhow can we make attrs better for functional programming?\nYou can always implement your own `__getitem__`...\n```\r\n    def __getitem__(self, key):\r\n        return self.__getattribute__(key)\r\n```\r\nworked like a charm, thanks for reminding me, that would be a fun default to add!\nPlease check out #666 y'all.\nSo FTR, NG APIs will ship as stable in 21.1, _now_ is the last chance to ask for changes in APIs that are annoying.\r\n\r\nSo far there's #705 but I'm sure there might be more?\r\n\r\nTo be clear: define/mutable/frozen/field are set in stone now. But there's a buttload of other APIs that may benefit from polish?\nI just want to say thanks for `order=False` by default.  :pray: \nI think retain=True makes a lot of sense. \r\n\r\nAs much as I love tuples (and immutable data in general), it seems risky to (essentially) auto-convert lists to tuples. I imagine there's too much code out there that relies on the Python-wide \"default\" of mutable container types. It would work fine for my use cases, though.",
        "created_at": "2021-12-15T07:01:27Z",
        "version": "21.2"
    }
}