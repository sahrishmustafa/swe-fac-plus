{
    "task_id": "python-attrs__attrs-363",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-363_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 363,
        "instance_id": "python-attrs__attrs-363",
        "issue_numbers": [
            "249"
        ],
        "base_commit": "c2fef8c6973ad4ce57b0a2f41a46b97b26dde2de",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -1034,7 +1034,7 @@ def _make_init(attrs, post_init, frozen, slots, super_attr_map):\n         sha1.hexdigest()\n     )\n \n-    script, globs = _attrs_to_init_script(\n+    script, globs, annotations = _attrs_to_init_script(\n         attrs,\n         frozen,\n         slots,\n@@ -1063,7 +1063,9 @@ def _make_init(attrs, post_init, frozen, slots, super_attr_map):\n         unique_filename,\n     )\n \n-    return locs[\"__init__\"]\n+    __init__ = locs[\"__init__\"]\n+    __init__.__annotations__ = annotations\n+    return __init__\n \n \n def _add_init(cls, frozen):\n@@ -1259,6 +1261,7 @@ def fmt_setter_with_converter(attr_name, value_var):\n     # This is a dictionary of names to validator and converter callables.\n     # Injecting this into __init__ globals lets us avoid lookups.\n     names_for_globals = {}\n+    annotations = {'return': None}\n \n     for a in attrs:\n         if a.validator:\n@@ -1349,6 +1352,9 @@ def fmt_setter_with_converter(attr_name, value_var):\n             else:\n                 lines.append(fmt_setter(attr_name, arg_name))\n \n+        if a.init is True and a.converter is None and a.type is not None:\n+            annotations[arg_name] = a.type\n+\n     if attrs_to_validate:  # we can skip this if there are no validators.\n         names_for_globals[\"_config\"] = _config\n         lines.append(\"if _config._run_validators is True:\")\n@@ -1368,7 +1374,7 @@ def __init__(self, {args}):\n \"\"\".format(\n         args=\", \".join(args),\n         lines=\"\\n    \".join(lines) if lines else \"pass\",\n-    ), names_for_globals\n+    ), names_for_globals, annotations\n \n \n class Attribute(object):\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -32,6 +32,11 @@ class C:\n         assert int is attr.fields(C).x.type\n         assert str is attr.fields(C).y.type\n         assert None is attr.fields(C).z.type\n+        assert C.__init__.__annotations__ == {\n+            'x': int,\n+            'y': str,\n+            'return': None,\n+        }\n \n     def test_catches_basic_type_conflict(self):\n         \"\"\"\n@@ -57,6 +62,11 @@ class C:\n \n         assert typing.List[int] is attr.fields(C).x.type\n         assert typing.Optional[str] is attr.fields(C).y.type\n+        assert C.__init__.__annotations__ == {\n+            'x': typing.List[int],\n+            'y': typing.Optional[str],\n+            'return': None,\n+        }\n \n     def test_only_attrs_annotations_collected(self):\n         \"\"\"\n@@ -68,6 +78,10 @@ class C:\n             y: int\n \n         assert 1 == len(attr.fields(C))\n+        assert C.__init__.__annotations__ == {\n+            'x': typing.List[int],\n+            'return': None,\n+        }\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_auto_attribs(self, slots):\n@@ -115,6 +129,15 @@ class C:\n             i.y = 23\n             assert 23 == i.y\n \n+        assert C.__init__.__annotations__ == {\n+            'a': int,\n+            'x': typing.List[int],\n+            'y': int,\n+            'z': int,\n+            'foo': typing.Any,\n+            'return': None,\n+        }\n+\n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_auto_attribs_unannotated(self, slots):\n         \"\"\"\n@@ -154,3 +177,51 @@ class C(A):\n \n         assert \"B(a=1, b=2)\" == repr(B())\n         assert \"C(a=1)\" == repr(C())\n+\n+        assert A.__init__.__annotations__ == {\n+            'a': int,\n+            'return': None,\n+        }\n+        assert B.__init__.__annotations__ == {\n+            'a': int,\n+            'b': int,\n+            'return': None,\n+        }\n+        assert C.__init__.__annotations__ == {\n+            'a': int,\n+            'return': None,\n+        }\n+\n+    def test_converter_annotations(self):\n+        \"\"\"\n+        Attributes with converters don't have annotations.\n+        \"\"\"\n+\n+        @attr.s(auto_attribs=True)\n+        class A:\n+            a: int = attr.ib(converter=int)\n+\n+        assert A.__init__.__annotations__ == {'return': None}\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_annotations_strings(self, slots):\n+        \"\"\"\n+        String annotations are passed into __init__ as is.\n+        \"\"\"\n+        @attr.s(auto_attribs=True, slots=slots)\n+        class C:\n+            cls_var: 'typing.ClassVar[int]' = 23\n+            a: 'int'\n+            x: 'typing.List[int]' = attr.Factory(list)\n+            y: 'int' = 2\n+            z: 'int' = attr.ib(default=3)\n+            foo: 'typing.Any' = None\n+\n+        assert C.__init__.__annotations__ == {\n+            'a': 'int',\n+            'x': 'typing.List[int]',\n+            'y': 'int',\n+            'z': 'int',\n+            'foo': 'typing.Any',\n+            'return': None,\n+        }\n",
        "problem_statement": "Annotate __init__ with type hints?\nSo I'm not sure this makes 100% sense, but technically we could start adding type hints to the signature of our `__init__`.\r\n\r\nI guess there would be some runtime introspection benefits?\n",
        "hints_text": "Ooh, yes please - [Hypothesis](HypothesisWorks/hypothesis-python) does runtime introspection of type hints to work out how to call things when the user didn't supply all the required arguments for an example object to test.  We'd like deeper integration with attrs on our end at some point, but adding type hints would be a great start - and also work for other projects doing similar things \ud83d\ude04 \n+1 for this. I'm trying to use attrs with [injector](https://github.com/alecthomas/injector), and currently it does not work because `__init__` generated by attrs \"looses\" annotations:\r\n\r\n```\r\n>>> class Inner: pass\r\n... \r\n>>> @attr.s\r\n... class Outer:\r\n...     inner: Inner = attr.ib()\r\n... \r\n>>> Outer.__init__.__annotations__\r\n{}\r\n```\nI came here specifically to see about adding support for annotation of `__init__`. My use case is exactly the same as @haizaar except that I plan to use `auto_attribs`.\r\n\r\nI'd do it myself, but the code isn't particularly beginner-friendly.\r\n\r\nOne approach would be to simply add a block inside `_ClassBuilder.add_init` where we get the annotations off the decorated class and put them on the generated init method. Possibly by doing something like:\r\n\r\n```\r\ninit = self._cls_dict['__init__']\r\nannotations = get_type_hints(self._cls)\r\ninit_arg_list = init.__code__.co_varnames\r\nfor annotation_key, annotation_value in annotations \r\n    if annotation_key in init_arg_list:\r\n        add_annotation(init, annotation_key, annotation_value)\r\n        remove_annotation(self._cls, annotation_key)\r\n```\r\n\r\nalthough i suspect this is extremely unportable (on the other hand, it appears that it could work in pypy3).\r\n\r\nAlso, there is a great deal of stuff I don't really understand (and which is not related to my use case) involving super-attrs and whatnot. I don't understand what those are, so I can't tell if they would affect a solution like the one I sketched.\nI wouldn't use `get_type_hints` in this case - from 3.7 Python is moving towards lazy evaluation of type annotations, and forcing them from string to object form in attrs could break people's code (shouldn't, but could) and would almost certainly have a substantial performance hit for some users.\r\n\r\nInstead, I'd just copy keys out of the `__annotations__` dict, or `inspect.getfullargspec(...).annotations`\n@Zac-HD I don't know enough about the current discussion around python types direction to comment specifically on the stability of the approach, but the fact that there's ambiguity suggests that we (possibly \"you\"; i'm not a contributor) should add a little layer of abstraction here (possibly just `get_type_annotations_for_the_attrs_pkg()`).\r\n\r\nI'm currently collecting the above into a little package to allow a user to write\r\n\r\n```\r\n@inject_attr.s\r\nclass Thing:\r\n    field: KlassA\r\n    other_field: KlassB\r\n```\r\n\r\nAlthough since it's basically just for me, not all python users everywhere, I'm not going to be worrying too much about the fwd-compatibility of the annotations stuff.\r\n\r\nBy the way, you wouldn't happen to know if there's a way to delete specific type annotations from an object? It's not a big deal, but in the attrs-context, `field` and `other_field` are args to the ctor, and I can copy their annotations to `Thing.__init__`, but the annotations still remain as annotations for (i _think_) non-existent class variables on `Thing`.\n@haizaar in the meantime, you could try my shitty new [inject-attrs](https://github.com/dradetsky/inject-attrs) package (or something like it).\r\n\r\n@hynek you might take into consideration the fact that I've been motivated to make this.\nI was going to say that almost all my FOSS time goes to Hypothesis (currently working on a major release), but after that it *would* start to address HypothesisWorks/hypothesis-python#954 ...  So maybe, we'll see :smile: \nI think adding the annotations to `__init__` is great idea.  And what @Zac-HD recommends is definitely the way to do it.\r\n\r\nHowever, I don't think think removing the annotation is necessary because\r\n```\r\nclass Thing:\r\n    field: KlassA\r\n    other_field: KlassB\r\n```\r\nmeans that `field` is an instance variable of type `KlassA`.  If you wanted a class variable you'd use `ClassVar[KlassA]`\r\n",
        "created_at": "2018-03-26T14:12:16Z",
        "version": "17.4"
    }
}