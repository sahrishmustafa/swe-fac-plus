{
    "task_id": "python-attrs__attrs-1117",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1117_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1117,
        "instance_id": "python-attrs__attrs-1117",
        "issue_numbers": [
            "1109"
        ],
        "base_commit": "22ae8473fb88d6e585b05c709e81e1a46398a649",
        "patch": "diff --git a/src/attr/_funcs.py b/src/attr/_funcs.py\n--- a/src/attr/_funcs.py\n+++ b/src/attr/_funcs.py\n@@ -351,9 +351,10 @@ def assoc(inst, **changes):\n     return new\n \n \n-def evolve(inst, **changes):\n+def evolve(*args, **changes):\n     \"\"\"\n-    Create a new instance, based on *inst* with *changes* applied.\n+    Create a new instance, based on the first positional argument with\n+    *changes* applied.\n \n     :param inst: Instance of a class with *attrs* attributes.\n     :param changes: Keyword changes in the new copy.\n@@ -365,8 +366,40 @@ def evolve(inst, **changes):\n     :raise attrs.exceptions.NotAnAttrsClassError: If *cls* is not an *attrs*\n         class.\n \n-    ..  versionadded:: 17.1.0\n+    .. versionadded:: 17.1.0\n+    .. deprecated:: 23.1.0\n+       It is now deprecated to pass the instance using the keyword argument\n+       *inst*. It will raise a warning until at least April 2024, after which\n+       it will become an error. Always pass the instance as a positional\n+       argument.\n     \"\"\"\n+    # Try to get instance by positional argument first.\n+    # Use changes otherwise and warn it'll break.\n+    if args:\n+        try:\n+            (inst,) = args\n+        except ValueError:\n+            raise TypeError(\n+                f\"evolve() takes 1 positional argument, but {len(args)} \"\n+                \"were given\"\n+            ) from None\n+    else:\n+        try:\n+            inst = changes.pop(\"inst\")\n+        except KeyError:\n+            raise TypeError(\n+                \"evolve() missing 1 required positional argument: 'inst'\"\n+            ) from None\n+\n+        import warnings\n+\n+        warnings.warn(\n+            \"Passing the instance per keyword argument is deprecated and \"\n+            \"will stop working in, or after, April 2024.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+\n     cls = inst.__class__\n     attrs = fields(cls)\n     for a in attrs:\n",
        "test_patch": "diff --git a/tests/test_funcs.py b/tests/test_funcs.py\n--- a/tests/test_funcs.py\n+++ b/tests/test_funcs.py\n@@ -689,3 +689,47 @@ class Cls2:\n         assert Cls1({\"foo\": 42, \"param2\": 42}) == attr.evolve(\n             obj1a, param1=obj2b\n         )\n+\n+    def test_inst_kw(self):\n+        \"\"\"\n+        If `inst` is passed per kw argument, a warning is raised.\n+        See #1109\n+        \"\"\"\n+\n+        @attr.s\n+        class C:\n+            pass\n+\n+        with pytest.warns(DeprecationWarning) as wi:\n+            evolve(inst=C())\n+\n+        assert __file__ == wi.list[0].filename\n+\n+    def test_no_inst(self):\n+        \"\"\"\n+        Missing inst argument raises a TypeError like Python would.\n+        \"\"\"\n+        with pytest.raises(TypeError, match=r\"evolve\\(\\) missing 1\"):\n+            evolve(x=1)\n+\n+    def test_too_many_pos_args(self):\n+        \"\"\"\n+        More than one positional argument raises a TypeError like Python would.\n+        \"\"\"\n+        with pytest.raises(\n+            TypeError,\n+            match=r\"evolve\\(\\) takes 1 positional argument, but 2 were given\",\n+        ):\n+            evolve(1, 2)\n+\n+    def test_can_change_inst(self):\n+        \"\"\"\n+        If the instance is passed by positional argument, a field named `inst`\n+        can be changed.\n+        \"\"\"\n+\n+        @attr.define\n+        class C:\n+            inst: int\n+\n+        assert C(42) == evolve(C(23), inst=42)\n",
        "problem_statement": "Make evolve 1st arg positional-only\nIt's arbitrary that the 1st argument is named `inst` and could conflict with a field.\r\n\r\nSince PEP-570 positional-only arguments require Python 3.8 and next major version will be \u2265 Python 3.7, we can do it the old-fashion way in the next breaking version (as this is an API change), i.e.\r\n```python\r\ndef evolve(*args, **changes):\r\n  (inst,) = args\r\n  ...\r\n```\n",
        "hints_text": "Wow that's gross :D \u2013 I wonder if that's possible to express for typing? It would probably break some people who passed it as keyword arguments\u2026 \ud83e\udd14\nattrs has type stubs so the way it looks to typing can be modern w/PEP-570.\n\nAlso, recently I've merged https://github.com/python/mypy/pull/14526 where you can provide the instance only positionally, so in attrs it will be positional only from the next release due to plugin code.\nDataclasses did something similar, albeit with warning and not a breaking change. Maybe we want to do the same: https://bugs.python.org/issue37163\nFWIW, they did break later as announced in the issue:\r\n\r\n```\r\nIn [2]: dataclasses.replace?\r\nSignature: dataclasses.replace(obj, /, **changes)\r\nDocstring:\r\nReturn a new object replacing specified fields with new values.\r\n\r\nThis is especially useful for frozen classes.  Example usage::\r\n\r\n  @dataclass(frozen=True)\r\n  class C:\r\n      x: int\r\n      y: int\r\n\r\n  c = C(1, 2)\r\n  c1 = replace(c, x=3)\r\n  assert c1.x == 3 and c1.y == 2\r\nFile:      /Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/dataclasses.py\r\nType:      function\r\n```\r\n\r\nguess we could warn now and break in a year.",
        "created_at": "2023-04-03T16:19:29Z",
        "version": "22.2"
    }
}