{
    "task_id": "python-attrs__attrs-292",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-292_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 292,
        "instance_id": "python-attrs__attrs-292",
        "issue_numbers": [
            "291"
        ],
        "base_commit": "a84a36d45f34a82a1bb3180a33d5842f7718cdef",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -201,6 +201,22 @@ def _is_class_var(annot):\n     return str(annot).startswith(\"typing.ClassVar\")\n \n \n+def _get_annotations(cls):\n+    \"\"\"\n+    Get annotations for *cls*.\n+    \"\"\"\n+    anns = getattr(cls, \"__annotations__\", None)\n+    if anns is None:\n+        return {}\n+\n+    # Verify that the annotations aren't merely inherited.\n+    for super_cls in cls.__mro__[1:]:\n+        if anns is getattr(super_cls, \"__annotations__\", None):\n+            return {}\n+\n+    return anns\n+\n+\n def _transform_attrs(cls, these, auto_attribs):\n     \"\"\"\n     Transform all `_CountingAttr`s on a class into `Attribute`s.\n@@ -210,16 +226,15 @@ def _transform_attrs(cls, these, auto_attribs):\n     Return an `_Attributes`.\n     \"\"\"\n     cd = cls.__dict__\n-    anns = getattr(cls, \"__annotations__\", {})\n+    anns = _get_annotations(cls)\n \n-    if these is None and auto_attribs is False:\n+    if these is not None:\n         ca_list = sorted((\n-            (name, attr)\n-            for name, attr\n-            in cd.items()\n-            if isinstance(attr, _CountingAttr)\n+            (name, ca)\n+            for name, ca\n+            in iteritems(these)\n         ), key=lambda e: e[1].counter)\n-    elif these is None and auto_attribs is True:\n+    elif auto_attribs is True:\n         ca_names = {\n             name\n             for name, attr\n@@ -251,9 +266,10 @@ def _transform_attrs(cls, these, auto_attribs):\n             )\n     else:\n         ca_list = sorted((\n-            (name, ca)\n-            for name, ca\n-            in iteritems(these)\n+            (name, attr)\n+            for name, attr\n+            in cd.items()\n+            if isinstance(attr, _CountingAttr)\n         ), key=lambda e: e[1].counter)\n \n     non_super_attrs = [\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -131,3 +131,26 @@ class C:\n         assert (\n             \"The following `attr.ib`s lack a type annotation: v, y.\",\n         ) == e.value.args\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_auto_attribs_subclassing(self, slots):\n+        \"\"\"\n+        Attributes from super classes are inherited, it doesn't matter if the\n+        subclass has annotations or not.\n+\n+        Ref #291\n+        \"\"\"\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class A:\n+            a: int = 1\n+\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class B(A):\n+            b: int = 2\n+\n+        @attr.s(slots=slots, auto_attribs=True)\n+        class C(A):\n+            pass\n+\n+        assert \"B(a=1, b=2)\" == repr(B())\n+        assert \"C(a=1)\" == repr(C())\n",
        "problem_statement": "Type hint defaults don't work with inheritance\nConsider\r\n\r\n```\r\nIn [12]: @attr.s(auto_attribs=True)\r\n    ...: class A:\r\n    ...:     a: int = 10\r\n    ...:\r\n\r\nIn [13]: @attr.s(auto_attribs=True)\r\n    ...: class B(A):\r\n    ...:     pass\r\n    ...:\r\n\r\nIn [14]: A()\r\nOut[14]: A(a=10)\r\n\r\nIn [15]: B()\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-15-1c5ecc61f85b> in <module>()\r\n----> 1 B()\r\n\r\nTypeError: __init__() missing 1 required positional argument: 'a'\r\n\r\n```\r\n\r\nThis should work, given that the following works:\r\n\r\n```\r\nIn [16]: @attr.s()\r\n    ...: class A:\r\n    ...:     a = attr.ib(default=10)\r\n    ...:\r\n\r\nIn [17]: @attr.s()\r\n    ...: class B(A):\r\n    ...:     pass\r\n    ...:\r\n\r\nIn [18]: A()\r\nOut[18]: A(a=10)\r\n\r\nIn [19]: B()\r\nOut[19]: B(a=10)\r\n\r\n```\n",
        "hints_text": "Ugh so it\u2019s not inheritance, it\u2019s inheritance + no new annotations.  The problem is that `__annotations__` gets inherited:\r\n\r\n```pycon\r\n>>> import attr\r\n\r\n>>> @attr.s(auto_attribs=True)\r\n... class A:\r\n...     a: int = 10\r\n\r\n>>> @attr.s(auto_attribs=True)\r\n... class B(A):\r\n...     pass\r\n\r\n>>> A.__annotations__\r\n{'a': <class 'int'>}\r\n\r\n>>> B.__annotations__\r\n{'a': <class 'int'>}\r\n\r\n>>> A.__annotations__ is B.__annotations__\r\nTrue\r\n\r\n>>> @attr.s(auto_attribs=True)\r\n... class C(A):\r\n...     c: float = 20.0\r\n\r\n>>> C()\r\nC(a=10, c=20.0)\r\n```",
        "created_at": "2017-11-11T07:04:59Z",
        "version": "17.3"
    }
}