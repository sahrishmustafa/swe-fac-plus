{
    "task_id": "python-attrs__attrs-343",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-343_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 343,
        "instance_id": "python-attrs__attrs-343",
        "issue_numbers": [
            "300"
        ],
        "base_commit": "93eb1e4d21b5cc5c88da61e8182a42bb41cab557",
        "patch": "diff --git a/src/attr/_compat.py b/src/attr/_compat.py\n--- a/src/attr/_compat.py\n+++ b/src/attr/_compat.py\n@@ -10,6 +10,13 @@\n PYPY = platform.python_implementation() == \"PyPy\"\n \n \n+if PYPY or sys.version_info[:2] >= (3, 6):\n+    ordered_dict = dict\n+else:\n+    from collections import OrderedDict\n+    ordered_dict = OrderedDict\n+\n+\n if PY2:\n     from UserDict import IterableUserDict\n \ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -8,7 +8,9 @@\n from operator import itemgetter\n \n from . import _config\n-from ._compat import PY2, isclass, iteritems, metadata_proxy, set_closure_cell\n+from ._compat import (\n+    PY2, isclass, iteritems, metadata_proxy, ordered_dict, set_closure_cell\n+)\n from .exceptions import (\n     DefaultAlreadySetError, FrozenInstanceError, NotAnAttrsClassError,\n     UnannotatedAttributeError\n@@ -233,6 +235,13 @@ def _get_annotations(cls):\n     return anns\n \n \n+def _counter_getter(e):\n+    \"\"\"\n+    Key function for sorting to avoid re-creating a lambda for every class.\n+    \"\"\"\n+    return e[1].counter\n+\n+\n def _transform_attrs(cls, these, auto_attribs):\n     \"\"\"\n     Transform all `_CountingAttr`s on a class into `Attribute`s.\n@@ -245,11 +254,14 @@ def _transform_attrs(cls, these, auto_attribs):\n     anns = _get_annotations(cls)\n \n     if these is not None:\n-        ca_list = sorted((\n+        ca_list = [\n             (name, ca)\n             for name, ca\n             in iteritems(these)\n-        ), key=lambda e: e[1].counter)\n+        ]\n+\n+        if not isinstance(these, ordered_dict):\n+            ca_list.sort(key=_counter_getter)\n     elif auto_attribs is True:\n         ca_names = {\n             name\n@@ -593,6 +605,11 @@ def attrs(maybe_cls=None, these=None, repr_ns=None,\n         If *these* is not ``None``, ``attrs`` will *not* search the class body\n         for attributes and will *not* remove any attributes from it.\n \n+        If *these* is an ordered dict (:class:`dict` on Python 3.6+,\n+        :class:`collections.OrderedDict` otherwise), the order is deduced from\n+        the order of the attributes inside *these*.  Otherwise the order\n+        of the definition of the attributes is used.\n+\n     :type these: :class:`dict` of :class:`str` to :func:`attr.ib`\n \n     :param str repr_ns: When using nested classes, there's no way in Python 2\n@@ -681,6 +698,7 @@ def attrs(maybe_cls=None, these=None, repr_ns=None,\n     .. versionadded:: 17.3.0 *auto_attribs*\n     .. versionchanged:: 18.1.0\n        If *these* is passed, no attributes are deleted from the class body.\n+    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.\n     \"\"\"\n     def wrap(cls):\n         if getattr(cls, \"__class__\", None) is None:\n@@ -1513,6 +1531,11 @@ def make_class(name, attrs, bases=(object,), **attributes_arguments):\n \n     :param attrs: A list of names or a dictionary of mappings of names to\n         attributes.\n+\n+        If *attrs* is a list or an ordered dict (:class:`dict` on Python 3.6+,\n+        :class:`collections.OrderedDict` otherwise), the order is deduced from\n+        the order of the names or attributes inside *attrs*.  Otherwise the\n+        order of the definition of the attributes is used.\n     :type attrs: :class:`list` or :class:`dict`\n \n     :param tuple bases: Classes that the new class will subclass.\n@@ -1522,7 +1545,8 @@ def make_class(name, attrs, bases=(object,), **attributes_arguments):\n     :return: A new class with *attrs*.\n     :rtype: type\n \n-    ..  versionadded:: 17.1.0 *bases*\n+    .. versionadded:: 17.1.0 *bases*\n+    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.\n     \"\"\"\n     if isinstance(attrs, dict):\n         cls_dict = attrs\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -19,7 +19,7 @@\n import attr\n \n from attr import _config\n-from attr._compat import PY2\n+from attr._compat import PY2, ordered_dict\n from attr._make import (\n     Attribute, Factory, _AndValidator, _Attributes, _ClassBuilder,\n     _CountingAttr, _transform_attrs, and_, fields, make_class, validate\n@@ -281,6 +281,20 @@ class C(object):\n         assert 5 == C().x\n         assert \"C(x=5)\" == repr(C())\n \n+    def test_these_ordered(self):\n+        \"\"\"\n+        If these is passed ordered attrs, their order respect instead of the\n+        counter.\n+        \"\"\"\n+        b = attr.ib(default=2)\n+        a = attr.ib(default=1)\n+\n+        @attr.s(these=ordered_dict([(\"a\", a), (\"b\", b)]))\n+        class C(object):\n+            pass\n+\n+        assert \"C(a=1, b=2)\" == repr(C())\n+\n     def test_multiple_inheritance(self):\n         \"\"\"\n         Order of attributes doesn't get mixed up by multiple inheritance.\n@@ -610,6 +624,18 @@ def test_missing_sys_getframe(self, monkeypatch):\n \n         assert 1 == len(C.__attrs_attrs__)\n \n+    def test_make_class_ordered(self):\n+        \"\"\"\n+        If `make_class()` is passed ordered attrs, their order is respected\n+        instead of the counter.\n+        \"\"\"\n+        b = attr.ib(default=2)\n+        a = attr.ib(default=1)\n+\n+        C = attr.make_class(\"C\", ordered_dict([(\"a\", a), (\"b\", b)]))\n+\n+        assert \"C(a=1, b=2)\" == repr(C())\n+\n \n class TestFields(object):\n     \"\"\"\n@@ -686,13 +712,14 @@ def test_convert_factory_property(self, val, init):\n         \"\"\"\n         Property tests for attributes with convert, and a factory default.\n         \"\"\"\n-        C = make_class(\"C\", {\n-            \"y\": attr.ib(),\n-            \"x\": attr.ib(\n+        C = make_class(\"C\", ordered_dict([\n+            (\"y\", attr.ib()),\n+            (\"x\", attr.ib(\n                 init=init,\n                 default=Factory(lambda: val),\n-                converter=lambda v: v + 1),\n-        })\n+                converter=lambda v: v + 1\n+            )),\n+        ]))\n         c = C(2)\n \n         assert c.x == val + 1\n",
        "problem_statement": "Allow overwriting order inferred from _CountingAttr.counter when passing ordered `these`\nattrs classes can be constructed dynamically using `attr.s(maybe_cls=A, these=some_dict)`.\r\nUsually `some_dict` will be a standard (unordered) python dictionary and the order of attributes has to be inferred from `_CountingAttr.counter`.\r\n\r\nWhat about allowing the user to overwrite the `_CountingAttr.counter` by passing an `OrderedDict` as argument to `these`?\n",
        "hints_text": "I think @Julian would like this?\nYep! Would love to see what this looks like.",
        "created_at": "2018-02-05T09:39:46Z",
        "version": "17.4"
    }
}