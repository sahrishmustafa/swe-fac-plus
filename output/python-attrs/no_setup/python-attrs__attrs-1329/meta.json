{
    "task_id": "python-attrs__attrs-1329",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-1329_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 1329,
        "instance_id": "python-attrs__attrs-1329",
        "issue_numbers": [
            "1326"
        ],
        "base_commit": "f520d9a89f1fde6fdc5310ffe6c5d4c7467fb10b",
        "patch": "diff --git a/src/attr/_compat.py b/src/attr/_compat.py\n--- a/src/attr/_compat.py\n+++ b/src/attr/_compat.py\n@@ -15,6 +15,7 @@\n PY_3_10_PLUS = sys.version_info[:2] >= (3, 10)\n PY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\n PY_3_13_PLUS = sys.version_info[:2] >= (3, 13)\n+PY_3_14_PLUS = sys.version_info[:2] >= (3, 14)\n \n \n if sys.version_info < (3, 8):\n@@ -25,6 +26,19 @@\n else:\n     from typing import Protocol  # noqa: F401\n \n+if PY_3_14_PLUS:  # pragma: no cover\n+    import annotationlib\n+\n+    _get_annotations = annotationlib.get_annotations\n+\n+else:\n+\n+    def _get_annotations(cls):\n+        \"\"\"\n+        Get annotations for *cls*.\n+        \"\"\"\n+        return cls.__dict__.get(\"__annotations__\", {})\n+\n \n class _AnnotationExtractor:\n     \"\"\"\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -23,6 +23,7 @@\n     PY_3_8_PLUS,\n     PY_3_10_PLUS,\n     _AnnotationExtractor,\n+    _get_annotations,\n     get_generic_base,\n )\n from .exceptions import (\n@@ -308,13 +309,6 @@ def _has_own_attribute(cls, attrib_name):\n     return attrib_name in cls.__dict__\n \n \n-def _get_annotations(cls):\n-    \"\"\"\n-    Get annotations for *cls*.\n-    \"\"\"\n-    return cls.__dict__.get(\"__annotations__\", {})\n-\n-\n def _collect_base_attrs(cls, taken_attr_names):\n     \"\"\"\n     Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.\n",
        "test_patch": "diff --git a/tests/test_3rd_party.py b/tests/test_3rd_party.py\n--- a/tests/test_3rd_party.py\n+++ b/tests/test_3rd_party.py\n@@ -8,12 +8,17 @@\n \n from hypothesis import given\n \n+from attr._compat import PY_3_14_PLUS\n+\n from .strategies import simple_classes\n \n \n cloudpickle = pytest.importorskip(\"cloudpickle\")\n \n \n+@pytest.mark.xfail(\n+    PY_3_14_PLUS, reason=\"cloudpickle is currently broken on 3.14.\"\n+)\n class TestCloudpickleCompat:\n     \"\"\"\n     Tests for compatibility with ``cloudpickle``.\ndiff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -12,6 +12,7 @@\n \n import attr\n \n+from attr._compat import PY_3_14_PLUS\n from attr._make import _is_class_var\n from attr.exceptions import UnannotatedAttributeError\n \n@@ -588,6 +589,8 @@ def test_self_reference(self, slots):\n         \"\"\"\n         References to self class using quotes can be resolved.\n         \"\"\"\n+        if PY_3_14_PLUS and not slots:\n+            pytest.xfail(\"References are changing a lot in 3.14.\")\n \n         @attr.s(slots=slots, auto_attribs=True)\n         class A:\n@@ -603,6 +606,8 @@ def test_forward_reference(self, slots):\n         \"\"\"\n         Forward references can be resolved.\n         \"\"\"\n+        if PY_3_14_PLUS and not slots:\n+            pytest.xfail(\"Forward references are changing a lot in 3.14.\")\n \n         @attr.s(slots=slots, auto_attribs=True)\n         class A:\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -21,7 +21,7 @@\n import attr\n \n from attr import _config\n-from attr._compat import PY_3_8_PLUS, PY_3_10_PLUS\n+from attr._compat import PY_3_8_PLUS, PY_3_10_PLUS, PY_3_14_PLUS\n from attr._make import (\n     Attribute,\n     Factory,\n@@ -1838,9 +1838,11 @@ class C2(C):\n         assert [C2] == C.__subclasses__()\n \n     @pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\n+    @pytest.mark.xfail(PY_3_14_PLUS, reason=\"Currently broken on nightly.\")\n     def test_no_references_to_original_when_using_cached_property(self):\n         \"\"\"\n-        When subclassing a slotted class and using cached property, there are no stray references to the original class.\n+        When subclassing a slotted class and using cached property, there are\n+        no stray references to the original class.\n         \"\"\"\n \n         @attr.s(slots=True)\ndiff --git a/tests/test_slots.py b/tests/test_slots.py\n--- a/tests/test_slots.py\n+++ b/tests/test_slots.py\n@@ -3,6 +3,7 @@\n \"\"\"\n Unit tests for slots-related functionality.\n \"\"\"\n+\n import functools\n import pickle\n import weakref\n@@ -14,7 +15,7 @@\n import attr\n import attrs\n \n-from attr._compat import PY_3_8_PLUS, PYPY\n+from attr._compat import PY_3_8_PLUS, PY_3_14_PLUS, PYPY\n \n \n # Pympler doesn't work on PyPy.\n@@ -774,6 +775,9 @@ def f(self) -> int:\n \n \n @pytest.mark.skipif(not PY_3_8_PLUS, reason=\"cached_property is 3.8+\")\n+@pytest.mark.xfail(\n+    PY_3_14_PLUS, reason=\"3.14 returns weird annotation for cached_properies\"\n+)\n def test_slots_cached_property_infers_type():\n     \"\"\"\n     Infers type of cached property.\n",
        "problem_statement": "Latest release breaks hypothesis tests in CPython main branch\nSee https://github.com/python/cpython/issues/122686.  Pinning to \"attrs<=23.2.0\" - a workaround.\n",
        "hints_text": "I\u2019m afk, can I have a \r\n[_Short, Self Contained, Correct, Example_](http://sscce.org) please?\nSorry, I didn't deep debugging (yet).  If that helps, tracebacks from above job looks like:\r\n```\r\n[...]\r\n  File \"/home/runner/work/cpython/cpython-builddir/hypovenv/lib/python3.14/site-packages/hypothesis/internal/conjecture/data.py\", line 2466, in stop_example\r\n    self.tags.update([structural_coverage(l) for l in labels_for_structure])\r\n                      ~~~~~~~~~~~~~~~~~~~^^^\r\n  File \"/home/runner/work/cpython/cpython-builddir/hypovenv/lib/python3.14/site-packages/hypothesis/internal/conjecture/data.py\", line 170, in structural_coverage\r\n    return STRUCTURAL_COVERAGE_CACHE.setdefault(label, StructuralCoverageTag(label))\r\n                                                       ~~~~~~~~~~~~~~~~~~~~~^^^^^^^\r\nTypeError: StructuralCoverageTag.__init__() takes 1 positional argument but 2 were given\r\n```\r\n\r\nIt's this class in Hypothesis:\r\nhttps://github.com/HypothesisWorks/hypothesis/blob/3c15b34ece30825ed153a0b350f5847efb30dd79/hypothesis-python/src/hypothesis/internal/conjecture/data.py#L157-L160\r\n\r\nMaybe hypothesis package should add pinning, but it's not clear for me from release notes that was broken here.\nFrom looking on my phone it looks like the breakage is that we now use the official dataclass transform decorator and they\u2019re applying is a second time. I _think_ that\u2019s something they have to fix, this is just the price of the typing bleeding edge. Has someone opened a ticket over there?\nhttps://github.com/HypothesisWorks/hypothesis/issues/4067\nSo it looks like *attrs* can't find annotation-only fields **Python 3.14 only** anymore.\r\n\r\n\r\nIt's caused by 689a0e6 and my wild guess is that it's related to [PEP 649](https://peps.python.org/pep-0649/) / [PEP 749](https://peps.python.org/pep-0749/).",
        "created_at": "2024-08-06T10:03:58Z",
        "version": "24.1"
    }
}