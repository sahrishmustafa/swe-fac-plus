{
    "task_id": "python-attrs__attrs-356",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-356_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 356,
        "instance_id": "python-attrs__attrs-356",
        "issue_numbers": [
            "178"
        ],
        "base_commit": "16e65835f4fbecd1ef8fabf5a208bf90be4efcd0",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -58,7 +58,8 @@ def __hash__(self):\n \n def attrib(default=NOTHING, validator=None,\n            repr=True, cmp=True, hash=None, init=True,\n-           convert=None, metadata=None, type=None, converter=None):\n+           convert=None, metadata=None, type=None, converter=None,\n+           factory=None):\n     \"\"\"\n     Create a new attribute on a class.\n \n@@ -83,6 +84,9 @@ def attrib(default=NOTHING, validator=None,\n \n     :type default: Any value.\n \n+    :param callable factory: Syntactic sugar for\n+        ``default=attr.Factory(callable)``.\n+\n     :param validator: :func:`callable` that is called by ``attrs``-generated\n         ``__init__`` methods after the instance has been initialized.  They\n         receive the initialized instance, the :class:`Attribute`, and the\n@@ -137,6 +141,8 @@ def attrib(default=NOTHING, validator=None,\n     .. deprecated:: 17.4.0 *convert*\n     .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated\n        *convert* to achieve consistency with other noun-based arguments.\n+    .. versionadded:: 18.1.0\n+       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.\n     \"\"\"\n     if hash is not None and hash is not True and hash is not False:\n         raise TypeError(\n@@ -156,6 +162,18 @@ def attrib(default=NOTHING, validator=None,\n         )\n         converter = convert\n \n+    if factory is not None:\n+        if default is not NOTHING:\n+            raise ValueError(\n+                \"The `default` and `factory` arguments are mutually \"\n+                \"exclusive.\"\n+            )\n+        if not callable(factory):\n+            raise ValueError(\n+                \"The `factory` argument must be a callable.\"\n+            )\n+        default = Factory(factory)\n+\n     if metadata is None:\n         metadata = {}\n \n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -525,6 +525,35 @@ class C(object):\n \n         assert not isinstance(x, _CountingAttr)\n \n+    def test_factory_sugar(self):\n+        \"\"\"\n+        Passing factory=f is syntactic sugar for passing default=Factory(f).\n+        \"\"\"\n+        @attr.s\n+        class C(object):\n+            x = attr.ib(factory=list)\n+\n+        assert Factory(list) == attr.fields(C).x.default\n+\n+    def test_sugar_factory_mutex(self):\n+        \"\"\"\n+        Passing both default and factory raises ValueError.\n+        \"\"\"\n+        with pytest.raises(ValueError, match=\"mutually exclusive\"):\n+            @attr.s\n+            class C(object):\n+                x = attr.ib(factory=list, default=Factory(list))\n+\n+    def test_sugar_callable(self):\n+        \"\"\"\n+        Factory has to be a callable to prevent people from passing Factory\n+        into it.\n+        \"\"\"\n+        with pytest.raises(ValueError, match=\"must be a callable\"):\n+            @attr.s\n+            class C(object):\n+                x = attr.ib(factory=Factory(list))\n+\n \n @attr.s\n class GC(object):\n",
        "problem_statement": "attr.Factory is a little wordy\nattrs is a huge net win on an object like this:\r\n\r\n```python\r\n@attr.s\r\nclass Point(object):\r\n    def __init__(self, x, y, z):\r\n        self.x = x\r\n        self.y = y\r\n        self.z = z\r\n\r\nimport attr\r\n@attr.s\r\nclass Point(object):\r\n    x = attr.ib()\r\n    y = attr.ib()\r\n    z = attr.ib()\r\n```\r\n\r\nbut it's a lot less clear when you have something like this:\r\n\r\n```python\r\nclass Cache(object):\r\n    def __init__(self):\r\n        self._stored = []\r\n        self._by_name = {}\r\n        self._by_id = {}\r\n```\r\n\r\nwhich becomes\r\n\r\n```python\r\n@attr.s\r\nclass Cache(object):\r\n    _stored = attr.ib(default=attr.Factory(list))\r\n    _by_name = attr.ib(default=attr.Factory(dict))\r\n    _by_id = attr.ib(default=attr.Factory(dict))\r\n```\r\n\r\nI think an alias for this behavior, like:\r\n\r\n```python\r\n@attr.s\r\nclass Cache(object):\r\n    _stored = attr.ib(new=list)\r\n    _by_name = attr.ib(new=dict)\r\n    _by_id = attr.ib(new=dict)\r\n```\r\n\r\ncould make initializing these types of mutable objects a lot less verbose.\n",
        "hints_text": "Don't really have a strong opinion here, but I've been finding myself really needing factories that take `self` lately. (I'm getting along with using `__attrs_post_init__` but it's kind of a workaround...)\r\n\r\nIf we're changing the design it'd be nice for the new design to elegantly accommodate these kinds of callables too.\nI think it should *at least* be `factory` if anything.  But I have to admit that the reason it\u2019s wordy is that I wanted to avoid mutually exclusive arguments.\r\n\r\nSadly, that ship has sailed *long* ago so keeping it up doesn\u2019t make a lot of sense anymore.\r\n\r\n***\r\n\r\nI guess passing a half-initialized self into the factory would make a lot of people happy\u2026\nI also think that attr could make it easier to set default mutable attribute values. IMHO having to explicitly create a Factory object is too wordy and not very discoverable.  Thus I like this proposal. In fact I proposed something similar to Hynek via email, although I suggested \"factory\" rather than \"new\" for the keyword argument. I think using \"factory\" rather than \"new\" would make it more clear than a factory is introduced automatically.\r\n\r\nThat being said, I think that while this would be nice it would only be a partial solution. It would not make it easy enough to set an attribute default value to a non empty list. To do that currently you need to use a Factory and a lambda:\r\n\r\n~~~Python\r\n@attr.s\r\nclass Player(object):\r\n    position = attr.ib(default=attr.Factory(lambda: [0, 0, 0]))\r\n~~~\r\n\r\nIMHO that is way too verbose, complex and obscure for such as common use case. With this new proposal you would do:\r\n\r\n~~~Python\r\n@attr.s\r\nclass Player(object):\r\n    position = attr.ib(factory=lambda: [0, 0, 0])\r\n~~~\r\n\r\nwhich is better, but still a bit obscure.\r\n\r\nInstead, or perhaps in addition to the \"factory\" parameter there should be a simple way to set an attribute default value to a mutable, non empty value. For example there could be a new \"mdefault\" attribute  (or perhaps \"new\", if we use \"factory\" for the previous use case) which would both add the Factory and the lambda for you:\r\n\r\n~~~Python\r\n@attr.s\r\nclass Player(object):\r\n    position = attr.ib(new=[0, 0, 0])\r\n~~~\r\n\r\nIdeally attr may be smart enough to detect when the value is immutable and skip the lambda when not needed.\r\n\nHm, I see @hynek 's point. I don't actually need `self`, but I do need the values of other arguments (post-convert, ideally post-validation). There's already an issue for this over at https://github.com/python-attrs/attrs/issues/165.\r\n\r\nFirst of all, I like `attr.ib(factory=<callable>)`. Second, we could run with this and inspect the callable arguments. For every argument, inject the value of the attribute with the same name. No arguments - just call the callable.\r\n\r\n```\r\n@attr.s\r\nclass A:\r\n    a = attr.ib(convert=int)\r\n    b = attr.ib(factory=lambda a: a+1)\r\n\r\n\r\n# Generated __init__ equivalent:\r\ndef __init__(self, a, b):\r\n    self.a = int(a)\r\n    self.b = (lambda a: a+1)(self.a)\r\n```\r\n\r\nA small problem with this is runtime errors:\r\n\r\n```\r\n@attr.s\r\nclass A:\r\n    a = attr.ib()\r\n    b = attr.ib(factory=lambda c: c+1)\r\n    c = attr.ib()\r\n```\r\n\r\nThis should be an error. But we kinda already do this by throwing errors if attributes with default aren't listed last.\nOn the one hand, I love this because it is incredibly precise and doesn't carry the structural risk of \"here's half a `self` I found lying around in the garbage, do stuff to it, I'm sure it's fine\" that you have with `__init__`.\r\n\r\nOn the other hand, wow, what terrifying magic.  Where did `a` come from???\r\n\r\nFinally though - there's no problem with putting `c` into `b`'s arg list, as long as there are no cycles in the graph, we can just topologically sort all attributes by their dependencies and then set them in reverse dependency order in the generated `__init__` \ud83d\ude08 \nHave you guys lost your minds? \ud83d\ude31\n> Have you guys lost your minds? \ud83d\ude31\r\n\r\nYou're right, if brevity is the goal, a kwarg is probably not sufficiently terse to be worthwhile.  How about this:\r\n\r\n```python\r\n@attr.s\r\nclass X:\r\n    a = attr.ib() | None # -> `default=`\r\n    b = attr.ib() ^ list # -> `default=Factory(list)`\r\n    c = attr.ib() & [] # -> `default=Factory(lambda shared_list=[]: copy.deepcopy(shared_list))\r\n```\r\n\r\nThoughts?\nOh wait, perhaps I missed the obvious here:\n```python\r\n@attr.s\r\nclass X:\r\n    a = attr.ib() + None # -> `default=None`\r\n    b = attr.ib() * list # -> `default=Factory(list)`\r\n    c = attr.ib() ** [] # -> `default=Factory(lambda shared_list=[]: copy.deepcopy(shared_list))\r\n```\r\n\nSilliness aside, if we\u2019d want to pass optionally a half-initialized self, we\u2019d have to distinguish between methods whose only argument happens to be `self` and functions that take a self.  So I guess we need to use a unique name? `half_initialized_self`? \ud83d\ude02\r\n\r\nSeems fragile and implicit though\u2026\nDid we kind of agree on `attr.ib(default=attr.Factory(list)) == attr.ib(factory=list)`?\n(if you need `self`, you can always use the `@x.default` decorator)\nA lot of people really dislike the word \"factory\"; it has some baggage.  How do you feel about something even briefer, like `attr.ib(new=list)`?\nI appreciate the marketing angle but we really want to add a second name for the same concept --  a name that doesn't really make a lot of sense? :-/\r\n\r\nDon't get me wrong: I'd love to call it `new` I just have a very hard time to reconcile/rationalize it.\nFactory is a pattern for an object with methods that produces other objects with methods.  But the more general concept of making a new thing, or creating something, is far more general than a factory.  For me it makes sense that `Factory` would be the class, but that the non-`Factory` way of specifying it would be under a different name.\nglyph has a far tighter definition of \"factory\" than I've ever heard. I think that name is fine, FWIW.\r\n\r\nThough oddly, I associate \"new\" with other languages (Java) and totally think of that as a thing that produces an object with methods.  But then\u2026 isn't everything an object with methods in Python?  `SIGLOOP`\n[There's some debate](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)); it's certainly used in other ways too.  I didn't mean to say that my definition was precisely technically correct, just that the term has more of a technical connotation due to the design-patterns literature.\n1. For me, a factory is something that poops out instances and isn\u2019t a constructor/initializer.\r\n2. I have no problem to associate `new` with creating new objects \u2013 you guys are forgetting the \u201cdefault\u201d part of it. :)  To that end, factory isn\u2019t great either I have to concede. `default_new` would probably be best I think \u2013 but y\u2019all are too lazy to type that, aren\u2019t you? :-|\r\n\r\nWhat I\u2019m thinking about right now is that someone who isn\u2019t intimate with attrs comes to a code base and `new` seems like something _super_ confusing.  And being hard on code readers has always been a popular point to bash attrs for so I would prefer to not fuel that any more.\r\n\r\nWould it kill y\u2019all to have:\r\n\r\n```\r\ndef clever_factory(inst):\r\n    ...\r\n    return value\r\n\r\n@attr.s\r\nclass C:\r\n    x = attr.ib(default_new=list)\r\n    y = attr.ib(default_new(attr.takes_self(clever_factory))\r\n    z = attr.ib(default=42)\r\n```\r\n\r\n?\r\n\r\nTo *me*, this seems like a sweet spot for consistency, brevity, and clarity.  Comments? \ud83d\ude48\nFor the middle one, what about `attr.ib(default=Factory(clever_factory, pass_self=True))`?\nThat\u2019s a *great* idea @glyph!  I love the idea so much that I built a time machine and implemented it in the past, so it can be in [17.1](http://www.attrs.org/en/stable/api.html#attr.Factory)! :D\r\n\r\n(but good you made me re-look it up; it\u2019s takes_self not pass_self).\nAt this point I feel like the easiest way of solving this is just changing the docs to:\r\n\r\n```\r\nfrom attr import Factory as new\r\n\r\n@attr.s\r\nclass C:\r\n    x = attr.ib(default=new(list))\r\n    y = attr.ib(default=new(clever_factory, takes_self=True))\r\n    z = attr.ib(default=42)\r\n```\r\n\r\n\ud83d\ude0e\n@Tinche\u2026 uh\u2026 dammit that's too easy!\r\n\nThis is actually what I do in my own code :).\nSo um after typing `attr.ib(default=attr.Factory(list))` 8x for a single class\u2026am I the only one having weird feelings about `new=`?  Suddenly I\u2019m sympathetic but I don\u2019t want to make decisions out of recent pain.\ngive in to your anger\nOK but I just can\u2019t get over the inconsistency of new/factory.   That would bother me until my death.\r\n\r\nWould you consider `attr.ib(factory=list)` a sufficiently significant improvement?\n@Tinche's example is pretty concise, even if you type `Factory` instead of `new`, so this seems unnecessary\u2026  I agree with your desire to void mutually exclusive arguments.\r\n\nWell, we could go as far as adding a factory for Factory called `new`. \ud83e\udd23\nI do own factoryfactoryfactory.com\n`attr.ib(factory=list)` is certainly a step up!\r\n\r\n`attr.ib(default=new(list))` looks quite nice too, but `new` has a lot of baggage in Python speak.\nfor \"correctness\" sake `attr.ib(default=attr.OciousParameterFreeDataFactory(list))` **hides**\n> Don't really have a strong opinion here, but I've been finding myself really needing factories that take self lately. (I'm getting along with using __attrs_post_init__ but it's kind of a workaround...)\r\n\r\nWanted to also confirm this. I've run into this very often, e.g. setting one attr with other attr as a default value. Writing out\r\n\r\n```python\r\n    y = attr.ib(default=attr.Factory(lambda self: self.x, takes_self=True))\r\n```\r\n\r\nis a bit too heavy though.\r\n\r\nWondering if `takes_self` could automatically be set to `True` if the factory argument is a callable whose signature is exactly one argument named `self`, as a shortcut? This introduces no ambiguity since a \"normal factory\" isn't expected to accept any arguments anyway. So the above could be just:\r\n\r\n```python\r\n    y = attr.ib(factory=lambda self: self.x)\r\n```\r\n\nAs a working proof of concept:\r\n\r\n```python\r\nfrom inspect import Signature, Parameter, signature\r\n\r\nclass Factory(attr.Factory):\r\n    def __init__(self, func, takes_self=None):\r\n        if takes_self is None:\r\n            takes_self = signature(func) == Signature(\r\n                [Parameter('self', Parameter.POSITIONAL_OR_KEYWORD)]\r\n            )\r\n        super().__init__(func, takes_self=takes_self)\r\n        \r\ndef attrib(*args, factory=None, **kwargs):\r\n    if factory is not None:\r\n        kwargs['default'] = Factory(factory)\r\n    return attr.ib(*args, **kwargs)\r\n\r\n@attr.s\r\nclass Bar:\r\n    x = attrib()\r\n    y = attrib(factory=lambda self: self.x)\r\n```\r\n\r\n```python\r\n>>> Bar(42)\r\nBar(x=42, y=42)\r\n```\n@glyph: The [current state of things](https://github.com/python-attrs/attrs/blob/master/docs/examples.rst#types) is pretty good, yo:\r\n\r\n```python\r\n@attr.s(auto_attribs=True)\r\nclass Cache(object):\r\n    _stored: list = Factory(list)\r\n    _by_name: dict = Factory(dict)\r\n    _by_id: dict = Factory(dict)\r\n```\r\n\nmakes me wonder if a `auto_factory` would be a neat thing to have\nWhat would `auto_factory` mean?\r\n\r\nAnyway, I'd assert that the above syntax addresses this ticket.\nOops didn't mean to close\nSince this thread has already fans on Twitter and I got annoyed by the wordiness a few times myself, here\u2019s my final offer:\r\n\r\n`attr.ib(factory=list)` as syntactic sugar for `attr.ib(default=attr.Factory(list, pass_self=False))`\r\n\r\nNo magic, no nothing. If you need more power: there\u2019s two other ways for it.\nSounds cool!",
        "created_at": "2018-03-14T16:04:05Z",
        "version": "17.4"
    }
}