{
    "task_id": "python-attrs__attrs-886",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-886_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 886,
        "instance_id": "python-attrs__attrs-886",
        "issue_numbers": [
            "835"
        ],
        "base_commit": "8ae0bd904d6147ce37750fa7ec336f951c14495c",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -59,6 +59,8 @@\n # Unique object for unequivocal getattr() defaults.\n _sentinel = object()\n \n+_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\n+\n \n class _Nothing(object):\n     \"\"\"\n@@ -722,13 +724,31 @@ def __init__(\n             self._cls_dict[\"__delattr__\"] = _frozen_delattrs\n \n             self._wrote_own_setattr = True\n-        elif on_setattr == setters.validate:\n+        elif on_setattr in (\n+            _ng_default_on_setattr,\n+            setters.validate,\n+            setters.convert,\n+        ):\n+            has_validator = has_converter = False\n             for a in attrs:\n                 if a.validator is not None:\n+                    has_validator = True\n+                if a.converter is not None:\n+                    has_converter = True\n+\n+                if has_validator and has_converter:\n                     break\n-            else:\n-                # If class-level on_setattr is set to validating, but there's\n-                # no field to validate, pretend like there's no on_setattr.\n+            if (\n+                (\n+                    on_setattr == _ng_default_on_setattr\n+                    and not (has_validator or has_converter)\n+                )\n+                or (on_setattr == setters.validate and not has_validator)\n+                or (on_setattr == setters.convert and not has_converter)\n+            ):\n+                # If class-level on_setattr is set to convert + validate, but\n+                # there's no field to convert or validate, pretend like there's\n+                # no on_setattr.\n                 self._on_setattr = None\n \n         if getstate_setstate:\n@@ -2123,9 +2143,7 @@ def _make_init(\n                 raise ValueError(\"Frozen classes can't use on_setattr.\")\n \n             needs_cached_setattr = True\n-        elif (\n-            has_cls_on_setattr and a.on_setattr is not setters.NO_OP\n-        ) or _is_slot_attr(a.name, base_attr_map):\n+        elif has_cls_on_setattr and a.on_setattr is not setters.NO_OP:\n             needs_cached_setattr = True\n \n     unique_filename = _generate_unique_filename(cls, \"init\")\ndiff --git a/src/attr/_next_gen.py b/src/attr/_next_gen.py\n--- a/src/attr/_next_gen.py\n+++ b/src/attr/_next_gen.py\n@@ -8,7 +8,13 @@\n from attr.exceptions import UnannotatedAttributeError\n \n from . import setters\n-from ._make import NOTHING, _frozen_setattrs, attrib, attrs\n+from ._make import (\n+    NOTHING,\n+    _frozen_setattrs,\n+    _ng_default_on_setattr,\n+    attrib,\n+    attrs,\n+)\n \n \n def define(\n@@ -35,8 +41,10 @@ def define(\n     match_args=True,\n ):\n     r\"\"\"\n-    The only behavioral differences are the handling of the *auto_attribs*\n-    option:\n+    Define an ``attrs`` class.\n+\n+    The behavioral differences to `attr.s` are the handling of the\n+    *auto_attribs* option:\n \n     :param Optional[bool] auto_attribs: If set to `True` or `False`, it behaves\n        exactly like `attr.s`. If left `None`, `attr.s` will try to guess:\n@@ -46,9 +54,11 @@ def define(\n        2. Otherwise it assumes *auto_attribs=False* and tries to collect\n           `attr.ib`\\ s.\n \n-    and that mutable classes (``frozen=False``) validate on ``__setattr__``.\n+    and that mutable classes (``frozen=False``) convert and validate on\n+    ``__setattr__``.\n \n     .. versionadded:: 20.1.0\n+    .. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.\n     \"\"\"\n \n     def do_it(cls, auto_attribs):\n@@ -86,9 +96,9 @@ def wrap(cls):\n \n         had_on_setattr = on_setattr not in (None, setters.NO_OP)\n \n-        # By default, mutable classes validate on setattr.\n+        # By default, mutable classes convert & validate on setattr.\n         if frozen is False and on_setattr is None:\n-            on_setattr = setters.validate\n+            on_setattr = _ng_default_on_setattr\n \n         # However, if we subclass a frozen class, we inherit the immutability\n         # and disable on_setattr.\n",
        "test_patch": "diff --git a/tests/test_functional.py b/tests/test_functional.py\n--- a/tests/test_functional.py\n+++ b/tests/test_functional.py\n@@ -17,7 +17,7 @@\n \n import attr\n \n-from attr._compat import PY2, TYPE\n+from attr._compat import PY2, PY36, TYPE\n from attr._make import NOTHING, Attribute\n from attr.exceptions import FrozenInstanceError\n \n@@ -692,8 +692,9 @@ class C(object):\n     @pytest.mark.parametrize(\"slots\", [True, False])\n     def test_no_setattr_if_validate_without_validators(self, slots):\n         \"\"\"\n-        If a class has on_setattr=attr.setters.validate (default in NG APIs)\n-        but sets no validators, don't use the (slower) setattr in __init__.\n+        If a class has on_setattr=attr.setters.validate (former default in NG\n+        APIs) but sets no validators, don't use the (slower) setattr in\n+        __init__.\n \n         Regression test for #816.\n         \"\"\"\n@@ -713,6 +714,58 @@ class D(C):\n         assert \"self.y = y\" in src\n         assert object.__setattr__ == D.__setattr__\n \n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_no_setattr_if_convert_without_converters(self, slots):\n+        \"\"\"\n+        If a class has on_setattr=attr.setters.convert but sets no validators,\n+        don't use the (slower) setattr in __init__.\n+        \"\"\"\n+\n+        @attr.s(on_setattr=attr.setters.convert)\n+        class C(object):\n+            x = attr.ib()\n+\n+        @attr.s(on_setattr=attr.setters.convert)\n+        class D(C):\n+            y = attr.ib()\n+\n+        src = inspect.getsource(D.__init__)\n+\n+        assert \"setattr\" not in src\n+        assert \"self.x = x\" in src\n+        assert \"self.y = y\" in src\n+        assert object.__setattr__ == D.__setattr__\n+\n+    @pytest.mark.skipif(not PY36, reason=\"NG APIs are 3.6+\")\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_no_setattr_with_ng_defaults(self, slots):\n+        \"\"\"\n+        If a class has the NG default on_setattr=[convert, validate] but sets\n+        no validators or converters, don't use the (slower) setattr in\n+        __init__.\n+        \"\"\"\n+\n+        @attr.define\n+        class C(object):\n+            x = attr.ib()\n+\n+        src = inspect.getsource(C.__init__)\n+\n+        assert \"setattr\" not in src\n+        assert \"self.x = x\" in src\n+        assert object.__setattr__ == C.__setattr__\n+\n+        @attr.define\n+        class D(C):\n+            y = attr.ib()\n+\n+        src = inspect.getsource(D.__init__)\n+\n+        assert \"setattr\" not in src\n+        assert \"self.x = x\" in src\n+        assert \"self.y = y\" in src\n+        assert object.__setattr__ == D.__setattr__\n+\n     def test_on_setattr_detect_inherited_validators(self):\n         \"\"\"\n         _make_init detects the presence of a validator even if the field is\ndiff --git a/tests/test_next_gen.py b/tests/test_next_gen.py\n--- a/tests/test_next_gen.py\n+++ b/tests/test_next_gen.py\n@@ -308,3 +308,28 @@ class MyException(Exception):\n \n         assert \"foo\" == ei.value.x\n         assert ei.value.__cause__ is None\n+\n+    def test_converts_and_validates_by_default(self):\n+        \"\"\"\n+        If no on_setattr is set, assume setters.convert, setters.validate.\n+        \"\"\"\n+\n+        @attr.define\n+        class C:\n+            x: int = attr.field(converter=int)\n+\n+            @x.validator\n+            def _v(self, _, value):\n+                if value < 10:\n+                    raise ValueError(\"must be >=10\")\n+\n+        inst = C(10)\n+\n+        # Converts\n+        inst.x = \"11\"\n+\n+        assert 11 == inst.x\n+\n+        # Validates\n+        with pytest.raises(ValueError, match=\"must be >=10\"):\n+            inst.x = \"9\"\n",
        "problem_statement": "Clarification - Converters vs on_setattr / Convert automatically when setting \nattrs version: 21.2.0\r\n\r\nUsing the documentation [on Converters](https://www.attrs.org/en/stable/init.html#converters) it was not immediately clear that converters only work on instantiation of a new attrs-enhanced class. (Or I totally missed something.) \r\n\r\n1. Is this the intended function? That the type conversion only happens on class instantiation and not when setting an attribute? (e.g. ```o.x = \"2\" ``` in the example in the documentation)\r\n    * If yes: Perhaps the documentation could be clarified to explain this and also provide a clear example of using ```on_setattr``` to also run the converter\r\n    * If no: Perhaps there's a bug because setting an attribute when a converter is specified does not work\r\n\r\nAnd further: from a logical design standpoint, it seems that if you're specifying a converter to be run at class instantiation [which means *all* values on *new* instances are run through that converter....] what circumstances would you *not* want that to run when setting attributes? Part of the purpose of converters is to ensure consistent typing and normalization (from the documentation: _\"Finally, sometimes you may want to normalize the values coming in. For that\u00a0attrs\u00a0comes with converters.\"_). Given that, it seems strange that you could break that normalization by simply setting an attribute.\r\n\r\nTL;DR: Converters only run on class instantiation. Shouldn't they be run when setting an attribute as well?\n",
        "hints_text": "Marking as documentation because `on_setattr` seems to lack narrative docs, and running converters and validators on set as well as init time is probably a common enough use case to warrant some text.\nI'm not sure where to put narrative information\u2026should we open a new chapter for it?\nI just ran into this behavior that validators are run on instantiation only. \r\nPlease find time to add this to https://www.attrs.org/en/stable/examples.html#validators as a warning. Its behavior is fine as it is as long as its documented. \r\nAs far as documenting on_setattr is concerned doing it bellow validators on same page would be nice. \r\nI have tried to implement it the same way i did validator (by using decorator example) but ended up with TypeError: 'NoneType\" object is not callable. In the end i just used standard python way to define setter via decorator. \r\nThanks\nI have added blurbs in 95b70bd, although I hope that by the next release, the examples will be rewritten using NG APIs.\r\n\r\n---\r\n\r\nAs for the original issue \u2013 I'm willing to break b/w compat here since the APIs are new and the impact is limited to few people. I honestly don't remember why I chose to only run validators \u2013 maybe because people kept complaining about it and I just\u2026forgot about converters?\n@hynek \r\nI am also complaining ! ;-)\r\nI would definitely need the converters also on_setattr !\r\n\r\n```\r\n@attr.define(slots=True)\r\nclass MyDataClass(object):\r\n    my_value=attr.ib(default=0, converter=int)\r\n\r\n>>> my_data=MyDataClass()\r\n>>> my_data.my_value='1'\r\n>>> assert 1 == my_data.my_value\r\n```\r\nbetter yesterday then tomorrow ;-),  i just needed to write ugly and slow own converters - \r\nit would have saved me a lot of effort it that would work.\r\n\r\nI just came here to put a question why it is not working - and landed at this thread.\r\n\r\nyours sincerely, und Gr\u00fc\u00dfe nach Berlin\r\n\r\nbitranox, Vienna\r\n\r\n\r\n",
        "created_at": "2021-12-13T13:23:03Z",
        "version": "21.2"
    }
}