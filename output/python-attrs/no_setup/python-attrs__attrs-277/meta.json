{
    "task_id": "python-attrs__attrs-277",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-277_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 277,
        "instance_id": "python-attrs__attrs-277",
        "issue_numbers": [
            "262"
        ],
        "base_commit": "2a50c4b93002a0f4f4355051759beae5e0324497",
        "patch": "diff --git a/src/attr/__init__.py b/src/attr/__init__.py\n--- a/src/attr/__init__.py\n+++ b/src/attr/__init__.py\n@@ -1,5 +1,7 @@\n from __future__ import absolute_import, division, print_function\n \n+from functools import partial\n+\n from ._funcs import (\n     asdict,\n     assoc,\n@@ -43,6 +45,7 @@\n \n s = attributes = attrs\n ib = attr = attrib\n+dataclass = partial(attrs, auto_attribs=True)  # happy Easter ;)\n \n __all__ = [\n     \"Attribute\",\ndiff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -18,6 +18,7 @@\n     DefaultAlreadySetError,\n     FrozenInstanceError,\n     NotAnAttrsClassError,\n+    UnannotatedAttributeError,\n )\n \n \n@@ -190,7 +191,17 @@ class MyClassAttributes(tuple):\n ])\n \n \n-def _transform_attrs(cls, these):\n+def _is_class_var(annot):\n+    \"\"\"\n+    Check whether *annot* is a typing.ClassVar.\n+\n+    The implementation is gross but importing `typing` is slow and there are\n+    discussions to remove it from the stdlib alltogether.\n+    \"\"\"\n+    return str(annot).startswith(\"typing.ClassVar\")\n+\n+\n+def _transform_attrs(cls, these, auto_attribs):\n     \"\"\"\n     Transform all `_CountingAttr`s on a class into `Attribute`s.\n \n@@ -198,24 +209,58 @@ def _transform_attrs(cls, these):\n \n     Return an `_Attributes`.\n     \"\"\"\n-    if these is None:\n-        ca_list = [(name, attr)\n-                   for name, attr\n-                   in cls.__dict__.items()\n-                   if isinstance(attr, _CountingAttr)]\n+    cd = cls.__dict__\n+    anns = getattr(cls, \"__annotations__\", {})\n+\n+    if these is None and auto_attribs is False:\n+        ca_list = sorted((\n+            (name, attr)\n+            for name, attr\n+            in cd.items()\n+            if isinstance(attr, _CountingAttr)\n+        ), key=lambda e: e[1].counter)\n+    elif these is None and auto_attribs is True:\n+        ca_names = {\n+            name\n+            for name, attr\n+            in cd.items()\n+            if isinstance(attr, _CountingAttr)\n+        }\n+        ca_list = []\n+        annot_names = set()\n+        for attr_name, type in anns.items():\n+            if _is_class_var(type):\n+                continue\n+            annot_names.add(attr_name)\n+            a = cd.get(attr_name, NOTHING)\n+            if not isinstance(a, _CountingAttr):\n+                if a is NOTHING:\n+                    a = attrib()\n+                else:\n+                    a = attrib(default=a)\n+            ca_list.append((attr_name, a))\n+\n+        unannotated = ca_names - annot_names\n+        if len(unannotated) > 0:\n+            raise UnannotatedAttributeError(\n+                \"The following `attr.ib`s lack a type annotation: \" +\n+                \", \".join(sorted(\n+                    unannotated,\n+                    key=lambda n: cd.get(n).counter\n+                )) + \".\"\n+            )\n     else:\n-        ca_list = [(name, ca)\n-                   for name, ca\n-                   in iteritems(these)]\n-    ca_list = sorted(ca_list, key=lambda e: e[1].counter)\n-\n-    ann = getattr(cls, \"__annotations__\", {})\n+        ca_list = sorted((\n+            (name, ca)\n+            for name, ca\n+            in iteritems(these)\n+        ), key=lambda e: e[1].counter)\n \n     non_super_attrs = [\n         Attribute.from_counting_attr(\n             name=attr_name,\n             ca=ca,\n-            type=ann.get(attr_name),\n+            type=anns.get(attr_name),\n         )\n         for attr_name, ca\n         in ca_list\n@@ -250,7 +295,7 @@ def _transform_attrs(cls, these):\n             Attribute.from_counting_attr(\n                 name=attr_name,\n                 ca=ca,\n-                type=ann.get(attr_name)\n+                type=anns.get(attr_name)\n             )\n             for attr_name, ca\n             in ca_list\n@@ -296,8 +341,8 @@ class _ClassBuilder(object):\n         \"_frozen\", \"_has_post_init\",\n     )\n \n-    def __init__(self, cls, these, slots, frozen):\n-        attrs, super_attrs = _transform_attrs(cls, these)\n+    def __init__(self, cls, these, slots, frozen, auto_attribs):\n+        attrs, super_attrs = _transform_attrs(cls, these, auto_attribs)\n \n         self._cls = cls\n         self._cls_dict = dict(cls.__dict__) if slots else {}\n@@ -460,7 +505,7 @@ def add_cmp(self):\n \n def attrs(maybe_cls=None, these=None, repr_ns=None,\n           repr=True, cmp=True, hash=None, init=True,\n-          slots=False, frozen=False, str=False):\n+          slots=False, frozen=False, str=False, auto_attribs=False):\n     r\"\"\"\n     A class decorator that adds `dunder\n     <https://wiki.python.org/moin/DunderAlias>`_\\ -methods according to the\n@@ -535,6 +580,23 @@ def attrs(maybe_cls=None, these=None, repr_ns=None,\n                ``object.__setattr__(self, \"attribute_name\", value)``.\n \n         ..  _slots: https://docs.python.org/3/reference/datamodel.html#slots\n+    :param bool auto_attribs: If True, collect `PEP 526`_-annotated attributes\n+        (Python 3.6 and later only) from the class body.\n+\n+        In this case, you **must** annotate every field.  If ``attrs``\n+        encounters a field that is set to an :func:`attr.ib` but lacks a type\n+        annotation, an :exc:`attr.exceptions.UnannotatedAttributeError` is\n+        raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't\n+        want to set a type.\n+\n+        If you assign a value to those attributes (e.g. ``x: int = 42``), that\n+        value becomes the default value like if it were passed using\n+        ``attr.ib(default=42)``.  Passing an instance of :class:`Factory` also\n+        works as expected.\n+\n+        Attributes annotated as :class:`typing.ClassVar` are **ignored**.\n+\n+        .. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/\n \n     ..  versionadded:: 16.0.0 *slots*\n     ..  versionadded:: 16.1.0 *frozen*\n@@ -542,12 +604,13 @@ def attrs(maybe_cls=None, these=None, repr_ns=None,\n     ..  versionchanged::\n             17.1.0 *hash* supports ``None`` as value which is also the default\n             now.\n+    .. versionadded:: 17.3.0 *auto_attribs*\n     \"\"\"\n     def wrap(cls):\n         if getattr(cls, \"__class__\", None) is None:\n             raise TypeError(\"attrs only works with new-style classes.\")\n \n-        builder = _ClassBuilder(cls, these, slots, frozen)\n+        builder = _ClassBuilder(cls, these, slots, frozen, auto_attribs)\n \n         if repr is True:\n             builder.add_repr(repr_ns)\ndiff --git a/src/attr/exceptions.py b/src/attr/exceptions.py\n--- a/src/attr/exceptions.py\n+++ b/src/attr/exceptions.py\n@@ -37,3 +37,12 @@ class DefaultAlreadySetError(RuntimeError):\n \n     .. versionadded:: 17.1.0\n     \"\"\"\n+\n+\n+class UnannotatedAttributeError(RuntimeError):\n+    \"\"\"\n+    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n+    annotation.\n+\n+    .. versionadded:: 17.3.0\n+    \"\"\"\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -4,12 +4,15 @@\n Python 3.6+ only.\n \"\"\"\n \n+import types\n import typing\n \n import pytest\n \n import attr\n \n+from attr.exceptions import UnannotatedAttributeError\n+\n \n class TestAnnotations:\n     \"\"\"\n@@ -65,3 +68,66 @@ class C:\n             y: int\n \n         assert 1 == len(attr.fields(C))\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_auto_attribs(self, slots):\n+        \"\"\"\n+        If *auto_attribs* is True, bare annotations are collected too.\n+        Defaults work and class variables are ignored.\n+        \"\"\"\n+        @attr.s(auto_attribs=True, slots=slots)\n+        class C:\n+            cls_var: typing.ClassVar[int] = 23\n+            a: int\n+            x: typing.List[int] = attr.Factory(list)\n+            y: int = 2\n+            z: int = attr.ib(default=3)\n+            foo: typing.Any = None\n+\n+        i = C(42)\n+        assert \"C(a=42, x=[], y=2, z=3, foo=None)\" == repr(i)\n+\n+        attr_names = set(a.name for a in C.__attrs_attrs__)\n+        assert \"a\" in attr_names  # just double check that the set works\n+        assert \"cls_var\" not in attr_names\n+\n+        assert int == attr.fields(C).a.type\n+\n+        assert attr.Factory(list) == attr.fields(C).x.default\n+        assert typing.List[int] == attr.fields(C).x.type\n+\n+        assert int == attr.fields(C).y.type\n+        assert 2 == attr.fields(C).y.default\n+\n+        assert int == attr.fields(C).z.type\n+\n+        assert typing.Any == attr.fields(C).foo.type\n+\n+        # Class body is clean.\n+        if slots is False:\n+            with pytest.raises(AttributeError):\n+                C.y\n+\n+            assert 2 == i.y\n+        else:\n+            assert isinstance(C.y, types.MemberDescriptorType)\n+\n+            i.y = 23\n+            assert 23 == i.y\n+\n+    @pytest.mark.parametrize(\"slots\", [True, False])\n+    def test_auto_attribs_unannotated(self, slots):\n+        \"\"\"\n+        Unannotated `attr.ib`s raise an error.\n+        \"\"\"\n+        with pytest.raises(UnannotatedAttributeError) as e:\n+            @attr.s(slots=slots, auto_attribs=True)\n+            class C:\n+                v = attr.ib()\n+                x: int\n+                y = attr.ib()\n+                z: str\n+\n+        assert (\n+            \"The following `attr.ib`s lack a type annotation: v, y.\",\n+        ) == e.value.args\ndiff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -144,7 +144,7 @@ def test_no_modifications(self):\n         Doesn't attach __attrs_attrs__ to the class anymore.\n         \"\"\"\n         C = make_tc()\n-        _transform_attrs(C, None)\n+        _transform_attrs(C, None, False)\n \n         assert None is getattr(C, \"__attrs_attrs__\", None)\n \n@@ -153,7 +153,7 @@ def test_normal(self):\n         Transforms every `_CountingAttr` and leaves others (a) be.\n         \"\"\"\n         C = make_tc()\n-        attrs, _, = _transform_attrs(C, None)\n+        attrs, _, = _transform_attrs(C, None, False)\n \n         assert [\"z\", \"y\", \"x\"] == [a.name for a in attrs]\n \n@@ -165,14 +165,14 @@ def test_empty(self):\n         class C(object):\n             pass\n \n-        assert _Attributes(((), [])) == _transform_attrs(C, None)\n+        assert _Attributes(((), [])) == _transform_attrs(C, None, False)\n \n     def test_transforms_to_attribute(self):\n         \"\"\"\n         All `_CountingAttr`s are transformed into `Attribute`s.\n         \"\"\"\n         C = make_tc()\n-        attrs, super_attrs = _transform_attrs(C, None)\n+        attrs, super_attrs = _transform_attrs(C, None, False)\n \n         assert [] == super_attrs\n         assert 3 == len(attrs)\n@@ -188,7 +188,7 @@ class C(object):\n             y = attr.ib()\n \n         with pytest.raises(ValueError) as e:\n-            _transform_attrs(C, None)\n+            _transform_attrs(C, None, False)\n         assert (\n             \"No mandatory attributes allowed after an attribute with a \"\n             \"default value or factory.  Attribute in question: Attribute\"\n@@ -207,7 +207,7 @@ class Base(object):\n         class C(Base):\n             y = attr.ib()\n \n-        attrs, super_attrs = _transform_attrs(C, {\"x\": attr.ib()})\n+        attrs, super_attrs = _transform_attrs(C, {\"x\": attr.ib()}, False)\n \n         assert [] == super_attrs\n         assert (\n@@ -817,7 +817,7 @@ def test_repr(self):\n         class C(object):\n             pass\n \n-        b = _ClassBuilder(C, None, True, True)\n+        b = _ClassBuilder(C, None, True, True, False)\n \n         assert \"<_ClassBuilder(cls=C)>\" == repr(b)\n \n@@ -828,7 +828,7 @@ def test_returns_self(self):\n         class C(object):\n             x = attr.ib()\n \n-        b = _ClassBuilder(C, None, True, True)\n+        b = _ClassBuilder(C, None, True, True, False)\n \n         cls = b.add_cmp().add_hash().add_init().add_repr(\"ns\").add_str() \\\n             .build_class()\n",
        "problem_statement": "Add option to collect annotated fields\nSince I\u2019m sick of hearing that \u201c[PEP 557](https://www.python.org/dev/peps/pep-0557/) is like attrs, but using variable annotations for field declarations\u201d, I\u2019d like to have an option to collect annotated fields that have no attr.ib definition.\r\n\r\nie.\r\n\r\n```python\r\n@attr.s(collect_bare=True)\r\nclass C:\r\n    x: int\r\n```\r\n\r\nshould be equivalent to:\r\n\r\n```python\r\n@attr.s\r\nclass C:\r\n    x: int = attr.ib()\r\n```\r\n\r\nI\u2019m open to better/shorter names.\r\n\r\nVolunteers?  @chadrik maybe? :)\n",
        "hints_text": "Hm I'd actually be ok with doing this by default?\nA turn off switch would be nice, just default collect_bare to true? Is this a compatibility issue?\nI\u2019d love to but that is technically backward incompatible.\nDurn it.\nWe could run it thru a deprecation cycle I guess?\n`s/collect_bare/automatic_attributes/`\r\n\nMaybe just `auto_attribs`?\nSo I gave this a lackluster shot and I\u2019ve run into a problem:\r\n\r\n```python\r\n    def test_auto_attribs(self):\r\n        \"\"\"\r\n        If *auto_attribs* is True, bare annotations are collected too.\r\n        \"\"\"\r\n        @attr.s(auto_attribs=True)\r\n        class C:\r\n            x: typing.List[int]\r\n            b = attr.ib()\r\n            y: int\r\n\r\n        assert \"C(x=1, b=2, y=3)\" == repr(C(1, 2, 3))\r\n```\r\n\r\n`x` and `y` are defined in `__annotations__` while `b` is defined in `__dict__`.  It there a way to determine their order?\r\n\r\n***\r\n\r\nTo me it looks like all we can do is to allow either 100% annotations or 100% `attr.ib`s which only makes sense once we have something like this:\r\n\r\n```python\r\n@attr.s(auto_attribs=True, check_types=True)\r\nclass Point:\r\n    x: float\r\n    y: float\r\n```\r\n\r\nor am I missing something?  (since we can\u2019t attach any more meta data to the fields, this has to be something that happens in `@attr.s`)\r\n\r\nThis kind of smells like a `record = attr.s(auto_attribs=True, check_types=True, frozen=True, slots=True)` which is certainly useful\r\n\r\n***\r\n\r\nOr am I missing something?.\nAh OK: we just have to enforce that all fields are annotated.  That\u2019s not that bad.",
        "created_at": "2017-10-27T08:03:24Z",
        "version": "17.2"
    }
}