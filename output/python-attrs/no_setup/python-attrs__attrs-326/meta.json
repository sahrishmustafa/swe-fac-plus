{
    "task_id": "python-attrs__attrs-326",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-326_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 326,
        "instance_id": "python-attrs__attrs-326",
        "issue_numbers": [
            "311"
        ],
        "base_commit": "1f0d85199666cfa881385c31314a6b2d39f6c36e",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -443,20 +443,26 @@ def _create_slots_class(self):\n         if qualname is not None:\n             cd[\"__qualname__\"] = qualname\n \n-        attr_names = tuple(self._attr_names)\n+        # __weakref__ is not writable.\n+        state_attr_names = tuple(\n+            an for an in self._attr_names if an != \"__weakref__\"\n+        )\n \n         def slots_getstate(self):\n             \"\"\"\n             Automatically created by attrs.\n             \"\"\"\n-            return tuple(getattr(self, name) for name in attr_names)\n+            return tuple(\n+                getattr(self, name)\n+                for name in state_attr_names\n+            )\n \n         def slots_setstate(self, state):\n             \"\"\"\n             Automatically created by attrs.\n             \"\"\"\n             __bound_setattr = _obj_setattr.__get__(self, Attribute)\n-            for name, value in zip(attr_names, state):\n+            for name, value in zip(state_attr_names, state):\n                 __bound_setattr(name, value)\n \n         # slots and frozen require __getstate__/__setstate__ to work\n",
        "test_patch": "diff --git a/tests/test_make.py b/tests/test_make.py\n--- a/tests/test_make.py\n+++ b/tests/test_make.py\n@@ -4,6 +4,7 @@\n \n from __future__ import absolute_import, division, print_function\n \n+import copy\n import inspect\n import itertools\n import sys\n@@ -1054,3 +1055,16 @@ def fake_meth(self):\n \n         assert \"42\" == rv.__module__ == fake_meth.__module__\n         assert \"23\" == rv.__qualname__ == fake_meth.__qualname__\n+\n+    def test_weakref_setstate(self):\n+        \"\"\"\n+        __weakref__ is not set on in setstate because it's not writable in\n+        slots classes.\n+        \"\"\"\n+        @attr.s(slots=True)\n+        class C(object):\n+            __weakref__ = attr.ib(\n+                init=False, hash=False, repr=False, cmp=False\n+            )\n+\n+        assert C() == copy.deepcopy(C())\n",
        "problem_statement": "deepcopy stopped working with slots=True and __weakref__ after updating to 17.3.0\n```Python 2.7.12 (default, Nov 20 2017, 18:23:56) \r\n[GCC 5.4.0 20160609] on linux2\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import attr\r\n>>> attr.__version__\r\n'17.3.0'\r\n>>> from copy import deepcopy\r\n>>> @attr.s(slots=True)\r\n... class Han(object):\r\n...     __weakref__ = attr.ib(init=False, hash=False, repr=False, cmp=False)\r\n... \r\n>>> h = Han()\r\n>>> o = deepcopy(h)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/usr/lib/python2.7/copy.py\", line 190, in deepcopy\r\n    y = _reconstruct(x, rv, 1, memo)\r\n  File \"/usr/lib/python2.7/copy.py\", line 336, in _reconstruct\r\n    y.__setstate__(state)\r\n  File \"/usr/local/lib/python2.7/dist-packages/attr/_make.py\", line 432, in slots_setstate\r\n    __bound_setattr(name, value)\r\nAttributeError: attribute '__weakref__' of 'Han' objects is not writable\r\n```\n",
        "hints_text": "Hm. I'll take a look soonish.\nAny update Tin?\nUhh totally forgot about this. Will take a look tomorrow.\nPlot twist, the above code works on OS X, CPython 3.6.1. But I remember looking at this at home on Linux and it didn't work.\nIt doesn\u2019t work for me on macOS High Sierra and 3.6.3.  Could you maybe have forgotten the decorator?  Happened to me too while checking.\r\n\r\nI also think I know what\u2019s happening: attrs deletes `__weakref__` because it\u2019s an attribute.\r\n\r\nWe\u2019ll have to create a blacklist of things that shouldn\u2019t be deleted.\nRunning Python docker images on OS X, 2.7.14 and 3.6.4 seem to work?\r\n\r\n```\r\nroot@ec456701d792:~# cat d.py\r\nimport attr\r\nfrom copy import deepcopy\r\n\r\n\r\n@attr.s(slots=True)\r\nclass Han(object):\r\n    __weakref__ = attr.ib(init=False, hash=False, repr=False, cmp=False)\r\n\r\n\r\nh = Han()\r\n\r\no = deepcopy(h)\r\n```\nThis is against master, btw.\n> I also think I know what\u2019s happening: attrs deletes __weakref__ because it\u2019s an attribute.\r\n\r\nWe don't do that for slot classes, right?\n```python\r\nTraceback (most recent call last):\r\n  File \"t2.py\", line 12, in <module>\r\n    o = deepcopy(h)\r\n  File \"/Users/hynek/.virtualenvs/attrs/lib/python3.6/copy.py\", line 180, in deepcopy\r\n    y = _reconstruct(x, memo, *rv)\r\n  File \"/Users/hynek/.virtualenvs/attrs/lib/python3.6/copy.py\", line 282, in _reconstruct\r\n    y.__setstate__(state)\r\n  File \"/Users/hynek/Projects/attrs/src/attr/_make.py\", line 460, in slots_setstate\r\n    __bound_setattr(name, value)\r\nAttributeError: attribute '__weakref__' of 'Han' objects is not writable\r\n```\n> We don't do that for slot classes, right?\r\n\r\nOh yeah right.  So the bug seems to be in `slots_setstate` \u2013 I\u2019ve just had a look and it doesn\u2019t seem to check for init=False? \ud83e\udd14\nI still can't repro this. 3.6.3 you say?\r\n\r\n```\r\nttvrtkovic@NANOZAGDEV019 ~/p/attrs> docker run --rm -ti -v (pwd):/root python:3.6.3 /bin/bash\r\nUnable to find image 'python:3.6.3' locally\r\n3.6.3: Pulling from library/python\r\nf49cf87b52c1: Already exists\r\n7b491c575b06: Already exists\r\nb313b08bab3b: Already exists\r\n51d6678c3f0e: Already exists\r\n09f35bd58db2: Already exists\r\n1bda3d37eead: Pull complete\r\n9f47966d4de2: Pull complete\r\n9fd775bfe531: Pull complete\r\nDigest: sha256:cdef88d8625cf50ca705b7abfe99e8eb33b889652a9389b017eb46a6d2f1aaf3\r\nStatus: Downloaded newer image for python:3.6.3\r\nroot@83388638cbc3:/# cd root\r\nroot@83388638cbc3:~# pip install -e .\r\nObtaining file:///root\r\nInstalling collected packages: attrs\r\n  Running setup.py develop for attrs\r\nSuccessfully installed attrs\r\nroot@83388638cbc3:~# python -V\r\nPython 3.6.3\r\nroot@83388638cbc3:~# cat d.py\r\nimport attr\r\nfrom copy import deepcopy\r\n\r\n\r\n@attr.s(slots=True)\r\nclass Han(object):\r\n    __weakref__ = attr.ib(init=False, hash=False, repr=False, cmp=False)\r\n\r\n\r\nh = Han()\r\n\r\no = deepcopy(h)\r\nroot@83388638cbc3:~# python d.py\r\nroot@83388638cbc3:~#\r\n```\r\nSomething fishy going on.\nI'm an idiot, I wasn't actually on master.\n(replaced the last comment with this one)\r\n\r\nYeah, I can repro now. I think our `__setstate__` implementation is interacting badly with, well, Python. Consider this:\r\n\r\n```\r\nclass D:\r\n    __slots__ = ('__weakref__')\r\n\r\n>>> d = D()\r\n>>> d.__weakref__ = None\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nAttributeError: attribute '__weakref__' of 'D' objects is not writable\r\n```\r\nWhy isn't weakref writable? No idea, but it just isn't. So I guess we can't treat it like a normal attribute.\nThe question now is whether we add some duct tape or add proper weakref support that has been asked for by many people.\r\n\r\nAs you may suspect, I\u2019m for the latter. :)\nYeah, that'd be for the best probably. Ideas for the API?\nPaging @njsmith who asked for this feature before. :)\r\n\r\n(I think I\u2019ll also additionally add duct tape, that seems to be trivial to fix)",
        "created_at": "2018-01-17T11:07:36Z",
        "version": "17.4"
    }
}