{
    "task_id": "python-attrs__attrs-367",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-367_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 367,
        "instance_id": "python-attrs__attrs-367",
        "issue_numbers": [
            "361"
        ],
        "base_commit": "57817b2c0e9cf98a2d974e8e845e8f6a1a1be89a",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -23,6 +23,8 @@\n _init_converter_pat = \"__attr_converter_{}\"\n _init_factory_pat = \"__attr_factory_{}\"\n _tuple_property_pat = \"    {attr_name} = property(itemgetter({index}))\"\n+_classvar_prefixes = (\"typing.ClassVar\", \"t.ClassVar\", \"ClassVar\")\n+\n _empty_metadata_singleton = metadata_proxy({})\n \n \n@@ -232,10 +234,11 @@ def _is_class_var(annot):\n     \"\"\"\n     Check whether *annot* is a typing.ClassVar.\n \n-    The implementation is gross but importing `typing` is slow and there are\n-    discussions to remove it from the stdlib alltogether.\n+    The string comparison hack is used to avoid evaluating all string\n+    annotations which would put attrs-based classes at a performance\n+    disadvantage compared to plain old classes.\n     \"\"\"\n-    return str(annot).startswith(\"typing.ClassVar\")\n+    return str(annot).startswith(_classvar_prefixes)\n \n \n def _get_annotations(cls):\n",
        "test_patch": "diff --git a/tests/test_annotations.py b/tests/test_annotations.py\n--- a/tests/test_annotations.py\n+++ b/tests/test_annotations.py\n@@ -11,6 +11,7 @@\n \n import attr\n \n+from attr._make import _classvar_prefixes\n from attr.exceptions import UnannotatedAttributeError\n \n \n@@ -204,13 +205,14 @@ class A:\n         assert A.__init__.__annotations__ == {'return': None}\n \n     @pytest.mark.parametrize(\"slots\", [True, False])\n-    def test_annotations_strings(self, slots):\n+    @pytest.mark.parametrize(\"classvar\", _classvar_prefixes)\n+    def test_annotations_strings(self, slots, classvar):\n         \"\"\"\n         String annotations are passed into __init__ as is.\n         \"\"\"\n         @attr.s(auto_attribs=True, slots=slots)\n         class C:\n-            cls_var: 'typing.ClassVar[int]' = 23\n+            cls_var: classvar + '[int]' = 23\n             a: 'int'\n             x: 'typing.List[int]' = attr.Factory(list)\n             y: 'int' = 2\n",
        "problem_statement": "Support ClassVar string annotations\nThe following doesn't work in Python 3.7\r\n\r\n```\r\nfrom __future__ import annotations\r\nimport attr\r\nfrom typing import ClassVar\r\n\r\n@attr.dataclass\r\nclass A:\r\n    x: ClassVar[int]\r\n\r\na = A()\r\n```\r\n\r\nBecause `ClassVar[int]` will be `'ClassVar[int]` in `A.__annotations__` and so `return str(annot).startswith(\"typing.ClassVar\")` returns `False`.\r\n\r\nYou can repro without 3.7 using this:\r\n\r\n```\r\nimport attr\r\nfrom typing import ClassVar\r\n\r\n@attr.dataclass\r\nclass A:\r\n    x: 'ClassVar[int]'\r\n\r\na = A()\r\n```\r\n\r\nNote: It's weird I'm not giving it a value but if I do then attrs will think it's a default value and the code won't error out.\r\n\r\nOh and the following works fine:\r\n```\r\nimport attr\r\nimport typing\r\n\r\n@attr.dataclass\r\nclass A:\r\n    x: 'typing.ClassVar[int]'\r\n\r\na = A()\r\n```\r\n\n",
        "hints_text": "Oh god more string comparisons. \ud83d\ude48\nThis is the last blocker for the next release. Any ideas how to solve this save expanding the comparison to just ClassVar and call it a day?\nI believe these are our only viable options:\r\n\r\n1. `eval` the first part (up to the first `[`) of every string annotation.  \r\n* If it raises, move on, if you get something check if it's a ClassVar.\r\n* Pros:  Catches every possible invocation, `from typing import ClassVar as MyClassVar`\r\n* Cons: I imagine this is prohibitively slow but it could be tested.\r\n  \r\n2. Just check for `.startswith('ClassVar')` also and move on.\r\n* Pros: Fast.\r\n* Cons: This will miss `as` imports.  And will also ignore situations in which you didn't import ClassVar correctly or at all.  e.g.\r\n```\r\n@attr.s(auto_attrib=True)\r\nclass a:\r\n    a: 'ClassVar'\r\n```\r\n(Though any good linter would catch that)\r\n\nCan I haz a non-terrible third option? :'(\nThe non-gross option is to import typing and use `get_type_hints()`. I thought you're already doing that for resolving regular fields but apparently not.\r\n\r\nHow about this: if user code *is* using annotations *and* that annotation is a string, *then* we import typing and use `get_type_hints()` like grown-ups? In all likelihood if the code was already using annotations, it was importing typing somewhere anyway so there's no danger of slowing anybody down. Plus, since user code is already using annotations, we know it's Python 3 so `typing` is there?\r\n\r\nLet me create a pull request to that effect.\nOK, so I tried the above and it seems it's a nuclear option since it forces all annotations to be evaluated. This is what I wanted to avoid with `from __future__ import annotations`.\r\n\r\nMaking it more intelligent would be possible with `typing.ForwardRef` and its `_evaluate()` method but those are only available on 3.7+ (PEP 560).\r\n\r\nI looked what `dataclasses` do in this case and they also don't work with `from __future__ import annotations` which I need to fix before Python 3.7 beta4.\r\n\r\nSo my pull request is going with Euresti's Option 2. This is going to be enough for 99.9% users.",
        "created_at": "2018-04-11T08:32:48Z",
        "version": "17.4"
    }
}