{
    "task_id": "python-attrs__attrs-358",
    "setup_info": {
        "repo_path": "testbed/python-attrs__attrs-358_2025-07-03_17-42-35",
        "repo_cache_path": "testbed/python-attrs/attrs_cache"
    },
    "task_info": {
        "repo": "python-attrs/attrs",
        "pull_number": 358,
        "instance_id": "python-attrs__attrs-358",
        "issue_numbers": [
            "95"
        ],
        "base_commit": "780e1e5e1ea9d712e4df59f17fa1c8d4d3febcd5",
        "patch": "diff --git a/src/attr/_make.py b/src/attr/_make.py\n--- a/src/attr/_make.py\n+++ b/src/attr/_make.py\n@@ -3,6 +3,7 @@\n import hashlib\n import linecache\n import sys\n+import threading\n import warnings\n \n from operator import itemgetter\n@@ -953,6 +954,9 @@ def _add_cmp(cls, attrs=None):\n     return cls\n \n \n+_already_repring = threading.local()\n+\n+\n def _make_repr(attrs, ns):\n     \"\"\"\n     Make a repr method for *attr_names* adding *ns* to the full name.\n@@ -967,6 +971,14 @@ def __repr__(self):\n         \"\"\"\n         Automatically created by attrs.\n         \"\"\"\n+        try:\n+            working_set = _already_repring.working_set\n+        except AttributeError:\n+            working_set = set()\n+            _already_repring.working_set = working_set\n+\n+        if id(self) in working_set:\n+            return \"...\"\n         real_cls = self.__class__\n         if ns is None:\n             qualname = getattr(real_cls, \"__qualname__\", None)\n@@ -977,13 +989,23 @@ def __repr__(self):\n         else:\n             class_name = ns + \".\" + real_cls.__name__\n \n-        return \"{0}({1})\".format(\n-            class_name,\n-            \", \".join(\n-                name + \"=\" + repr(getattr(self, name, NOTHING))\n-                for name in attr_names\n-            )\n-        )\n+        # Since 'self' remains on the stack (i.e.: strongly referenced) for the\n+        # duration of this call, it's safe to depend on id(...) stability, and\n+        # not need to track the instance and therefore worry about properties\n+        # like weakref- or hash-ability.\n+        working_set.add(id(self))\n+        try:\n+            result = [class_name, \"(\"]\n+            first = True\n+            for name in attr_names:\n+                if first:\n+                    first = False\n+                else:\n+                    result.append(\", \")\n+                result.extend((name, \"=\", repr(getattr(self, name, NOTHING))))\n+            return \"\".join(result) + \")\"\n+        finally:\n+            working_set.remove(id(self))\n     return __repr__\n \n \n",
        "test_patch": "diff --git a/tests/test_dunders.py b/tests/test_dunders.py\n--- a/tests/test_dunders.py\n+++ b/tests/test_dunders.py\n@@ -187,6 +187,20 @@ def test_repr_works(self, cls):\n         \"\"\"\n         assert \"C(a=1, b=2)\" == repr(cls(1, 2))\n \n+    def test_infinite_recursion(self):\n+        \"\"\"\n+        In the presence of a cyclic graph, repr will emit an ellipsis and not\n+        raise an exception.\n+        \"\"\"\n+        @attr.s\n+        class Cycle(object):\n+            value = attr.ib(default=7)\n+            cycle = attr.ib(default=None)\n+\n+        cycle = Cycle()\n+        cycle.cycle = cycle\n+        assert \"Cycle(value=7, cycle=...)\" == repr(cycle)\n+\n     def test_underscores(self):\n         \"\"\"\n         repr does not strip underscores.\n",
        "problem_statement": "Infinite Recursion in repr with bi-directional relationships\nTake a fairly trivial example (which has obviously been simplified to the point of absurdity):\n\n``` python\nimport attr\n\n@attr.s\nclass Test():\n    attr = attr.ib(default=None)\n\ntest = Test()\nother = Test()\ntest.attr = other\nother.attr = test\n\nprint(repr(test))\n```\n\nThis will result in infinite recursion. This can be worked around by setting `repr=False` in the attr.s decorator.\n\nI've sat on this bug for a week trying to come up with a good solution, and I can't think of anything good. I'm starting to think the best solution is to add a warning to the documentation of this behavior and calling it good.\n\n",
        "hints_text": "How do lists handle this?  (Where does list.__repr__ store state?)\n\n```\nPython 3.5.2 (default, Jul  2 2016, 07:15:59) \n[GCC 4.2.1 Compatible FreeBSD Clang 3.4.1 (tags/RELEASE_34/dot1-final 208032)] on freebsd10\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import attr\n>>> @attr.s\n... class A:\n...     a = attr.ib(default=None)\n... \n>>> L = []\n>>> L.append([A(L)])\n>>> L\n[[A(a=[...])]]\n```\n\nThis seems relavent:\nhttps://github.com/python/cpython/blob/8285672c6e174601589cc55cbe71d301488d3767/Objects/listobject.c#L369\n\nIt looks like they test the call for the recursion error and somewhere below that they replace it with ... .\n\nI don't think attrs could easily use the same strategy without handling all RuntimeErrors.  I think it would be better to do what you first suggested: note in the docs, but don't handle it.\n\nIf someone needs to handle it for a specific class, they can replace the generated __repr__, and can probably do a better job.\n\nYeah, that's kinda what I though too.\n\nUsually I solve this kinda thing by using a `set` to track which objects are currently being `repr`ed, if `self` is already in the set, return `...` instead of the usual value, when done, remove `self` from the set.  The only tricky part is figuring out how best to pass the set from one object to the next, since `__repr__` doesn't take an argument.  Probably would need a helper method that `__repr__` calls, that can explicitly pass a set.\n\nYes I thought about something like that too.\n\nThe problem is you have no place to store that state (the set), so it ends up being mutable global state.  I suspect the problems caused by that will be worse than \"<unprintable ... object>\" and RuntimeError(\"maximum recursion depth exceeded\").  At least for the default behavior, and remembering the vast majority of uses will not be cycles.\n\n(List cheats by not storing state and handling the exception instead.  However, list does it slightly differently than we could in pure Python, and it would be complicated to emulate that.  AFAICT, please correct.)\n\nIt wouldn't have to be mutable global state, attrs could generate it's own __attrs_repr__ (or similar) that takes an argument of a set or list (I don't think it would really matter since I think you'd need to call __contains__ at each step), you'd just call down the chain passing the instance until __contains__ came back true, then you'd just print \"...\"; and the attrs generated __repr__ would call __attrs_repr__. Unless I've completely overlooked something?\n\nOf course, that would require adding another method and some overhead to the __repr__ method.\n\nYou can't ensure __attrs_repr__ exists on all attributes of a class, in order to pass that parameter.  Here, A's repr calls list's repr which calls A's repr, but the cycle could be arbitrarily deeper or longer.\n\n```\n@attr.s\nclass A:\n  x = attr.ib()\na = A([])\na.x.append(a)\n```\n\nThe bulitins at least do the right thing in that case (set, list, dict).  Your example would resolve to 'A(x=[A(x=[...])])', for example (at least on python 3.5, maybe this doesn't work on python 2?).\n\nWhat about this? (obviously this is incomplete, it only handles the bits relevant to the stack)\n\n``` python\ndef __attr_repr__(self, stack=None)\n    stack = stack or []\n\n    if self in stack:\n        return '...'\n\n    stack.append(self)\n\n    try:\n        r = child.__attr_repr__(stack)\n    except AttributeError:\n        try:\n            r = child.__repr__()\n        except RecurssionError:\n            r = '...'\n    # XXX: might need to handle a RecursionError here too, since one could\n    # create a chain that big? If they did the assert below would fail\n\n    assert stack[-1] is self\n    del stack[-1]\n\n    return r\n```\n\nThis only place I could see this doing something less than ideal would be for classes that implement their own __repr__ method that does recursion, but in that case it should be replaced with \"...\"; it wouldn't be perfect but better than raising an exception like it does now, and that wouldn't be a problem for attr to solve anyway.\n\n[RecursionError](https://docs.python.org/3/library/exceptions.html#RecursionError) didn't exist prior to Python 3.5 (I made the same mistake in an edited earlier comment here); a RuntimeError was used previously. Even with the special exception class in 3.5, I'm leery of hiding a true error as a \"...\" string (when cycles are involved, a recursion limit exception could easily be unintentional), though there is no need for the stack at all if that's what you want.\n\n> it wouldn't be perfect but better than raising an exception like it does now\n\nWould it be better than raising an exception? I think the exception is better in general for this case, compared to trying to handle an uncommon or rare case in an unsurprising, on-by-default, one-size-fits-all hack.  Your code above still doesn't handle:\n\n```\n@attr.s\nclass A:\n    x = attr.ib()\na = A([])\na.x.append(a)\n```\n\nBecause list doesn't have the special repr method and the exception is caught \"inside\" the call chain.  For example, your code is equivalent (AFAICT, please correct) to:\n\n```\n>>> def f():\n...     try:\n...         return \"x\" + f()\n...     except RecursionError:\n...         return \"-\"\n... \n>>> print(f())\nxxx[...]xxx-\n```\n\nRather than \"x-\" or \"-\" for the last line, which is what we desire here. (Desire \"A(...)\" not \"A(A(A([...]A(...)[...])))\".)\n\n`threading.local` (sorry/not sorry)",
        "created_at": "2018-03-16T18:35:32Z",
        "version": "17.4"
    }
}