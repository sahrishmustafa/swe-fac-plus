[
  {
    "repo": "yhirose/cpp-httplib",
    "pull_number": 1046,
    "instance_id": "yhirose__cpp-httplib-1046",
    "issue_numbers": [
      "1023"
    ],
    "base_commit": "e3e28c623165f9965efd2abbb7a31891c0fad684",
    "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1671,6 +1671,10 @@ bool parse_range_header(const std::string &s, Ranges &ranges);\n \n int close_socket(socket_t sock);\n \n+ssize_t send_socket(socket_t sock, const void *ptr, size_t size, int flags);\n+\n+ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags);\n+\n enum class EncodingType { None = 0, Gzip, Brotli };\n \n EncodingType encoding_type(const Request &req, const Response &res);\n@@ -2189,6 +2193,34 @@ template <typename T> inline ssize_t handle_EINTR(T fn) {\n   return res;\n }\n \n+inline ssize_t read_socket(socket_t sock, void *ptr, size_t size, int flags) {\n+  return handle_EINTR([&]() {\n+    return recv(sock,\n+#ifdef _WIN32\n+                static_cast<char *>(ptr),\n+                static_cast<int>(size),\n+#else\n+                ptr,\n+                size,\n+#endif\n+                flags);\n+  });\n+}\n+\n+inline ssize_t send_socket(socket_t sock, const void *ptr, size_t size, int flags) {\n+  return handle_EINTR([&]() {\n+    return send(sock,\n+#ifdef _WIN32\n+                static_cast<const char *>(ptr),\n+                static_cast<int>(size),\n+#else\n+                ptr,\n+                size,\n+#endif\n+                flags);\n+  });\n+}\n+\n inline ssize_t select_read(socket_t sock, time_t sec, time_t usec) {\n #ifdef CPPHTTPLIB_USE_POLL\n   struct pollfd pfd_read;\n@@ -2313,6 +2345,12 @@ class SocketStream : public Stream {\n   time_t read_timeout_usec_;\n   time_t write_timeout_sec_;\n   time_t write_timeout_usec_;\n+\n+  std::vector<char> read_buff_;\n+  size_t read_buff_off_ = 0;\n+  size_t read_buff_content_size_ = 0;\n+\n+  static const size_t read_buff_size_ = 1024 * 4;\n };\n \n #ifdef CPPHTTPLIB_OPENSSL_SUPPORT\n@@ -4368,7 +4406,8 @@ inline SocketStream::SocketStream(socket_t sock, time_t read_timeout_sec,\n     : sock_(sock), read_timeout_sec_(read_timeout_sec),\n       read_timeout_usec_(read_timeout_usec),\n       write_timeout_sec_(write_timeout_sec),\n-      write_timeout_usec_(write_timeout_usec) {}\n+      write_timeout_usec_(write_timeout_usec),\n+      read_buff_(read_buff_size_, 0) {}\n \n inline SocketStream::~SocketStream() {}\n \n@@ -4381,31 +4420,56 @@ inline bool SocketStream::is_writable() const {\n }\n \n inline ssize_t SocketStream::read(char *ptr, size_t size) {\n-  if (!is_readable()) { return -1; }\n-\n #ifdef _WIN32\n-  if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {\n-    return -1;\n-  }\n-  return recv(sock_, ptr, static_cast<int>(size), CPPHTTPLIB_RECV_FLAGS);\n+  size = std::min(size, static_cast<size_t>((std::numeric_limits<int>::max)()));\n #else\n-  return handle_EINTR(\n-      [&]() { return recv(sock_, ptr, size, CPPHTTPLIB_RECV_FLAGS); });\n+  size = std::min(size, static_cast<size_t>((std::numeric_limits<ssize_t>::max)()));\n #endif\n+\n+  if (read_buff_off_ < read_buff_content_size_) {\n+    auto remaining_size = read_buff_content_size_ - read_buff_off_;\n+    if (size <= remaining_size) {\n+      memcpy(ptr, read_buff_.data() + read_buff_off_, size);\n+      read_buff_off_ += size;\n+      return static_cast<ssize_t>(size);\n+    } else {\n+      memcpy(ptr, read_buff_.data() + read_buff_off_, remaining_size);\n+      read_buff_off_ += remaining_size;\n+      return static_cast<ssize_t>(remaining_size);\n+    }\n+  }\n+\n+  if (!is_readable()) { return -1; }\n+\n+  read_buff_off_ = 0;\n+  read_buff_content_size_ = 0;\n+\n+  if (size < read_buff_size_) {\n+    auto n = read_socket(sock_, read_buff_.data(), read_buff_size_, CPPHTTPLIB_RECV_FLAGS);\n+    if (n <= 0) {\n+      return n;\n+    } else if (n <= static_cast<ssize_t>(size)) {\n+      memcpy(ptr, read_buff_.data(), static_cast<size_t>(n));\n+      return n;\n+    } else {\n+      memcpy(ptr, read_buff_.data(), size);\n+      read_buff_off_ = size;\n+      read_buff_content_size_ = static_cast<size_t>(n);\n+      return static_cast<ssize_t>(size);\n+    }\n+  } else {\n+    return read_socket(sock_, ptr, size, CPPHTTPLIB_RECV_FLAGS);\n+  }\n }\n \n inline ssize_t SocketStream::write(const char *ptr, size_t size) {\n   if (!is_writable()) { return -1; }\n \n #ifdef _WIN32\n-  if (size > static_cast<size_t>((std::numeric_limits<int>::max)())) {\n-    return -1;\n-  }\n-  return send(sock_, ptr, static_cast<int>(size), CPPHTTPLIB_SEND_FLAGS);\n-#else\n-  return handle_EINTR(\n-      [&]() { return send(sock_, ptr, size, CPPHTTPLIB_SEND_FLAGS); });\n+  size = std::min(size, static_cast<size_t>((std::numeric_limits<int>::max)()));\n #endif\n+\n+  return send_socket(sock_, ptr, size, CPPHTTPLIB_SEND_FLAGS);\n }\n \n inline void SocketStream::get_remote_ip_and_port(std::string &ip,\n",
    "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1349,11 +1349,13 @@ class ServerTest : public ::testing::Test {\n                std::this_thread::sleep_for(std::chrono::seconds(2));\n                res.set_content(\"slow\", \"text/plain\");\n              })\n+#if 0\n         .Post(\"/slowpost\",\n               [&](const Request & /*req*/, Response &res) {\n                 std::this_thread::sleep_for(std::chrono::seconds(2));\n                 res.set_content(\"slow\", \"text/plain\");\n               })\n+#endif\n         .Get(\"/remote_addr\",\n              [&](const Request &req, Response &res) {\n                auto remote_addr = req.headers.find(\"REMOTE_ADDR\")->second;\n@@ -2623,6 +2625,7 @@ TEST_F(ServerTest, SlowRequest) {\n       std::thread([=]() { auto res = cli_.Get(\"/slow\"); }));\n }\n \n+#if 0\n TEST_F(ServerTest, SlowPost) {\n   char buffer[64 * 1024];\n   memset(buffer, 0x42, sizeof(buffer));\n@@ -2640,7 +2643,6 @@ TEST_F(ServerTest, SlowPost) {\n   EXPECT_EQ(200, res->status);\n }\n \n-#if 0\n TEST_F(ServerTest, SlowPostFail) {\n   char buffer[64 * 1024];\n   memset(buffer, 0x42, sizeof(buffer));\n@@ -3564,10 +3566,12 @@ TEST(StreamingTest, NoContentLengthStreaming) {\n   Client client(HOST, PORT);\n \n   auto get_thread = std::thread([&client]() {\n-    auto res = client.Get(\"/stream\", [](const char *data, size_t len) -> bool {\n-      EXPECT_EQ(\"aaabbb\", std::string(data, len));\n+    std::string s;\n+    auto res = client.Get(\"/stream\", [&s](const char *data, size_t len) -> bool {\n+      s += std::string(data, len);\n       return true;\n     });\n+    EXPECT_EQ(\"aaabbb\", s);\n   });\n \n   // Give GET time to get a few messages.\n",
    "problem_statement": "Getline/header parsing is very inefficient\nIt reads one byte from the stream: https://github.com/yhirose/cpp-httplib/blob/a58f0426148daef861e4eaf43548784d340a8ad6/httplib.h#L2133\r\nThis triggers one select + recv() system call on linux for each byte.\n",
    "hints_text": "I also don't understand why there is a `select` for a single socket. Why not just block on the socket and use `read`?\n@Mic92, sorry that this library doesn't meet your performance requirement. Let me explain the background of this library a bit. This library started to provide a solution to embed HTTP functionalities in desktop applications at my workplace. The performance wasn't a priority, rather I focused on how easily the HTTP client/server capabilities can be added to applications. That's why I keep this library as a simple single header-only library.\r\n\r\n> This triggers one select + recv() system call on linux for each byte.\r\n\r\nYou are absolutely right. If there is an easy way to do buffering in `SocketStream` class, I think we can reduce the `recv` and `select` calls with a small change just within the class. (I believe `SSLSocketStream::read` is ok, because it uses OpenSSL BIO underneath.) I don't have time to work on the improvement right now, but I would very much appreciate if you could work on it and send a pull request. :)\r\n\r\n> I also don't understand why there is a select for a single socket. Why not just block on the socket and use read?\r\n\r\nI was trying to provide a reliable socket 'time out' detection. I tried some different ways, but `select` was the most reliable way working on various operating systems. If you have a better idea which is guaranteed to work on Windows, Mac and Linux OSs, please let me know. (You can also see how we got to this solution in the past issues and unit test cases.)\r\n\r\nIf you need a performance intensive cross-platform HTTP functionality, why not use [drogon](https://github.com/drogonframework/drogon) instead?\r\n\r\nThank you for bring the attention to this matter!\r\n\r\n\r\n\r\n\r\n\r\n\nfair enough. Drogon it is. Using socket option one can usually set timeouts on connections.\n> Using socket option one can usually set timeouts on connections. \r\n\r\nhttps://github.com/yhirose/cpp-httplib/blob/a58f0426148daef861e4eaf43548784d340a8ad6/httplib.h#L2595\r\n\r\nBut some socket options like `SO_RCVTIMEO` above don't work or aren't stable as they advertise on some OSs. That's the real world unfortunately...\r\nhttps://github.com/yhirose/cpp-httplib/issues/34#issuecomment-354512631\r\n\r\nEven `select` isn't perfect for all the situations. So sometimes, users need to chose `poll` with `CPPHTTPLIB_USE_POLL` for timeout.\r\n\n@Mic92, approximately how much slower do you think this library is than other HTTP libraries? Is it very much noticeable in any cases, or only on some situations where the performance is really critical? Thanks for you comment since I don't have any experience of using other HTTP libraries. :)\nI don't have very complex applications written for cpp-httplib,\r\nbut let's just do this simple comparison with go http server from the standard library:\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"log\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc handler(w http.ResponseWriter, r *http.Request) {\r\n    fmt.Fprintf(w, \"Hello world!\")\r\n}\r\n\r\nfunc main() {\r\n    http.HandleFunc(\"/some/random/url/lets/see/how/it/goes\", handler)\r\n    log.Fatal(http.ListenAndServe(\":1234\", nil))\r\n}\r\n```\r\n\r\n```cpp\r\n#include \"httplib.h\"\r\n\r\nint main() {\r\n    using namespace httplib;\r\n    Server svr;\r\n    svr.Get(\"/some/random/url/lets/see/how/it/goes\", [](const Request &req, Response &res) {\r\n      res.set_content(\"Hello World!\", \"text/plain\");\r\n    });\r\n    svr.listen(\"localhost\", 1234);\r\n}\r\n```\r\n\r\nAnd benchmark with `wrk`:\r\n\r\n```console\r\n$ wrk http://localhost:1234/some/random/url/lets/see/how/it/goes\r\n```\r\n\r\nResult for cpp-httplib:\r\n\r\n```\r\nRunning 10s test @ http://localhost:1234/some/random/url/lets/see/how/it/goes\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency   342.05us    5.20ms 202.06ms   99.81%\r\n    Req/Sec    26.13k     4.31k   37.27k    66.00%\r\n  519796 requests in 10.00s, 51.95MB read\r\nRequests/sec:  51973.49\r\nTransfer/sec:      5.19MB\r\n```\r\n\r\nResult for golang:\r\n\r\n```\r\nRunning 10s test @ http://localhost:1234/some/random/url/lets/see/how/it/goes\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency    60.79us  127.00us   9.54ms   96.16%\r\n    Req/Sec   102.96k     9.79k  122.31k    62.38%\r\n  2067862 requests in 10.10s, 254.40MB read\r\nRequests/sec: 204752.15\r\nTransfer/sec:     25.19MB\r\n```\r\n\r\nI am surprised it's only 4 times slower on my laptop with an 8 hyper-threads i7... I think it becomes slower as soon as you start adding a real-world amount of headers and browser cookies. I mean yeah compared to some python server it's probably still some magnitudes faster, however I don't think a classical select + read http server would be more code than the current implementation.\r\n\r\nChears.\n@Mic92, thanks for the very helpful information. When I have time, I'll try to implement buffering in `SocketStream` to increase performance. Thanks for your fine contribution!",
    "created_at": "2021-09-11T21:00:23Z",
    "version": "0.9",
    "dockerfile": "FROM ubuntu:20.04\n\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# Install essential tools and system libraries required for building and running tests.\n# git: for cloning the repository.\n# build-essential: provides core build utilities like g++ and make.\n# cmake: Project's CMake build system, referred to in the README, though 'make' is used directly for tests.\n# libssl-dev: For OpenSSL/HTTPS support as mentioned in README.md. (Ubuntu 20.04 uses OpenSSL 1.1.1)\n# zlib1g-dev: For Zlib compression support.\n# libbrotli-dev: For Brotli compression support.\n# libgtest-dev: For the Google Test framework used by test/test.cc.\n# python3: Required by the 'split.py' script during the build process.\n# openssl: Command-line tool required for certificate generation.\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    libssl-dev \\\n    zlib1g-dev \\\n    libbrotli-dev \\\n    libgtest-dev \\\n    python3 \\\n    openssl \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set the working directory inside the container.\nWORKDIR /testbed/\n\n# Clone the target repository into the working directory.\nRUN git clone https://github.com/yhirose/cpp-httplib.git /testbed\n\n# Checkout the specific commit SHA to ensure reproducibility.\nRUN git reset --hard e3e28c623165f9965efd2abbb7a31891c0fad684\n\n# Build the test executable (test/test.cc).\n# Replaced 'make' command with explicit build steps to prevent tests from running during Dockerfile build.\n# This sequence performs certificate generation, runs split.py, and then compiles the test executable.\n# The G++ command uses standard library paths for OpenSSL and Brotli, which are correctly handled by apt-installed packages.\nRUN cd test && \\\n    openssl genrsa 2048 > key.pem && \\\n    python3 ../split.py -o . && \\\n    openssl req -new -batch -config test.conf -key key.pem | openssl x509 -days 3650 -req -signkey key.pem > cert.pem && \\\n    openssl req -x509 -config test.conf -key key.pem -sha256 -days 3650 -nodes -out cert2.pem -extensions SAN && \\\n    openssl genrsa 2048 > rootCA.key.pem && \\\n    openssl req -x509 -new -batch -config test.rootCA.conf -key rootCA.key.pem -days 1024 > rootCA.cert.pem && \\\n    openssl genrsa 2048 > client.key.pem && \\\n    openssl req -new -batch -config test.conf -key client.key.pem | openssl x509 -days 370 -req -CA rootCA.cert.pem -CAkey rootCA.key.pem -CAcreateserial > client.cert.pem && \\\n    g++ -o test -I.. -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion  test.cc include_httplib.cc gtest/gtest-all.cc gtest/gtest_main.cc -DCPPHTTPLIB_OPENSSL_SUPPORT -lssl -lcrypto -DCPPHTTPLIB_ZLIB_SUPPORT -lz -DCPPHTTPLIB_BROTLI_SUPPORT -lbrotlicommon -lbrotlienc -lbrotlidec -pthread",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned.\ncd /testbed\n\n# Ensure the target test file is at the commit's state before applying the patch.\ngit checkout e3e28c623165f9965efd2abbb7a31891c0fad684 \"test/test.cc\"\n\n# Apply the test patch to the specified file.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -1349,11 +1349,13 @@ class ServerTest : public ::testing::Test {\n                std::this_thread::sleep_for(std::chrono::seconds(2));\n                res.set_content(\"slow\", \"text/plain\");\n              })\n+#if 0\n         .Post(\"/slowpost\",\n               [&](const Request & /*req*/, Response &res) {\n                 std::this_thread::sleep_for(std::chrono::seconds(2));\n                 res.set_content(\"slow\", \"text/plain\");\n               })\n+#endif\n         .Get(\"/remote_addr\",\n              [&](const Request &req, Response &res) {\n                auto remote_addr = req.headers.find(\"REMOTE_ADDR\")->second;\n@@ -2623,6 +2625,7 @@ TEST_F(ServerTest, SlowRequest) {\n       std::thread([=]() { auto res = cli_.Get(\"/slow\"); }));\n }\n \n+#if 0\n TEST_F(ServerTest, SlowPost) {\n   char buffer[64 * 1024];\n   memset(buffer, 0x42, sizeof(buffer));\n@@ -2640,7 +2643,6 @@ TEST_F(ServerTest, SlowPost) {\n   EXPECT_EQ(200, res->status);\n }\n \n-#if 0\n TEST_F(ServerTest, SlowPostFail) {\n   char buffer[64 * 1024];\n   memset(buffer, 0x42, sizeof(buffer));\n@@ -3564,10 +3566,12 @@ TEST(StreamingTest, NoContentLengthStreaming) {\n   Client client(HOST, PORT);\n \n   auto get_thread = std::thread([&client]() {\n-    auto res = client.Get(\"/stream\", [](const char *data, size_t len) -> bool {\n-      EXPECT_EQ(\"aaabbb\", std::string(data, len));\n+    std::string s;\n+    auto res = client.Get(\"/stream\", [&s](const char *data, size_t len) -> bool {\n+      s += std::string(data, len);\n       return true;\n     });\n+    EXPECT_EQ(\"aaabbb\", s);\n   });\n \n   // Give GET time to get a few messages.\nEOF_114329324912\n\n# Explicitly build and run the specific test file (test/test.cc) within a subshell.\n# This sequence replaces the 'make' command to ensure correct library linkages.\n(\n    cd test && \\\n    openssl genrsa 2048 > key.pem && \\\n    python3 ../split.py -o . && \\\n    openssl req -new -batch -config test.conf -key key.pem | openssl x509 -days 3650 -req -signkey key.pem > cert.pem && \\\n    openssl req -x509 -config test.conf -key key.pem -sha256 -days 3650 -nodes -out cert2.pem -extensions SAN && \\\n    openssl genrsa 2048 > rootCA.key.pem && \\\n    openssl req -x509 -new -batch -config test.rootCA.conf -key rootCA.key.pem -days 1024 > rootCA.cert.pem && \\\n    openssl genrsa 2048 > client.key.pem && \\\n    openssl req -new -batch -config test.conf -key client.key.pem | openssl x509 -days 370 -req -CA rootCA.cert.pem -CAkey rootCA.key.pem -CAcreateserial > client.cert.pem && \\\n    g++ -o test -I.. -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion  test.cc include_httplib.cc gtest/gtest-all.cc gtest/gtest_main.cc -DCPPHTTPLIB_OPENSSL_SUPPORT -lssl -lcrypto -DCPPHTTPLIB_ZLIB_SUPPORT -lz -DCPPHTTPLIB_BROTLI_SUPPORT -lbrotlicommon -lbrotlienc -lbrotlidec -pthread && \\\n    ./test\n)\nrc=$? # Capture the exit code of the test run\n\n# Output the exit code for the test log analysis agent.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up: revert the changes made to test/test.cc by the patch.\n# This ensures the repository is in a clean state after the evaluation.\ngit checkout e3e28c623165f9965efd2abbb7a31891c0fad684 \"test/test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned.\ncd /testbed\n\n# Ensure the target test file is at the commit's state before applying the patch.\ngit checkout e3e28c623165f9965efd2abbb7a31891c0fad684 \"test/test.cc\"\n\n# Apply the test patch to the specified file.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Explicitly build and run the specific test file (test/test.cc) within a subshell.\n# This sequence replaces the 'make' command to ensure correct library linkages.\n(\n    cd test && \\\n    openssl genrsa 2048 > key.pem && \\\n    python3 ../split.py -o . && \\\n    openssl req -new -batch -config test.conf -key key.pem | openssl x509 -days 3650 -req -signkey key.pem > cert.pem && \\\n    openssl req -x509 -config test.conf -key key.pem -sha256 -days 3650 -nodes -out cert2.pem -extensions SAN && \\\n    openssl genrsa 2048 > rootCA.key.pem && \\\n    openssl req -x509 -new -batch -config test.rootCA.conf -key rootCA.key.pem -days 1024 > rootCA.cert.pem && \\\n    openssl genrsa 2048 > client.key.pem && \\\n    openssl req -new -batch -config test.conf -key client.key.pem | openssl x509 -days 370 -req -CA rootCA.cert.pem -CAkey rootCA.key.pem -CAcreateserial > client.cert.pem && \\\n    g++ -o test -I.. -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion  test.cc include_httplib.cc gtest/gtest-all.cc gtest/gtest_main.cc -DCPPHTTPLIB_OPENSSL_SUPPORT -lssl -lcrypto -DCPPHTTPLIB_ZLIB_SUPPORT -lz -DCPPHTTPLIB_BROTLI_SUPPORT -lbrotlicommon -lbrotlienc -lbrotlidec -pthread && \\\n    ./test\n)\nrc=$? # Capture the exit code of the test run\n\n# Output the exit code for the test log analysis agent.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up: revert the changes made to test/test.cc by the patch.\n# This ensures the repository is in a clean state after the evaluation.\ngit checkout e3e28c623165f9965efd2abbb7a31891c0fad684 \"test/test.cc\""
  },
  {
    "repo": "yhirose/cpp-httplib",
    "pull_number": 1051,
    "instance_id": "yhirose__cpp-httplib-1051",
    "issue_numbers": ["1050"],
    "base_commit": "3c522386e961d61768ea527d04713b5402356dd4",
    "patch": "diff --git a/httplib.h b/httplib.h\n--- a/httplib.h\n+++ b/httplib.h\n@@ -1161,6 +1161,8 @@ class Client {\n                   const std::string &client_cert_path,\n                   const std::string &client_key_path);\n \n+  Client(Client &&) = default;\n+\n   ~Client();\n \n   bool is_valid() const;\n",
    "test_patch": "diff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -8,6 +8,8 @@\n #include <sstream>\n #include <stdexcept>\n #include <thread>\n+#include <type_traits>\n+#include \"../httplib.h\"\n \n #define SERVER_CERT_FILE \"./cert.pem\"\n #define SERVER_CERT2_FILE \"./cert2.pem\"\n@@ -40,6 +42,11 @@ MultipartFormData &get_file_value(MultipartFormDataItems &files,\n   throw std::runtime_error(\"invalid mulitpart form data name error\");\n }\n \n+TEST(ConstructorTest, MoveConstructible) {\n+  EXPECT_FALSE(std::is_copy_constructible<httplib::Client>::value);\n+  EXPECT_TRUE(std::is_nothrow_move_constructible<httplib::Client>::value);\n+}\n+\n #ifdef _WIN32\n TEST(StartupTest, WSAStartup) {\n   WSADATA wsaData;",
    "problem_statement": "Add move constructor for Client\nSince `Client` already uses the PIMPL pattern, it seems reasonably to provide a default move constructor for it. This enables classes that have a `Client` member variable to be movable.\r\n\r\nIf using C++11 or later, we only need to add\r\n```c++\r\nClient(Client &&) = default;\r\n```\r\nunless we want to support older standards.",
    "hints_text": "@ZizhengTai, that's a reasonable request even if I don't need it. Could you send me a pull request and a unit test for it? I'll take a look at and merge it right away. Thanks!\n@yhirose In the test, I can either use `static_assert` to fail the test build at compile time if `Client` is not move-constructible, or use `EXPECT_TRUE` to fail the test only at test runtime. Which approach do you prefer? The former fails sooner while the latter outputs the failure together with the rest of the test, which might be desired.",
    "created_at": "2021-09-16T06:17:13Z",
    "version": "0.9",
    "dockerfile": "FROM ubuntu:20.04\n\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    libssl-dev \\\n    zlib1g-dev \\\n    libbrotli-dev \\\n    libgtest-dev \\\n    python3 \\\n    openssl \\\n    && rm -rf /var/lib/apt/lists/*\n\nWORKDIR /testbed/\n\nRUN git clone https://github.com/yhirose/cpp-httplib.git /testbed\nRUN cd /testbed && git reset --hard 3c522386e961d61768ea527d04713b5402356dd4\n\nRUN cd /testbed/test && \\\n    openssl genrsa 2048 > key.pem && \\\n    python3 ../split.py -o . && \\\n    openssl req -new -batch -config test.conf -key key.pem | openssl x509 -days 3650 -req -signkey key.pem > cert.pem && \\\n    openssl req -x509 -config test.conf -key key.pem -sha256 -days 3650 -nodes -out cert2.pem -extensions SAN && \\\n    openssl genrsa 2048 > rootCA.key.pem && \\\n    openssl req -x509 -new -batch -config test.rootCA.conf -key rootCA.key.pem -days 1024 > rootCA.cert.pem && \\\n    openssl genrsa 2048 > client.key.pem && \\\n    openssl req -new -batch -config test.conf -key client.key.pem | openssl x509 -days 370 -req -CA rootCA.cert.pem -CAkey rootCA.key.pem -CAcreateserial > client.cert.pem && \\\n    g++ -o test -I.. -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion test.cc include_httplib.cc gtest/gtest-all.cc gtest/gtest_main.cc -DCPPHTTPLIB_OPENSSL_SUPPORT -lssl -lcrypto -DCPPHTTPLIB_ZLIB_SUPPORT -lz -DCPPHTTPLIB_BROTLI_SUPPORT -lbrotlicommon -lbrotlienc -lbrotlidec -pthread",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\ncd /testbed\ngit checkout 3c522386e961d61768ea527d04713b5402356dd4 \"test/test.cc\"\n\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/test.cc b/test/test.cc\n--- a/test/test.cc\n+++ b/test/test.cc\n@@ -8,6 +8,8 @@\n #include <sstream>\n #include <stdexcept>\n #include <thread>\n+#include <type_traits>\n+#include \"../httplib.h\"\n \n #define SERVER_CERT_FILE \"./cert.pem\"\n #define SERVER_CERT2_FILE \"./cert2.pem\"\n@@ -40,6 +42,11 @@ MultipartFormData &get_file_value(MultipartFormDataItems &files,\n   throw std::runtime_error(\"invalid mulitpart form data name error\");\n }\n \n+TEST(ConstructorTest, MoveConstructible) {\n+  EXPECT_FALSE(std::is_copy_constructible<httplib::Client>::value);\n+  EXPECT_TRUE(std::is_nothrow_move_constructible<httplib::Client>::value);\n+}\n+\n #ifdef _WIN32\n TEST(StartupTest, WSAStartup) {\n   WSADATA wsaData;\nEOF_114329324912\n\n# ✅ Rebuild the test binary so the new test is included\ncd /testbed/test\ng++ -o test -I.. -g -std=c++11 -I. -Wall -Wextra -Wtype-limits -Wconversion test.cc include_httplib.cc gtest/gtest-all.cc gtest/gtest_main.cc \\\n    -DCPPHTTPLIB_OPENSSL_SUPPORT -lssl -lcrypto \\\n    -DCPPHTTPLIB_ZLIB_SUPPORT -lz \\\n    -DCPPHTTPLIB_BROTLI_SUPPORT -lbrotlicommon -lbrotlienc -lbrotlidec -pthread\n\n# ✅ Run the test binary\n./test\nrc=$?\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# ✅ Clean up\ncd /testbed\ngit checkout 3c522386e961d61768ea527d04713b5402356dd4 \"test/test.cc\""
  }   
]