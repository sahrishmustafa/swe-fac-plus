{"repo": "catchorg/Catch2", "pull_number": 1363, "instance_id": "catchorg__Catch2-1363", "issue_numbers": ["1360"], "base_commit": "c9de7dd12d2971c63f9d32ce5459eb98f2fec13d", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -147,11 +147,12 @@\n // \"BDD-style\" convenience wrappers\n #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n-#define CATCH_GIVEN( desc )    INTERNAL_CATCH_DYNAMIC_SECTION( \"   Given: \" << desc )\n-#define CATCH_WHEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    When: \" << desc )\n-#define CATCH_AND_WHEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And when: \" << desc )\n-#define CATCH_THEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Then: \" << desc )\n-#define CATCH_AND_THEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"     And: \" << desc )\n+#define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Given: \" << desc )\n+#define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And given: \" << desc )\n+#define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     When: \" << desc )\n+#define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \" And when: \" << desc )\n+#define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n+#define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n // If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required\n #else\n@@ -211,11 +212,12 @@\n #define SCENARIO( ... ) TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, \"Scenario: \" __VA_ARGS__ )\n \n-#define GIVEN( desc )    INTERNAL_CATCH_DYNAMIC_SECTION( \"   Given: \" << desc )\n-#define WHEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    When: \" << desc )\n-#define AND_WHEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And when: \" << desc )\n-#define THEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Then: \" << desc )\n-#define AND_THEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"     And: \" << desc )\n+#define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( \"    Given: \" << desc )\n+#define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( \"And given: \" << desc )\n+#define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     When: \" << desc )\n+#define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \" And when: \" << desc )\n+#define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( \"     Then: \" << desc )\n+#define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( \"      And: \" << desc )\n \n using Catch::Detail::Approx;\n \n@@ -276,6 +278,7 @@ using Catch::Detail::Approx;\n #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n #define CATCH_GIVEN( desc )\n+#define CATCH_AND_GIVEN( desc )\n #define CATCH_WHEN( desc )\n #define CATCH_AND_WHEN( desc )\n #define CATCH_THEN( desc )\n@@ -340,6 +343,7 @@ using Catch::Detail::Approx;\n #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )\n \n #define GIVEN( desc )\n+#define AND_GIVEN( desc )\n #define WHEN( desc )\n #define AND_WHEN( desc )\n #define THEN( desc )\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/BDD.tests.cpp b/projects/SelfTest/UsageTests/BDD.tests.cpp\n--- a/projects/SelfTest/UsageTests/BDD.tests.cpp\n+++ b/projects/SelfTest/UsageTests/BDD.tests.cpp\n@@ -38,11 +38,14 @@ namespace { namespace BDDTests {\n     SCENARIO(\"Do that thing with the thing\", \"[BDD][Tags]\") {\n         GIVEN(\"This stuff exists\") {\n             // make stuff exist\n-            WHEN(\"I do this\") {\n-                // do this\n-                THEN(\"it should do this\") {\n-                    REQUIRE(itDoesThis());\n-                    AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+            AND_GIVEN(\"And some assumption\") {\n+                // Validate assumption\n+                WHEN(\"I do this\") {\n+                    // do this\n+                    THEN(\"it should do this\") {\n+                        REQUIRE(itDoesThis());\n+                        AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+                    }\n                 }\n             }\n         }\n", "problem_statement": "Feature Request: AND_GIVEN\n\r\nTo be consistent with the `AND_WHEN` and `AND_THEN`; \r\n\r\nWith BDD:\r\n\r\nthere are times when you require to expand the context, if you feel a need to type *'and'* in the context of a `GIVEN`, `WHEN`, and/or `THEN`, you should use `AND`.\r\n\r\nwe don't have an `AND`, because that just doesn't work in this abstraction; thus we have `AND_WHEN` and `AND_THEN`; thus we should also have `AND_GIVEN`.\n", "hints_text": "", "created_at": "2018-08-14T10:25:40Z", "version": "2.3", "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM --platform=linux/x86_64 ubuntu:18.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set default workdir to /testbed/ for cloning the repository\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version\nRUN git clone https://github.com/catchorg/Catch2.git . \\\n    && git reset --hard c9de7dd12d2971c63f9d32ce5459eb98f2fec13d \\\n    && git remote remove origin\n\n# Create a build directory and perform the out-of-source build\nRUN mkdir build\nWORKDIR /testbed/build\n\n# Configure Catch2 with CMake (enabling testing) and compile\nRUN cmake -DCMAKE_BUILD_TYPE=Release -DCATCH_BUILD_TESTING=ON .. \\\n    && make -j $(nproc)", "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\ncd /testbed\n\n# Checkout the specific test file to its original state at the commit SHA\n# This ensures a clean state before applying any potential patches.\ngit checkout c9de7dd12d2971c63f9d32ce5459eb98f2fec13d \"projects/SelfTest/UsageTests/BDD.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/projects/SelfTest/UsageTests/BDD.tests.cpp b/projects/SelfTest/UsageTests/BDD.tests.cpp\n--- a/projects/SelfTest/UsageTests/BDD.tests.cpp\n+++ b/projects/SelfTest/UsageTests/BDD.tests.cpp\n@@ -38,11 +38,14 @@ namespace { namespace BDDTests {\n     SCENARIO(\"Do that thing with the thing\", \"[Tags]\") {\n         GIVEN(\"This stuff exists\") {\n             // make stuff exist\n-            WHEN(\"I do this\") {\n-                // do this\n-                THEN(\"it should do this\") {\n-                    REQUIRE(itDoesThis());\n-                    AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+            AND_GIVEN(\"And some assumption\") {\n+                // Validate assumption\n+                WHEN(\"I do this\") {\n+                    // do this\n+                    THEN(\"it should do this\") {\n+                        REQUIRE(itDoesThis());\n+                        AND_THEN(\"do that\")REQUIRE(itDoesThat());\n+                    }\n                 }\n             }\n         }\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 'SelfTest' executable is located.\n# The Dockerfile ensures this directory exists and the project is built.\ncd build\n\n# Execute the specific test cases from BDD.tests.cpp using the Catch2 SelfTest executable.\n# Tests from BDD.tests.cpp are typically tagged with [BDD].\n# --success flag ensures a non-zero exit code on test failure, critical for automation.\n# Removed '--verbosity high' as it is not supported by Catch2 v2.3.\n./projects/SelfTest \"[BDD]\" --success\nrc=$? # Capture the exit code of the test command\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test file again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout c9de7dd12d2971c63f9d32ce5459eb98f2fec13d \"projects/SelfTest/UsageTests/BDD.tests.cpp\"", "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\ncd /testbed\n\n# Checkout the specific test file to its original state at the commit SHA\n# This ensures a clean state before applying any potential patches.\ngit checkout c9de7dd12d2971c63f9d32ce5459eb98f2fec13d \"projects/SelfTest/UsageTests/BDD.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 'SelfTest' executable is located.\n# The Dockerfile ensures this directory exists and the project is built.\ncd build\n\n# Execute the specific test cases from BDD.tests.cpp using the Catch2 SelfTest executable.\n# Tests from BDD.tests.cpp are typically tagged with [BDD].\n# --success flag ensures a non-zero exit code on test failure, critical for automation.\n# Removed '--verbosity high' as it is not supported by Catch2 v2.3.\n./projects/SelfTest \"[BDD]\" --success\nrc=$? # Capture the exit code of the test command\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test file again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout c9de7dd12d2971c63f9d32ce5459eb98f2fec13d \"projects/SelfTest/UsageTests/BDD.tests.cpp\""}
{"repo": "catchorg/Catch2", "pull_number": 1448, "instance_id": "catchorg__Catch2-1448", "issue_numbers": ["1436"], "base_commit": "62460fafe6b54c3173bc5cbc46d05a5f071017ff", "patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -11,6 +11,7 @@\n #include \"catch_uncaught_exceptions.h\"\n \n #include <cassert>\n+#include <stack>\n \n namespace Catch {\n \n@@ -60,19 +61,48 @@ namespace Catch {\n \n \n     Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {\n-        auto start = std::string::npos;\n-        for( size_t pos = 0; pos <= names.size(); ++pos ) {\n+        auto trimmed = [&] (size_t start, size_t end) {\n+            while (names[start] == ',' || isspace(names[start])) {\n+                ++start;\n+            }\n+            while (names[end] == ',' || isspace(names[end])) {\n+                --end;\n+            }\n+            return names.substr(start, end - start + 1);\n+        };\n+\n+        size_t start = 0;\n+        std::stack<char> openings;\n+        for (size_t pos = 0; pos < names.size(); ++pos) {\n             char c = names[pos];\n-            if( pos == names.size() || c == ' ' || c == '\\t' || c == ',' || c == ']' ) {\n-                if( start != std::string::npos ) {\n-                    m_messages.push_back( MessageInfo( macroName, lineInfo, resultType ) );\n-                    m_messages.back().message = names.substr( start, pos-start) + \" := \";\n-                    start = std::string::npos;\n+            switch (c) {\n+            case '[':\n+            case '{':\n+            case '(':\n+            // It is basically impossible to disambiguate between\n+            // comparison and start of template args in this context\n+//            case '<':\n+                openings.push(c);\n+                break;\n+            case ']':\n+            case '}':\n+            case ')':\n+//           case '>':\n+                openings.pop();\n+                break;\n+            case ',':\n+                if (start != pos && openings.size() == 0) {\n+                    m_messages.emplace_back(macroName, lineInfo, resultType);\n+                    m_messages.back().message = trimmed(start, pos);\n+                    m_messages.back().message += \" := \";\n+                    start = pos;\n                 }\n             }\n-            else if( c != '[' && c != ']' && start == std::string::npos )\n-                start = pos;\n         }\n+        assert(openings.size() == 0 && \"Mismatched openings\");\n+        m_messages.emplace_back(macroName, lineInfo, resultType);\n+        m_messages.back().message = trimmed(start, names.size() - 1);\n+        m_messages.back().message += \" := \";\n     }\n     Capturer::~Capturer() {\n         if ( !uncaught_exceptions() ){\n@@ -82,7 +112,7 @@ namespace Catch {\n         }\n     }\n \n-    void Capturer::captureValue( size_t index, StringRef value ) {\n+    void Capturer::captureValue( size_t index, std::string const& value ) {\n         assert( index < m_messages.size() );\n         m_messages[index].message += value;\n         m_resultCapture.pushScopedMessage( m_messages[index] );\ndiff --git a/include/internal/catch_message.h b/include/internal/catch_message.h\n--- a/include/internal/catch_message.h\n+++ b/include/internal/catch_message.h\n@@ -77,16 +77,16 @@ namespace Catch {\n         Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );\n         ~Capturer();\n \n-        void captureValue( size_t index, StringRef value );\n+        void captureValue( size_t index, std::string const& value );\n \n         template<typename T>\n-        void captureValues( size_t index, T&& value ) {\n+        void captureValues( size_t index, T const& value ) {\n             captureValue( index, Catch::Detail::stringify( value ) );\n         }\n \n         template<typename T, typename... Ts>\n-        void captureValues( size_t index, T&& value, Ts&&... values ) {\n-            captureValues( index, value );\n+        void captureValues( size_t index, T const& value, Ts const&... values ) {\n+            captureValue( index, Catch::Detail::stringify(value) );\n             captureValues( index+1, values... );\n         }\n     };\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -9,10 +9,6 @@\n #include \"catch.hpp\"\n #include <iostream>\n \n-#ifdef __clang__\n-#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n-#endif\n-\n TEST_CASE( \"INFO and WARN do not abort tests\", \"[messages][.]\" ) {\n     INFO( \"this is a \" << \"message\" );    // This should output the message if a failure occurs\n     WARN( \"this is a \" << \"warning\" );    // This should always output the message but then continue\n@@ -135,3 +131,60 @@ TEST_CASE( \"Pointers can be converted to strings\", \"[messages][.][approvals]\" )\n     WARN( \"actual address of p: \" << &p );\n     WARN( \"toString(p): \" << ::Catch::Detail::stringify( &p ) );\n }\n+\n+TEST_CASE( \"CAPTURE can deal with complex expressions\", \"[messages][capture]\" ) {\n+    int a = 1;\n+    int b = 2;\n+    int c = 3;\n+    CAPTURE( a, b, c, a + b, a+b, c > b, a == 1 );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wunused-value\" // In (1, 2), the \"1\" is unused ...\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-value\" // All the comma operators are side-effect free\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(push)\n+#pragma warning(disable:4709) // comma in indexing operator\n+#endif\n+\n+template <typename T1, typename T2>\n+struct helper_1436 {\n+    helper_1436(T1 t1, T2 t2):\n+        t1{ t1 },\n+        t2{ t2 }\n+    {}\n+    T1 t1;\n+    T2 t2;\n+};\n+\n+template <typename T1, typename T2>\n+std::ostream& operator<<(std::ostream& out, helper_1436<T1, T2> const& helper) {\n+    out << \"{ \" << helper.t1 << \", \" << helper.t2 << \" }\";\n+    return out;\n+}\n+\n+TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messages][capture]\") {\n+    CAPTURE(std::vector<int>{1, 2, 3}[0, 1, 2],\n+            std::vector<int>{1, 2, 3}[(0, 1)],\n+            std::vector<int>{1, 2, 3}[0]);\n+    CAPTURE((helper_1436<int, int>{12, -12}),\n+            (helper_1436<int, int>(-12, 12)));\n+    CAPTURE( (1, 2), (2, 3) );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic pop\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(pop)\n+#endif\n", "problem_statement": "Capturer destructor asserts due to bad expression parsing\nThe following asserts:\r\n\r\n```\r\nTEST_CASE(\"Explodes\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a + b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe following does not:\r\n```\r\nTEST_CASE(\"Works\")\r\n{\r\n    int a = 1;\r\n    int b = 2;\r\n    CAPTURE(a+b);\r\n    REQUIRE(false);\r\n}\r\n```\r\n\r\nThe assertion that fires:\r\nhttps://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L79\r\n\r\nThe issue appears to have been caused here: https://github.com/catchorg/Catch2/blame/1cdaa48a0b20e28ee32553070700b86557f9619d/include/internal/catch_message.cpp#L66\r\n\r\n\n", "hints_text": "Looks like you'd want to only count `,` instead of all whitespace as an argument delimiter, and also only when `,` appears at the top level (not nested within `[]`, `{}`, or `()`). You can count the nesting depth of each bracket type in one variable since mismatching brackets would cause the compilation to fail anyway.", "created_at": "2018-11-19T22:15:46Z", "version": "2.4", "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM --platform=linux/x86_64 ubuntu:20.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    python3 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set default workdir to /testbed/ for cloning the repository\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version\nRUN git clone https://github.com/catchorg/Catch2.git . \\\n    && git reset --hard 62460fafe6b54c3173bc5cbc46d05a5f071017ff \\\n    && git remote remove origin\n\n# Pre-build step: Run the Python script to generate the single header file\nRUN python3 scripts/generateSingleHeader.py\n\n# Create a build directory and perform the out-of-source build\nRUN mkdir build\nWORKDIR /testbed/build\n\n# New: Add CXXFLAGS environment variable to ensure -Wno-error and -Wno-redundant-move are propagated directly to g++.\nENV CXXFLAGS=\"-Wno-error -Wno-redundant-move\"\n\n# Configure Catch2 with CMake (enabling testing) and compile\n# CATCH_BUILD_TESTING is ON by default, but explicitly set for clarity.\n# CMAKE_BUILD_TYPE set to Release to avoid aggressive warning flags in Debug builds.\n# Removed -DCATCH_BUILD_WARNINGS_AS_ERRORS=OFF as it's not recognized for this version.\n# Removed -DCMAKE_CXX_FLAGS=\"-Wno-error\" as CXXFLAGS environment variable is used instead.\nRUN cmake .. -DCMAKE_BUILD_TYPE=Release -DCATCH_BUILD_TESTING=ON \\\n    && make -j $(nproc)", "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory, as Git operations are relative to it.\ncd /testbed\n\n# Checkout the specific test file to its original state at the commit SHA.\n# This ensures a clean state before applying any potential patches, especially crucial\n# if the file was modified by a previous test run or context.\ngit checkout 62460fafe6b54c3173bc5cbc46d05a5f071017ff \"projects/SelfTest/UsageTests/Message.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\n# This step is critical if the test requires specific modifications to pass or fail.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -9,10 +9,6 @@\n #include \"catch.hpp\"\n #include <iostream>\n \n-#ifdef __clang__\n-#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n-#endif\n-\n TEST_CASE( \"INFO and WARN do not abort tests\", \"[messages][.]\" ) {\n     INFO( \"this is a \" << \"message\" );    // This should output the message if a failure occurs\n     WARN( \"this is a \" << \"warning\" );    // This should always output the message but then continue\n@@ -135,3 +131,60 @@ TEST_CASE( \"Pointers can be converted to strings\", \"[messages][.][approvals]\" )\n     WARN( \"actual address of p: \" << &p );\n     WARN( \"toString(p): \" << ::Catch::Detail::stringify( &p ) );\n }\n+\n+TEST_CASE( \"CAPTURE can deal with complex expressions\", \"[messages][capture]\" ) {\n+    int a = 1;\n+    int b = 2;\n+    int c = 3;\n+    CAPTURE( a, b, c, a + b, a+b, c > b, a == 1 );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wunused-value\" // In (1, 2), the \"1\" is unused ...\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-value\" // All the comma operators are side-effect free\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(push)\n+#pragma warning(disable:4709) // comma in indexing operator\n+#endif\n+\n+template <typename T1, typename T2>\n+struct helper_1436 {\n+    helper_1436(T1 t1, T2 t2):\n+        t1{ t1 },\n+        t2{ t2 }\n+    {}\n+    T1 t1;\n+    T2 t2;\n+};\n+\n+template <typename T1, typename T2>\n+std::ostream& operator<<(std::ostream& out, helper_1436<T1, T2> const& helper) {\n+    out << \"{ \" << helper.t1 << \", \" << helper.t2 << \" }\";\n+    return out;\n+}\n+\n+TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messages][capture]\") {\n+    CAPTURE(std::vector<int>{1, 2, 3}[0, 1, 2],\n+            std::vector<int>{1, 2, 3}[(0, 1)],\n+            std::vector<int>{1, 2, 3}[0]);\n+    CAPTURE((helper_1436<int, int>{12, -12}),\n+            (helper_1436<int, int>(-12, 12)));\n+    CAPTURE( (1, 2), (2, 3) );\n+    SUCCEED();\n+}\n+\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+#ifdef __GNUC__\n+#pragma GCC diagnostic pop\n+#endif\n+#ifdef _MSC_VER\n+#pragma warning(pop)\n+#endif\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 project was configured and built.\n# All build artifacts and the CTest setup are located here.\ncd build\n\n# Execute tests using CTest.\n# As per the collected information, projects/SelfTest/UsageTests/Message.tests.cpp is a\n# source file compiled into the SelfTest executable. There is no isolated ctest command\n# to run only this single C++ source file. A general 'ctest' run from the build directory\n# will execute all self-tests, including those from Message.tests.cpp.\n# -j$(nproc) optimizes parallelism, and --output-on-failure provides necessary output.\nctest -j$(nproc) --output-on-failure\nrc=$? # Capture the exit code of the test command immediately after execution.\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test file again to revert any changes made by the patch.\n# This ensures that the file system is clean and restored to its original state\n# after the test run, which is vital for subsequent operations or tests.\ngit checkout 62460fafe6b54c3173bc5cbc46d05a5f071017ff \"projects/SelfTest/UsageTests/Message.tests.cpp\"", "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory, as Git operations are relative to it.\ncd /testbed\n\n# Checkout the specific test file to its original state at the commit SHA.\n# This ensures a clean state before applying any potential patches, especially crucial\n# if the file was modified by a previous test run or context.\ngit checkout 62460fafe6b54c3173bc5cbc46d05a5f071017ff \"projects/SelfTest/UsageTests/Message.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\n# This step is critical if the test requires specific modifications to pass or fail.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 project was configured and built.\n# All build artifacts and the CTest setup are located here.\ncd build\n\n# Execute tests using CTest.\n# As per the collected information, projects/SelfTest/UsageTests/Message.tests.cpp is a\n# source file compiled into the SelfTest executable. There is no isolated ctest command\n# to run only this single C++ source file. A general 'ctest' run from the build directory\n# will execute all self-tests, including those from Message.tests.cpp.\n# -j$(nproc) optimizes parallelism, and --output-on-failure provides necessary output.\nctest -j$(nproc) --output-on-failure\nrc=$? # Capture the exit code of the test command immediately after execution.\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test file again to revert any changes made by the patch.\n# This ensures that the file system is clean and restored to its original state\n# after the test run, which is vital for subsequent operations or tests.\ngit checkout 62460fafe6b54c3173bc5cbc46d05a5f071017ff \"projects/SelfTest/UsageTests/Message.tests.cpp\""}
{"repo": "catchorg/Catch2", "pull_number": 1468, "instance_id": "catchorg__Catch2-1468", "issue_numbers": ["1454"], "base_commit": "4902cd721586822ded795afe0c418c553137306a", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -148,9 +148,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -226,9 +230,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -313,9 +321,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -384,9 +396,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/catch_meta.hpp\n@@ -0,0 +1,76 @@\n+/*\n+ *  Created by Jozef on 02/12/2018.\n+ *  Copyright 2018 Two Blue Cubes Ltd. All rights reserved.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#ifndef TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+\n+template< typename... >\n+struct TypeList{};\n+\n+template< typename... >\n+struct append;\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t>\n+struct append< L1<E1...>, L2<E2...> >\n+{\n+\tusing type = L1<E1..., E2...>;\n+};\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t, typename...Rest\n+\t>\n+struct append< L1<E1...>, L2<E2...>, Rest...>\n+{\n+\tusing type = typename append< L1<E1..., E2...>, Rest... >::type;\n+};\n+\n+template< template<typename...> class\n+        , typename...\n+        >\n+struct rewrap;\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , typename...elems\n+        >\n+struct rewrap<Container, List<elems...>>\n+{\n+    using type = TypeList< Container< elems... > >;\n+};\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , class...Elems\n+        , typename...Elements>\n+struct rewrap<Container, List<Elems...>, Elements...>\n+{\n+    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n+};\n+\n+template< template<typename...> class...Containers >\n+struct combine\n+{\n+    template< typename...Types >\n+    struct with_types\n+    {\n+        template< template <typename...> class Final >\n+        struct into\n+        {\n+            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n+        };\n+    };\n+};\n+\n+#endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -71,4 +71,9 @@\n #define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+\n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -118,6 +118,7 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_matchers_string.h\n         ${HEADER_DIR}/internal/catch_matchers_vector.h\n         ${HEADER_DIR}/internal/catch_message.h\n+        ${HEADER_DIR}/internal/catch_meta.hpp\n         ${HEADER_DIR}/internal/catch_objc.hpp\n         ${HEADER_DIR}/internal/catch_objc_arc.hpp\n         ${HEADER_DIR}/internal/catch_option.hpp\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -95,7 +95,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by type, in the form of `TEMPLATE_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE` and\n+`TEMPLATE_PRODUCT_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -147,9 +148,48 @@ TEMPLATE_TEST_CASE( \"vectors can be sized and resized\", \"[vector][template]\", in\n }\n ```\n \n+* **TEMPLATE_PRODUCT_TEST_CASE(** _test name_ , _tags_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+_template-type1_ through _template-typen_ is list of template template\n+types which should be combined with each of _template-arg1_ through\n+ _template-argm_, resulting in _n * m_ test cases. Inside the test case,\n+the resulting type is available under the name of `TestType`.\n+\n+To specify more than 1 type as a single _template-type_ or _template-arg_,\n+you must enclose the types in an additional set of parentheses, e.g.\n+`((int, float), (char, double))` specifies 2 template-args, each\n+consisting of 2 concrete types (`int`, `float` and `char`, `double`\n+respectively). You can also omit the outer set of parentheses if you\n+specify only one type as the full set of either the _template-types_,\n+or the _template-args_.\n+\n+\n+Example:\n+```\n+template< typename T>\n+struct Foo {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+```\n+\n+You can also have different arities in the _template-arg_ packs:\n+```\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    TestType x;\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+```\n+\n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n+is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -31,16 +31,22 @@ class UniqueTestsFixture {\n The two test cases here will create uniquely-named derived classes of UniqueTestsFixture and thus can access the `getID()` protected method and `conn` member variables. This ensures that both the test cases are able to create a DBConnection using the same method (DRY principle) and that any ID's created are unique such that the order that tests are executed does not matter.\n \n \n-Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` that can be used together\n-with templated fixtures to perform tests for multiple different types.\n-However, unlike `TEST_CASE_METHOD`, `TEMPLATE_TEST_CASE_METHOD` requires\n-the tag specification to be non-empty, as it is followed by further macros\n-arguments.\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` and\n+`TEMPLATE_PRODUCT_TEST_CASE_METHOD` that can be used together\n+with templated fixtures and templated template fixtures to perform\n+tests for multiple different types. Unlike `TEST_CASE_METHOD`,\n+`TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD` do\n+require the tag specification to be non-empty, as it is followed by\n+further macro arguments.\n \n Also note that, because of limitations of the C++ preprocessor, if you\n want to specify a type with multiple template parameters, you need to\n enclose it in parentheses, e.g. `std::map<int, std::string>` needs to be\n passed as `(std::map<int, std::string>)`.\n+In the case of `TEMPLATE_PRODUCT_TEST_CASE_METHOD`, if a member of the\n+type list should consist of more than single type, it needs to be enclosed\n+in another pair of parentheses, e.g. `(std::map, std::pair)` and\n+`((int, float), (char, double))`.\n \n Example:\n ```cpp\n@@ -54,11 +60,29 @@ struct Template_Fixture {\n TEMPLATE_TEST_CASE_METHOD(Template_Fixture,\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds\", \"[class][template]\", int, float, double) {\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n+\n+template<typename T>\n+struct Template_Template_Fixture {\n+    Template_Template_Fixture() {}\n+\n+    T m_a;\n+};\n+\n+template<typename T>\n+struct Foo_class {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Template_Fixture, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test succeeds\", \"[class][template]\", (Foo_class, std::vector), int) {\n+    REQUIRE( Template_Template_Fixture<TestType>::m_a.size() == 0 );\n+}\n ```\n \n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+the limit is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -14,6 +14,7 @@\n #include \"catch_stringref.h\"\n #include \"catch_type_traits.hpp\"\n #include \"catch_preprocessor.hpp\"\n+#include \"catch_meta.hpp\"\n \n namespace Catch {\n \n@@ -150,6 +151,38 @@ struct AutoReg : NonCopyable {\n             return 0;\\\n         }();\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        template<typename TestType> static void TestFuncName();       \\\n+        namespace {                                                   \\\n+            template<typename... Types>                               \\\n+            struct TestName {                                         \\\n+                TestName() {                                          \\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)       \\\n+                    int index = 0;                                    \\\n+                    using expander = int[];                           \\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }                                                     \\\n+            };                                                        \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n+                TestInit();                                           \\\n+                return 0;                                             \\\n+            }();                                                      \\\n+        }                                                             \\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFuncName()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         namespace{ \\\n@@ -180,4 +213,39 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+                void test();\\\n+            };\\\n+        namespace {\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                TestNameClass(){\\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n+                TestInit();\\\n+                return 0;\\\n+            }(); \\\n+        }\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -46,6 +46,18 @@ struct Template_Fixture {\n     T m_a;\n };\n \n+template<typename T>\n+struct Template_Fixture_2 {\n+    Template_Fixture_2() {}\n+\n+    T m_a;\n+};\n+\n+template< typename T>\n+struct Template_Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n \n@@ -62,6 +74,11 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n+{\n+    REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -74,6 +91,11 @@ namespace Inner\n     {\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n+    {\n+        REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -61,6 +61,11 @@ CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\n static AutoTestReg autoTestReg;\n CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n+template<typename T>\n+struct Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -301,6 +306,15 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\n", "problem_statement": "TEMPLATE_TEST_CASE does not support template templates\n## Description\r\nTEMPLATE_TEST_CASE only supports substitution of simple types, and not template templates.\r\n\r\n### Steps to reproduce\r\n\r\n```cpp\r\ntemplate <template <typename> typename T>\r\nstruct Foo { };\r\n\r\nTEMPLATE_TEST_CASE(\"instantiate a template template with int\", \"\", Foo) {\r\n     using T = TestType<int>;  // ... or something\r\n}\r\n```\n", "hints_text": "@porpoises in your example you probably wanted to do\r\n```c++\r\ntemplate<typename T>\r\nstruct Foo {};\r\n```\r\nin linked PR #1457 i added support for this kind of types. For this kind of tests you will have to use\r\n`TEMPLATE_TEMPLATE_TEST_CASE`.\r\n\nAwesome, thanks!", "created_at": "2018-12-06T19:16:07Z", "version": "2.5", "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM --platform=linux/x86_64 ubuntu:18.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    python3 \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install Python packages required for the build system (e.g., Conan)\nRUN pip3 install \\\n    conan \\\n    conan-package-tools\n\n# Set default workdir to /testbed/ for cloning the repository\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code and checkouts to the target version\nRUN git clone https://github.com/catchorg/Catch2.git . \\\n    && git reset --hard 4902cd721586822ded795afe0c418c553137306a \\\n    && git remote remove origin\n\n# Set environment variable for the C++ compiler to use g++-7.\n# On Ubuntu 18.04, build-essential provides g++-7 by default.\nENV CXX=g++-7", "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\ncd /testbed\n\n# Checkout the specific test files to their original state at the commit SHA.\n# This ensures a clean state before applying any potential patches.\n# The listed files include documentation and header files, which are included\n# for a complete reset, even though only .cpp files are actual tests.\ngit checkout 4902cd721586822ded795afe0c418c553137306a \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -95,7 +95,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by type, in the form of `TEMPLATE_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE` and\n+`TEMPLATE_PRODUCT_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -147,9 +148,48 @@ TEMPLATE_TEST_CASE( \"vectors can be sized and resized\", \"[vector][template]\", in\n }\n ```\n \n+* **TEMPLATE_PRODUCT_TEST_CASE(** _test name_ , _tags_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+_template-type1_ through _template-typen_ is list of template template\n+types which should be combined with each of _template-arg1_ through\n+ _template-argm_, resulting in _n * m_ test cases. Inside the test case,\n+the resulting type is available under the name of `TestType`.\n+\n+To specify more than 1 type as a single _template-type_ or _template-arg_,\n+you must enclose the types in an additional set of parentheses, e.g.\n+`((int, float), (char, double))` specifies 2 template-args, each\n+consisting of 2 concrete types (`int`, `float` and `char`, `double`\n+respectively). You can also omit the outer set of parentheses if you\n+specify only one type as the full set of either the _template-types_,\n+or the _template-args_.\n+\n+\n+Example:\n+```\n+template< typename T>\n+struct Foo {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+```\n+\n+You can also have different arities in the _template-arg_ packs:\n+```\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    TestType x;\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+```\n+\n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n+is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -31,16 +31,22 @@ class UniqueTestsFixture {\n The two test cases here will create uniquely-named derived classes of UniqueTestsFixture and thus can access the `getID()` protected method and `conn` member variables. This ensures that both the test cases are able to create a DBConnection using the same method (DRY principle) and that any ID's created are unique such that the order that tests are executed does not matter.\n \n \n-Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` that can be used together\n-with templated fixtures to perform tests for multiple different types.\n-However, unlike `TEST_CASE_METHOD`, `TEMPLATE_TEST_CASE_METHOD` requires\n-the tag specification to be non-empty, as it is followed by further macros\n-arguments.\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` and\n+`TEMPLATE_PRODUCT_TEST_CASE_METHOD` that can be used together\n+with templated fixtures and templated template fixtures to perform\n+tests for multiple different types. Unlike `TEST_CASE_METHOD`,\n+`TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD` do\n+require the tag specification to be non-empty, as it is followed by\n+further macro arguments.\n \n Also note that, because of limitations of the C++ preprocessor, if you\n want to specify a type with multiple template parameters, you need to\n enclose it in parentheses, e.g. `std::map<int, std::string>` needs to be\n passed as `(std::map<int, std::string>)`.\n+In the case of `TEMPLATE_PRODUCT_TEST_CASE_METHOD`, if a member of the\n+type list should consist of more than single type, it needs to be enclosed\n+in another pair of parentheses, e.g. `(std::map, std::pair)` and\n+`((int, float), (char, double))`.\n \n Example:\n ```cpp\n@@ -54,11 +60,29 @@ struct Template_Fixture {\n TEMPLATE_TEST_CASE_METHOD(Template_Fixture,\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds\", \"[class][template]\", int, float, double) {\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n+\n+template<typename T>\n+struct Template_Template_Fixture {\n+    Template_Template_Fixture() {}\n+\n+    T m_a;\n+};\n+\n+template<typename T>\n+struct Foo_class {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Template_Fixture, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test succeeds\", \"[class][template]\", (Foo_class, std::vector), int) {\n+    REQUIRE( Template_Template_Fixture<TestType>::m_a.size() == 0 );\n+}\n ```\n \n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+the limit is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -14,6 +14,7 @@\n #include \"catch_stringref.h\"\n #include \"catch_type_traits.hpp\"\n #include \"catch_preprocessor.hpp\"\n+#include \"catch_meta.hpp\"\n \n namespace Catch {\n \n@@ -150,6 +151,38 @@ struct AutoReg : NonCopyable {\n             return 0;\\\n         }();\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        template<typename TestType> static void TestFuncName();       \\\n+        namespace {                                                   \\\n+            template<typename... Types>                               \\\n+            struct TestName {                                         \\\n+                TestName() {                                          \\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)       \\\n+                    int index = 0;                                    \\\n+                    using expander = int[];                           \\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }                                                     \\\n+            };                                                        \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n+                TestInit();                                           \\\n+                return 0;                                             \\\n+            }();                                                      \\\n+        }                                                             \\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFuncName()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         namespace{ \\\n@@ -180,4 +213,39 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+                void test();\\\n+            };\\\n+        namespace {\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                TestNameClass(){\\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n+                TestInit();\\\n+                return 0;\\\n+            }(); \\\n+        }\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -46,6 +46,18 @@ struct Template_Fixture {\n     T m_a;\n };\n \n+template<typename T>\n+struct Template_Fixture_2 {\n+    Template_Fixture_2() {}\n+\n+    T m_a;\n+};\n+\n+template< typename T>\n+struct Template_Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n \n@@ -62,6 +74,11 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n+{\n+    REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -74,6 +91,11 @@ namespace Inner\n     {\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n+    {\n+        REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -61,6 +61,11 @@ CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\n static AutoTestReg autoTestReg;\n CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n+template<typename T>\n+struct Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -301,6 +306,15 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\nEOF_114329324912\n\n# --- Pre-build Step ---\n# Execute the single header generation script required by Catch2's build process.\npython3 scripts/generateSingleHeader.py\n\n# --- Build Steps ---\n# Create a dedicated build directory to perform an out-of-source build.\nmkdir Build-Debug\n# Change into the build directory. All subsequent build commands will be executed here.\ncd Build-Debug\n\n# Configure CMake for a Debug build with C++14 standard and test options.\n# Updated based on test log analysis: explicitly setting CMAKE_CXX_STANDARD=14\n# and CMAKE_CXX_EXTENSIONS=OFF to resolve compilation issues.\ncmake .. \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCMAKE_CXX_STANDARD=14 \\\n    -DCMAKE_CXX_EXTENSIONS=OFF \\\n    -DCATCH_BUILD_EXTRA_TESTS=ON \\\n    -DCATCH_ENABLE_WERROR=ON \\\n    -DCATCH_BUILD_TESTING=ON\n\n# Compile the project using all available CPU cores for speed.\nmake -j \"$(nproc)\"\n\n# --- Test Execution ---\n# Current directory is 'Build-Debug'.\n# Run the CTest suite.\n# As per the collected information, CTest automatically discovers and runs the compiled\n# test executables (including those from Class.tests.cpp and Misc.tests.cpp).\n# CTEST_OUTPUT_ON_FAILURE=1 ensures detailed output in case of test failures.\nCTEST_OUTPUT_ON_FAILURE=1 ctest -j \"$(nproc)\"\nrc=$? # Capture the exit code of the test command immediately after execution.\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific files again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout 4902cd721586822ded795afe0c418c553137306a \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\"", "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\ncd /testbed\n\n# Checkout the specific test files to their original state at the commit SHA.\n# This ensures a clean state before applying any potential patches.\n# The listed files include documentation and header files, which are included\n# for a complete reset, even though only .cpp files are actual tests.\ngit checkout 4902cd721586822ded795afe0c418c553137306a \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# --- Pre-build Step ---\n# Execute the single header generation script required by Catch2's build process.\npython3 scripts/generateSingleHeader.py\n\n# --- Build Steps ---\n# Create a dedicated build directory to perform an out-of-source build.\nmkdir Build-Debug\n# Change into the build directory. All subsequent build commands will be executed here.\ncd Build-Debug\n\n# Configure CMake for a Debug build with C++14 standard and test options.\n# Updated based on test log analysis: explicitly setting CMAKE_CXX_STANDARD=14\n# and CMAKE_CXX_EXTENSIONS=OFF to resolve compilation issues.\ncmake .. \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCMAKE_CXX_STANDARD=14 \\\n    -DCMAKE_CXX_EXTENSIONS=OFF \\\n    -DCATCH_BUILD_EXTRA_TESTS=ON \\\n    -DCATCH_ENABLE_WERROR=ON \\\n    -DCATCH_BUILD_TESTING=ON\n\n# Compile the project using all available CPU cores for speed.\nmake -j \"$(nproc)\"\n\n# --- Test Execution ---\n# Current directory is 'Build-Debug'.\n# Run the CTest suite.\n# As per the collected information, CTest automatically discovers and runs the compiled\n# test executables (including those from Class.tests.cpp and Misc.tests.cpp).\n# CTEST_OUTPUT_ON_FAILURE=1 ensures detailed output in case of test failures.\nCTEST_OUTPUT_ON_FAILURE=1 ctest -j \"$(nproc)\"\nrc=$? # Capture the exit code of the test command immediately after execution.\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific files again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout 4902cd721586822ded795afe0c418c553137306a \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\""}
{"repo": "catchorg/Catch2", "pull_number": 1492, "instance_id": "catchorg__Catch2-1492", "issue_numbers": ["1394", "1394", "1394"], "base_commit": "0387fb64ced7c3626b3164207c2d29aadb9ceaf2", "patch": "diff --git a/misc/coverage-helper.cpp b/misc/coverage-helper.cpp\n--- a/misc/coverage-helper.cpp\n+++ b/misc/coverage-helper.cpp\n@@ -9,6 +9,38 @@\n #include <string>\n #include <vector>\n \n+std::string escape_arg(const std::string& arg) {\n+    if (arg.empty() == false &&\n+        arg.find_first_of(\" \\t\\n\\v\\\"\") == arg.npos) {\n+        return arg;\n+    }\n+\n+    std::string escaped;\n+    escaped.push_back('\"');\n+    for (auto it = arg.begin(); ; ++it) {\n+        int num_backslashes = 0;\n+\n+        while (it != arg.end() && *it == '\\\\') {\n+            ++it;\n+            ++num_backslashes;\n+        }\n+\n+        if (it == arg.end()) {\n+            escaped.append(num_backslashes * 2, '\\\\');\n+            break;\n+        } else if (*it == '\"') {\n+            escaped.append(num_backslashes * 2 + 1, '\\\\');\n+            escaped.push_back(*it);\n+        } else {\n+            escaped.append(num_backslashes, '\\\\');\n+            escaped.push_back(*it);\n+        }\n+    }\n+    escaped.push_back('\"');\n+\n+    return escaped;\n+}\n+\n \n void create_empty_file(std::string const& path) {\n     std::ofstream ofs(path);\n@@ -60,8 +92,9 @@ std::string windowsify_path(std::string path) {\n void exec_cmd(std::string const& cmd, int log_num, std::string const& path) {\n     std::array<char, 128> buffer;\n #if defined(_WIN32)\n+    // cmd has already been escaped outside this function.\n     auto real_cmd = \"OpenCppCoverage --export_type binary:cov-report\" + std::to_string(log_num)\n-        + \".bin --quiet \" + \"--sources \" + path + \" --cover_children -- \" + cmd;\n+        + \".bin --quiet \" + \"--sources \" + escape_arg(path) + \" --cover_children -- \" + cmd;\n     std::cout << \"=== Marker ===: Cmd: \" << real_cmd << '\\n';\n     std::shared_ptr<FILE> pipe(_popen(real_cmd.c_str(), \"r\"), _pclose);\n #else // Just for testing, in the real world we will always work under WIN32\n@@ -91,9 +124,9 @@ int main(int argc, char** argv) {\n     assert(sep - begin(args) == 2 && \"Structure differs from expected!\");\n \n     auto num = parse_log_file_arg(args[1]);\n-\n+    \n     auto cmdline = std::accumulate(++sep, end(args), std::string{}, [] (const std::string& lhs, const std::string& rhs) {\n-        return lhs + ' ' + rhs;\n+        return lhs + ' ' + escape_arg(rhs);\n     });\n \n     try {\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -345,10 +345,16 @@ set_tests_properties(NoAssertions PROPERTIES PASS_REGULAR_EXPRESSION \"No asserti\n add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> -w NoTests \"___nonexistent_test___\")\n set_tests_properties(NoTest PROPERTIES PASS_REGULAR_EXPRESSION \"No test cases matched\")\n \n+add_test(NAME FilteredSection-1 COMMAND $<TARGET_FILE:SelfTest> \\#1394 -c RunSection)\n+set_tests_properties(FilteredSection-1 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+add_test(NAME FilteredSection-2 COMMAND $<TARGET_FILE:SelfTest> \\#1394\\ nested -c NestedRunSection -c s1)\n+set_tests_properties(FilteredSection-2 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+\n # AppVeyor has a Python 2.7 in path, but doesn't have .py files as autorunnable\n add_test(NAME ApprovalTests COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/scripts/approvalTests.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(ApprovalTests PROPERTIES FAIL_REGULAR_EXPRESSION \"Results differed\")\n \n+\n if (CATCH_USE_VALGRIND)\n     add_test(NAME ValgrindRunTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest>)\n     add_test(NAME ValgrindListTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest> --list-tests --verbosity high)\n", "test_patch": "diff --git a/include/internal/catch_test_case_tracker.cpp b/include/internal/catch_test_case_tracker.cpp\n--- a/include/internal/catch_test_case_tracker.cpp\n+++ b/include/internal/catch_test_case_tracker.cpp\n@@ -190,6 +190,17 @@ namespace TestCaseTracking {\n         }\n     }\n \n+    bool SectionTracker::isComplete() const {\n+        bool complete = true;\n+\n+        if ((m_filters.empty() || m_filters[0] == \"\") ||\n+             std::find(m_filters.begin(), m_filters.end(),\n+                       m_nameAndLocation.name) != m_filters.end())\n+            complete = TrackerBase::isComplete();\n+        return complete;\n+\n+    }\n+\n     bool SectionTracker::isSectionTracker() const { return true; }\n \n     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\ndiff --git a/include/internal/catch_test_case_tracker.h b/include/internal/catch_test_case_tracker.h\n--- a/include/internal/catch_test_case_tracker.h\n+++ b/include/internal/catch_test_case_tracker.h\n@@ -140,6 +140,8 @@ namespace TestCaseTracking {\n \n         bool isSectionTracker() const override;\n \n+        bool isComplete() const override;\n+\n         static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n \n         void tryOpen();\ndiff --git a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n@@ -324,3 +324,33 @@ TEST_CASE( \"Tracker\" ) {\n         //   two sections within a generator\n     }\n }\n+\n+static bool previouslyRun = false;\n+static bool previouslyRunNested = false;\n+\n+TEST_CASE( \"#1394\", \"[.][approvals][tracker]\" ) {\n+    // -- Don't re-run after specified section is done\n+    REQUIRE(previouslyRun == false);\n+\n+    SECTION( \"RunSection\" ) {\n+        previouslyRun = true;\n+    }\n+    SECTION( \"SkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n+\n+TEST_CASE( \"#1394 nested\", \"[.][approvals][tracker]\" ) {\n+    REQUIRE(previouslyRunNested == false);\n+\n+    SECTION( \"NestedRunSection\" ) {\n+        SECTION( \"s1\" ) {\n+            previouslyRunNested = true;\n+        }\n+    }\n+    SECTION( \"NestedSkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n", "problem_statement": "If a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\n", "hints_text": "I agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.", "created_at": "2019-01-08T13:45:01Z", "version": "2.5", "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM --platform=linux/x86_64 ubuntu:22.04\n\n# Set environment variables for silent package installations and timezone\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    python3 \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install Python packages required for the build system (e.g., Conan)\nRUN pip3 install \\\n    conan==1.10.2 \\\n    conan-package-tools\n\n# Set default workdir to /testbed/ for cloning the repository\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code and checkouts to the target version\nRUN git clone https://github.com/catchorg/Catch2.git . \\\n    && git reset --hard 0387fb64ced7c3626b3164207c2d29aadb9ceaf2 \\\n    && git remote remove origin", "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\ncd /testbed\n\n# Checkout the specific test files to their original state at the commit SHA.\n# This ensures a clean state before applying any potential patches.\ngit checkout 0387fb64ced7c3626b3164207c2d29aadb9ceaf2 \"include/internal/catch_test_case_tracker.cpp\" \"include/internal/catch_test_case_tracker.h\" \"projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/include/internal/catch_test_case_tracker.cpp b/include/internal/catch_test_case_tracker.cpp\n--- a/include/internal/catch_test_case_tracker.cpp\n+++ b/include/internal/catch_test_case_tracker.cpp\n@@ -190,6 +190,17 @@ namespace TestCaseTracking {\n         }\n     }\n \n+    bool SectionTracker::isComplete() const {\n+        bool complete = true;\n+\n+        if ((m_filters.empty() || m_filters[0] == \"\") ||\n+             std::find(m_filters.begin(), m_filters.end(),\n+                       m_nameAndLocation.name) != m_filters.end())\n+            complete = TrackerBase::isComplete();\n+        return complete;\n+\n+    }\n+\n     bool SectionTracker::isSectionTracker() const { return true; }\n \n     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\ndiff --git a/include/internal/catch_test_case_tracker.h b/include/internal/catch_test_case_tracker.h\n--- a/include/internal/catch_test_case_tracker.h\n+++ b/include/internal/catch_test_case_tracker.h\n@@ -140,6 +140,8 @@ namespace TestCaseTracking {\n \n         bool isSectionTracker() const override;\n \n+        bool isComplete() const override;\n+\n         static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n \n         void tryOpen();\ndiff --git a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n@@ -324,3 +324,33 @@ TEST_CASE( \"Tracker\" ) {\n         //   two sections within a generator\n     }\n }\n+\n+static bool previouslyRun = false;\n+static bool previouslyRunNested = false;\n+\n+TEST_CASE( \"#1394\", \"[.][approvals][tracker]\" ) {\n+    // -- Don't re-run after specified section is done\n+    REQUIRE(previouslyRun == false);\n+\n+    SECTION( \"RunSection\" ) {\n+        previouslyRun = true;\n+    }\n+    SECTION( \"SkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n+\n+TEST_CASE( \"#1394 nested\", \"[.][approvals][tracker]\" ) {\n+    REQUIRE(previouslyRunNested == false);\n+\n+    SECTION( \"NestedRunSection\" ) {\n+        SECTION( \"s1\" ) {\n+            previouslyRunNested = true;\n+        }\n+    }\n+    SECTION( \"NestedSkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\nEOF_114329324912\n\n# --- Pre-build Step ---\n# Execute the single header generation script required by Catch2's build process.\n# This step is included as it's common for Catch2 builds.\npython3 scripts/generateSingleHeader.py\n\n# --- Build Steps ---\n# Create a dedicated build directory to perform an out-of-source build.\nmkdir build\n# Change into the build directory. All subsequent build commands will be executed here.\ncd build\n\n# Configure CMake for a Debug build with C++17 standard and test options.\n# Updated CMAKE_CXX_STANDARD to 17 and passed -DCATCH_CONFIG_NO_POSIX_SIGNALS\n# via CMAKE_CXX_FLAGS to resolve compilation issues as per test log analysis.\ncmake -S .. -B . \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCMAKE_CXX_STANDARD=17 \\\n    -DCMAKE_CXX_EXTENSIONS=OFF \\\n    -DCATCH_BUILD_EXTRA_TESTS=ON \\\n    -DCATCH_ENABLE_WERROR=ON \\\n    -DCATCH_BUILD_TESTING=ON \\\n    -DCMAKE_CXX_FLAGS=\"-DCATCH_CONFIG_NO_POSIX_SIGNALS\"\n\n# Compile the project using all available CPU cores for speed.\ncmake --build . -j \"$(nproc)\"\n\n# --- Test Execution ---\n# Current directory is 'build'.\n# Run the CTest suite.\n# As per the collected information, CTest automatically discovers and runs the compiled\n# test executables (including projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp).\n# CTEST_OUTPUT_ON_FAILURE=1 ensures detailed output in case of test failures.\nCTEST_OUTPUT_ON_FAILURE=1 ctest -j \"$(nproc)\"\nrc=$? # Capture the exit code of the test command immediately after execution.\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific files again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout 0387fb64ced7c3626b3164207c2d29aadb9ceaf2 \"include/internal/catch_test_case_tracker.cpp\" \"include/internal/catch_test_case_tracker.h\" \"projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\"", "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\ncd /testbed\n\n# Checkout the specific test files to their original state at the commit SHA.\n# This ensures a clean state before applying any potential patches.\ngit checkout 0387fb64ced7c3626b3164207c2d29aadb9ceaf2 \"include/internal/catch_test_case_tracker.cpp\" \"include/internal/catch_test_case_tracker.h\" \"projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# --- Pre-build Step ---\n# Execute the single header generation script required by Catch2's build process.\n# This step is included as it's common for Catch2 builds.\npython3 scripts/generateSingleHeader.py\n\n# --- Build Steps ---\n# Create a dedicated build directory to perform an out-of-source build.\nmkdir build\n# Change into the build directory. All subsequent build commands will be executed here.\ncd build\n\n# Configure CMake for a Debug build with C++17 standard and test options.\n# Updated CMAKE_CXX_STANDARD to 17 and passed -DCATCH_CONFIG_NO_POSIX_SIGNALS\n# via CMAKE_CXX_FLAGS to resolve compilation issues as per test log analysis.\ncmake -S .. -B . \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCMAKE_CXX_STANDARD=17 \\\n    -DCMAKE_CXX_EXTENSIONS=OFF \\\n    -DCATCH_BUILD_EXTRA_TESTS=ON \\\n    -DCATCH_ENABLE_WERROR=ON \\\n    -DCATCH_BUILD_TESTING=ON \\\n    -DCMAKE_CXX_FLAGS=\"-DCATCH_CONFIG_NO_POSIX_SIGNALS\"\n\n# Compile the project using all available CPU cores for speed.\ncmake --build . -j \"$(nproc)\"\n\n# --- Test Execution ---\n# Current directory is 'build'.\n# Run the CTest suite.\n# As per the collected information, CTest automatically discovers and runs the compiled\n# test executables (including projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp).\n# CTEST_OUTPUT_ON_FAILURE=1 ensures detailed output in case of test failures.\nCTEST_OUTPUT_ON_FAILURE=1 ctest -j \"$(nproc)\"\nrc=$? # Capture the exit code of the test command immediately after execution.\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific files again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout 0387fb64ced7c3626b3164207c2d29aadb9ceaf2 \"include/internal/catch_test_case_tracker.cpp\" \"include/internal/catch_test_case_tracker.h\" \"projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\""}
{"repo": "catchorg/Catch2", "pull_number": 1608, "instance_id": "catchorg__Catch2-1608", "issue_numbers": ["1607"], "base_commit": "979bbf03bb00bc55ca09783791b5091a2247df68", "patch": "diff --git a/include/internal/catch_message.cpp b/include/internal/catch_message.cpp\n--- a/include/internal/catch_message.cpp\n+++ b/include/internal/catch_message.cpp\n@@ -9,6 +9,7 @@\n #include \"catch_message.h\"\n #include \"catch_interfaces_capture.h\"\n #include \"catch_uncaught_exceptions.h\"\n+#include \"catch_enforce.h\"\n \n #include <cassert>\n #include <stack>\n@@ -76,6 +77,15 @@ namespace Catch {\n             }\n             return names.substr(start, end - start + 1);\n         };\n+        auto skipq = [&] (size_t start, char quote) {\n+            for (auto i = start + 1; i < names.size() ; ++i) {\n+                if (names[i] == quote)\n+                    return i;\n+                if (names[i] == '\\\\')\n+                    ++i;\n+            }\n+            CATCH_INTERNAL_ERROR(\"CAPTURE parsing encountered unmatched parentheses\");\n+        };\n \n         size_t start = 0;\n         std::stack<char> openings;\n@@ -96,6 +106,10 @@ namespace Catch {\n //           case '>':\n                 openings.pop();\n                 break;\n+            case '\"':\n+            case '\\'':\n+                pos = skipq(pos, c);\n+                break;\n             case ',':\n                 if (start != pos && openings.size() == 0) {\n                     m_messages.emplace_back(macroName, lineInfo, resultType);\n", "test_patch": "diff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -251,6 +251,13 @@ TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messag\n     SUCCEED();\n }\n \n+TEST_CASE(\"CAPTURE parses string and character constants\", \"[messages][capture]\") {\n+    CAPTURE((\"comma, in string\", \"escaped, \\\", \"), \"single quote in string,',\", \"some escapes, \\\\,\\\\\\\\\");\n+    CAPTURE(\"some, ), unmatched, } prenheses {[<\");\n+    CAPTURE('\"', '\\'', ',', '}', ')', '(', '{');\n+    SUCCEED();\n+}\n+\n #ifdef __clang__\n #pragma clang diagnostic pop\n #endif\n", "problem_statement": "CAPTURE(\"text, with comma\") fails\n**Describe the bug**\r\nWhen string containing comma is passed to CAPTURE and test succeeds, the program will fail assertion \r\n`Capturer::~Capturer() : assert( m_captured == m_messages.size() );`\r\n\r\n**Expected behavior**\r\nDocumenting this behavior is probably enough. CAPTURE((\"test, with comma\")) works as expected. \r\n\r\n**Reproduction steps**\r\n```\r\nTEST_CASE(\"catch\") {\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(false);\r\n  CAPTURE(\"test, with comma\");\r\n  CHECK(true);\r\n}\r\n```\r\nproduces:\r\n```\r\ntest/test_suite.cpp:35: FAILED:\r\n  CHECK( false )\r\nwith message:\r\n  \"test := \"test, with comma\"\r\n\r\ntest_suite: test/catch.hpp:9638: Catch::Capturer::~Capturer(): Assertion `m_captured == m_messages.size()' failed.\r\n```\r\n**Platform information:**\r\n<!-- Fill in any extra information that might be important for your issue. -->\r\n - OS: **Debian stretch**\r\n - Compiler+version: **gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516**\r\n - Catch version: **Catch v2.7.0**\r\n\r\n\r\n**Additional context**\r\nCapturer::Capturer() does not expect quotation in names. It should be quite easy to fix (just add `bool isquoted` into parsing algorithm.\r\n\r\nBTW: Capturing string is quite useful when capturing __VA_ARGS__ in macro ... \r\n\n", "hints_text": "", "created_at": "2019-04-24T14:13:38Z", "version": "2.7", "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM --platform=linux/x86_64 ubuntu:20.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    python3 \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install Python dependencies using pip, specifically for Conan which is a C/C++ package manager\nRUN pip3 install conan==1.10.2 conan-package-tools\n\n# Set default workdir to /testbed/ for cloning the repository\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version\nRUN git clone https://github.com/catchorg/Catch2.git . \\\n    && git reset --hard 979bbf03bb00bc55ca09783791b5091a2247df68 \\\n    && git remote remove origin\n\n# Run the pre-build step: generate the single header file\nRUN python3 scripts/generateSingleHeader.py\n\n# Create a build directory and perform the out-of-source build\nRUN mkdir build\nWORKDIR /testbed/build\n\n# Configure Catch2 with CMake (enabling testing) and specify C++17 standard\nRUN cmake .. \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCATCH_BUILD_TESTING=ON \\\n    -DBUILD_TESTING=ON \\\n    -DCMAKE_CXX_STANDARD=17 \\\n    -DCMAKE_CXX_STANDARD_REQUIRED=ON\n\n# Compile the project\nRUN make -j $(nproc)", "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\n# The Dockerfile sets /testbed/build as WORKDIR, so we need to go up one level.\ncd /testbed\n\n# Checkout the specific test file to its original state at the commit SHA\n# This ensures a clean state before applying any potential patches.\ngit checkout 979bbf03bb00bc55ca09783791b5091a2247df68 \"projects/SelfTest/UsageTests/Message.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/projects/SelfTest/UsageTests/Message.tests.cpp b/projects/SelfTest/UsageTests/Message.tests.cpp\n--- a/projects/SelfTest/UsageTests/Message.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Message.tests.cpp\n@@ -251,6 +251,13 @@ TEST_CASE(\"CAPTURE can deal with complex expressions involving commas\", \"[messag\n     SUCCEED();\n }\n \n+TEST_CASE(\"CAPTURE parses string and character constants\", \"[messages][capture]\") {\n+    CAPTURE((\"comma, in string\", \"escaped, \\\", \"), \"single quote in string,',\", \"some escapes, \\\\,\\\\\\\\\");\n+    CAPTURE(\"some, ), unmatched, } prenheses {[<\");\n+    CAPTURE('\"', '\\'', ',', '}', ')', '(', '{');\n+    SUCCEED();\n+}\n+\n #ifdef __clang__\n #pragma clang diagnostic pop\n #endif\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 'SelfTest' executable is located.\n# The Dockerfile ensures this directory exists and the project is built.\ncd build\n\n# Execute the specific test cases from Message.tests.cpp using the Catch2 SelfTest executable.\n# Tests from Message.tests.cpp are typically tagged with [messages].\n# --success flag ensures a non-zero exit code on test failure, critical for automation.\n./projects/SelfTest \"[messages]\" --success\nrc=$? # Capture the exit code of the test command\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test file again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout 979bbf03bb00bc55ca09783791b5091a2247df68 \"projects/SelfTest/UsageTests/Message.tests.cpp\"", "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory\n# The Dockerfile sets /testbed/build as WORKDIR, so we need to go up one level.\ncd /testbed\n\n# Checkout the specific test file to its original state at the commit SHA\n# This ensures a clean state before applying any potential patches.\ngit checkout 979bbf03bb00bc55ca09783791b5091a2247df68 \"projects/SelfTest/UsageTests/Message.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 'SelfTest' executable is located.\n# The Dockerfile ensures this directory exists and the project is built.\ncd build\n\n# Execute the specific test cases from Message.tests.cpp using the Catch2 SelfTest executable.\n# Tests from Message.tests.cpp are typically tagged with [messages].\n# --success flag ensures a non-zero exit code on test failure, critical for automation.\n./projects/SelfTest \"[messages]\" --success\nrc=$? # Capture the exit code of the test command\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test file again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout 979bbf03bb00bc55ca09783791b5091a2247df68 \"projects/SelfTest/UsageTests/Message.tests.cpp\""}
{"repo": "catchorg/Catch2", "pull_number": 1609, "instance_id": "catchorg__Catch2-1609", "issue_numbers": ["1531"], "base_commit": "bd703dd74be7fd2413eb0c01662a491bcebea430", "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -150,14 +150,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -233,14 +241,22 @@\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -324,15 +340,23 @@ using Catch::Detail::Approx;\n #define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -400,15 +424,23 @@ using Catch::Detail::Approx;\n #define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n-#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n-#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )\n+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )\n+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_compiler_capabilities.h b/include/internal/catch_compiler_capabilities.h\n--- a/include/internal/catch_compiler_capabilities.h\n+++ b/include/internal/catch_compiler_capabilities.h\n@@ -64,6 +64,12 @@\n #       define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS \\\n             _Pragma( \"clang diagnostic pop\" )\n \n+#       define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic push\" ) \\\n+            _Pragma( \"clang diagnostic ignored \\\"-Wgnu-zero-variadic-macro-arguments\\\"\" )\n+#       define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+            _Pragma( \"clang diagnostic pop\" )\n+\n #endif // __clang__\n \n \n@@ -274,6 +280,10 @@\n #   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS\n #   define CATCH_INTERNAL_UNSUPPRESS_UNUSED_WARNINGS\n #endif\n+#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)\n+#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS\n+#   define CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\n+#endif\n \n #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)\n #define CATCH_TRY if ((true))\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -12,66 +12,8 @@\n #include <type_traits>\n \n namespace Catch {\n-template< typename... >\n-struct TypeList {};\n-\n-template< typename... >\n-struct append;\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n->\n-struct append< L1<E1...>, L2<E2...> > {\n-    using type = L1<E1..., E2...>;\n-};\n-\n-template< template<typename...> class L1\n-    , typename...E1\n-    , template<typename...> class L2\n-    , typename...E2\n-    , typename...Rest\n->\n-struct append< L1<E1...>, L2<E2...>, Rest...> {\n-    using type = typename append< L1<E1..., E2...>, Rest... >::type;\n-};\n-\n-template< template<typename...> class\n-    , typename...\n->\n-struct rewrap;\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , typename...elems\n->\n-struct rewrap<Container, List<elems...>> {\n-    using type = TypeList< Container< elems... > >;\n-};\n-\n-template< template<typename...> class Container\n-    , template<typename...> class List\n-    , class...Elems\n-    , typename...Elements>\n-    struct rewrap<Container, List<Elems...>, Elements...> {\n-    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n-};\n-\n-template< template<typename...> class...Containers >\n-struct combine {\n-    template< typename...Types >\n-    struct with_types {\n-        template< template <typename...> class Final >\n-        struct into {\n-            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n-        };\n-    };\n-};\n-\n-template<typename T>\n-struct always_false : std::false_type {};\n-\n+    template<typename T>\n+    struct always_false : std::false_type {};\n } // namespace Catch\n \n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -68,22 +68,151 @@\n #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)\n #endif\n \n+#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__\n+#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)\n+\n #define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)\n \n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name, __VA_ARGS__)\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" - \" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name,...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\n #else\n-// MSVC is adding extra space and needs more calls to properly remove ()\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME3(Name,...) Name \" -\" #__VA_ARGS__\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME2(Name, __VA_ARGS__)\n-#define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))\n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) Catch::TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)\n+\n+#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)\n+#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)\n+#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)\n+#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)\n+#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)\n+#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)\n+#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _4, _5, _6)\n+#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)\n+#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)\n+#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)\n+#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)\n+\n+#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n+\n+#define INTERNAL_CATCH_TYPE_GEN\\\n+    template<typename...> struct TypeList {};\\\n+    template<typename...Ts>\\\n+    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\\\n+    \\\n+    template<template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2> \\\n+    constexpr auto append(L1<E1...>, L2<E2...>) noexcept -> L1<E1...,E2...> { return {}; }\\\n+    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\\n+    constexpr auto append(L1<E1...>, L2<E2...>, Rest...) noexcept -> decltype(append(L1<E1...,E2...>{}, Rest{}...)) { return {}; }\\\n+    \\\n+    template< template<typename...> class Container, template<typename...> class List, typename...elems>\\\n+    constexpr auto rewrap(List<elems...>) noexcept -> TypeList<Container<elems...>> { return {}; }\\\n+    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\\\n+    constexpr auto rewrap(List<Elems...>,Elements...) noexcept -> decltype(append(TypeList<Container<Elems...>>{}, rewrap<Container>(Elements{}...))) { return {}; }\\\n+    \\\n+    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_NTTP_1(signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \\\n+    \\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>) noexcept -> TypeList<Container<__VA_ARGS__>> { return {}; }\\\n+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\\\n+    constexpr auto rewrap(List<__VA_ARGS__>,Elements...elems) noexcept -> decltype(append(TypeList<Container<__VA_ARGS__>>{}, rewrap<Container>(elems...))) { return {}; }\\\n+    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\\\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    static void TestName()\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\\\n+    template<typename Type>\\\n+    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\n+    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\n+    {\\\n+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\\\n+    template<typename TestType> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \\\n+        void test();\\\n+    }\n+\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\\\n+    template<typename TestType> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\\\n+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\n+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()\n \n-#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n-    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+#define INTERNAL_CATCH_NTTP_0\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)\n+#else\n+#define INTERNAL_CATCH_NTTP_0(signature)\n+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))\n+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( \"dummy\", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))\n+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))\n+#endif\n \n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\n", "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -6,6 +6,7 @@\n [Tag aliases](#tag-aliases)<br>\n [BDD-style test cases](#bdd-style-test-cases)<br>\n [Type parametrised test cases](#type-parametrised-test-cases)<br>\n+[Signature based parametrised test cases](#signature-based-parametrised-test-cases)<br>\n \n While Catch fully supports the traditional, xUnit, style of class-based fixtures containing test case methods this is not the preferred style.\n \n@@ -191,6 +192,56 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+\n+## Signature based parametrised test cases\n+\n+In addition to [type parametrised test cases](#type-parametrised-test-cases) Catch2 also supports\n+signature base parametrised test cases, in form of `TEMPLATE_TEST_CASE_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_SIG`.\n+These test cases have similar syntax like [type parametrised test cases](#type-parametrised-test-cases), with one\n+additional positional argument which specifies the signature.\n+\n+### Signature\n+Signature has some strict rules for these tests cases to work properly:\n+* signature with multiple template parameters e.g. `typename T, size_t S` must have this format in test case declaration\n+  `((typename T, size_t S), T, S)`\n+* signature with variadic template arguments e.g. `typename T, size_t S, typename...Ts` must have this format in test case declaration\n+  `((typename T, size_t S, typename...Ts), T, S, Ts...)`\n+* signature with single non type template parameter e.g. `int V` must have this format in test case declaration `((int V), V)`\n+* signature with single type template parameter e.g. `typename T` should not be used as it is in fact `TEMPLATE_TEST_CASE`\n+\n+Currently Catch2 support up to 11 template parameters in signature\n+\n+### Examples\n+\n+* **TEMPLATE_TEST_CASE_SIG(** _test name_ , _tags_,  _signature_, _type1_, _type2_, ..., _typen_ **)**\n+\n+Inside `TEMPLATE_TEST_CASE_SIG` test case you can use the names of template parameters as defined in _signature_. \n+\n+```cpp\n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: arrays can be created from NTTP arguments\", \"[vector][template][nttp]\",\n+  ((typename T, int V), T, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::array<T, V> v;\n+    REQUIRE(v.size() > 1);\n+}\n+```\n+\n+* **TEMPLATE_PRODUCT_TEST_CASE_SIG(** _test name_ , _tags_, _signature_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+```cpp\n+\n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+```\n+\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -84,6 +84,33 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n the limit is very high and should not be encountered in practice._\n \n+\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG` to support\n+fixtures using non-type template parameters. These test cases work similar to `TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+with additional positional argument for [signature](test-cases-and-sections.md#signature-based-parametrised-test-cases).\n+\n+Example:\n+```cpp\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n+\n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -60,18 +60,47 @@ struct AutoReg : NonCopyable {\n             };                            \\\n         }                                 \\\n         void TestName::test()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION( TestName, ... )  \\\n-        template<typename TestType>                                             \\\n-        static void TestName()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... )    \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \\\n         namespace{                                                                                  \\\n-            template<typename TestType>                                                             \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) {     \\\n-                void test();                                                                        \\\n-            };                                                                                      \\\n+            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         }                                                                                           \\\n-        template<typename TestType>                                                                 \\\n-        void TestName::test()\n+        }                                                                                           \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+    #endif  \n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n #endif\n \n     ///////////////////////////////////////////////////////////////////////////////\n@@ -111,46 +140,61 @@ struct AutoReg : NonCopyable {\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n     ///////////////////////////////////////////////////////////////////////////////\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, ... )\\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc();\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestName{\\\n-                template<typename...Ts> \\\n-                TestName(Ts...names){\\\n+                TestName(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, __VA_ARGS__) \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+            return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n-#endif\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+#endif  \n \n-    #define INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, ...)\\\n-        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-            TestName<CATCH_REC_LIST(INTERNAL_CATCH_REMOVE_PARENS, __VA_ARGS__)>(CATCH_REC_LIST_UD(INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME,Name, __VA_ARGS__));\\\n-            return 0;\\\n-        }();\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\\n         template<typename TestType> static void TestFuncName();       \\\n-        namespace {                                                   \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \\\n+            INTERNAL_CATCH_TYPE_GEN                                                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\\n             template<typename... Types>                               \\\n             struct TestName {                                         \\\n-                TestName() {                                          \\\n+                void reg_tests() {                                          \\\n                     int index = 0;                                    \\\n                     using expander = int[];                           \\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -160,63 +204,92 @@ struct AutoReg : NonCopyable {\n                 }                                                     \\\n             };                                                        \\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n-                TestInit();                                           \\\n+                using TestInit = decltype(create<TestName, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n                 return 0;                                             \\\n             }();                                                      \\\n         }                                                             \\\n+        }                                                             \\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS              \\\n         template<typename TestType>                                   \\\n         static void TestFuncName()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )\n+#endif\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        namespace{ \\\n-            template<typename TestType> \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n-                void test();\\\n-            };\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n+            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestNameClass{\\\n-                template<typename...Ts> \\\n-                TestNameClass(Ts...names){\\\n+                TestNameClass(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestNameClass, Name, __VA_ARGS__)\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+                return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\\\n-        template<typename TestType> \\\n-        void TestName<TestType>::test()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n+\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n                 void test();\\\n             };\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\\\n+            INTERNAL_CATCH_TYPE_GEN                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types>\\\n             struct TestNameClass{\\\n-                TestNameClass(){\\\n+                void reg_tests(){\\\n                     int index = 0;\\\n                     using expander = int[];\\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -226,22 +299,33 @@ struct AutoReg : NonCopyable {\n                 }\\\n             };\\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n-                TestInit();\\\n+                using TestInit = decltype(create<TestNameClass, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n                 return 0;\\\n             }(); \\\n         }\\\n+        }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n         void TestName<TestType>::test()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )\n #endif\n \n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n+#endif\n+\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -7,6 +7,7 @@\n  */\n \n #include \"catch.hpp\"\n+#include <array>\n \n namespace{ namespace ClassTests {\n \n@@ -58,6 +59,15 @@ struct Template_Foo {\n     size_t size() { return 0; }\n };\n \n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n #endif\n \n \n@@ -74,11 +84,20 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n {\n     REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -92,10 +111,19 @@ namespace Inner\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n \n+    TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][nttp][failing]\", ((int V), V), 1, 3, 6) {\n+        REQUIRE(Nttp_Fixture<V>::value == 0);\n+    }\n+\n     TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n     {\n         REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][product][nttp][failing]\", ((typename T, size_t S), T, S), (std::array, Template_Foo_2), ((int, 2), (float, 6)))\n+    {\n+        REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() < 2);\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -18,6 +18,7 @@\n #include <cerrno>\n #include <limits>\n #include <sstream>\n+#include <array>\n \n namespace { namespace MiscTests {\n \n@@ -66,6 +67,10 @@ struct Foo {\n     size_t size() { return 0; }\n };\n \n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -306,11 +311,56 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: vectors can be sized and resized\", \"[vector][template][nttp]\", ((typename TestType, int V), TestType, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::vector<TestType> v(V);\n+\n+    REQUIRE(v.size() == V);\n+    REQUIRE(v.capacity() >= V);\n+\n+    SECTION(\"resizing bigger changes size and capacity\") {\n+        v.resize(2 * V);\n+\n+        REQUIRE(v.size() == 2 * V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"resizing smaller changes size but not capacity\") {\n+        v.resize(0);\n+\n+        REQUIRE(v.size() == 0);\n+        REQUIRE(v.capacity() >= V);\n+\n+        SECTION(\"We can use the 'swap trick' to reset the capacity\") {\n+            std::vector<TestType> empty;\n+            empty.swap(v);\n+\n+            REQUIRE(v.capacity() == 0);\n+        }\n+    }\n+    SECTION(\"reserving bigger changes capacity but not size\") {\n+        v.reserve(2 * V);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"reserving smaller does not change size or capacity\") {\n+        v.reserve(0);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= V);\n+    }\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n     TestType x;\n     REQUIRE(x.size() == 0);\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\n", "problem_statement": "Type parametrised test case: support for non-type template parameters\nRight now, TEMPLATE_TEST_CASE and friends only seem to support type template parameters. Would be nice if we can also do something like this:\r\n\r\n    template<std::size_t,typename> struct Type;\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", 1, 2, 3, 4) {\r\n       Type<TestType, float> test;\r\n    }\r\n\r\n or even\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (1, int), (2, float), (3, int), (4, float)) {\r\n       Type<TestType> test;\r\n    }\r\n  \r\nP.S. Right now I am circumventing it like this:\r\n\r\n    TEMPLATE_TEST_CASE(\"\", \"\", (Type<1, float), (Type<2, float), (Type<3, float), (Type<4, float)) {\r\n       TestType test;\r\n    }\r\n\r\nwhich does work\n", "hints_text": "@tzakharko actually we thought about NTTP support for `TEMPLATE_PRODUCT_TEST_CASE`.\r\nWe decided that it would not be so trivial since the whole generation of the final `TestType` depends on the template signature for that type.\r\nEither way I think that I will take a deeper look on this feature.", "created_at": "2019-04-24T18:06:50Z", "version": "2.7", "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM --platform=linux/x86_64 ubuntu:20.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    git \\\n    build-essential \\\n    cmake \\\n    python3 \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set default workdir to /testbed/ for cloning the repository\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version\nRUN git clone https://github.com/catchorg/Catch2.git . \\\n    && git reset --hard bd703dd74be7fd2413eb0c01662a491bcebea430 \\\n    && git remote remove origin\n\n# Run the pre-build step: generate the single header file\nRUN python3 scripts/generateSingleHeader.py\n\n# Create a build directory and perform the out-of-source build\nRUN mkdir build\nWORKDIR /testbed/build\n\n# Configure Catch2 with CMake, enabling testing and specifying C++17 standard\nRUN cmake .. \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCATCH_BUILD_TESTING=ON \\\n    -DBUILD_TESTING=ON \\\n    -DCMAKE_CXX_STANDARD=17 \\\n    -DCMAKE_CXX_STANDARD_REQUIRED=ON\n\n# Compile the project (this will also build the self-tests)\nRUN make -j$(nproc)", "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory.\n# The Dockerfile sets /testbed/build as WORKDIR initially, so we need to go up one level.\ncd /testbed\n\n# Checkout the specific test files to their original state at the commit SHA.\n# This ensures a clean state before applying any potential patches.\ngit checkout bd703dd74be7fd2413eb0c01662a491bcebea430 \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -6,6 +6,7 @@\n [Tag aliases](#tag-aliases)<br>\n [BDD-style test cases](#bdd-style-test-cases)<br>\n [Type parametrised test cases](#type-parametrised-test-cases)<br>\n+[Signature based parametrised test cases](#signature-based-parametrised-test-cases)<br>\n \n While Catch fully supports the traditional, xUnit, style of class-based fixtures containing test case methods this is not the preferred style.\n \n@@ -191,6 +192,56 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+\n+## Signature based parametrised test cases\n+\n+In addition to [type parametrised test cases](#type-parametrised-test-cases) Catch2 also supports\n+signature base parametrised test cases, in form of `TEMPLATE_TEST_CASE_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_SIG`.\n+These test cases have similar syntax like [type parametrised test cases](#type-parametrised-test-cases), with one\n+additional positional argument which specifies the signature.\n+\n+### Signature\n+Signature has some strict rules for these tests cases to work properly:\n+* signature with multiple template parameters e.g. `typename T, size_t S` must have this format in test case declaration\n+  `((typename T, size_t S), T, S)`\n+* signature with variadic template arguments e.g. `typename T, size_t S, typename...Ts` must have this format in test case declaration\n+  `((typename T, size_t S, typename...Ts), T, S, Ts...)`\n+* signature with single non type template parameter e.g. `int V` must have this format in test case declaration `((int V), V)`\n+* signature with single type template parameter e.g. `typename T` should not be used as it is in fact `TEMPLATE_TEST_CASE`\n+\n+Currently Catch2 support up to 11 template parameters in signature\n+\n+### Examples\n+\n+* **TEMPLATE_TEST_CASE_SIG(** _test name_ , _tags_,  _signature_, _type1_, _type2_, ..., _typen_ **)**\n+\n+Inside `TEMPLATE_TEST_CASE_SIG` test case you can use the names of template parameters as defined in _signature_. \n+\n+```cpp\n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: arrays can be created from NTTP arguments\", \"[vector][template][nttp]\",\n+  ((typename T, int V), T, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::array<T, V> v;\n+    REQUIRE(v.size() > 1);\n+}\n+```\n+\n+* **TEMPLATE_PRODUCT_TEST_CASE_SIG(** _test name_ , _tags_, _signature_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+```cpp\n+\n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+```\n+\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -84,6 +84,33 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n the limit is very high and should not be encountered in practice._\n \n+\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD_SIG` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG` to support\n+fixtures using non-type template parameters. These test cases work similar to `TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+with additional positional argument for [signature](test-cases-and-sections.md#signature-based-parametrised-test-cases).\n+\n+Example:\n+```cpp\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n+\n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -60,18 +60,47 @@ struct AutoReg : NonCopyable {\n             };                            \\\n         }                                 \\\n         void TestName::test()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION( TestName, ... )  \\\n-        template<typename TestType>                                             \\\n-        static void TestName()\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... )    \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \\\n         namespace{                                                                                  \\\n-            template<typename TestType>                                                             \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) {     \\\n-                void test();                                                                        \\\n-            };                                                                                      \\\n+            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         }                                                                                           \\\n-        template<typename TestType>                                                                 \\\n-        void TestName::test()\n+        }                                                                                           \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+    #endif  \n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n+    #endif\n+\n+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+    #else\n+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\\n+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+    #endif\n #endif\n \n     ///////////////////////////////////////////////////////////////////////////////\n@@ -111,46 +140,61 @@ struct AutoReg : NonCopyable {\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n     ///////////////////////////////////////////////////////////////////////////////\n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, ... )\\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc();\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestName{\\\n-                template<typename...Ts> \\\n-                TestName(Ts...names){\\\n+                TestName(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, __VA_ARGS__) \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+            return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n-        template<typename TestType> \\\n-        static void TestFunc()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n-#endif\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )\n+#endif  \n \n-    #define INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestName, Name, ...)\\\n-        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-            TestName<CATCH_REC_LIST(INTERNAL_CATCH_REMOVE_PARENS, __VA_ARGS__)>(CATCH_REC_LIST_UD(INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME,Name, __VA_ARGS__));\\\n-            return 0;\\\n-        }();\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\\n         template<typename TestType> static void TestFuncName();       \\\n-        namespace {                                                   \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \\\n+            INTERNAL_CATCH_TYPE_GEN                                                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\\n             template<typename... Types>                               \\\n             struct TestName {                                         \\\n-                TestName() {                                          \\\n+                void reg_tests() {                                          \\\n                     int index = 0;                                    \\\n                     using expander = int[];                           \\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -160,63 +204,92 @@ struct AutoReg : NonCopyable {\n                 }                                                     \\\n             };                                                        \\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n-                TestInit();                                           \\\n+                using TestInit = decltype(create<TestName, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n                 return 0;                                             \\\n             }();                                                      \\\n         }                                                             \\\n+        }                                                             \\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS              \\\n         template<typename TestType>                                   \\\n         static void TestFuncName()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )\n+#endif\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n-        namespace{ \\\n-            template<typename TestType> \\\n-            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n-                void test();\\\n-            };\\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\n+            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types> \\\n             struct TestNameClass{\\\n-                template<typename...Ts> \\\n-                TestNameClass(Ts...names){\\\n+                TestNameClass(){\\\n+                    int index = 0;                                    \\\n+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\\\n                     using expander = int[];\\\n-                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ names, Tags } ), 0)... };/* NOLINT */ \\\n+                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \\\n                 }\\\n             };\\\n-            INTERNAL_CATCH_TEMPLATE_REGISTRY_INITIATE(TestNameClass, Name, __VA_ARGS__)\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\n+                return 0;\\\n+        }();\\\n+        }\\\n         }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\\\n-        template<typename TestType> \\\n-        void TestName<TestType>::test()\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS\\\n+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )\n #endif\n \n-    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )\n+#endif\n+\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n                 void test();\\\n             };\\\n         namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\\\n+            INTERNAL_CATCH_TYPE_GEN                  \\\n+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\n             template<typename...Types>\\\n             struct TestNameClass{\\\n-                TestNameClass(){\\\n+                void reg_tests(){\\\n                     int index = 0;\\\n                     using expander = int[];\\\n                     constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\\\n@@ -226,22 +299,33 @@ struct AutoReg : NonCopyable {\n                 }\\\n             };\\\n             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n-                using TestInit = Catch::combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n-                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n-                TestInit();\\\n+                using TestInit = decltype(create<TestNameClass, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>(TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>{}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n                 return 0;\\\n             }(); \\\n         }\\\n+        }\\\n         CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        CATCH_INTERNAL_UNSUPPRESS_ZERO_VARIADIC_WARNINGS \\\n         template<typename TestType> \\\n         void TestName<TestType>::test()\n \n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )\n #else\n     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n-        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )\n #endif\n \n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n+#endif\n+\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -7,6 +7,7 @@\n  */\n \n #include \"catch.hpp\"\n+#include <array>\n \n namespace{ namespace ClassTests {\n \n@@ -58,6 +59,15 @@ struct Template_Foo {\n     size_t size() { return 0; }\n };\n \n+template< typename T, size_t V>\n+struct Template_Foo_2 {\n+    size_t size() { return V; }\n+};\n+\n+template <int V>\n+struct Nttp_Fixture{\n+    int value = V;\n+};\n #endif\n \n \n@@ -74,11 +84,20 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][nttp]\",((int V), V), 1, 3, 6) {\n+    REQUIRE(Nttp_Fixture<V>::value > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n {\n     REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\", \"[class][template][product][nttp]\", ((typename T, size_t S), T, S),(std::array, Template_Foo_2), ((int,2), (float,6)))\n+{\n+    REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -92,10 +111,19 @@ namespace Inner\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n \n+    TEMPLATE_TEST_CASE_METHOD_SIG(Nttp_Fixture, \"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][nttp][failing]\", ((int V), V), 1, 3, 6) {\n+        REQUIRE(Nttp_Fixture<V>::value == 0);\n+    }\n+\n     TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n     {\n         REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that fails\", \"[.][class][template][product][nttp][failing]\", ((typename T, size_t S), T, S), (std::array, Template_Foo_2), ((int, 2), (float, 6)))\n+    {\n+        REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() < 2);\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -18,6 +18,7 @@\n #include <cerrno>\n #include <limits>\n #include <sstream>\n+#include <array>\n \n namespace { namespace MiscTests {\n \n@@ -66,6 +67,10 @@ struct Foo {\n     size_t size() { return 0; }\n };\n \n+template<typename T, size_t S>\n+struct Bar {\n+    size_t size() { return S; }\n+};\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -306,11 +311,56 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: vectors can be sized and resized\", \"[vector][template][nttp]\", ((typename TestType, int V), TestType, V), (int,5), (float,4), (std::string,15), ((std::tuple<int, float>), 6)) {\n+\n+    std::vector<TestType> v(V);\n+\n+    REQUIRE(v.size() == V);\n+    REQUIRE(v.capacity() >= V);\n+\n+    SECTION(\"resizing bigger changes size and capacity\") {\n+        v.resize(2 * V);\n+\n+        REQUIRE(v.size() == 2 * V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"resizing smaller changes size but not capacity\") {\n+        v.resize(0);\n+\n+        REQUIRE(v.size() == 0);\n+        REQUIRE(v.capacity() >= V);\n+\n+        SECTION(\"We can use the 'swap trick' to reset the capacity\") {\n+            std::vector<TestType> empty;\n+            empty.swap(v);\n+\n+            REQUIRE(v.capacity() == 0);\n+        }\n+    }\n+    SECTION(\"reserving bigger changes capacity but not size\") {\n+        v.reserve(2 * V);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= 2 * V);\n+    }\n+    SECTION(\"reserving smaller does not change size or capacity\") {\n+        v.reserve(0);\n+\n+        REQUIRE(v.size() == V);\n+        REQUIRE(v.capacity() >= V);\n+    }\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n     TestType x;\n     REQUIRE(x.size() == 0);\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\n+    TestType x;\n+    REQUIRE(x.size() > 0);\n+}\n+\n TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 'SelfTest' executable is located.\n# The Dockerfile ensures this directory exists and the project is built.\ncd build\n\n# Execute the specific test cases from Class.tests.cpp and Misc.tests.cpp using the Catch2 SelfTest executable.\n# Tests from Class.tests.cpp are typically tagged with [class] or [classification].\n# Tests from Misc.tests.cpp are typically tagged with [misc].\n# We combine these tags to run only the relevant tests efficiently.\n# The --success flag ensures a non-zero exit code upon test failure, which is critical for automation.\n./projects/SelfTest \"[class],[classification],[misc]\" --success\nrc=$? # Capture the exit code of the test command\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test files again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout bd703dd74be7fd2413eb0c01662a491bcebea430 \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\"", "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root directory.\n# The Dockerfile sets /testbed/build as WORKDIR initially, so we need to go up one level.\ncd /testbed\n\n# Checkout the specific test files to their original state at the commit SHA.\n# This ensures a clean state before applying any potential patches.\ngit checkout bd703dd74be7fd2413eb0c01662a491bcebea430 \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\"\n\n# Apply the test patch (if required) to modify the target test file(s).\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate to the build directory where the Catch2 'SelfTest' executable is located.\n# The Dockerfile ensures this directory exists and the project is built.\ncd build\n\n# Execute the specific test cases from Class.tests.cpp and Misc.tests.cpp using the Catch2 SelfTest executable.\n# Tests from Class.tests.cpp are typically tagged with [class] or [classification].\n# Tests from Misc.tests.cpp are typically tagged with [misc].\n# We combine these tags to run only the relevant tests efficiently.\n# The --success flag ensures a non-zero exit code upon test failure, which is critical for automation.\n./projects/SelfTest \"[class],[classification],[misc]\" --success\nrc=$? # Capture the exit code of the test command\n\n# Echo the exit code in the required format for the test judge.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the repository root for cleanup.\ncd /testbed\n\n# Checkout the specific test files again to revert any changes made by the patch.\n# This ensures that the file system is clean after the test run.\ngit checkout bd703dd74be7fd2413eb0c01662a491bcebea430 \"docs/test-cases-and-sections.md\" \"docs/test-fixtures.md\" \"include/internal/catch_test_registry.h\" \"projects/SelfTest/UsageTests/Class.tests.cpp\" \"projects/SelfTest/UsageTests/Misc.tests.cpp\""}
