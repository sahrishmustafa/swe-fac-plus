{
    "task_id": "catchorg__Catch2-2919",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2919_2025-06-30_16-30-35",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2919,
        "instance_id": "catchorg__Catch2-2919",
        "issue_numbers": [
            "2915"
        ],
        "base_commit": "fa43b77429ba76c462b1898d6cd2f2d7a9416b14",
        "patch": "diff --git a/src/catch2/matchers/catch_matchers_range_equals.hpp b/src/catch2/matchers/catch_matchers_range_equals.hpp\n--- a/src/catch2/matchers/catch_matchers_range_equals.hpp\n+++ b/src/catch2/matchers/catch_matchers_range_equals.hpp\n@@ -96,55 +96,64 @@ namespace Catch {\n          * Creates a matcher that checks if all elements in a range are equal\n          * to all elements in another range.\n          *\n-         * Uses `std::equal_to` to do the comparison\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike>\n+        template <typename RangeLike,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        std::enable_if_t<!Detail::is_matcher<RangeLike>::value,\n-                         RangeEqualsMatcher<RangeLike, std::equal_to<>>>\n-        RangeEquals( RangeLike&& range ) {\n-            return { CATCH_FORWARD( range ), std::equal_to<>{} };\n+        RangeEqualsMatcher<RangeLike, Equality>\n+        RangeEquals( RangeLike&& range,\n+                     Equality&& predicate = std::equal_to<>{} ) {\n+            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range.\n+         * to all elements in an initializer list.\n          *\n-         * Uses to provided predicate `predicate` to do the comparisons\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike, typename Equality>\n+        template <typename T,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        RangeEqualsMatcher<RangeLike, Equality>\n-        RangeEquals( RangeLike&& range, Equality&& predicate ) {\n-            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n+        RangeEqualsMatcher<std::initializer_list<T>, Equality>\n+        RangeEquals( std::initializer_list<T> range,\n+                     Equality&& predicate = std::equal_to<>{} ) {\n+            return { range, CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range, in some permutation\n+         * to all elements in another range, in some permutation.\n          *\n-         * Uses `std::equal_to` to do the comparison\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike>\n+        template <typename RangeLike,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        std::enable_if_t<\n-            !Detail::is_matcher<RangeLike>::value,\n-            UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>\n-        UnorderedRangeEquals( RangeLike&& range ) {\n-            return { CATCH_FORWARD( range ), std::equal_to<>{} };\n+        UnorderedRangeEqualsMatcher<RangeLike, Equality>\n+        UnorderedRangeEquals( RangeLike&& range,\n+                              Equality&& predicate = std::equal_to<>{} ) {\n+            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n         }\n \n         /**\n          * Creates a matcher that checks if all elements in a range are equal\n-         * to all elements in another range, in some permutation.\n+         * to all elements in an initializer list, in some permutation.\n          *\n-         * Uses to provided predicate `predicate` to do the comparisons\n+         * Uses the provided predicate `predicate` to do the comparisons\n+         * (defaulting to `std::equal_to`)\n          */\n-        template <typename RangeLike, typename Equality>\n+        template <typename T,\n+                  typename Equality = decltype( std::equal_to<>{} )>\n         constexpr\n-        UnorderedRangeEqualsMatcher<RangeLike, Equality>\n-        UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) {\n-            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };\n+        UnorderedRangeEqualsMatcher<std::initializer_list<T>, Equality>\n+        UnorderedRangeEquals( std::initializer_list<T> range,\n+                              Equality&& predicate = std::equal_to<>{} ) {\n+            return { range, CATCH_FORWARD( predicate ) };\n         }\n     } // namespace Matchers\n } // namespace Catch\n",
        "test_patch": "diff --git a/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp b/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n--- a/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n+++ b/tests/SelfTest/UsageTests/MatchersRanges.tests.cpp\n@@ -727,6 +727,15 @@ TEST_CASE( \"Usage of RangeEquals range matcher\", \"[matchers][templated][quantifi\n                       } ) );\n     }\n \n+    SECTION( \"Compare against std::initializer_list\" ) {\n+        const std::array<int, 3> array_a{ { 1, 2, 3 } };\n+\n+        REQUIRE_THAT( array_a, RangeEquals( { 1, 2, 3 } ) );\n+        REQUIRE_THAT( array_a, RangeEquals( { 2, 4, 6 }, []( int l, int r ) {\n+                          return l * 2 == r;\n+                      } ) );\n+    }\n+\n     SECTION(\"Check short-circuiting behaviour\") {\n         with_mocked_iterator_access<int> const mocked1{ 1, 2, 3, 4 };\n \n@@ -820,6 +829,16 @@ TEST_CASE( \"Usage of UnorderedRangeEquals range matcher\",\n \n         REQUIRE_THAT( needs_adl1, UnorderedRangeEquals( needs_adl2 ) );\n     }\n+\n+    SECTION( \"Compare against std::initializer_list\" ) {\n+        const std::array<int, 3> array_a{ { 1, 10, 20 } };\n+\n+        REQUIRE_THAT( array_a, UnorderedRangeEquals( { 10, 20, 1 } ) );\n+        REQUIRE_THAT( array_a,\n+                      UnorderedRangeEquals( { 11, 21, 2 }, []( int l, int r ) {\n+                          return std::abs( l - r ) <= 1;\n+                      } ) );\n+    }\n }\n \n /**\n",
        "problem_statement": "RangeEquals doesn't support literal std::initializer_list\nIt would often be useful to write something like this:\r\n```c++\r\n  const auto v = calculateSomeVectorOfInts();\r\n  CHECK_THAT(v, RangeEquals({1, 2, 3}));\r\n```\r\nThis doesn't compile. It can be made to compile by adding an overload to RangeEquals that takes a std::initializer_list. Would a PR adding such an overload have a chance of being accepted?\r\n\r\nIt's not a huge issue since there are workarounds, including any of these:\r\n```c++\r\n  const auto expected = {1, 2, 3};\r\n  CHECK_THAT(v, RangeEquals(expected));\r\n\r\n  CHECK_THAT(v, RangeEquals(std::vector{1, 2, 3}));\r\n\r\n  CHECK_THAT(v, RangeEquals(std::initializer_list<int>{1, 2, 3}));\r\n```\r\nStill, the convenience of writing the initializer_list inline without extra qualification would be nice.\n",
        "hints_text": "Sure, why not.",
        "created_at": "2024-10-12T15:21:56Z",
        "version": "3.7"
    }
}