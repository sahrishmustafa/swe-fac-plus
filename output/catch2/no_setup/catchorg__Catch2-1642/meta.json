{
    "task_id": "catchorg__Catch2-1642",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-1642_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 1642,
        "instance_id": "catchorg__Catch2-1642",
        "issue_numbers": [
            "1627"
        ],
        "base_commit": "b468d7cbff70291200294732c3795c53b5c502f6",
        "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -259,6 +259,8 @@\n #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\n+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)\n+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )\n@@ -268,6 +270,8 @@\n #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )\n+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\n--- a/include/internal/catch_meta.hpp\n+++ b/include/internal/catch_meta.hpp\n@@ -31,4 +31,8 @@ struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args..\n \n } // namespace Catch\n \n+namespace mpl_{\n+    struct na;\n+}\n+\n #endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -107,6 +107,8 @@\n     constexpr auto append(L1<E1...>, L2<E2...>) noexcept -> L1<E1...,E2...> { return {}; }\\\n     template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\\n     constexpr auto append(L1<E1...>, L2<E2...>, Rest...) noexcept -> decltype(append(L1<E1...,E2...>{}, Rest{}...)) { return {}; }\\\n+    template< template<typename...> class L1, typename...E1, typename...Rest>\\\n+    constexpr auto append(L1<E1...>, TypeList<mpl_::na>, Rest...) noexcept -> L1<E1...> { return {}; }\\\n     \\\n     template< template<typename...> class Container, template<typename...> class List, typename...elems>\\\n     constexpr auto rewrap(List<elems...>) noexcept -> TypeList<Container<elems...>> { return {}; }\\\n@@ -114,7 +116,9 @@\n     constexpr auto rewrap(List<Elems...>,Elements...) noexcept -> decltype(append(TypeList<Container<Elems...>>{}, rewrap<Container>(Elements{}...))) { return {}; }\\\n     \\\n     template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\\n-    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\n+    constexpr auto create(TypeList<Types...>) noexcept -> decltype(append(Final<>{}, rewrap<Containers>(Types{}...)...)) { return {}; }\\\n+    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\\\n+    constexpr auto convert(List<Ts...>) noexcept -> decltype(append(Final<>{},TypeList<Ts>{}...)) { return {}; }\n \n #define INTERNAL_CATCH_NTTP_1(signature, ...)\\\n     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\\\n",
        "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -96,8 +96,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by types, in the form of `TEMPLATE_TEST_CASE` and\n-`TEMPLATE_PRODUCT_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE`,\n+`TEMPLATE_PRODUCT_TEST_CASE` and `TEMPLATE_LIST_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -192,6 +192,23 @@ _While there is an upper limit on the number of types you can specify\n in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n is very high and should not be encountered in practice._\n \n+* **TEMPLATE_LIST_TEST_CASE(** _test name_, _tags_, _type list_ **)**\n+\n+_type list_ is a generic list of types on which test case should be instantiated.\n+List can be `std::tuple`, `boost::mpl::list`, `boost::mp11::mp_list` or anything with\n+`template <typename...>` signature.\n+\n+This allows you to reuse the _type list_ in multiple test cases.\n+\n+Example:\n+```cpp\n+using MyTypes = std::tuple<int, char, float>;\n+TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n+{\n+    REQUIRE(sizeof(TestType) > 0);\n+}\n+```\n+\n \n ## Signature based parametrised test cases\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -111,6 +111,19 @@ TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TE\n }\n ```\n \n+Catch2 also provides `TEMPLATE_LIST_TEST_CASE_METHOD` to support template fixtures with types specified in\n+template type lists like `std::tuple`, `boost::mpl::list` or `boost::mp11::mp_list`. This test case works the same as `TEMPLATE_TEST_CASE_METHOD`,\n+only difference is the source of types. This allows you to reuse the template type list in multiple test cases.\n+\n+Example:\n+```cpp\n+using MyTypes = std::tuple<int, char, double>;\n+TEMPLATE_LIST_TEST_CASE_METHOD(Template_Fixture, \"Template test case method with test types specified inside std::tuple\", \"[class][template][list]\", MyTypes)\n+{\n+    REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n+}\n+```\n+\n ---\n \n [Home](Readme.md#top)\ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -232,6 +232,35 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> static void TestFunc();       \\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\\\n+        INTERNAL_CATCH_TYPE_GEN\\\n+        template<typename... Types>                               \\\n+        struct TestName {                                         \\\n+            void reg_tests() {                                          \\\n+                int index = 0;                                    \\\n+                using expander = int[];                           \\\n+                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + \" - \" + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */\\\n+            }                                                     \\\n+        };\\\n+        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = decltype(convert<TestName>(TmplList {})); \\\n+                TestInit t;                                           \\\n+                t.reg_tests();                                        \\\n+                return 0;                                             \\\n+            }();                                                        \\\n+        }}\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFunc()\n+\n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \\\n+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )\n+\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\n@@ -327,5 +356,36 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+            void test();\\\n+        };\\\n+        namespace {\\\n+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \\\n+            INTERNAL_CATCH_TYPE_GEN\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                void reg_tests(){\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + \" - \" + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = decltype(convert<TestNameClass>(TmplList {}));\\\n+                TestInit t;\\\n+                t.reg_tests();\\\n+                return 0;\\\n+            }(); \\\n+        }}\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \\\n+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )\n+\n \n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -98,6 +98,12 @@ TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TE\n     REQUIRE(Template_Fixture_2<TestType>{}.m_a.size() >= 2);\n }\n \n+using MyTypes = std::tuple<int, char, double>;\n+TEMPLATE_LIST_TEST_CASE_METHOD(Template_Fixture, \"Template test case method with test types specified inside std::tuple\", \"[class][template][list]\", MyTypes)\n+{\n+    REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -365,6 +365,12 @@ TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product\n     REQUIRE(std::tuple_size<TestType>::value >= 1);\n }\n \n+using MyTypes = std::tuple<int, char, float>;\n+TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n+{\n+    REQUIRE(sizeof(TestType) > 0);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\n",
        "problem_statement": "Support for generic typelists in TEMPLATE_TEST_CASE\n**Description**\r\nOften I already have a typelist of some kind (std::tuple, boost::mpl::list (Boost.MPL), mp_list (Boost.mp11)) and I want to execute a test for each of the types contained in the typelist. I have not yet found a good way to do this with catch2. In my case the types in those lists depend on the current platform and other settings so it is hard if not impossible to write them into the test case header.\r\n\r\nCurrently I am working around this by iterating over the type list in the test body and calling a separate template test method for each type. However, with this approach the type is not part of the test name and it is not easily possible to see which type triggered the error.\r\n\r\nTo enable this use-case, a new macro called `TEMPLATE_LIST_TEST_CASE` or similar would have to be added which internally adds a test case for each of the contained types.\r\nThis is supported by [Boost.Test](https://www.boost.org/doc/libs/1_70_0/libs/test/doc/html/boost_test/tests_organization/test_cases/test_organization_templates.html) as well as [gtest](https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#typed-tests).\r\n\r\n**Additional context**\r\nExample pseudo code usage:\r\n```\r\nusing Types = std::tuple<int, double, float>;\r\nTEMPLATE_LIST_TEST_CASE(\"test\", \"[test]\", Types)\r\n{\r\n    // Do something with the TestType here which would be `int`, `double` or `float`\r\n}\r\nTEMPLATE_LIST_TEST_CASE(\"test2\", \"[test]\", Types)\r\n{\r\n    // This allows to reuse the typelist for multiple tests\r\n}\r\n```\r\n\n",
        "hints_text": "",
        "created_at": "2019-05-27T18:46:18Z",
        "version": "2.8"
    }
}