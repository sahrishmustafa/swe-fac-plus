{
    "task_id": "catchorg__Catch2-2334",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2334_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2334,
        "instance_id": "catchorg__Catch2-2334",
        "issue_numbers": [
            "898"
        ],
        "base_commit": "d3199c42c2af0f69e43686c2b47189c8bad04026",
        "patch": "diff --git a/src/catch2/internal/catch_fatal_condition_handler.cpp b/src/catch2/internal/catch_fatal_condition_handler.cpp\n--- a/src/catch2/internal/catch_fatal_condition_handler.cpp\n+++ b/src/catch2/internal/catch_fatal_condition_handler.cpp\n@@ -84,7 +84,7 @@ namespace Catch {\n         { static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), \"Divide by zero error\" },\n     };\n \n-    static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {\n+    static LONG CALLBACK topLevelExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo) {\n         for (auto const& def : signalDefs) {\n             if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {\n                 reportFatal(def.name);\n@@ -98,7 +98,7 @@ namespace Catch {\n     // Since we do not support multiple instantiations, we put these\n     // into global variables and rely on cleaning them up in outlined\n     // constructors/destructors\n-    static PVOID exceptionHandlerHandle = nullptr;\n+    static LPTOP_LEVEL_EXCEPTION_FILTER previousTopLevelExceptionFilter = nullptr;\n \n \n     // For MSVC, we reserve part of the stack memory for handling\n@@ -120,18 +120,15 @@ namespace Catch {\n \n \n     void FatalConditionHandler::engage_platform() {\n-        // Register as first handler in current chain\n-        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\n-        if (!exceptionHandlerHandle) {\n-            CATCH_RUNTIME_ERROR(\"Could not register vectored exception handler\");\n-        }\n+        // Register as a the top level exception filter.\n+        previousTopLevelExceptionFilter = SetUnhandledExceptionFilter(topLevelExceptionFilter);\n     }\n \n     void FatalConditionHandler::disengage_platform() {\n-        if (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) {\n-            CATCH_RUNTIME_ERROR(\"Could not unregister vectored exception handler\");\n+        if (SetUnhandledExceptionFilter(reinterpret_cast<LPTOP_LEVEL_EXCEPTION_FILTER>(previousTopLevelExceptionFilter)) != topLevelExceptionFilter) {\n+            CATCH_RUNTIME_ERROR(\"Could not restore previous top level exception filter\");\n         }\n-        exceptionHandlerHandle = nullptr;\n+        previousTopLevelExceptionFilter = nullptr;\n     }\n \n } // end namespace Catch\n",
        "test_patch": "diff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -6,6 +6,7 @@\n #include <catch2/catch_test_macros.hpp>\n #include <catch2/catch_template_test_macros.hpp>\n #include <catch2/internal/catch_config_wchar.hpp>\n+#include <catch2/internal/catch_windows_h_proxy.hpp>\n \n #ifdef __clang__\n #   pragma clang diagnostic ignored \"-Wc++98-compat\"\n@@ -498,3 +499,34 @@ TEMPLATE_TEST_CASE_SIG(\"#1954 - 7 arg template test case sig compiles\", \"[regres\n \n TEST_CASE(\"Same test name but with different tags is fine\", \"[.approvals][some-tag]\") {}\n TEST_CASE(\"Same test name but with different tags is fine\", \"[.approvals][other-tag]\") {}\n+\n+#if defined(CATCH_PLATFORM_WINDOWS)\n+void throw_and_catch()\n+{\n+    __try {\n+        RaiseException(0xC0000005, 0, 0, NULL);\n+    }\n+    __except (1)\n+    {\n+\n+    }\n+}\n+\n+\n+TEST_CASE(\"Validate SEH behavior - handled\", \"[approvals][FatalConditionHandler][CATCH_PLATFORM_WINDOWS]\")\n+{\n+    // Validate that Catch2 framework correctly handles tests raising and handling SEH exceptions.\n+    throw_and_catch();\n+}\n+\n+void throw_no_catch()\n+{\n+    RaiseException(0xC0000005, 0, 0, NULL);\n+}\n+\n+TEST_CASE(\"Validate SEH behavior - unhandled\", \"[.approvals][FatalConditionHandler][CATCH_PLATFORM_WINDOWS]\")\n+{\n+    // Validate that Catch2 framework correctly handles tests raising and not handling SEH exceptions.\n+    throw_no_catch();\n+}\n+#endif\n",
        "problem_statement": "[clang] [windows] [address-sanitizer] stack overflow when test is failing\n## Description\r\nCatch enters infinite recursion trying to print error message when compiled with clang -faddress-sanitize under Windows\r\n\r\n### Steps to reproduce\r\n0. Install VS 2015 and [clang](http://llvm.org/pre-releases/win-snapshots/LLVM-5.0.0-r300231-win64.exe)\r\n1. Put `catch.hpp` and `test.bat` from [test.zip](https://github.com/philsquared/Catch/files/964783/test.zip) in one directory, start `test.bat`\r\n2. Resulting executable, instead of reporting an error, will output:\r\n<pre>\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n</pre>\r\nand then it will crash.\r\n\n",
        "hints_text": "FWIW this works normally under Linux.\r\n\r\nWhat if you use normal Clang:\r\n\r\n```\r\nclang++ -fsanitize=address -o test.exe test.cpp\r\n```\r\n\r\nAlso, you seem to be building a normal, shared executable. What if you change the library name to `clang_rt.asan_dynamic-x86_64.lib`? (The one you're using is for applications using the static CRT.)\nCompiling with \r\n\r\n    clang++ -fsanitize=address -o test.exe test.cpp\r\n\r\ngives me \r\n\r\n<pre>\r\n==748==AddressSanitizer CHECK failed: D:\\src\\llvm_package_300231\\llvm\\projects\\compiler-rt\\lib\\asan\\asan_rtl.cc:505 \"((!asan_init_is_running && \"ASan init calls itself!\")) != (0)\" (0x0, 0x0)\r\n==748==AddressSanitizer CHECK failed: D:\\src\\llvm_package_300231\\llvm\\projects\\compiler-rt\\lib\\asan\\asan_poisoning.cc:37 \"((AddrIsInMem(addr))) != (0)\" (0x0, 0x0)\r\n</pre>\r\n \r\neven if 'test.cpp' is just an empty `main`. This is why I've added `/DEBUG` when linking. This has nothing to do with Catch, must be clang bug.\r\n\r\nWith `clang_rt.asan_dynamic-x86_64.lib` linking fails:\r\n<pre>\r\ntest.obj : error LNK2019: unresolved external symbol __asan_shadow_memory_dynamic_address referenced in function \"struct Catch::IResultCapture & __cdecl Catch::getResultCapture(void)\" (?getResultCapture@Catch@@YAAEAUIResultCapture@1@XZ)\r\ntest.obj : error LNK2019: unresolved external symbol __asan_option_detect_stack_use_after_return referenced in function \"struct Catch::IResultCapture & __cdecl Catch::getResultCapture(void)\" (?getResultCapture@Catch@@YAAEAUIResultCapture@1@XZ)\r\ntest.exe : fatal error LNK1120: 2 unresolved externals\r\n</pre>\r\n\nIs ASan supported under Windows? Last time I checked, it was \"this will very likely work for C, C++ is very much beta\".\nHello. Now that Address Sanitizer is [Generally Available](https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/) for MSVC, I've noticed that I'm unable to run my tests due to this issue--they get stuck and won't complete.\r\n\r\nAfter some digging, I found a relevant open issue on Microsoft's tracker with a [potential workaround](https://developercommunity.visualstudio.com/t/Asan-problems-when-manual-exception-hand/1242524#T-N1295191) that would consist of the following (naive) change to Catch here https://github.com/catchorg/Catch2/blob/b025a007b924cc16da84c07a5d35118695cb9bcc/include/internal/catch_fatal_condition.cpp#L64 and here for the single include header: https://github.com/catchorg/Catch2/blob/b025a007b924cc16da84c07a5d35118695cb9bcc/single_include/catch2/catch.hpp#L10787\r\n\r\n```diff\r\n- exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\r\n+ exceptionHandlerHandle = AddVectoredExceptionHandler(0, handleVectoredException);\r\n```\r\n\r\n\r\nI've tested this change locally with a modified (read: updated) version of the batch script in the OP with a fully updated Visual Studio (v16.9.1) on latest Catch (v2.13.4), and it seems to run to completion! \r\n```bat\r\necho #define CATCH_CONFIG_MAIN > test.cpp\r\necho #include \"catch.hpp\" >> test.cpp\r\necho TEST_CASE( \"t\", \"[t]\" ) { REQUIRE( 2 == 1 ); } >> test.cpp\r\n\r\ncall \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" amd64\r\necho Please wait...\r\ncl /EHsc test.cpp -fsanitize=address -c\r\nlink /DEBUG test.obj\r\n\r\nstart test.exe\r\n```\r\n\r\nHowever, I don't understand the consequences of this change and how it could affect the rest of Catch's logic and exception handling, so hopefully this helps one of the maintainers or someone else more familiar with the code base and C++ in general \ud83d\ude42 \nThis is related to the way asan is implemented on x64 msvc. See here [doc](https://devblogs.microsoft.com/cppblog/asan-for-windows-x64-and-debug-build-support/).\r\nCatch2 is catching tons of 0xc0000005 (FCE - first chance exceptions) and gets confused.\r\nYour fix works but gives up on FCEs.\r\n\r\ncatch2+asan+msvc is working on x86 unmodified (but nobody builds for x86 anymore)\r\n\r\nMaybe catch2 could offer an option to give up on first chance exception or do it automatically on x64 with\r\n```#  if __SANITIZE_ADDRESS__\r\n... ```\r\n\r\nEdit: with catch2 moving as a library, this way to fix depending on asan would not work. \nas a workaround, setting `CATCH_CONFIG_NO_WINDOWS_SEH` fixed this issue for me (tested with 2.13.6).",
        "created_at": "2021-12-15T17:06:20Z",
        "version": "3.0"
    }
}