{
    "task_id": "catchorg__Catch2-2177",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2177_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2177,
        "instance_id": "catchorg__Catch2-2177",
        "issue_numbers": [
            "2166"
        ],
        "base_commit": "c12170ff69ddc9a0a25ec2025783b815354c6d26",
        "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -17,6 +17,8 @@ cmake_dependent_option(CATCH_BUILD_EXTRA_TESTS \"Build extra tests\" OFF \"CATCH_DE\n cmake_dependent_option(CATCH_BUILD_FUZZERS \"Build fuzzers\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n cmake_dependent_option(CATCH_ENABLE_COVERAGE \"Generate coverage for codecov.io\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n cmake_dependent_option(CATCH_ENABLE_WERROR \"Enables Werror during build\" ON \"CATCH_DEVELOPMENT_BUILD\" OFF)\n+cmake_dependent_option(CATCH_BUILD_SURROGATES \"Enable generating and building surrogate TUs for the main headers\" OFF \"CATCH_DEVELOPMENT_BUILD\" OFF)\n+\n \n # Catch2's build breaks if done in-tree. You probably should not build\n # things in tree anyway, but we can allow projects that include Catch2\ndiff --git a/src/catch2/benchmark/catch_constructor.hpp b/src/catch2/benchmark/catch_constructor.hpp\n--- a/src/catch2/benchmark/catch_constructor.hpp\n+++ b/src/catch2/benchmark/catch_constructor.hpp\n@@ -11,6 +11,7 @@\n #define CATCH_CONSTRUCTOR_HPP_INCLUDED\n \n #include <type_traits>\n+#include <utility>\n \n namespace Catch {\n     namespace Benchmark {\ndiff --git a/src/catch2/benchmark/detail/catch_analyse.hpp b/src/catch2/benchmark/detail/catch_analyse.hpp\n--- a/src/catch2/benchmark/detail/catch_analyse.hpp\n+++ b/src/catch2/benchmark/detail/catch_analyse.hpp\n@@ -11,8 +11,10 @@\n #define CATCH_ANALYSE_HPP_INCLUDED\n \n #include <catch2/benchmark/catch_clock.hpp>\n+#include <catch2/benchmark/catch_environment.hpp>\n #include <catch2/benchmark/catch_sample_analysis.hpp>\n #include <catch2/benchmark/detail/catch_stats.hpp>\n+#include <catch2/interfaces/catch_interfaces_config.hpp>\n \n #include <algorithm>\n #include <iterator>\ndiff --git a/src/catch2/catch_reporter_registrars.hpp b/src/catch2/catch_reporter_registrars.hpp\n--- a/src/catch2/catch_reporter_registrars.hpp\n+++ b/src/catch2/catch_reporter_registrars.hpp\n@@ -9,11 +9,15 @@\n #define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED\n \n #include <catch2/interfaces/catch_interfaces_registry_hub.hpp>\n+#include <catch2/interfaces/catch_interfaces_reporter.hpp>\n #include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n #include <catch2/internal/catch_unique_ptr.hpp>\n \n namespace Catch {\n \n+    struct IStreamingReporter;\n+    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\n+\n     template <typename T>\n     class ReporterFactory : public IReporterFactory {\n \ndiff --git a/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp b/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n--- a/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n+++ b/src/catch2/interfaces/catch_interfaces_reporter_factory.hpp\n@@ -8,9 +8,16 @@\n #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED\n #define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED\n \n+#include <catch2/internal/catch_unique_ptr.hpp>\n+\n+#include <string>\n+\n namespace Catch {\n \n     struct ReporterConfig;\n+    struct IStreamingReporter;\n+    using IStreamingReporterPtr = Detail::unique_ptr<IStreamingReporter>;\n+\n \n     struct IReporterFactory {\n         virtual ~IReporterFactory(); // = default\ndiff --git a/src/catch2/internal/catch_container_nonmembers.hpp b/src/catch2/internal/catch_container_nonmembers.hpp\n--- a/src/catch2/internal/catch_container_nonmembers.hpp\n+++ b/src/catch2/internal/catch_container_nonmembers.hpp\n@@ -10,6 +10,8 @@\n \n #include <catch2/internal/catch_compiler_capabilities.hpp>\n \n+#include <cstddef>\n+#include <initializer_list>\n \n // We want a simple polyfill over `std::empty`, `std::size` and so on\n // for C++14 or C++ libraries with incomplete support.\n",
        "test_patch": "diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -1,5 +1,66 @@\n include(MiscFunctions)\n \n+if (CATCH_BUILD_SURROGATES)\n+  message(STATUS \"Configuring targets for surrogate TUs\")\n+\n+  # If the folder does not exist before we ask for output redirect to\n+  # a file, it won't work.\n+  file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/surrogates)\n+\n+  # Creates target to generate the surrogate TU for provided header.\n+  # Returns the path to the generated file.\n+  function(createSurrogateFileTarget sourceHeader pathToFile)\n+    set(pathPrefix ${PROJECT_SOURCE_DIR}/src)\n+\n+    file(RELATIVE_PATH includePath ${pathPrefix} ${sourceHeader})\n+\n+    get_filename_component(basicFileName \"${sourceHeader}\" NAME_WE)\n+\n+    set(surrogateFilePath ${CMAKE_CURRENT_BINARY_DIR}/surrogates/surrogate_${basicFileName}.cpp)\n+\n+    add_custom_command(\n+      OUTPUT ${surrogateFilePath}\n+      COMMAND cmake -E echo \"\\#include <${includePath}>\" > \"${surrogateFilePath}\"\n+      VERBATIM\n+    )\n+\n+    set(${pathToFile} ${surrogateFilePath} PARENT_SCOPE)\n+  endfunction()\n+\n+  # Extracts all non-helper (e.g. catch_all.hpp) headers from the\n+  # Catch2 target, and returns them through the argument.\n+  function(ExtractCatch2Headers OutArg)\n+    get_target_property(targetSources Catch2 SOURCES)\n+    foreach(Source ${targetSources})\n+      string(REGEX MATCH \"^.*\\\\.hpp$\" isHeader ${Source})\n+      string(REGEX MATCH \"_all.hpp\" isAllHeader ${Source})\n+      if(isHeader AND NOT isAllHeader)\n+        list(APPEND AllHeaders ${Source})\n+      endif()\n+    endforeach()\n+    set(${OutArg} ${AllHeaders} PARENT_SCOPE)\n+  endfunction()\n+\n+\n+  ExtractCatch2Headers(mainHeaders)\n+\n+  if (NOT mainHeaders)\n+    message(FATAL_ERROR \"No headers in the main target were detected. Something is broken.\")\n+  endif()\n+\n+  foreach(header ${mainHeaders})\n+    createSurrogateFileTarget(${header} pathToGeneratedFile)\n+    list(APPEND surrogateFiles ${pathToGeneratedFile})\n+  endforeach()\n+\n+\n+  add_executable(Catch2SurrogateTarget\n+    ${surrogateFiles}\n+  )\n+  target_link_libraries(Catch2SurrogateTarget PRIVATE Catch2WithMain)\n+\n+endif(CATCH_BUILD_SURROGATES)\n+\n ####\n # Temporary workaround for VS toolset changes in 2017\n # We need to disable <UseFullPaths> property, but CMake doesn't support it\n",
        "problem_statement": "Add surrogate TUs for header files\n## Description\r\n\r\nThis PR adds surrogate TUs to test that each header file in the project can be included without depending on other files.\r\n\r\nIn order for the PR to be complete I have to clean the commit history.\r\nAlso 5 files are commented in the CMakeLists.txt of SurrogateCpps since they need to be fixed.\r\n\r\n## GitHub Issues\r\n\r\nCloses #2106\r\n\n",
        "hints_text": "# [Codecov](https://codecov.io/gh/catchorg/Catch2/pull/2166?src=pr&el=h1) Report\n> Merging [#2166](https://codecov.io/gh/catchorg/Catch2/pull/2166?src=pr&el=desc) (4fad45c) into [devel](https://codecov.io/gh/catchorg/Catch2/commit/ba8150516800dd5e18f818346a2a12c45b6ec542?el=desc) (ba81505) will **increase** coverage by `0.04%`.\n> The diff coverage is `n/a`.\n\n```diff\n@@            Coverage Diff             @@\n##            devel    #2166      +/-   ##\n==========================================\n+ Coverage   90.03%   90.07%   +0.04%     \n==========================================\n  Files         146      146              \n  Lines        7089     7110      +21     \n==========================================\n+ Hits         6382     6404      +22     \n+ Misses        707      706       -1     \n```\n\nCleared commit history.\nActually don't do a thing now, this might be an entirely wrong approach \ud83d\ude03 \r\n\r\nI realized that this approach where the surrogate cpp files actually exist on disk add a lot of mechanical overhead to creating new headers, and that we could replace it with generating the surrogate cpp files on-demand. This would move the mechanical work from the developer to a machine, which is much better.\nAt some point, I got bored copy-pasting headers, and I wrote a script to autogenerate the surrogate files. Should I make it generic to autogenerate them based on what exists in the src directory of catch2?",
        "created_at": "2021-02-16T15:26:54Z",
        "version": "3.0"
    }
}