{
    "task_id": "catchorg__Catch2-2855",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2855_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2855,
        "instance_id": "catchorg__Catch2-2855",
        "issue_numbers": [
            "1210"
        ],
        "base_commit": "2bce3e276b5f859ac45c43f011ffed98d0325115",
        "patch": "diff --git a/src/catch2/internal/catch_run_context.cpp b/src/catch2/internal/catch_run_context.cpp\n--- a/src/catch2/internal/catch_run_context.cpp\n+++ b/src/catch2/internal/catch_run_context.cpp\n@@ -450,6 +450,13 @@ namespace Catch {\n         assertionEnded(CATCH_MOVE(result) );\n         resetAssertionInfo();\n \n+        // Best effort cleanup for sections that have not been destructed yet\n+        // Since this is a fatal error, we have not had and won't have the opportunity to destruct them properly\n+        while (!m_activeSections.empty()) {\n+            auto nl = m_activeSections.back()->nameAndLocation();\n+            SectionEndInfo endInfo{ SectionInfo(CATCH_MOVE(nl.location), CATCH_MOVE(nl.name)), {}, 0.0 };\n+            sectionEndedEarly(CATCH_MOVE(endInfo));\n+        }\n         handleUnfinishedSections();\n \n         // Recreate section for test case (as we will lose the one that was in scope)\n",
        "test_patch": "diff --git a/tests/ExtraTests/CMakeLists.txt b/tests/ExtraTests/CMakeLists.txt\n--- a/tests/ExtraTests/CMakeLists.txt\n+++ b/tests/ExtraTests/CMakeLists.txt\n@@ -467,6 +467,18 @@ set_tests_properties(\n     PASS_REGULAR_EXPRESSION \"Errors occurred during startup!\"\n )\n \n+add_executable(ReportingCrashWithJunitReporter ${TESTS_DIR}/X36-ReportingCrashWithJunitReporter.cpp)\n+target_link_libraries(ReportingCrashWithJunitReporter PRIVATE Catch2::Catch2WithMain)\n+add_test(\n+  NAME Reporters::CrashInJunitReporter\n+  COMMAND ${CMAKE_COMMAND} -E env $<TARGET_FILE:ReportingCrashWithJunitReporter> --reporter JUnit\n+)\n+set_tests_properties(\n+    Reporters::CrashInJunitReporter\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"</testsuites>\"\n+    LABELS \"uses-signals\"\n+)\n \n add_executable(AssertionStartingEventGoesBeforeAssertionIsEvaluated\n   X20-AssertionStartingEventGoesBeforeAssertionIsEvaluated.cpp\ndiff --git a/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp b/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ExtraTests/X36-ReportingCrashWithJunitReporter.cpp\n@@ -0,0 +1,32 @@\n+\n+//              Copyright Catch2 Authors\n+// Distributed under the Boost Software License, Version 1.0.\n+//   (See accompanying file LICENSE.txt or copy at\n+//        https://www.boost.org/LICENSE_1_0.txt)\n+\n+// SPDX-License-Identifier: BSL-1.0\n+\n+/**\\file\n+ * Checks that signals/SEH within open section does not hard crash JUnit\n+ * (or similar reporter) while we are trying to report fatal error.\n+ */\n+\n+#include <catch2/catch_test_macros.hpp>\n+\n+#include <csignal>\n+\n+// On Windows we need to send SEH and not signal to test the\n+// RunContext::handleFatalErrorCondition code path\n+#if defined( _MSC_VER )\n+#    include <windows.h>\n+#endif\n+\n+TEST_CASE( \"raises signal\" ) {\n+    SECTION( \"section\" ) {\n+#if defined( _MSC_VER )\n+        RaiseException( 0xC0000005, 0, 0, NULL );\n+#else\n+        std::raise( SIGILL );\n+#endif\n+    }\n+}\ndiff --git a/tools/misc/appveyorTestRunScript.bat b/tools/misc/appveyorTestRunScript.bat\n--- a/tools/misc/appveyorTestRunScript.bat\n+++ b/tools/misc/appveyorTestRunScript.bat\n@@ -5,7 +5,7 @@ reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug\\AutoExclusion\n cd Build\n if \"%CONFIGURATION%\"==\"Debug\" (\n   if \"%coverage%\"==\"1\" (\n-    ctest -j 2 -C %CONFIGURATION% -D ExperimentalMemCheck || exit /b !ERRORLEVEL!\n+    ctest -j 2 -C %CONFIGURATION% -D ExperimentalMemCheck -LE uses-signals || exit /b !ERRORLEVEL!\n     python ..\\tools\\misc\\appveyorMergeCoverageScript.py || exit /b !ERRORLEVEL!\n     codecov --root .. --no-color --disable gcov -f cobertura.xml -t %CODECOV_TOKEN% || exit /b !ERRORLEVEL!\n   ) else (\n",
        "problem_statement": "virtual void Catch::CumulativeReporterBase::testCaseEnded(const Catch::TestCaseStats&):  Assertion `m_sectionStack.size() == 0' failed\n## Description\r\nI am getting this error sometimes in CI.\r\n```\r\ntestd: /build/agent-2/FAL-BS-JOB1/third-party/catch-1.9.3/catch.hpp:9611: \r\nvirtual void Catch::CumulativeReporterBase::testCaseEnded(const Catch::TestCaseStats&): \r\nAssertion `m_sectionStack.size() == 0' failed.\r\n```\r\nRerunning the job fixes the problem.  \r\n\r\nThis was mentioned in a comment to #663.\r\n\r\n### Extra information\r\n* Catch command line options: **-r junit -o testresults.xml**\r\n* Catch version: **v1.9.3**\r\n* Operating System: **RHEL 4.9**\r\n* Compiler+version: **g++ 5.3**\r\n\n",
        "hints_text": "This is happening almost all the time now\nDo you have a reliable repro, or is it still an intermittent thing? The JUnit reporter is ran multiple times on each commit and it doesn't reproduce with our tests, so it's hard to tell what is going on.\nI will work on a repro\nI'm using `-fno-exceptions` and see the same problem; this reproduces the problem for me:\r\na.cpp:\r\n```C++\r\n#define CATCH_CONFIG_MAIN\r\n#include \"catch2/catch.hpp\"\r\n\r\nTEST_CASE(\"doomed\", \"[tag]\") {\r\n\r\n  SECTION(\"only section\") {\r\n    REQUIRE(false);\r\n  }\r\n}\r\n```\r\n    > g++ --version\r\n    g++ (GCC) 7.3.0\r\n    Copyright (C) 2017 Free Software Foundation, Inc.\r\n    This is free software; see the source for copying conditions.  There is NO\r\n    warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n    > g++ -fno-exceptions -I../Catch2/single_include a.cpp\r\n    > ./a.out -r junit\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    terminate called without an active exception\r\n    <testsuitesa.out: ../Catch2/single_include/catch2/catch.hpp:4463: void Catch::CumulativeReporterBase<DerivedT>::testCaseEnded(const Catch::TestCaseStats&) [with DerivedT = Catch::JunitReporter]: Assertion `m_sectionStack.size() == 0' failed.\r\n    Aborted (core dumped)\r\n\n@sd-x That's actually quite useful, thanks.\nSeeing this also in my CI sometimes.\r\n\nI'm seeing this pretty regularly, but not 100% consistently, on our windows builds. We don't have exceptions disabled or anything. Is the recommended workaround to stop using SECTIONs?\r\n\r\nfor reference, also using junit. seems to be a common factor in these reports.\nOur GitLab CI just ran into the same or a very similar issue, the exact assertion error in our case is\r\n```\r\nAssertion failed: m_sectionStack.size() == 0, file catch.hpp, line 5859\r\n```\r\n\r\nWe are also running on Windows and using the JUnit reporter. Catch version v2.11.1, MSVC 16.5. The issue disappeared after rerunning.\nProbably I found one possible scenario, why it could happen #1967 \r\n\nMy problem was that I was dividing by zero which crashed on my Linux CI but did not crash on my macOS dev machine. A working stacktrace from Catch would have saved me 30 minutes of printf debugging!\nI am not too familiar with catch internals but here is what I assume is happening\r\n\r\nIn `RunContext::handleFatalErrorCondition`, `handleUnfinishedSections()`  is called:\r\nhttps://github.com/catchorg/Catch2/blob/029fe3b4609dd84cd939b73357f37bbb75bcf82f/src/catch2/internal/catch_run_context.cpp#L453\r\n\r\nIf I understand it correctly, running Sections are in `m_activeSections`, and when a Section's destructor is called with an active exception, that Section is moved to `m_unfinishedSections`. `handleUnfinishedSections()` then handles those Sections in `m_unfinishedSections`. However, if a signal is being handled, we have not and will not call the destructors for the Sections, which means, all those Sections are in `m_activeSections` and not `m_unfinishedSections`.\r\n\r\nMy (potentially very dirty) fix is the following before the call to `handleUnfinishedSections()`:\r\n```c++\r\nwhile (!m_activeSections.empty()) {\r\n    auto nl = m_activeSections.back()->nameAndLocation();\r\n    SectionEndInfo endInfo{ SectionInfo(nl.location, nl.name), {}, 0.0 };\r\n    sectionEndedEarly(CATCH_MOVE(endInfo));\r\n}\r\nhandleUnfinishedSections();\r\n```\r\n\r\nI move the Sections from `m_activeSections` to `m_unfinishedSections` in a best effort way as to not trigger the assertion later.\r\n\r\nBtw, here is a test case that reproduces the issue for me (with `--reporter JUnit`):\r\n```c++\r\nTEST_CASE(\"broken\") {\r\n   SECTION(\"section\") {\r\n      /// Use illegal cpu instruction\r\n      __asm__ __volatile__(\"ud2\" : : : \"memory\");\r\n   }\r\n}\r\n```\r\n\r\n",
        "created_at": "2024-04-15T11:26:37Z",
        "version": "3.5"
    }
}