{
    "task_id": "catchorg__Catch2-2394",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2394_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2394,
        "instance_id": "catchorg__Catch2-2394",
        "issue_numbers": [
            "2304"
        ],
        "base_commit": "1a8a793178d50b74b0f9a0adb3eec937b61039a9",
        "patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -157,6 +157,7 @@ set(INTERNAL_HEADERS\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.hpp\n     ${SOURCES_DIR}/internal/catch_windows_h_proxy.hpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.hpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.hpp\n )\n set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_approx.cpp\n@@ -213,6 +214,7 @@ set(IMPL_SOURCES\n     ${SOURCES_DIR}/catch_version.cpp\n     ${SOURCES_DIR}/internal/catch_wildcard_pattern.cpp\n     ${SOURCES_DIR}/internal/catch_xmlwriter.cpp\n+    ${SOURCES_DIR}/internal/catch_test_case_info_hasher.cpp\n )\n set(INTERNAL_FILES ${IMPL_SOURCES} ${INTERNAL_HEADERS})\n \ndiff --git a/src/catch2/catch_all.hpp b/src/catch2/catch_all.hpp\n--- a/src/catch2/catch_all.hpp\n+++ b/src/catch2/catch_all.hpp\n@@ -95,6 +95,7 @@\n #include <catch2/internal/catch_stringref.hpp>\n #include <catch2/internal/catch_tag_alias_registry.hpp>\n #include <catch2/internal/catch_template_test_registry.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n #include <catch2/internal/catch_test_case_registry_impl.hpp>\n #include <catch2/internal/catch_test_case_tracker.hpp>\n #include <catch2/internal/catch_test_failure_exception.hpp>\n",
        "test_patch": "diff --git a/src/catch2/internal/catch_test_case_info_hasher.cpp b/src/catch2/internal/catch_test_case_info_hasher.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.cpp\n@@ -0,0 +1,31 @@\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+namespace Catch {\n+    TestCaseInfoHasher::TestCaseInfoHasher( hash_t seed ): m_seed( seed ) {}\n+\n+    uint32_t TestCaseInfoHasher::operator()( TestCaseInfo const& t ) const {\n+        // FNV-1a hash algorithm that is designed for uniqueness:\n+        const hash_t prime = 1099511628211u;\n+        hash_t hash = 14695981039346656037u;\n+        for ( const char c : t.name ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const char c : t.className ) {\n+            hash ^= c;\n+            hash *= prime;\n+        }\n+        for ( const Tag& tag : t.tags ) {\n+            for ( const char c : tag.original ) {\n+                hash ^= c;\n+                hash *= prime;\n+            }\n+        }\n+        hash ^= m_seed;\n+        hash *= prime;\n+        const uint32_t low{ static_cast<uint32_t>( hash ) };\n+        const uint32_t high{ static_cast<uint32_t>( hash >> 32 ) };\n+        return low * high;\n+    }\n+} // namespace Catch\ndiff --git a/src/catch2/internal/catch_test_case_info_hasher.hpp b/src/catch2/internal/catch_test_case_info_hasher.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/src/catch2/internal/catch_test_case_info_hasher.hpp\n@@ -0,0 +1,22 @@\n+#ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED\n+\n+#include <cstdint>\n+\n+namespace Catch {\n+\n+    struct TestCaseInfo;\n+\n+    class TestCaseInfoHasher {\n+    public:\n+        using hash_t = std::uint64_t;\n+        TestCaseInfoHasher( hash_t seed );\n+        uint32_t operator()( TestCaseInfo const& t ) const;\n+\n+    private:\n+        hash_t m_seed;\n+    };\n+\n+} // namespace Catch\n+\n+#endif /* CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED */\ndiff --git a/src/catch2/internal/catch_test_case_registry_impl.cpp b/src/catch2/internal/catch_test_case_registry_impl.cpp\n--- a/src/catch2/internal/catch_test_case_registry_impl.cpp\n+++ b/src/catch2/internal/catch_test_case_registry_impl.cpp\n@@ -16,38 +16,13 @@\n #include <catch2/catch_test_case_info.hpp>\n #include <catch2/catch_test_spec.hpp>\n #include <catch2/internal/catch_move_and_forward.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n \n #include <algorithm>\n #include <set>\n \n namespace Catch {\n \n-namespace {\n-    struct TestHasher {\n-        using hash_t = uint64_t;\n-\n-        explicit TestHasher( hash_t hashSuffix ):\n-            m_hashSuffix( hashSuffix ) {}\n-\n-        uint64_t m_hashSuffix;\n-\n-        uint32_t operator()( TestCaseInfo const& t ) const {\n-            // FNV-1a hash with multiplication fold.\n-            const hash_t prime = 1099511628211u;\n-            hash_t hash = 14695981039346656037u;\n-            for (const char c : t.name) {\n-                hash ^= c;\n-                hash *= prime;\n-            }\n-            hash ^= m_hashSuffix;\n-            hash *= prime;\n-            const uint32_t low{ static_cast<uint32_t>(hash) };\n-            const uint32_t high{ static_cast<uint32_t>(hash >> 32) };\n-            return low * high;\n-        }\n-    };\n-} // end anonymous namespace\n-\n     std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases ) {\n         switch (config.runOrder()) {\n         case TestRunOrder::Declared:\n@@ -66,9 +41,9 @@ namespace {\n         }\n         case TestRunOrder::Randomized: {\n             seedRng(config);\n-            using TestWithHash = std::pair<TestHasher::hash_t, TestCaseHandle>;\n+            using TestWithHash = std::pair<TestCaseInfoHasher::hash_t, TestCaseHandle>;\n \n-            TestHasher h{ config.rngSeed() };\n+            TestCaseInfoHasher h{ config.rngSeed() };\n             std::vector<TestWithHash> indexed_tests;\n             indexed_tests.reserve(unsortedTestCases.size());\n \ndiff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt\n--- a/tests/CMakeLists.txt\n+++ b/tests/CMakeLists.txt\n@@ -88,6 +88,7 @@ set(TEST_SOURCES\n         ${SELF_TEST_DIR}/IntrospectiveTests/RandomNumberGeneration.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Reporters.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Tag.tests.cpp\n+        ${SELF_TEST_DIR}/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TestSpecParser.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/TextFlow.tests.cpp\n         ${SELF_TEST_DIR}/IntrospectiveTests/Sharding.tests.cpp\ndiff --git a/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/SelfTest/IntrospectiveTests/TestCaseInfoHasher.tests.cpp\n@@ -0,0 +1,51 @@\n+#include <catch2/catch_test_macros.hpp>\n+#include <catch2/catch_test_case_info.hpp>\n+#include <catch2/internal/catch_test_case_info_hasher.hpp>\n+\n+static constexpr Catch::SourceLineInfo dummySourceLineInfo = CATCH_INTERNAL_LINEINFO;\n+\n+TEST_CASE( \"TestCaseInfoHasher produces equal hashes.\" ) {\n+    SECTION( \"class names and names and tags are equal.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) == hasherWithCustomSeed(testCase2));\n+    }\n+}\n+\n+TEST_CASE( \"TestCaseInfoHasher produces different hashes.\" ) {\n+    SECTION( \"class names are equal, names are equal but tags are different.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag2]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names are equal, tags are equal but names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name1\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name2\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"names are equal, tags are equal but class names are different\" ) {\n+        Catch::TestCaseInfo testCase1(\"class1\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"class2\", {\"name\", \"[.magic-tag]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher hasherWithCustomSeed(123456789u);\n+        CHECK(hasherWithCustomSeed(testCase1) != hasherWithCustomSeed(testCase2));\n+    }\n+\n+    SECTION( \"class names and names and tags are equal but hashers are seeded differently.\" ) {\n+        Catch::TestCaseInfo testCase1(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+        Catch::TestCaseInfo testCase2(\"\", {\"name\", \"[.magic-tag1]\"}, dummySourceLineInfo);\n+\n+        Catch::TestCaseInfoHasher h1(14695981039346656037u);\n+        Catch::TestCaseInfoHasher h2(14695981039346656038u);\n+\n+        CHECK(h1(testCase1) != h2(testCase2));\n+    }\n+}\n",
        "problem_statement": "Test case name hashing should consider tags and class name too\n**Describe the bug**\r\nRecently I changed the \"unique test case\" criteria to allow test cases with same name, but different tags, or same names and tags but different class name (when a test case hangs off a type).\r\n\r\nHowever, we also hash test cases when ordering them randomly (to get subset-stable ordering), and the hashing currently only considers test case name, which means that hash collisions are now much more realistic (in fact the collision is guaranteed if two test cases have same name, which is a desired property by some users).\r\n\r\n_Note that this doesn't break the subset invariant, because we use the ordering of test case infos to break ties, which handles tags and class name properly_\r\n\r\n**Expected behavior**\r\nTo fix this, the hasher should also consider tags and class name.\r\n\r\n**Additional context**\r\nThis change also makes the hasher complex enough that it should be promoted to a header and receive direct unit tests.\n",
        "hints_text": "I am happy to work on this.\n@MohamedAlaa201 Sure, go for it.",
        "created_at": "2022-03-18T19:32:21Z",
        "version": "3.0"
    }
}