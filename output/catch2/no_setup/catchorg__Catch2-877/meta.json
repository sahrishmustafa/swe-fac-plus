{
    "task_id": "catchorg__Catch2-877",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-877_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 877,
        "instance_id": "catchorg__Catch2-877",
        "issue_numbers": [
            "872"
        ],
        "base_commit": "0354d50278d725d52084601300eb955cee6756d8",
        "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -72,6 +72,7 @@ namespace Detail {\n \n     extern const std::string unprintableString;\n \n+ #if !defined(CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)\n     struct BorgType {\n         template<typename T> BorgType( T const& );\n     };\n@@ -90,6 +91,20 @@ namespace Detail {\n         static T  const&t;\n         enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };\n     };\n+#else\n+    template<typename T>\n+    class IsStreamInsertable {\n+        template<typename SS, typename TT>\n+        static auto test(int)\n+        -> decltype( std::declval<SS&>() << std::declval<TT>(), std::true_type() );\n+\n+        template<typename, typename>\n+        static auto test(...) -> std::false_type;\n+\n+    public:\n+        static const bool value = decltype(test<std::ostream,const T&>(0))::value;\n+    };\n+#endif\n \n #if defined(CATCH_CONFIG_CPP11_IS_ENUM)\n     template<typename T,\n",
        "test_patch": "diff --git a/projects/SelfTest/CompilationTests.cpp b/projects/SelfTest/CompilationTests.cpp\n--- a/projects/SelfTest/CompilationTests.cpp\n+++ b/projects/SelfTest/CompilationTests.cpp\n@@ -51,3 +51,22 @@ TEST_CASE(\"#833\") {\n     REQUIRE(templated_tests<int>(3));\n }\n \n+// Test containing example where original stream insertable check breaks compilation\n+#if defined (CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)\n+namespace {\n+    struct A {};\n+    std::ostream& operator<< (std::ostream &o, const A &) { return o << 0; }\n+\n+    struct B : private A {\n+        bool operator== (int) const { return true; }\n+    };\n+\n+    B f ();\n+    std::ostream g ();\n+}\n+\n+TEST_CASE( \"#872\" ) {\n+    B x;\n+    REQUIRE (x == 4);\n+}\n+#endif\n",
        "problem_statement": "Compilation error when private base of class of tested variable is \"ostreamable\" but class itself isn't\n## Description\r\nWhen private base of class of tested variable is \"ostreamable\" but class itself isn't test code fails to compile.\r\n\r\n### Steps to reproduce\r\n```\r\n#define CATCH_CONFIG_MAIN\r\n#include <catch.hpp>\r\nstruct A {};\r\nstd::ostream &operator<< (std::ostream &o, const A &v) { return o << 0;}\r\n\r\nstruct B : private A\r\n{\r\n    bool operator==(int){ return true;}\r\n};\r\n\r\nB f ();\r\nstd::ostream g ();\r\n\r\nTEST_CASE (\"asdas\")\r\n{\r\n    B x;\r\n    REQUIRE (x == 4);\r\n}\r\n\r\n```\r\n\r\n>main.cpp:1579:49: error: 'A' is an inaccessible base of 'B'\r\n>         enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };\r\n\r\nSo the problem is in `IsStreamInsertable` check which features converting type to some bogus stremable type named `Borgtype` which everything converts to but it's pretty obvious that converting to your base class is still easier and thus error happens. It seems like replacing this check to the one featured in [this stackoverflow answer](http://stackoverflow.com/a/22759544/1269661) fixes this problem. I can send pull-request if that's needed and proposed solution is fine.\r\n\r\n### Extra information\r\n* Catch version: 1.8.2\r\n* Operating System: Windows + online compilers\r\n* Compiler+version: g++ 6.3.0, clang 3.8, MSVC 2017\r\n\n",
        "hints_text": "Thanks for bringing this up, @Predelnik. We haven't had an `IsStreamInsertable` issue for a while.\r\nThat SO answer is interesting. It can't be used as-is as it relies on (quite a few, actually) C++11 features - and Catch (1.x, at least) needs to keep working on pre-C++11 compilers.\r\nBut if the approach there is genuinely better we could do something conditionally (and would also be useful for Catch2 - which will assume C++11).\r\nThe \"genuinely better\" qualification is there because I know from looking at this before that every technique I investigated had one trade-off or another. That was a few years ago and I don't recall seeing anything like this one - so maybe it's better? But I'd like to see it more road tested before I switch it in by default (even for C++11 compilers) as if it has different trade-offs to the current approach then it will break currently working code.\r\n\r\nSo I think a starting point is to include it as an \"opt-in\" alternative.\r\n\r\nIf you're happy to put together a PR for that I'd be grateful. Otherwise I'll try and get to it myself in the near future (but not this week).\r\n",
        "created_at": "2017-04-02T11:09:42Z",
        "version": "1.8"
    }
}