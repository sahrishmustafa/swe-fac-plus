{
    "task_id": "catchorg__Catch2-1684",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-1684_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 1684,
        "instance_id": "catchorg__Catch2-1684",
        "issue_numbers": [
            "1449",
            "1683"
        ],
        "base_commit": "fb74bb133ccc8b1bbf932071f3db039861dea73a",
        "patch": "diff --git a/include/internal/catch_session.cpp b/include/internal/catch_session.cpp\n--- a/include/internal/catch_session.cpp\n+++ b/include/internal/catch_session.cpp\n@@ -25,6 +25,8 @@\n \n #include <cstdlib>\n #include <iomanip>\n+#include <set>\n+#include <iterator>\n \n namespace Catch {\n \n@@ -58,46 +60,53 @@ namespace Catch {\n             return ret;\n         }\n \n-\n-        Catch::Totals runTests(std::shared_ptr<Config> const& config) {\n-            auto reporter = makeReporter(config);\n-\n-            RunContext context(config, std::move(reporter));\n-\n-            Totals totals;\n-\n-            context.testGroupStarting(config->name(), 1, 1);\n-\n-            TestSpec testSpec = config->testSpec();\n-\n-            auto const& allTestCases = getAllTestCasesSorted(*config);\n-            for (auto const& testCase : allTestCases) {\n-                bool matching = (!testSpec.hasFilters() && !testCase.isHidden()) ||\n-                                 (testSpec.hasFilters() && matchTest(testCase, testSpec, *config));\n-\n-                if (!context.aborting() && matching)\n-                    totals += context.runTest(testCase);\n-                else\n-                    context.reporter().skipTest(testCase);\n+        class TestGroup {\n+        public:\n+            explicit TestGroup(std::shared_ptr<Config> const& config)\n+            : m_config{config}\n+            , m_context{config, makeReporter(config)}\n+            {\n+                auto const& allTestCases = getAllTestCasesSorted(*m_config);\n+                m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);\n+\n+                if (m_matches.empty()) {\n+                    for (auto const& test : allTestCases)\n+                        if (!test.isHidden())\n+                            m_tests.emplace(&test);\n+                } else {\n+                    for (auto const& match : m_matches)\n+                        m_tests.insert(match.tests.begin(), match.tests.end());\n+                }\n             }\n \n-            if (config->warnAboutNoTests() && totals.testCases.total() == 0) {\n-                ReusableStringStream testConfig;\n-\n-                bool first = true;\n-                for (const auto& input : config->getTestsOrTags()) {\n-                    if (!first) { testConfig << ' '; }\n-                    first = false;\n-                    testConfig << input;\n+            Totals execute() {\n+                Totals totals;\n+                m_context.testGroupStarting(m_config->name(), 1, 1);\n+                for (auto const& testCase : m_tests) {\n+                    if (!m_context.aborting())\n+                        totals += m_context.runTest(*testCase);\n+                    else\n+                        m_context.reporter().skipTest(*testCase);\n                 }\n \n-                context.reporter().noMatchingTestCases(testConfig.str());\n-                totals.error = -1;\n+                for (auto const& match : m_matches) {\n+                    if (match.tests.empty()) {\n+                        m_context.reporter().noMatchingTestCases(match.name);\n+                        totals.error = -1;\n+                    }\n+                }\n+                m_context.testGroupEnded(m_config->name(), totals, 1, 1);\n+                return totals;\n             }\n \n-            context.testGroupEnded(config->name(), totals, 1, 1);\n-            return totals;\n-        }\n+        private:\n+            using Tests = std::set<TestCase const*>;\n+\n+            std::shared_ptr<Config> m_config;\n+            RunContext m_context;\n+            Tests m_tests;\n+            TestSpec::Matches m_matches;\n+        };\n \n         void applyFilenamesAsTags(Catch::IConfig const& config) {\n             auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));\n@@ -274,7 +283,12 @@ namespace Catch {\n             if( Option<std::size_t> listed = list( m_config ) )\n                 return static_cast<int>( *listed );\n \n-            auto totals = runTests( m_config );\n+            TestGroup tests { m_config };\n+            auto const totals = tests.execute();\n+\n+            if( m_config->warnAboutNoTests() && totals.error == -1 )\n+                return 2;\n+\n             // Note that on unices only the lower 8 bits are usually used, clamping\n             // the return value to 255 prevents false negative when some multiple\n             // of 256 tests has failed\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -393,8 +393,19 @@ set_tests_properties(ListTestNamesOnly PROPERTIES\n add_test(NAME NoAssertions COMMAND $<TARGET_FILE:SelfTest> -w NoAssertions)\n set_tests_properties(NoAssertions PROPERTIES PASS_REGULAR_EXPRESSION \"No assertions in test case\")\n \n-add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> -w NoTests \"___nonexistent_test___\")\n-set_tests_properties(NoTest PROPERTIES PASS_REGULAR_EXPRESSION \"No test cases matched\")\n+add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> Tracker, \"___nonexistent_test___\")\n+set_tests_properties(NoTest PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"No test cases matched '___nonexistent_test___'\"\n+    FAIL_REGULAR_EXPRESSION \"No tests ran\"\n+)\n+\n+add_test(NAME WarnAboutNoTests COMMAND ${CMAKE_COMMAND} -P ${CATCH_DIR}/projects/SelfTest/WarnAboutNoTests.cmake $<TARGET_FILE:SelfTest>)\n+\n+add_test(NAME UnmatchedOutputFilter COMMAND $<TARGET_FILE:SelfTest> [this-tag-does-not-exist] -w NoTests)\n+set_tests_properties(UnmatchedOutputFilter\n+  PROPERTIES\n+    PASS_REGULAR_EXPRESSION \"No test cases matched '\\\\[this-tag-does-not-exist\\\\]'\"\n+)\n \n add_test(NAME FilteredSection-1 COMMAND $<TARGET_FILE:SelfTest> \\#1394 -c RunSection)\n set_tests_properties(FilteredSection-1 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n",
        "test_patch": "diff --git a/include/internal/catch_interfaces_testcase.h b/include/internal/catch_interfaces_testcase.h\n--- a/include/internal/catch_interfaces_testcase.h\n+++ b/include/internal/catch_interfaces_testcase.h\n@@ -28,6 +28,7 @@ namespace Catch {\n         virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;\n     };\n \n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n     std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );\n     std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );\ndiff --git a/include/internal/catch_test_case_registry_impl.cpp b/include/internal/catch_test_case_registry_impl.cpp\n--- a/include/internal/catch_test_case_registry_impl.cpp\n+++ b/include/internal/catch_test_case_registry_impl.cpp\n@@ -36,8 +36,13 @@ namespace Catch {\n         }\n         return sorted;\n     }\n+\n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config ) {\n+        return !testCase.throws() || config.allowThrows();\n+    }\n+\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {\n-        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );\n+        return testSpec.matches( testCase ) && isThrowSafe( testCase, config );\n     }\n \n     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {\ndiff --git a/include/internal/catch_test_case_registry_impl.h b/include/internal/catch_test_case_registry_impl.h\n--- a/include/internal/catch_test_case_registry_impl.h\n+++ b/include/internal/catch_test_case_registry_impl.h\n@@ -23,6 +23,8 @@ namespace Catch {\n     struct IConfig;\n \n     std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );\n+\n+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );\n     bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );\n \n     void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );\ndiff --git a/include/internal/catch_test_spec.cpp b/include/internal/catch_test_spec.cpp\n--- a/include/internal/catch_test_spec.cpp\n+++ b/include/internal/catch_test_spec.cpp\n@@ -7,6 +7,7 @@\n \n #include \"catch_test_spec.h\"\n #include \"catch_string_manip.h\"\n+#include \"catch_interfaces_config.h\"\n \n #include <algorithm>\n #include <string>\n@@ -15,45 +16,80 @@\n \n namespace Catch {\n \n+    TestSpec::Pattern::Pattern( std::string const& name )\n+    : m_name( name )\n+    {}\n+\n     TestSpec::Pattern::~Pattern() = default;\n-    TestSpec::NamePattern::~NamePattern() = default;\n-    TestSpec::TagPattern::~TagPattern() = default;\n-    TestSpec::ExcludedPattern::~ExcludedPattern() = default;\n \n-    TestSpec::NamePattern::NamePattern( std::string const& name )\n-    : m_wildcardPattern( toLower( name ), CaseSensitive::No )\n+    std::string const& TestSpec::Pattern::name() const {\n+        return m_name;\n+    }\n+\n+\n+    TestSpec::NamePattern::NamePattern( std::string const& name, std::string const& filterString )\n+    : Pattern( filterString )\n+    , m_wildcardPattern( toLower( name ), CaseSensitive::No )\n     {}\n+\n     bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {\n         return m_wildcardPattern.matches( toLower( testCase.name ) );\n     }\n \n-    TestSpec::TagPattern::TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}\n+\n+    TestSpec::TagPattern::TagPattern( std::string const& tag, std::string const& filterString )\n+    : Pattern( filterString )\n+    , m_tag( toLower( tag ) )\n+    {}\n+\n     bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {\n         return std::find(begin(testCase.lcaseTags),\n                          end(testCase.lcaseTags),\n                          m_tag) != end(testCase.lcaseTags);\n     }\n \n-    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}\n-    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }\n+\n+    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern )\n+    : Pattern( underlyingPattern->name() )\n+    , m_underlyingPattern( underlyingPattern )\n+    {}\n+\n+    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const {\n+        return !m_underlyingPattern->matches( testCase );\n+    }\n+\n \n     bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {\n-        // All patterns in a filter must match for the filter to be a match\n-        for( auto const& pattern : m_patterns ) {\n-            if( !pattern->matches( testCase ) )\n-                return false;\n-        }\n-        return true;\n+        return std::all_of( m_patterns.begin(), m_patterns.end(), [&]( PatternPtr const& p ){ return p->matches( testCase ); } );\n+    }\n+\n+    std::string TestSpec::Filter::name() const {\n+        std::string name;\n+        for( auto const& p : m_patterns )\n+            name += p->name();\n+        return name;\n     }\n \n+\n     bool TestSpec::hasFilters() const {\n         return !m_filters.empty();\n     }\n+\n     bool TestSpec::matches( TestCaseInfo const& testCase ) const {\n-        // A TestSpec matches if any filter matches\n-        for( auto const& filter : m_filters )\n-            if( filter.matches( testCase ) )\n-                return true;\n-        return false;\n+        return std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter const& f ){ return f.matches( testCase ); } );\n     }\n+\n+    TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const\n+    {\n+        Matches matches( m_filters.size() );\n+        std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&]( Filter const& filter ){\n+            std::vector<TestCase const*> currentMatches;\n+            for( auto const& test : testCases )\n+                if( isThrowSafe( test, config ) && filter.matches( test ) )\n+                    currentMatches.emplace_back( &test );\n+            return FilterMatch{ filter.name(), currentMatches };\n+        } );\n+        return matches;\n+    }\n+\n }\ndiff --git a/include/internal/catch_test_spec.h b/include/internal/catch_test_spec.h\n--- a/include/internal/catch_test_spec.h\n+++ b/include/internal/catch_test_spec.h\n@@ -22,17 +22,23 @@\n \n namespace Catch {\n \n+    struct IConfig;\n+\n     class TestSpec {\n-        struct Pattern {\n+        class Pattern {\n+        public:\n+            explicit Pattern( std::string const& name );\n             virtual ~Pattern();\n             virtual bool matches( TestCaseInfo const& testCase ) const = 0;\n+            std::string const& name() const;\n+        private:\n+            std::string const m_name;\n         };\n         using PatternPtr = std::shared_ptr<Pattern>;\n \n         class NamePattern : public Pattern {\n         public:\n-            NamePattern( std::string const& name );\n-            virtual ~NamePattern();\n+            explicit NamePattern( std::string const& name, std::string const& filterString );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             WildcardPattern m_wildcardPattern;\n@@ -40,8 +46,7 @@ namespace Catch {\n \n         class TagPattern : public Pattern {\n         public:\n-            TagPattern( std::string const& tag );\n-            virtual ~TagPattern();\n+            explicit TagPattern( std::string const& tag, std::string const& filterString );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             std::string m_tag;\n@@ -49,8 +54,7 @@ namespace Catch {\n \n         class ExcludedPattern : public Pattern {\n         public:\n-            ExcludedPattern( PatternPtr const& underlyingPattern );\n-            virtual ~ExcludedPattern();\n+            explicit ExcludedPattern( PatternPtr const& underlyingPattern );\n             bool matches( TestCaseInfo const& testCase ) const override;\n         private:\n             PatternPtr m_underlyingPattern;\n@@ -60,11 +64,19 @@ namespace Catch {\n             std::vector<PatternPtr> m_patterns;\n \n             bool matches( TestCaseInfo const& testCase ) const;\n+            std::string name() const;\n         };\n \n     public:\n+        struct FilterMatch {\n+            std::string name;\n+            std::vector<TestCase const*> tests;\n+        };\n+        using Matches = std::vector<FilterMatch>;\n+\n         bool hasFilters() const;\n         bool matches( TestCaseInfo const& testCase ) const;\n+        Matches matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const;\n \n     private:\n         std::vector<Filter> m_filters;\ndiff --git a/include/internal/catch_test_spec_parser.cpp b/include/internal/catch_test_spec_parser.cpp\n--- a/include/internal/catch_test_spec_parser.cpp\n+++ b/include/internal/catch_test_spec_parser.cpp\n@@ -14,64 +14,125 @@ namespace Catch {\n     TestSpecParser& TestSpecParser::parse( std::string const& arg ) {\n         m_mode = None;\n         m_exclusion = false;\n-        m_start = std::string::npos;\n         m_arg = m_tagAliases->expandAliases( arg );\n         m_escapeChars.clear();\n+        m_substring.reserve(m_arg.size());\n+        m_patternName.reserve(m_arg.size());\n         for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\n             visitChar( m_arg[m_pos] );\n-        if( m_mode == Name )\n-            addPattern<TestSpec::NamePattern>();\n+        endMode();\n         return *this;\n     }\n     TestSpec TestSpecParser::testSpec() {\n         addFilter();\n         return m_testSpec;\n     }\n-\n     void TestSpecParser::visitChar( char c ) {\n-        if( m_mode == None ) {\n-            switch( c ) {\n-            case ' ': return;\n-            case '~': m_exclusion = true; return;\n-            case '[': return startNewMode( Tag, ++m_pos );\n-            case '\"': return startNewMode( QuotedName, ++m_pos );\n-            case '\\\\': return escape();\n-            default: startNewMode( Name, m_pos ); break;\n-            }\n+        if( c == ',' ) {\n+            endMode();\n+            addFilter();\n+            return;\n+        }\n+\n+        switch( m_mode ) {\n+        case None:\n+            if( processNoneChar( c ) )\n+                return;\n+            break;\n+        case Name:\n+            processNameChar( c );\n+            break;\n+        case EscapedName:\n+            endMode();\n+            break;\n+        default:\n+        case Tag:\n+        case QuotedName:\n+            if( processOtherChar( c ) )\n+                return;\n+            break;\n+        }\n+\n+        m_substring += c;\n+        if( !isControlChar( c ) )\n+            m_patternName += c;\n+    }\n+    // Two of the processing methods return true to signal the caller to return\n+    // without adding the given character to the current pattern strings\n+    bool TestSpecParser::processNoneChar( char c ) {\n+        switch( c ) {\n+        case ' ':\n+            return true;\n+        case '~':\n+            m_exclusion = true;\n+            return false;\n+        case '[':\n+            startNewMode( Tag );\n+            return false;\n+        case '\"':\n+            startNewMode( QuotedName );\n+            return false;\n+        case '\\\\':\n+            escape();\n+            return true;\n+        default:\n+            startNewMode( Name );\n+            return false;\n         }\n-        if( m_mode == Name ) {\n-            if( c == ',' ) {\n-                addPattern<TestSpec::NamePattern>();\n-                addFilter();\n-            }\n-            else if( c == '[' ) {\n-                if( subString() == \"exclude:\" )\n-                    m_exclusion = true;\n-                else\n-                    addPattern<TestSpec::NamePattern>();\n-                startNewMode( Tag, ++m_pos );\n-            }\n-            else if( c == '\\\\' )\n-                escape();\n+    }\n+    void TestSpecParser::processNameChar( char c ) {\n+        if( c == '[' ) {\n+            if( m_substring == \"exclude:\" )\n+                m_exclusion = true;\n+            else\n+                endMode();\n+            startNewMode( Tag );\n         }\n-        else if( m_mode == EscapedName )\n-            m_mode = Name;\n-        else if( m_mode == QuotedName && c == '\"' )\n-            addPattern<TestSpec::NamePattern>();\n-        else if( m_mode == Tag && c == ']' )\n-            addPattern<TestSpec::TagPattern>();\n     }\n-    void TestSpecParser::startNewMode( Mode mode, std::size_t start ) {\n+    bool TestSpecParser::processOtherChar( char c ) {\n+        if( !isControlChar( c ) )\n+            return false;\n+        m_substring += c;\n+        endMode();\n+        return true;\n+    }\n+    void TestSpecParser::startNewMode( Mode mode ) {\n         m_mode = mode;\n-        m_start = start;\n+    }\n+    void TestSpecParser::endMode() {\n+        switch( m_mode ) {\n+        case Name:\n+        case QuotedName:\n+            return addPattern<TestSpec::NamePattern>();\n+        case Tag:\n+            return addPattern<TestSpec::TagPattern>();\n+        case EscapedName:\n+            return startNewMode( Name );\n+        case None:\n+        default:\n+            return startNewMode( None );\n+        }\n     }\n     void TestSpecParser::escape() {\n-        if( m_mode == None )\n-            m_start = m_pos;\n         m_mode = EscapedName;\n         m_escapeChars.push_back( m_pos );\n     }\n-    std::string TestSpecParser::subString() const { return m_arg.substr( m_start, m_pos - m_start ); }\n+    bool TestSpecParser::isControlChar( char c ) const {\n+        switch( m_mode ) {\n+            default:\n+                return false;\n+            case None:\n+                return c == '~';\n+            case Name:\n+                return c == '[';\n+            case EscapedName:\n+                return true;\n+            case QuotedName:\n+                return c == '\"';\n+            case Tag:\n+                return c == '[' || c == ']';\n+        }\n+    }\n \n     void TestSpecParser::addFilter() {\n         if( !m_currentFilter.m_patterns.empty() ) {\ndiff --git a/include/internal/catch_test_spec_parser.h b/include/internal/catch_test_spec_parser.h\n--- a/include/internal/catch_test_spec_parser.h\n+++ b/include/internal/catch_test_spec_parser.h\n@@ -23,8 +23,10 @@ namespace Catch {\n         enum Mode{ None, Name, QuotedName, Tag, EscapedName };\n         Mode m_mode = None;\n         bool m_exclusion = false;\n-        std::size_t m_start = std::string::npos, m_pos = 0;\n+        std::size_t m_pos = 0;\n         std::string m_arg;\n+        std::string m_substring;\n+        std::string m_patternName;\n         std::vector<std::size_t> m_escapeChars;\n         TestSpec::Filter m_currentFilter;\n         TestSpec m_testSpec;\n@@ -38,26 +40,32 @@ namespace Catch {\n \n     private:\n         void visitChar( char c );\n-        void startNewMode( Mode mode, std::size_t start );\n+        void startNewMode( Mode mode );\n+        bool processNoneChar( char c );\n+        void processNameChar( char c );\n+        bool processOtherChar( char c );\n+        void endMode();\n         void escape();\n-        std::string subString() const;\n+        bool isControlChar( char c ) const;\n \n         template<typename T>\n         void addPattern() {\n-            std::string token = subString();\n+            std::string token = m_patternName;\n             for( std::size_t i = 0; i < m_escapeChars.size(); ++i )\n-                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );\n+                token = token.substr( 0, m_escapeChars[i] - i ) + token.substr( m_escapeChars[i] -i +1 );\n             m_escapeChars.clear();\n             if( startsWith( token, \"exclude:\" ) ) {\n                 m_exclusion = true;\n                 token = token.substr( 8 );\n             }\n             if( !token.empty() ) {\n-                TestSpec::PatternPtr pattern = std::make_shared<T>( token );\n+                TestSpec::PatternPtr pattern = std::make_shared<T>( token, m_substring );\n                 if( m_exclusion )\n                     pattern = std::make_shared<TestSpec::ExcludedPattern>( pattern );\n                 m_currentFilter.m_patterns.push_back( pattern );\n             }\n+            m_substring.clear();\n+            m_patternName.clear();\n             m_exclusion = false;\n             m_mode = None;\n         }\ndiff --git a/projects/SelfTest/WarnAboutNoTests.cmake b/projects/SelfTest/WarnAboutNoTests.cmake\nnew file mode 100644\n--- /dev/null\n+++ b/projects/SelfTest/WarnAboutNoTests.cmake\n@@ -0,0 +1,19 @@\n+# Workaround for a peculiarity where CTest disregards the return code from a\n+# test command if a PASS_REGULAR_EXPRESSION is also set\n+execute_process(\n+    COMMAND ${CMAKE_ARGV3} -w NoTests \"___nonexistent_test___\"\n+    RESULT_VARIABLE ret\n+    OUTPUT_VARIABLE out\n+)\n+\n+message(\"${out}\")\n+\n+if(NOT ${ret} MATCHES \"^[0-9]+$\")\n+    message(FATAL_ERROR \"${ret}\")\n+endif()\n+\n+if(${ret} EQUAL 0)\n+    message(FATAL_ERROR \"Expected nonzero return code\")\n+elseif(${out} MATCHES \"Helper failed with\")\n+    message(FATAL_ERROR \"Helper failed\")\n+endif()\n",
        "problem_statement": "Catch2 does not report unmatched parts of a partially-matched test spec\n## Description\r\nCatch2's runTests function calls the reporter's noMatchingTestCases if *no* tests match the spec, but if some test matches some part of the spec, nothing reports that the rest of the spec matched nothing. In other words, if I pass \"Test1 Test2\" as command-line args, and \"Test1\" matches some test, nothing complains about the fact that \"Test2\" matched nothing. This can lead the user to believe that they're running all the tests in the spec when they are not.\r\n\r\n### Steps to reproduce\r\nCreate a test file with one test. Run it with command-line args that specify two tests: the existing test and\r\nsome other, non-existent test. Everything will be green and happy, with no indication that the second test was not found.\r\n\r\n### Extra information\r\n* Catch version: **v2.4.1**\r\n* Operating System: **Windows 10**\r\n* Compiler+version: **MS VS 2015**\r\n\n-w NoTests should give non-zero status\ndocs/command-line.md says \"NoTests        // Return non-zero exit code when no test cases were run\" but I see a status of zero being returned instead of non-zero\r\n\r\nmy_bug.cpp:\r\n```#define CATCH_CONFIG_MAIN\r\n#include \"catch2/catch.hpp\"\r\n\r\nTEST_CASE(\"my case\", \"[foo]\") {\r\n  SECTION(\"my section\") {\r\n    CHECK(1);\r\n  }\r\n}\r\n```\r\n```\r\n> g++ -o my_bug my_bug.cpp -I ...\r\n> ./my_bug -w NoTests '[x]'\r\nFilters: [x]\r\nNo test cases matched '[x]'\r\n===============================================================================\r\nNo tests ran\r\n\r\nstatus=0\r\n```\r\n\r\nI expected a non-zero status.\r\n\r\n**Platform information:**\r\n - OS: **Linux CentOS 6**\r\n - Compiler+version: **GCC v7.3.0**\r\n - Catch version: **v2.9.1**\r\n\n",
        "hints_text": "This is actually true even if you run with just \"test2\". That is, you are told _\"No tests ran\"_, but the test calls `exit(0)`. So to my script it looks like everything ran as expected.\r\n\r\nI think that:\r\n\r\n1. It should report errors for any spec. which does not have a match; and\r\n2. If any such error is found, the test should return 1 (i.e. `exit(1)`) so my scripts break as expected on errors.\nYou're right. The main issue can be fixed with some changes to the test case filtering mechanism. As for the exit code issue, going by the documentation, the command-line option `-w NoTests` *should* do what @AlexisWilke wants, but the code does not seem to respect it. This is also easy to fix. I'll have a go at it soon.\n",
        "created_at": "2019-07-09T21:09:26Z",
        "version": "2.9"
    }
}