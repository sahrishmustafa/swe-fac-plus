{
    "task_id": "catchorg__Catch2-2128",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2128_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2128,
        "instance_id": "catchorg__Catch2-2128",
        "issue_numbers": [
            "2121"
        ],
        "base_commit": "65c9a1d31a338f28ef93cd61c475efc40f6cc42e",
        "patch": "diff --git a/src/catch2/internal/catch_decomposer.hpp b/src/catch2/internal/catch_decomposer.hpp\n--- a/src/catch2/internal/catch_decomposer.hpp\n+++ b/src/catch2/internal/catch_decomposer.hpp\n@@ -183,60 +183,53 @@ namespace Catch {\n     public:\n         explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}\n \n-        template<typename RhsT>\n-        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n-        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs == rhs, m_lhs, \"==\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator == ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"==\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { compareNotEqual( m_lhs, rhs ), m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n-        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {\n-            return { m_lhs != rhs, m_lhs, \"!=\"_sr, rhs };\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0>\n+        friend auto operator != ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> {\n+            return { compareNotEqual( lhs.m_lhs, rhs ), lhs.m_lhs, \"!=\"_sr, rhs };\n         }\n \n-        template<typename RhsT>\n-        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs > rhs), m_lhs, \">\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs < rhs), m_lhs, \"<\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs >= rhs), m_lhs, \">=\"_sr, rhs };\n-        }\n-        template<typename RhsT>\n-        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs <= rhs), m_lhs, \"<=\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs | rhs), m_lhs, \"|\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs & rhs), m_lhs, \"&\"_sr, rhs };\n-        }\n-        template <typename RhsT>\n-        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {\n-            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, \"^\"_sr, rhs };\n+    #define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(op) \\\n+        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<RhsT>>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n+        } \\\n+        template<typename RhsT, std::enable_if_t<std::is_arithmetic<RhsT>::value, int> = 0> \\\n+        friend auto operator op ( ExprLhs && lhs, RhsT rhs ) -> BinaryExpr<LhsT, RhsT> { \\\n+            return { static_cast<bool>(lhs.m_lhs op rhs), lhs.m_lhs, #op##_sr, rhs }; \\\n         }\n \n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(<=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(>=)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(|)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(&)\n+        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(^)\n+\n+    #undef CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR\n+\n         template<typename RhsT>\n-        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator && ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator&& is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n         }\n \n         template<typename RhsT>\n-        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {\n+        friend auto operator || ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {\n             static_assert(always_false<RhsT>::value,\n             \"operator|| is not supported inside assertions, \"\n             \"wrap the expression inside parentheses, or decompose it\");\n@@ -247,21 +240,15 @@ namespace Catch {\n         }\n     };\n \n-    void handleExpression( ITransientExpression const& expr );\n-\n-    template<typename T>\n-    void handleExpression( ExprLhs<T> const& expr ) {\n-        handleExpression( expr.makeUnaryExpr() );\n-    }\n-\n     struct Decomposer {\n-        template<typename T>\n-        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {\n-            return ExprLhs<T const&>{ lhs };\n+        template<typename T, std::enable_if_t<!std::is_arithmetic<std::remove_reference_t<T>>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T && lhs ) -> ExprLhs<T const&> {\n+            return ExprLhs<const T&>{ lhs };\n         }\n \n-        auto operator <=( bool value ) -> ExprLhs<bool> {\n-            return ExprLhs<bool>{ value };\n+        template<typename T, std::enable_if_t<std::is_arithmetic<T>::value, int> = 0>\n+        friend auto operator <= ( Decomposer &&, T value ) -> ExprLhs<T> {\n+            return ExprLhs<T>{ value };\n         }\n     };\n \n",
        "test_patch": "diff --git a/tests/SelfTest/UsageTests/Compilation.tests.cpp b/tests/SelfTest/UsageTests/Compilation.tests.cpp\n--- a/tests/SelfTest/UsageTests/Compilation.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Compilation.tests.cpp\n@@ -277,3 +277,42 @@ namespace {\n TEST_CASE(\"Immovable types are supported in basic assertions\", \"[compilation][.approvals]\") {\n     REQUIRE(ImmovableType{} == ImmovableType{});\n }\n+\n+namespace adl {\n+\n+struct always_true {\n+    explicit operator bool() const { return true; }\n+};\n+\n+#define COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(op) \\\n+template <class T, class U> \\\n+auto operator op (T&&, U&&) { \\\n+    return always_true{}; \\\n+}\n+\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(==)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(!=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(<=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(>=)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(|)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(&)\n+COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR(^)\n+\n+#undef COMPILATION_TEST_DEFINE_UNIVERSAL_OPERATOR\n+\n+}\n+\n+TEST_CASE(\"ADL universal operators don't hijack expression deconstruction\", \"[compilation][.approvals]\") {\n+    REQUIRE(adl::always_true{});\n+    REQUIRE(0 == adl::always_true{});\n+    REQUIRE(0 != adl::always_true{});\n+    REQUIRE(0 < adl::always_true{});\n+    REQUIRE(0 > adl::always_true{});\n+    REQUIRE(0 <= adl::always_true{});\n+    REQUIRE(0 >= adl::always_true{});\n+    REQUIRE(0 | adl::always_true{});\n+    REQUIRE(0 & adl::always_true{});\n+    REQUIRE(0 ^ adl::always_true{});\n+}\n",
        "problem_statement": "Problem with user provided operator == (with proposed fix)\n**Describe the bug**\r\nThe test doesn't compile when the user provides a more general `operator ==` overload than `ExprLhs`.\r\n`operator ==` in the code sample below is a better match when r-value reference is passed because it accepts forwarding reference (`U&&`) and `ExprLhs` accepts only const reference (`RhsT const& rhs`) https://github.com/catchorg/Catch2/blob/devel/src/catch2/internal/catch_decomposer.hpp#L187\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Expected behavior**\r\nThe test should compile.\r\n\r\n**Reproduction steps**\r\n```\r\nnamespace adl {\r\n\r\nstruct activate_adl {};\r\n\r\nstruct equality_expression {\r\n    operator bool() const { return true; }\r\n};\r\n\r\ntemplate <class T, class U>\r\nconstexpr auto operator == (T&&, U&&) {\r\n    return equality_expression{};\r\n}\r\n\r\n}\r\n\r\nTEST_CASE(\"User provided equality operator\", \"[compilation]\") {\r\n    REQUIRE(0 == adl::activate_adl{});\r\n}\r\n```\r\nerror: no matching member function for call to 'handleExpr' REQUIRE(0 == adl::activate_adl{});\r\n\r\n**Fix**\r\nMy first attempt was to change the `operator == ` definition (and similarly all other operators) to\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\nHowever, this broke a test for bitfields\r\nerror: non-const reference cannot bind to bit-field 'v' REQUIRE(0 == y.v);\r\n\r\nThis can be resolved by two not so clean overloads, maybe you know a better way:\r\n```\r\n        template<typename RhsT>\r\n        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n        template<typename RhsT, std::enable_if_t<!std::is_arithmetic<std::decay_t<RhsT>>::value, int> = 0>\r\n        auto operator == ( RhsT && rhs ) -> BinaryExpr<LhsT, RhsT const&> const {\r\n            return { compareEqual( m_lhs, rhs ), m_lhs, \"==\"_sr, rhs };\r\n        }\r\n```\r\n\r\n**Unrelated note**\r\nI don't think const reference here prolongs the lifetime of rhs, because it's not local but stored in a class: `BinaryExpr<LhsT, RhsT const&>`. Not sure if it's a problem.\n",
        "hints_text": "",
        "created_at": "2020-12-20T00:12:15Z",
        "version": "3.0"
    }
}