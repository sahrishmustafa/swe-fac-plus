{
    "task_id": "catchorg__Catch2-2058",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2058_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2058,
        "instance_id": "catchorg__Catch2-2058",
        "issue_numbers": [
            "2040",
            "2012"
        ],
        "base_commit": "4b2bc8757c6d5a95e163b8a54a122d4c95b84310",
        "patch": "diff --git a/src/catch2/generators/catch_generators.hpp b/src/catch2/generators/catch_generators.hpp\n--- a/src/catch2/generators/catch_generators.hpp\n+++ b/src/catch2/generators/catch_generators.hpp\n@@ -70,8 +70,11 @@ namespace Detail {\n     class SingleValueGenerator final : public IGenerator<T> {\n         T m_value;\n     public:\n+        SingleValueGenerator(T const& value) :\n+            m_value(value)\n+        {}\n         SingleValueGenerator(T&& value):\n-            m_value(std::forward<T>(value))\n+            m_value(std::move(value))\n         {}\n \n         T const& get() const override {\n@@ -101,9 +104,11 @@ namespace Detail {\n         }\n     };\n \n-    template <typename T>\n-    GeneratorWrapper<T> value(T&& value) {\n-        return GeneratorWrapper<T>(Catch::Detail::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));\n+    template <typename T, typename DecayedT = std::decay_t<T>>\n+    GeneratorWrapper<DecayedT> value( T&& value ) {\n+        return GeneratorWrapper<DecayedT>(\n+            Catch::Detail::make_unique<SingleValueGenerator<DecayedT>>(\n+                std::forward<T>( value ) ) );\n     }\n     template <typename T>\n     GeneratorWrapper<T> values(std::initializer_list<T> values) {\n@@ -115,27 +120,36 @@ namespace Detail {\n         std::vector<GeneratorWrapper<T>> m_generators;\n         size_t m_current = 0;\n \n-        void populate(GeneratorWrapper<T>&& generator) {\n-            m_generators.emplace_back(std::move(generator));\n+        void add_generator( GeneratorWrapper<T>&& generator ) {\n+            m_generators.emplace_back( std::move( generator ) );\n+        }\n+        void add_generator( T const& val ) {\n+            m_generators.emplace_back( value( val ) );\n         }\n-        void populate(T&& val) {\n-            m_generators.emplace_back(value(std::forward<T>(val)));\n+        void add_generator( T&& val ) {\n+            m_generators.emplace_back( value( std::move( val ) ) );\n         }\n-        template<typename U>\n-        void populate(U&& val) {\n-            populate(T(std::forward<U>(val)));\n+        template <typename U>\n+        std::enable_if_t<!std::is_same<std::decay_t<U>, T>::value>\n+        add_generator( U&& val ) {\n+            add_generator( T( std::forward<U>( val ) ) );\n         }\n-        template<typename U, typename... Gs>\n-        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {\n-            populate(std::forward<U>(valueOrGenerator));\n-            populate(std::forward<Gs>(moreGenerators)...);\n+\n+        template <typename U> void add_generators( U&& valueOrGenerator ) {\n+            add_generator( std::forward<U>( valueOrGenerator ) );\n+        }\n+\n+        template <typename U, typename... Gs>\n+        void add_generators( U&& valueOrGenerator, Gs&&... moreGenerators ) {\n+            add_generator( std::forward<U>( valueOrGenerator ) );\n+            add_generators( std::forward<Gs>( moreGenerators )... );\n         }\n \n     public:\n         template <typename... Gs>\n         Generators(Gs &&... moreGenerators) {\n             m_generators.reserve(sizeof...(Gs));\n-            populate(std::forward<Gs>(moreGenerators)...);\n+            add_generators(std::forward<Gs>(moreGenerators)...);\n         }\n \n         T const& get() const override {\n@@ -155,8 +169,9 @@ namespace Detail {\n     };\n \n \n-    template<typename... Ts>\n-    GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {\n+    template <typename... Ts>\n+    GeneratorWrapper<std::tuple<std::decay_t<Ts>...>>\n+    table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {\n         return values<std::tuple<Ts...>>( tuples );\n     }\n \n@@ -173,7 +188,7 @@ namespace Detail {\n         return Generators<T>(std::move(generator));\n     }\n     template<typename T, typename... Gs>\n-    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {\n+    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<std::decay_t<T>> {\n         return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );\n     }\n     template<typename T, typename U, typename... Gs>\n",
        "test_patch": "diff --git a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -358,3 +358,33 @@ TEST_CASE(\"Multiple random generators in one test case output different values\",\n         REQUIRE(same < 200);\n     }\n }\n+\n+TEST_CASE(\"#2040 - infinite compilation recursion in GENERATE with MSVC\", \"[generators][compilation][approvals]\") {\n+    int x = 42;\n+    auto test = GENERATE_COPY(1, x, 2 * x);\n+    CHECK(test < 100);\n+}\n+\n+namespace {\n+    static bool always_true(int) {\n+        return true;\n+    }\n+\n+    static bool is_even(int n) {\n+        return n % 2 == 0;\n+    }\n+\n+    static bool is_multiple_of_3(int n) {\n+        return n % 3 == 0;\n+    }\n+}\n+\n+TEST_CASE(\"GENERATE handles function (pointers)\", \"[generators][compilation][approvals]\") {\n+    auto f = GENERATE(always_true, is_even, is_multiple_of_3);\n+    REQUIRE(f(6));\n+}\n+\n+TEST_CASE(\"GENERATE decays arrays\", \"[generators][compilation][approvals]\") {\n+    auto str = GENERATE(\"abc\", \"def\", \"gh\");\n+    STATIC_REQUIRE(std::is_same<decltype(str), const char*>::value);\n+}\n",
        "problem_statement": "Infinite recursion in Generators::populate with MSVC\n```\r\nCATCH_TEST_CASE(\"Recursion Bug\")\r\n{\r\n    int x = 42;\r\n    auto test = GENERATE_COPY(1, x, 2 * x);\r\n    CATCH_CHECK(test < 50);\r\n}\r\n```\r\nThis worked in `2.9.2` but now I get \r\n`single_include\\catch2\\catch.hpp(4027):warning C4717: 'Catch::Generators::Generators<int>::populate<int &>': recursive on all control paths, function will cause runtime stack overflow` with MSVC 2017 `Microsoft (R) C/C++ Optimizing Compiler Version 19.16.27042 for x64`.\r\nIt matches the wrong template.\r\n\r\nA possible work-around is `GENERATE_COPY(values<int>({1, x, 2 * x}));`, but the above should work, right?\nGENERATE() changes compile time length of arrays\n**Description**\r\nGENERATE macro takes type of first argument and cast all other args to it. It is ok for most cases but for string literals it is bad. It takes length of first literal and force it for all.\r\n`TEST_CASE(\"t\", \"[t]\") {\r\n    auto& str = GENERATE(\"123\", \"1\");\r\n    WARN(typeid(str).name());\r\n}`\r\nOutput\r\n`warning:\r\n  A4_c`\r\nUsually you don't see it. If you use std::string to store the result of GENERATE then everything works fine, all lengths are correct. But some string implementations use length from type of array. E.g., https://stackoverflow.com/questions/2384107/magic-arguments-in-function-templates\r\nThis template magic works wrong with GENERATE. I cann't say this is a bug, because I have no idea how to fix it. May be detect arrays and generate compilation error if lengths are different?\r\n\r\nIt is very bad rule in C++ that references to arrays with different lengths can be cast to each other. \n",
        "hints_text": "I can reproduce this with an up-to-date MSVC.\r\n\r\nHowever, it doesn't reproduce with Clang/GCC, so I suspect the code runs into some MSVC bug, which is going to be hard to debug.\nDoes not reproduce with `/permissive-`...\nSo, this was almost definitely introduced in 6c9a255dc2973e97b2d6a155d36f47e145382d32.\r\n\r\n\nRight, so, there are two parts to this.\r\n\r\n1) single `GENERATE` \"call\" can have only one return type. (even though for e.g. `TEMPLATE_TEST_CASE`, the type can differ across different input types...)\r\n2) deducing string literals as char arrays with specific size _can_ be a problem.\r\n\r\nI cannot change 1), and fixing 2) by forcing a pointer decay would break people who already use it with all literals having the same size.\r\n\r\nI will have to think about whether there is an use case for having different size string literals deduce as the same size, and if not, `static_assert` that they share length is indeed the best option.\r\n\r\n\r\nIn the meantime, if you have this issue in your code, consider passing `as<char const*>{}` as the first element in `GENERATE`. Doing so forces the type to be deduced as `char const*`.\nThank you for answer.\r\nYes, casting to string is how I solved this problem in my case.\r\n\r\nFor general case there is the only solution - detect reference to array. It is a question what to do with it. One option is static assert for length, but it is code breakage. If somebody used `std::string a = GENERATE(\"a\", \"ab\");` it worked well and, imho, should continue working. But static_assert breaks it. \r\nAnother option is cast to `const char*`. Correct code with std::string continues to compile and incorrect depends on situation. If it could not work without length then it wouldn't compile. And it is good because it was wrong code that worked with wrong length. If it can work with `const char*` instead of `char&[N]` then everything is OK like std::string.\r\n\r\nDetection itself can be implemented with function overload, e.g., `template<typename T,size_t N> \r\n void generate(T (&a)[N])`\nUpdate: I've decided that for v3 I am going to make arrays decay. Not sure if I will port this to v2 as well.",
        "created_at": "2020-10-20T09:04:14Z",
        "version": "3.0"
    }
}