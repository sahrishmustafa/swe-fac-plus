{
    "task_id": "catchorg__Catch2-1614",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-1614_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 1614,
        "instance_id": "catchorg__Catch2-1614",
        "issue_numbers": [
            "1612"
        ],
        "base_commit": "9c741fe96073ed620ffc032afbed1f3c789d2b68",
        "patch": "diff --git a/include/internal/catch_tostring.cpp b/include/internal/catch_tostring.cpp\n--- a/include/internal/catch_tostring.cpp\n+++ b/include/internal/catch_tostring.cpp\n@@ -234,11 +234,16 @@ std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {\n     return \"nullptr\";\n }\n \n+int StringMaker<float>::precision = 5;\n+   \n std::string StringMaker<float>::convert(float value) {\n-    return fpToString(value, 5) + 'f';\n+    return fpToString(value, precision) + 'f';\n }\n+\n+int StringMaker<double>::precision = 10;\n+    \n std::string StringMaker<double>::convert(double value) {\n-    return fpToString(value, 10);\n+    return fpToString(value, precision);\n }\n \n std::string ratio_string<std::atto>::symbol() { return \"a\"; }\ndiff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -261,10 +261,13 @@ namespace Catch {\n     template<>\n     struct StringMaker<float> {\n         static std::string convert(float value);\n+        static int precision;\n     };\n+\n     template<>\n     struct StringMaker<double> {\n         static std::string convert(double value);\n+        static int precision;\n     };\n \n     template <typename T>\n",
        "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringGeneral.tests.cpp\n@@ -128,6 +128,40 @@ TEST_CASE(\"String views are stringified like other strings\", \"[toString][approva\n \n #endif\n \n+TEST_CASE(\"Precision of floating point stringification can be set\", \"[toString][floatingPoint]\") {\n+    SECTION(\"Floats\") {\n+        using sm = Catch::StringMaker<float>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const float testFloat = 1.12345678901234567899f;\n+        auto str1 = sm::convert(testFloat);\n+        sm::precision = 5;\n+        // \"1.\" prefix = 2 chars, f suffix is another char\n+        CHECK(str1.size() == 3 + 5);\n+\n+        sm::precision = 10;\n+        auto str2 = sm::convert(testFloat);\n+        REQUIRE(str2.size() == 3 + 10);\n+        sm::precision = oldPrecision;\n+    }\n+    SECTION(\"Double\") {\n+        using sm = Catch::StringMaker<double>;\n+        const auto oldPrecision = sm::precision;\n+\n+        const double testDouble = 1.123456789012345678901234567899;\n+        sm::precision = 5;\n+        auto str1 = sm::convert(testDouble);\n+        // \"1.\" prefix = 2 chars\n+        CHECK(str1.size() == 2 + 5);\n+\n+        sm::precision = 15;\n+        auto str2 = sm::convert(testDouble);\n+        REQUIRE(str2.size() == 2 + 15);\n+\n+        sm::precision = oldPrecision;\n+    }\n+}\n+\n namespace {\n \n struct WhatException : std::exception {\n",
        "problem_statement": "Allow custom precision in error reports for floating-point numbers\n**Description**\r\nAs in [this SO Q&A](https://stackoverflow.com/q/55867570/201787), it would be nice to allow customization of the precision of floating-point values that fail. At present, the precision for float and double are hard-coded within Catch2 to 5 and 10, respectively:\r\n```cpp\r\nstd::string StringMaker<float>::convert(float value) {\r\n    return fpToString(value, 5) + 'f';\r\n}\r\nstd::string StringMaker<double>::convert(double value) {\r\n    return fpToString(value, 10);\r\n}\r\n```\r\nSometimes things will fail (even with `Approx()`), but the precision of the failure message doesn't show enough precision to be meaningful.\r\n```\r\nprog.cc:22: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.0f\r\n```\r\nThe proposal here is to add a `setPrecision()` function to allow the user to control this. I have prototyped this, which you can see running [live on Wandbox](https://wandbox.org/permlink/mZXPLEuET5ZeTg1t). Here's the test:\r\n```cpp\r\nTEMPLATE_TEST_CASE( \"Double, double, toil and trouble\", \"[double]\", float, double ) \r\n{\r\n    const auto precision = GENERATE( -1, 0, 3, std::numeric_limits<TestType>::max_digits10 );\r\n\r\n    if( precision >= 0 )\r\n    {\r\n        Catch::StringMaker<TestType>::setPrecision( precision );\r\n    }\r\n    \r\n    // Expected to fail to demonstrate the problem\r\n    REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() ); \r\n}\r\n```\r\nThe output shows as expected for floats and doubles. For instance:\r\n```\r\nprog.cc:15: FAILED:\r\n  REQUIRE( TestType(0) == std::numeric_limits<TestType>::epsilon() )\r\nwith expansion:\r\n  0.0f == 0.000000119f\r\n```\r\nMaking a unit test for this is a little iffy since the actual string values are dependent on the usual floating-point fuzziness. I guess it could compare string length without looking too closely at the value.\n",
        "hints_text": "",
        "created_at": "2019-04-26T18:37:28Z",
        "version": "2.7"
    }
}