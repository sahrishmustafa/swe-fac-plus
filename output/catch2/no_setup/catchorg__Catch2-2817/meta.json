{
    "task_id": "catchorg__Catch2-2817",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-2817_2025-06-29_23-16-37",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 2817,
        "instance_id": "catchorg__Catch2-2817",
        "issue_numbers": [
            "2816"
        ],
        "base_commit": "c3fd4eb17e28ace4d3d9df1fb0656f3975879709",
        "patch": "diff --git a/examples/210-Evt-EventListeners.cpp b/examples/210-Evt-EventListeners.cpp\n--- a/examples/210-Evt-EventListeners.cpp\n+++ b/examples/210-Evt-EventListeners.cpp\n@@ -385,8 +385,7 @@ struct MyListener : Catch::EventListenerBase {\n CATCH_REGISTER_LISTENER( MyListener )\n \n // Get rid of Wweak-tables\n-MyListener::~MyListener() {}\n-\n+MyListener::~MyListener() = default;\n \n // -----------------------------------------------------------------------\n // 3. Test cases:\ndiff --git a/examples/231-Cfg-OutputStreams.cpp b/examples/231-Cfg-OutputStreams.cpp\n--- a/examples/231-Cfg-OutputStreams.cpp\n+++ b/examples/231-Cfg-OutputStreams.cpp\n@@ -22,7 +22,7 @@ class out_buff : public std::stringbuf {\n     std::FILE* m_stream;\n public:\n     out_buff(std::FILE* stream):m_stream(stream) {}\n-    ~out_buff();\n+    ~out_buff() override;\n     int sync() override {\n         int ret = 0;\n         for (unsigned char c : str()) {\ndiff --git a/examples/232-Cfg-CustomMain.cpp b/examples/232-Cfg-CustomMain.cpp\n--- a/examples/232-Cfg-CustomMain.cpp\n+++ b/examples/232-Cfg-CustomMain.cpp\n@@ -35,7 +35,7 @@ int main(int argc, char** argv) {\n       return returnCode;\n \n   // if set on the command line then 'height' is now set at this point\n-  std::cout << \"height: \" << height << std::endl;\n+  std::cout << \"height: \" << height << '\\n';\n \n   return session.run();\n }\ndiff --git a/examples/300-Gen-OwnGenerator.cpp b/examples/300-Gen-OwnGenerator.cpp\n--- a/examples/300-Gen-OwnGenerator.cpp\n+++ b/examples/300-Gen-OwnGenerator.cpp\n@@ -21,7 +21,7 @@\n namespace {\n \n // This class shows how to implement a simple generator for Catch tests\n-class RandomIntGenerator : public Catch::Generators::IGenerator<int> {\n+class RandomIntGenerator final : public Catch::Generators::IGenerator<int> {\n     std::minstd_rand m_rand;\n     std::uniform_int_distribution<> m_dist;\n     int current_number;\ndiff --git a/examples/301-Gen-MapTypeConversion.cpp b/examples/301-Gen-MapTypeConversion.cpp\n--- a/examples/301-Gen-MapTypeConversion.cpp\n+++ b/examples/301-Gen-MapTypeConversion.cpp\n@@ -24,12 +24,12 @@ namespace {\n // Returns a line from a stream. You could have it e.g. read lines from\n // a file, but to avoid problems with paths in examples, we will use\n // a fixed stringstream.\n-class LineGenerator : public Catch::Generators::IGenerator<std::string> {\n+class LineGenerator final : public Catch::Generators::IGenerator<std::string> {\n     std::string m_line;\n     std::stringstream m_stream;\n public:\n-    LineGenerator() {\n-        m_stream.str(\"1\\n2\\n3\\n4\\n\");\n+    explicit LineGenerator( std::string const& lines ) {\n+        m_stream.str( lines );\n         if (!next()) {\n             Catch::Generators::Detail::throw_generator_exception(\"Couldn't read a single line\");\n         }\n@@ -49,18 +49,19 @@ std::string const& LineGenerator::get() const {\n // This helper function provides a nicer UX when instantiating the generator\n // Notice that it returns an instance of GeneratorWrapper<std::string>, which\n // is a value-wrapper around std::unique_ptr<IGenerator<std::string>>.\n-Catch::Generators::GeneratorWrapper<std::string> lines(std::string /* ignored for example */) {\n+Catch::Generators::GeneratorWrapper<std::string>\n+lines( std::string const& lines ) {\n     return Catch::Generators::GeneratorWrapper<std::string>(\n-        new LineGenerator()\n-    );\n+        new LineGenerator( lines ) );\n }\n \n } // end anonymous namespace\n \n \n TEST_CASE(\"filter can convert types inside the generator expression\", \"[example][generator]\") {\n-    auto num = GENERATE(map<int>([](std::string const& line) { return std::stoi(line); },\n-                                 lines(\"fake-file\")));\n+    auto num = GENERATE(\n+        map<int>( []( std::string const& line ) { return std::stoi( line ); },\n+                  lines( \"1\\n2\\n3\\n4\\n\" ) ) );\n \n     REQUIRE(num > 0);\n }\ndiff --git a/src/catch2/catch_message.cpp b/src/catch2/catch_message.cpp\n--- a/src/catch2/catch_message.cpp\n+++ b/src/catch2/catch_message.cpp\n@@ -91,6 +91,7 @@ namespace Catch {\n                     m_messages.back().message += \" := \";\n                     start = pos;\n                 }\n+            default:; // noop\n             }\n         }\n         assert(openings.empty() && \"Mismatched openings\");\ndiff --git a/src/catch2/catch_registry_hub.cpp b/src/catch2/catch_registry_hub.cpp\n--- a/src/catch2/catch_registry_hub.cpp\n+++ b/src/catch2/catch_registry_hub.cpp\n@@ -20,7 +20,6 @@\n #include <catch2/internal/catch_noncopyable.hpp>\n #include <catch2/interfaces/catch_interfaces_reporter_factory.hpp>\n #include <catch2/internal/catch_move_and_forward.hpp>\n-#include <catch2/internal/catch_reporter_registry.hpp>\n \n #include <exception>\n \ndiff --git a/src/catch2/catch_tostring.cpp b/src/catch2/catch_tostring.cpp\n--- a/src/catch2/catch_tostring.cpp\n+++ b/src/catch2/catch_tostring.cpp\n@@ -54,13 +54,13 @@ namespace Detail {\n         }\n     } // end unnamed namespace\n \n-    std::string convertIntoString(StringRef string, bool escape_invisibles) {\n+    std::string convertIntoString(StringRef string, bool escapeInvisibles) {\n         std::string ret;\n         // This is enough for the \"don't escape invisibles\" case, and a good\n         // lower bound on the \"escape invisibles\" case.\n         ret.reserve(string.size() + 2);\n \n-        if (!escape_invisibles) {\n+        if (!escapeInvisibles) {\n             ret += '\"';\n             ret += string;\n             ret += '\"';\n@@ -138,7 +138,7 @@ std::string StringMaker<char const*>::convert(char const* str) {\n         return{ \"{null string}\" };\n     }\n }\n-std::string StringMaker<char*>::convert(char* str) {\n+std::string StringMaker<char*>::convert(char* str) { // NOLINT(readability-non-const-parameter)\n     if (str) {\n         return Detail::convertIntoString( str );\n     } else {\n@@ -235,8 +235,8 @@ std::string StringMaker<signed char>::convert(signed char value) {\n std::string StringMaker<char>::convert(char c) {\n     return ::Catch::Detail::stringify(static_cast<signed char>(c));\n }\n-std::string StringMaker<unsigned char>::convert(unsigned char c) {\n-    return ::Catch::Detail::stringify(static_cast<char>(c));\n+std::string StringMaker<unsigned char>::convert(unsigned char value) {\n+    return ::Catch::Detail::stringify(static_cast<char>(value));\n }\n \n int StringMaker<float>::precision = 5;\ndiff --git a/src/catch2/catch_tostring.hpp b/src/catch2/catch_tostring.hpp\n--- a/src/catch2/catch_tostring.hpp\n+++ b/src/catch2/catch_tostring.hpp\n@@ -279,11 +279,11 @@ namespace Catch {\n     };\n     template<>\n     struct StringMaker<signed char> {\n-        static std::string convert(signed char c);\n+        static std::string convert(signed char value);\n     };\n     template<>\n     struct StringMaker<unsigned char> {\n-        static std::string convert(unsigned char c);\n+        static std::string convert(unsigned char value);\n     };\n \n     template<>\ndiff --git a/src/catch2/internal/catch_commandline.cpp b/src/catch2/internal/catch_commandline.cpp\n--- a/src/catch2/internal/catch_commandline.cpp\n+++ b/src/catch2/internal/catch_commandline.cpp\n@@ -47,7 +47,7 @@ namespace Catch {\n                     line = trim(line);\n                     if( !line.empty() && !startsWith( line, '#' ) ) {\n                         if( !startsWith( line, '\"' ) )\n-                            line = '\"' + line + '\"';\n+                            line = '\"' + CATCH_MOVE(line) + '\"';\n                         config.testsOrTags.push_back( line );\n                         config.testsOrTags.emplace_back( \",\" );\n                     }\ndiff --git a/src/catch2/internal/catch_console_colour.cpp b/src/catch2/internal/catch_console_colour.cpp\n--- a/src/catch2/internal/catch_console_colour.cpp\n+++ b/src/catch2/internal/catch_console_colour.cpp\n@@ -230,21 +230,21 @@ namespace {\n \n namespace Catch {\n \n-    Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode implSelection,\n+    Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,\n                                                    IStream* stream ) {\n #if defined( CATCH_CONFIG_COLOUR_WIN32 )\n-        if ( implSelection == ColourMode::Win32 ) {\n+        if ( colourSelection == ColourMode::Win32 ) {\n             return Detail::make_unique<Win32ColourImpl>( stream );\n         }\n #endif\n-        if ( implSelection == ColourMode::ANSI ) {\n+        if ( colourSelection == ColourMode::ANSI ) {\n             return Detail::make_unique<ANSIColourImpl>( stream );\n         }\n-        if ( implSelection == ColourMode::None ) {\n+        if ( colourSelection == ColourMode::None ) {\n             return Detail::make_unique<NoColourImpl>( stream );\n         }\n \n-        if ( implSelection == ColourMode::PlatformDefault) {\n+        if ( colourSelection == ColourMode::PlatformDefault) {\n #if defined( CATCH_CONFIG_COLOUR_WIN32 )\n             if ( Win32ColourImpl::useImplementationForStream( *stream ) ) {\n                 return Detail::make_unique<Win32ColourImpl>( stream );\n@@ -256,7 +256,7 @@ namespace Catch {\n             return Detail::make_unique<NoColourImpl>( stream );\n         }\n \n-        CATCH_ERROR( \"Could not create colour impl for selection \" << static_cast<int>(implSelection) );\n+        CATCH_ERROR( \"Could not create colour impl for selection \" << static_cast<int>(colourSelection) );\n     }\n \n     bool isColourImplAvailable( ColourMode colourSelection ) {\ndiff --git a/src/catch2/internal/catch_enum_values_registry.hpp b/src/catch2/internal/catch_enum_values_registry.hpp\n--- a/src/catch2/internal/catch_enum_values_registry.hpp\n+++ b/src/catch2/internal/catch_enum_values_registry.hpp\n@@ -24,7 +24,7 @@ namespace Catch {\n \n             std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;\n \n-            EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values) override;\n+            EnumInfo const& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values) override;\n         };\n \n         std::vector<StringRef> parseEnums( StringRef enums );\ndiff --git a/src/catch2/internal/catch_jsonwriter.cpp b/src/catch2/internal/catch_jsonwriter.cpp\n--- a/src/catch2/internal/catch_jsonwriter.cpp\n+++ b/src/catch2/internal/catch_jsonwriter.cpp\n@@ -31,7 +31,7 @@ namespace Catch {\n         m_os{ os }, m_indent_level{ indent_level } {\n         m_os << '{';\n     }\n-    JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ):\n+    JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ) noexcept:\n         m_os{ source.m_os },\n         m_indent_level{ source.m_indent_level },\n         m_should_comma{ source.m_should_comma },\n@@ -62,7 +62,7 @@ namespace Catch {\n         m_os{ os }, m_indent_level{ indent_level } {\n         m_os << '[';\n     }\n-    JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ):\n+    JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ) noexcept:\n         m_os{ source.m_os },\n         m_indent_level{ source.m_indent_level },\n         m_should_comma{ source.m_should_comma },\ndiff --git a/src/catch2/internal/catch_jsonwriter.hpp b/src/catch2/internal/catch_jsonwriter.hpp\n--- a/src/catch2/internal/catch_jsonwriter.hpp\n+++ b/src/catch2/internal/catch_jsonwriter.hpp\n@@ -65,7 +65,7 @@ namespace Catch {\n         JsonObjectWriter( std::ostream& os );\n         JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );\n \n-        JsonObjectWriter( JsonObjectWriter&& source );\n+        JsonObjectWriter( JsonObjectWriter&& source ) noexcept;\n         JsonObjectWriter& operator=( JsonObjectWriter&& source ) = delete;\n \n         ~JsonObjectWriter();\n@@ -84,7 +84,7 @@ namespace Catch {\n         JsonArrayWriter( std::ostream& os );\n         JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );\n \n-        JsonArrayWriter( JsonArrayWriter&& source );\n+        JsonArrayWriter( JsonArrayWriter&& source ) noexcept;\n         JsonArrayWriter& operator=( JsonArrayWriter&& source ) = delete;\n \n         ~JsonArrayWriter();\ndiff --git a/src/catch2/internal/catch_reporter_spec_parser.cpp b/src/catch2/internal/catch_reporter_spec_parser.cpp\n--- a/src/catch2/internal/catch_reporter_spec_parser.cpp\n+++ b/src/catch2/internal/catch_reporter_spec_parser.cpp\n@@ -117,7 +117,7 @@ namespace Catch {\n             auto kv = splitKVPair( parts[i] );\n             auto key = kv.key, value = kv.value;\n \n-            if ( key.empty() || value.empty() ) {\n+            if ( key.empty() || value.empty() ) { // NOLINT(bugprone-branch-clone)\n                 return {};\n             } else if ( key[0] == 'X' ) {\n                 // This is a reporter-specific option, we don't check these\ndiff --git a/src/catch2/internal/catch_section.hpp b/src/catch2/internal/catch_section.hpp\n--- a/src/catch2/internal/catch_section.hpp\n+++ b/src/catch2/internal/catch_section.hpp\n@@ -69,7 +69,9 @@ namespace Catch {\n     namespace Detail {\n         // Intentionally without linkage, as it should only be used as a dummy\n         // symbol for static analysis.\n-        int GetNewSectionHint();\n+        // The arguments are used as a dummy for checking warnings in the passed\n+        // expressions.\n+        int GetNewSectionHint( StringRef, const char* const = nullptr );\n     } // namespace Detail\n } // namespace Catch\n \n@@ -80,7 +82,8 @@ namespace Catch {\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\\n         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\\n                  catchInternalSectionHint,                                  \\\n-             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(); \\\n+             catchInternalSectionHint =                                     \\\n+                 Catch::Detail::GetNewSectionHint(__VA_ARGS__);             \\\n              catchInternalPreviousSectionHint == __LINE__ )                 \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \n@@ -90,7 +93,8 @@ namespace Catch {\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\\n         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\\n                  catchInternalSectionHint,                                  \\\n-             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(); \\\n+             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(   \\\n+                ( Catch::ReusableStringStream() << __VA_ARGS__ ).str());    \\\n              catchInternalPreviousSectionHint == __LINE__ )                 \\\n         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n \ndiff --git a/src/catch2/internal/catch_string_manip.cpp b/src/catch2/internal/catch_string_manip.cpp\n--- a/src/catch2/internal/catch_string_manip.cpp\n+++ b/src/catch2/internal/catch_string_manip.cpp\n@@ -5,6 +5,7 @@\n //        https://www.boost.org/LICENSE_1_0.txt)\n \n // SPDX-License-Identifier: BSL-1.0\n+#include <catch2/internal/catch_move_and_forward.hpp>\n #include <catch2/internal/catch_string_manip.hpp>\n #include <catch2/internal/catch_stringref.hpp>\n \n@@ -65,17 +66,29 @@ namespace Catch {\n     }\n \n     bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {\n-        bool replaced = false;\n         std::size_t i = str.find( replaceThis );\n-        while( i != std::string::npos ) {\n-            replaced = true;\n-            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );\n-            if( i < str.size()-withThis.size() )\n-                i = str.find( replaceThis, i+withThis.size() );\n+        if (i == std::string::npos) {\n+            return false;\n+        }\n+        std::size_t copyBegin = 0;\n+        std::string origStr = CATCH_MOVE(str);\n+        str.clear();\n+        // There is at least one replacement, so reserve with the best guess\n+        // we can make without actually counting the number of occurences.\n+        str.reserve(origStr.size() - replaceThis.size() + withThis.size());\n+        do {\n+            str.append(origStr, copyBegin, i-copyBegin );\n+            str += withThis;\n+            copyBegin = i + replaceThis.size();\n+            if( copyBegin < origStr.size() )\n+                i = origStr.find( replaceThis, copyBegin );\n             else\n                 i = std::string::npos;\n+        } while( i != std::string::npos );\n+        if ( copyBegin < origStr.size() ) {\n+            str.append(origStr, copyBegin, origStr.size() );\n         }\n-        return replaced;\n+        return true;\n     }\n \n     std::vector<StringRef> splitStringRef( StringRef str, char delimiter ) {\ndiff --git a/src/catch2/internal/catch_stringref.hpp b/src/catch2/internal/catch_stringref.hpp\n--- a/src/catch2/internal/catch_stringref.hpp\n+++ b/src/catch2/internal/catch_stringref.hpp\n@@ -97,8 +97,8 @@ namespace Catch {\n         constexpr const_iterator end() const { return m_start + m_size; }\n \n \n-        friend std::string& operator += (std::string& lhs, StringRef sr);\n-        friend std::ostream& operator << (std::ostream& os, StringRef sr);\n+        friend std::string& operator += (std::string& lhs, StringRef rhs);\n+        friend std::ostream& operator << (std::ostream& os, StringRef str);\n         friend std::string operator+(StringRef lhs, StringRef rhs);\n \n         /**\ndiff --git a/src/catch2/reporters/catch_reporter_console.cpp b/src/catch2/reporters/catch_reporter_console.cpp\n--- a/src/catch2/reporters/catch_reporter_console.cpp\n+++ b/src/catch2/reporters/catch_reporter_console.cpp\n@@ -520,8 +520,8 @@ void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {\n     m_stream << '\\n' << std::flush;\n     StreamingReporterBase::testRunEnded(_testRunStats);\n }\n-void ConsoleReporter::testRunStarting(TestRunInfo const& _testInfo) {\n-    StreamingReporterBase::testRunStarting(_testInfo);\n+void ConsoleReporter::testRunStarting(TestRunInfo const& _testRunInfo) {\n+    StreamingReporterBase::testRunStarting(_testRunInfo);\n     if ( m_config->testSpec().hasFilters() ) {\n         m_stream << m_colour->guardColour( Colour::BrightYellow ) << \"Filters: \"\n                  << m_config->testSpec() << '\\n';\ndiff --git a/src/catch2/reporters/catch_reporter_cumulative_base.cpp b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n--- a/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n+++ b/src/catch2/reporters/catch_reporter_cumulative_base.cpp\n@@ -16,8 +16,7 @@ namespace Catch {\n     namespace {\n         struct BySectionInfo {\n             BySectionInfo( SectionInfo const& other ): m_other( other ) {}\n-            BySectionInfo( BySectionInfo const& other ):\n-                m_other( other.m_other ) {}\n+            BySectionInfo( BySectionInfo const& other ) = default;\n             bool operator()(\n                 Detail::unique_ptr<CumulativeReporterBase::SectionNode> const&\n                     node ) const {\ndiff --git a/src/catch2/reporters/catch_reporter_json.cpp b/src/catch2/reporters/catch_reporter_json.cpp\n--- a/src/catch2/reporters/catch_reporter_json.cpp\n+++ b/src/catch2/reporters/catch_reporter_json.cpp\n@@ -133,8 +133,8 @@ namespace Catch {\n         return \"Outputs listings as JSON. Test listing is Work-in-Progress!\";\n     }\n \n-    void JsonReporter::testRunStarting( TestRunInfo const& testInfo ) {\n-        StreamingReporterBase::testRunStarting( testInfo );\n+    void JsonReporter::testRunStarting( TestRunInfo const& runInfo ) {\n+        StreamingReporterBase::testRunStarting( runInfo );\n         endListing();\n \n         assert( isInside( Writer::Object ) );\ndiff --git a/src/catch2/reporters/catch_reporter_junit.cpp b/src/catch2/reporters/catch_reporter_junit.cpp\n--- a/src/catch2/reporters/catch_reporter_junit.cpp\n+++ b/src/catch2/reporters/catch_reporter_junit.cpp\n@@ -74,7 +74,7 @@ namespace Catch {\n \n         static void normalizeNamespaceMarkers(std::string& str) {\n             std::size_t pos = str.find( \"::\" );\n-            while ( pos != str.npos ) {\n+            while ( pos != std::string::npos ) {\n                 str.replace( pos, 2, \".\" );\n                 pos += 1;\n                 pos = str.find( \"::\", pos );\ndiff --git a/src/catch2/reporters/catch_reporter_multi.hpp b/src/catch2/reporters/catch_reporter_multi.hpp\n--- a/src/catch2/reporters/catch_reporter_multi.hpp\n+++ b/src/catch2/reporters/catch_reporter_multi.hpp\n@@ -53,7 +53,7 @@ namespace Catch {\n \n         void assertionEnded( AssertionStats const& assertionStats ) override;\n         void sectionEnded( SectionStats const& sectionStats ) override;\n-        void testCasePartialEnded(TestCaseStats const& testInfo, uint64_t partNumber) override;\n+        void testCasePartialEnded(TestCaseStats const& testStats, uint64_t partNumber) override;\n         void testCaseEnded( TestCaseStats const& testCaseStats ) override;\n         void testRunEnded( TestRunStats const& testRunStats ) override;\n \ndiff --git a/src/catch2/reporters/catch_reporter_sonarqube.hpp b/src/catch2/reporters/catch_reporter_sonarqube.hpp\n--- a/src/catch2/reporters/catch_reporter_sonarqube.hpp\n+++ b/src/catch2/reporters/catch_reporter_sonarqube.hpp\n@@ -37,7 +37,7 @@ namespace Catch {\n             xml.endElement();\n         }\n \n-        void writeRun( TestRunNode const& groupNode );\n+        void writeRun( TestRunNode const& runNode );\n \n         void writeTestFile(StringRef filename, std::vector<TestCaseNode const*> const& testCaseNodes);\n \ndiff --git a/src/catch2/reporters/catch_reporter_teamcity.hpp b/src/catch2/reporters/catch_reporter_teamcity.hpp\n--- a/src/catch2/reporters/catch_reporter_teamcity.hpp\n+++ b/src/catch2/reporters/catch_reporter_teamcity.hpp\n@@ -35,8 +35,8 @@ namespace Catch {\n             return \"Reports test results as TeamCity service messages\"s;\n         }\n \n-        void testRunStarting( TestRunInfo const& groupInfo ) override;\n-        void testRunEnded( TestRunStats const& testGroupStats ) override;\n+        void testRunStarting( TestRunInfo const& runInfo ) override;\n+        void testRunEnded( TestRunStats const& runStats ) override;\n \n \n         void assertionEnded(AssertionStats const& assertionStats) override;\n",
        "test_patch": "diff --git a/src/catch2/catch_test_case_info.hpp b/src/catch2/catch_test_case_info.hpp\n--- a/src/catch2/catch_test_case_info.hpp\n+++ b/src/catch2/catch_test_case_info.hpp\n@@ -68,7 +68,7 @@ namespace Catch {\n     struct TestCaseInfo : Detail::NonCopyable {\n \n         TestCaseInfo(StringRef _className,\n-                     NameAndTags const& _tags,\n+                     NameAndTags const& _nameAndTags,\n                      SourceLineInfo const& _lineInfo);\n \n         bool isHidden() const;\ndiff --git a/src/catch2/internal/catch_test_registry.hpp b/src/catch2/internal/catch_test_registry.hpp\n--- a/src/catch2/internal/catch_test_registry.hpp\n+++ b/src/catch2/internal/catch_test_registry.hpp\n@@ -95,7 +95,7 @@ struct AutoReg : Detail::NonCopyable {\n namespace Catch {\n     namespace Detail {\n         struct DummyUse {\n-            DummyUse( void ( * )( int ) );\n+            DummyUse( void ( * )( int ), Catch::NameAndTags const& );\n         };\n     } // namespace Detail\n } // namespace Catch\n@@ -107,18 +107,18 @@ namespace Catch {\n // tests can compile. The redefined `TEST_CASE` shadows this with param.\n static int catchInternalSectionHint = 0;\n \n-#    define INTERNAL_CATCH_TESTCASE2( fname )                              \\\n+#    define INTERNAL_CATCH_TESTCASE2( fname, ... )                         \\\n         static void fname( int );                                          \\\n         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \\\n         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                   \\\n         static const Catch::Detail::DummyUse INTERNAL_CATCH_UNIQUE_NAME(   \\\n-            dummyUser )( &(fname) );                                       \\\n+            dummyUser )( &(fname), Catch::NameAndTags{ __VA_ARGS__ } );    \\\n         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                            \\\n         static void fname( [[maybe_unused]] int catchInternalSectionHint ) \\\n             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\n #    define INTERNAL_CATCH_TESTCASE( ... ) \\\n-        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ) )\n+        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ), __VA_ARGS__ )\n \n \n #endif // CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT\ndiff --git a/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp b/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n--- a/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n+++ b/tests/ExtraTests/X22-BenchmarksInCumulativeReporter.cpp\n@@ -34,7 +34,7 @@ class CumulativeBenchmarkReporter final : public Catch::CumulativeReporterBase {\n         return \"Custom reporter for testing cumulative reporter base\";\n     }\n \n-    virtual void testRunEndedCumulative() override;\n+    void testRunEndedCumulative() override;\n };\n \n CATCH_REGISTER_REPORTER(\"testReporter\", CumulativeBenchmarkReporter)\ndiff --git a/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp b/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n--- a/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n+++ b/tests/ExtraTests/X29-CustomArgumentsForReporters.cpp\n@@ -36,6 +36,7 @@ class TestReporter : public Catch::StreamingReporterBase {\n \n     void testRunStarting( Catch::TestRunInfo const& ) override {\n         std::vector<std::pair<std::string, std::string>> options;\n+        options.reserve( m_customOptions.size() );\n         for ( auto const& kv : m_customOptions ) {\n             options.push_back( kv );\n         }\ndiff --git a/tests/ExtraTests/X91-AmalgamatedCatch.cpp b/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n--- a/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n+++ b/tests/ExtraTests/X91-AmalgamatedCatch.cpp\n@@ -16,10 +16,10 @@\n TEST_CASE(\"Just a dummy test\") {\n     auto i = GENERATE(1, 2, 3);\n     SECTION(\"a\") {\n-        REQUIRE(1 != 4);\n+        REQUIRE(i != 4);\n     }\n     SECTION(\"b\") {\n-        CHECK(1 != 5);\n+        CHECK(i != 5);\n     }\n     REQUIRE_THAT(1,\n                  Catch::Matchers::Predicate<int>([](int i) {\ndiff --git a/tests/SelfTest/IntrospectiveTests/Details.tests.cpp b/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/Details.tests.cpp\n@@ -120,13 +120,13 @@ TEST_CASE( \"Optional supports move ops\", \"[optional][approvals]\" ) {\n     }\n     SECTION( \"Move construction from optional\" ) {\n         Optional<MoveChecker> opt_B( CATCH_MOVE( opt_A ) );\n-        REQUIRE( opt_A->has_moved );\n+        REQUIRE( opt_A->has_moved ); // NOLINT(clang-analyzer-cplusplus.Move)\n     }\n     SECTION( \"Move assignment from optional\" ) {\n         Optional<MoveChecker> opt_B( opt_A );\n         REQUIRE_FALSE( opt_A->has_moved );\n         opt_B = CATCH_MOVE( opt_A );\n-        REQUIRE( opt_A->has_moved );\n+        REQUIRE( opt_A->has_moved ); // NOLINT(clang-analyzer-cplusplus.Move)\n     }\n }\n \ndiff --git a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/GeneratorsImpl.tests.cpp\n@@ -18,7 +18,6 @@\n #include <catch2/generators/catch_generators_adapters.hpp>\n #include <catch2/generators/catch_generators_random.hpp>\n #include <catch2/generators/catch_generators_range.hpp>\n-#include <catch2/generators/catch_generator_exception.hpp>\n \n // Tests of generator implementation details\n TEST_CASE(\"Generators internals\", \"[generators][internals]\") {\ndiff --git a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/Reporters.tests.cpp\n@@ -107,7 +107,7 @@ TEST_CASE( \"Reporter's write listings to provided stream\", \"[reporters]\" ) {\n     for (auto const& factory : factories) {\n         INFO(\"Tested reporter: \" << factory.first);\n         auto sstream = Catch::Detail::make_unique<StringIStream>();\n-        auto& sstreamRef = *sstream.get();\n+        auto& sstreamRef = *sstream;\n \n         Catch::ConfigData cfg_data;\n         cfg_data.rngSeed = 1234;\ndiff --git a/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp b/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/StringManip.tests.cpp\n@@ -57,6 +57,17 @@ TEST_CASE(\"replaceInPlace\", \"[string-manip]\") {\n         CHECK_FALSE(Catch::replaceInPlace(letters, \"x\", \"z\"));\n         CHECK(letters == letters);\n     }\n+    SECTION(\"no replace in already-replaced string\") {\n+        SECTION(\"lengthening\") {\n+            CHECK(Catch::replaceInPlace(letters, \"c\", \"cc\"));\n+            CHECK(letters == \"abccdefccg\");\n+        }\n+        SECTION(\"shortening\") {\n+            std::string s = \"----\";\n+            CHECK(Catch::replaceInPlace(s, \"--\", \"-\"));\n+            CHECK(s == \"--\");\n+        }\n+    }\n     SECTION(\"escape '\") {\n         std::string s = \"didn't\";\n         CHECK(Catch::replaceInPlace(s, \"'\", \"|'\"));\ndiff --git a/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp b/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TestSpec.tests.cpp\n@@ -236,7 +236,7 @@ TEST_CASE( \"Parse test names and tags\", \"[command-line][test-spec][approvals]\" )\n         CHECK( spec.matches( *tcD ) == false );\n     }\n     SECTION( \"two wildcarded names\" ) {\n-        TestSpec spec = parseTestSpec( \"\\\"longer*\\\"\\\"*spaces\\\"\" );\n+        TestSpec spec = parseTestSpec( R\"(\"longer*\"\"*spaces\")\" );\n         CHECK( spec.hasFilters() == true );\n         CHECK( spec.matches( *tcA ) == false );\n         CHECK( spec.matches( *tcB ) == false );\ndiff --git a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n--- a/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n+++ b/tests/SelfTest/IntrospectiveTests/TextFlow.tests.cpp\n@@ -152,7 +152,7 @@ TEST_CASE( \"TextFlow::Column respects indentation for empty lines\",\n \n     std::string written = as_written(col);\n \n-    REQUIRE(as_written(col) == \"  \\n  \\n  third line\");\n+    REQUIRE(written == \"  \\n  \\n  third line\");\n }\n \n TEST_CASE( \"TextFlow::Column leading/trailing whitespace\",\ndiff --git a/tests/SelfTest/UsageTests/Benchmark.tests.cpp b/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n--- a/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Benchmark.tests.cpp\n@@ -90,14 +90,14 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n         };\n         REQUIRE(v.size() == size);\n \n-        int array[size];\n+        int array[size] {};\n         BENCHMARK(\"A fixed size array that should require no allocations\") {\n             for (int i = 0; i < size; ++i)\n                 array[i] = i;\n         };\n         int sum = 0;\n-        for (int i = 0; i < size; ++i)\n-            sum += array[i];\n+        for (int val : array)\n+            sum += val;\n         REQUIRE(sum > size);\n \n         SECTION(\"XYZ\") {\n@@ -121,8 +121,8 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n                 runs = benchmarkIndex;\n             };\n \n-            for (size_t i = 0; i < v.size(); ++i) {\n-                REQUIRE(v[i] == runs);\n+            for (int val : v) {\n+                REQUIRE(val == runs);\n             }\n         }\n     }\n@@ -135,8 +135,8 @@ TEST_CASE(\"Benchmark containers\", \"[!benchmark]\") {\n             for (int i = 0; i < size; ++i)\n                 v[i] = generated;\n         };\n-        for (size_t i = 0; i < v.size(); ++i) {\n-            REQUIRE(v[i] == generated);\n+        for (int val : v) {\n+            REQUIRE(val == generated);\n         }\n     }\n \ndiff --git a/tests/SelfTest/UsageTests/Class.tests.cpp b/tests/SelfTest/UsageTests/Class.tests.cpp\n--- a/tests/SelfTest/UsageTests/Class.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Class.tests.cpp\n@@ -39,7 +39,7 @@ namespace {\n     };\n \n     template <typename T> struct Template_Fixture_2 {\n-        Template_Fixture_2() {}\n+        Template_Fixture_2() = default;\n \n         T m_a;\n     };\ndiff --git a/tests/SelfTest/UsageTests/Exception.tests.cpp b/tests/SelfTest/UsageTests/Exception.tests.cpp\n--- a/tests/SelfTest/UsageTests/Exception.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Exception.tests.cpp\n@@ -119,7 +119,7 @@ TEST_CASE( \"When unchecked exceptions are thrown, but caught, they do not affect\n     try {\n         throw std::domain_error( \"unexpected exception\" );\n     }\n-    catch(...) {}\n+    catch(...) {} // NOLINT(bugprone-empty-catch)\n }\n \n \n@@ -152,7 +152,7 @@ TEST_CASE( \"Custom exceptions can be translated when testing for throwing as som\n }\n \n TEST_CASE( \"Unexpected exceptions can be translated\", \"[.][failing][!throws]\"  ) {\n-    throw double( 3.14 );\n+    throw double( 3.14 ); // NOLINT(readability-redundant-casting): the type is important here, so we want to be explicit\n }\n \n TEST_CASE(\"Thrown string literals are translated\", \"[.][failing][!throws]\") {\ndiff --git a/tests/SelfTest/UsageTests/Matchers.tests.cpp b/tests/SelfTest/UsageTests/Matchers.tests.cpp\n--- a/tests/SelfTest/UsageTests/Matchers.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Matchers.tests.cpp\n@@ -1027,7 +1027,6 @@ TEST_CASE( \"Combining MatchNotOfGeneric does not nest\",\n }\n \n struct EvilAddressOfOperatorUsed : std::exception {\n-    EvilAddressOfOperatorUsed() {}\n     const char* what() const noexcept override {\n         return \"overloaded address-of operator of matcher was used instead of \"\n                \"std::addressof\";\n@@ -1035,7 +1034,6 @@ struct EvilAddressOfOperatorUsed : std::exception {\n };\n \n struct EvilCommaOperatorUsed : std::exception {\n-    EvilCommaOperatorUsed() {}\n     const char* what() const noexcept override {\n         return \"overloaded comma operator of matcher was used\";\n     }\n@@ -1073,7 +1071,6 @@ struct ImmovableMatcher : Catch::Matchers::MatcherGenericBase {\n };\n \n struct MatcherWasMovedOrCopied : std::exception {\n-    MatcherWasMovedOrCopied() {}\n     const char* what() const noexcept override {\n         return \"attempted to copy or move a matcher\";\n     }\n@@ -1081,17 +1078,20 @@ struct MatcherWasMovedOrCopied : std::exception {\n \n struct ThrowOnCopyOrMoveMatcher : Catch::Matchers::MatcherGenericBase {\n     ThrowOnCopyOrMoveMatcher() = default;\n-    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher const& ):\n-        Catch::Matchers::MatcherGenericBase() {\n+\n+    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher const& other ):\n+        Catch::Matchers::MatcherGenericBase( other ) {\n         throw MatcherWasMovedOrCopied();\n     }\n-    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher&& ):\n-        Catch::Matchers::MatcherGenericBase() {\n+    // NOLINTNEXTLINE(performance-noexcept-move-constructor)\n+    [[noreturn]] ThrowOnCopyOrMoveMatcher( ThrowOnCopyOrMoveMatcher&& other ):\n+        Catch::Matchers::MatcherGenericBase( CATCH_MOVE(other) ) {\n         throw MatcherWasMovedOrCopied();\n     }\n     ThrowOnCopyOrMoveMatcher& operator=( ThrowOnCopyOrMoveMatcher const& ) {\n         throw MatcherWasMovedOrCopied();\n     }\n+    // NOLINTNEXTLINE(performance-noexcept-move-constructor)\n     ThrowOnCopyOrMoveMatcher& operator=( ThrowOnCopyOrMoveMatcher&& ) {\n         throw MatcherWasMovedOrCopied();\n     }\ndiff --git a/tests/SelfTest/UsageTests/Message.tests.cpp b/tests/SelfTest/UsageTests/Message.tests.cpp\n--- a/tests/SelfTest/UsageTests/Message.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Message.tests.cpp\n@@ -80,20 +80,20 @@ TEST_CASE( \"Output from all sections is reported\", \"[failing][messages][.]\" ) {\n \n TEST_CASE( \"Standard output from all sections is reported\", \"[messages][.]\" ) {\n     SECTION( \"one\" ) {\n-        std::cout << \"Message from section one\" << std::endl;\n+        std::cout << \"Message from section one\\n\";\n     }\n \n     SECTION( \"two\" ) {\n-        std::cout << \"Message from section two\" << std::endl;\n+        std::cout << \"Message from section two\\n\";\n     }\n }\n \n TEST_CASE( \"Standard error is reported and redirected\", \"[messages][.][approvals]\" ) {\n     SECTION( \"std::cerr\" ) {\n-        std::cerr << \"Write to std::cerr\" << std::endl;\n+        std::cerr << \"Write to std::cerr\\n\";\n     }\n     SECTION( \"std::clog\" ) {\n-        std::clog << \"Write to std::clog\" << std::endl;\n+        std::clog << \"Write to std::clog\\n\";\n     }\n     SECTION( \"Interleaved writes to cerr and clog\" ) {\n         std::cerr << \"Inter\";\n@@ -101,7 +101,7 @@ TEST_CASE( \"Standard error is reported and redirected\", \"[messages][.][approvals\n         std::cerr << ' ';\n         std::clog << \"writes\";\n         std::cerr << \" to error\";\n-        std::clog << \" streams\" << std::endl;\n+        std::clog << \" streams\\n\" << std::flush;\n     }\n }\n \ndiff --git a/tests/SelfTest/UsageTests/Misc.tests.cpp b/tests/SelfTest/UsageTests/Misc.tests.cpp\n--- a/tests/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Misc.tests.cpp\n@@ -158,9 +158,9 @@ TEST_CASE( \"looped tests\", \"[.][failing]\" ) {\n }\n \n TEST_CASE( \"Sends stuff to stdout and stderr\", \"[.]\" ) {\n-    std::cout << \"A string sent directly to stdout\" << std::endl;\n-    std::cerr << \"A string sent directly to stderr\" << std::endl;\n-    std::clog << \"A string sent to stderr via clog\" << std::endl;\n+    std::cout << \"A string sent directly to stdout\\n\" << std::flush;\n+    std::cerr << \"A string sent directly to stderr\\n\" << std::flush;\n+    std::clog << \"A string sent to stderr via clog\\n\" << std::flush;\n }\n \n TEST_CASE( \"null strings\" ) {\n@@ -396,7 +396,7 @@ TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product\n using MyTypes = std::tuple<int, char, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_arithmetic<TestType>::value);\n }\n \n struct NonDefaultConstructibleType {\n@@ -406,7 +406,7 @@ struct NonDefaultConstructibleType {\n using MyNonDefaultConstructibleTypes = std::tuple<NonDefaultConstructibleType, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside non-default-constructible std::tuple\", \"[template][list]\", MyNonDefaultConstructibleTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_trivially_copyable<TestType>::value);\n }\n \n struct NonCopyableAndNonMovableType {\n@@ -421,7 +421,7 @@ struct NonCopyableAndNonMovableType {\n using NonCopyableAndNonMovableTypes = std::tuple<NonCopyableAndNonMovableType, float>;\n TEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside non-copyable and non-movable std::tuple\", \"[template][list]\", NonCopyableAndNonMovableTypes)\n {\n-    REQUIRE(sizeof(TestType) > 0);\n+    REQUIRE(std::is_default_constructible<TestType>::value);\n }\n \n // https://github.com/philsquared/Catch/issues/166\ndiff --git a/tests/SelfTest/UsageTests/Tricky.tests.cpp b/tests/SelfTest/UsageTests/Tricky.tests.cpp\n--- a/tests/SelfTest/UsageTests/Tricky.tests.cpp\n+++ b/tests/SelfTest/UsageTests/Tricky.tests.cpp\n@@ -261,7 +261,7 @@ TEST_CASE( \"non streamable - with conv. op\", \"[Tricky]\" )\n \n inline void foo() {}\n \n-typedef void (*fooptr_t)();\n+using fooptr_t = void (*)();\n \n TEST_CASE( \"Comparing function pointers\", \"[Tricky][function pointer]\" )\n {\n@@ -281,7 +281,7 @@ struct S\n \n TEST_CASE( \"Comparing member function pointers\", \"[Tricky][member function pointer][approvals]\" )\n {\n-    typedef void (S::*MF)();\n+    using MF = void (S::*)();\n     MF m = &S::f;\n \n     CHECK( m == &S::f );\n",
        "problem_statement": "Wunused-variable in (DYNAMIC_)SECTION when CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT is enabled\n**Describe the bug**\r\n\r\nIn static analysis mode, the argument of `SECTION`/`DYNAMIC_SECTION` is not evaluated. If it contains\r\na variable that is used only there, it'll lead to `Wunused-variable` warning.\r\n\r\n\r\n**Expected behavior**\r\nNo warning\r\n\r\n**Reproduction steps**\r\n\r\nhttps://compiler-explorer.com/z/K9fxKGaz4\r\n\r\n**Platform information:**\r\n - Compiler+version: clang (clang-tidy)\r\n - Catch version: devel\r\n\n",
        "hints_text": "",
        "created_at": "2024-02-19T17:20:35Z",
        "version": "3.5"
    }
}