{
    "task_id": "catchorg__Catch2-1468",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-1468_2025-06-26_18-55-36",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 1468,
        "instance_id": "catchorg__Catch2-1468",
        "issue_numbers": [
            "1454"
        ],
        "base_commit": "4902cd721586822ded795afe0c418c553137306a",
        "patch": "diff --git a/include/catch.hpp b/include/catch.hpp\n--- a/include/catch.hpp\n+++ b/include/catch.hpp\n@@ -148,9 +148,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -226,9 +230,13 @@\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )\n #endif\n \n \n@@ -313,9 +321,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n // \"BDD-style\" convenience wrappers\n@@ -384,9 +396,13 @@ using Catch::Detail::Approx;\n #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #else\n #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) ) )\n #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), className ) )\n+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )\n+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\n #endif\n \n #define STATIC_REQUIRE( ... )       (void)(0)\ndiff --git a/include/internal/catch_meta.hpp b/include/internal/catch_meta.hpp\nnew file mode 100644\n--- /dev/null\n+++ b/include/internal/catch_meta.hpp\n@@ -0,0 +1,76 @@\n+/*\n+ *  Created by Jozef on 02/12/2018.\n+ *  Copyright 2018 Two Blue Cubes Ltd. All rights reserved.\n+ *\n+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying\n+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n+ */\n+\n+#ifndef TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+#define TWOBLUECUBES_CATCH_META_HPP_INCLUDED\n+\n+template< typename... >\n+struct TypeList{};\n+\n+template< typename... >\n+struct append;\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t>\n+struct append< L1<E1...>, L2<E2...> >\n+{\n+\tusing type = L1<E1..., E2...>;\n+};\n+\n+template< template<typename...> class L1\n+\t, typename...E1\n+\t, template<typename...> class L2\n+\t, typename...E2\n+\t, typename...Rest\n+\t>\n+struct append< L1<E1...>, L2<E2...>, Rest...>\n+{\n+\tusing type = typename append< L1<E1..., E2...>, Rest... >::type;\n+};\n+\n+template< template<typename...> class\n+        , typename...\n+        >\n+struct rewrap;\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , typename...elems\n+        >\n+struct rewrap<Container, List<elems...>>\n+{\n+    using type = TypeList< Container< elems... > >;\n+};\n+\n+template< template<typename...> class Container\n+        , template<typename...> class List\n+        , class...Elems\n+        , typename...Elements>\n+struct rewrap<Container, List<Elems...>, Elements...>\n+{\n+    using type = typename append<TypeList<Container<Elems...>>, typename rewrap<Container, Elements...>::type>::type;\n+};\n+\n+template< template<typename...> class...Containers >\n+struct combine\n+{\n+    template< typename...Types >\n+    struct with_types\n+    {\n+        template< template <typename...> class Final >\n+        struct into\n+        {\n+            using type = typename append<Final<>, typename rewrap<Containers, Types...>::type...>::type;\n+        };\n+    };\n+};\n+\n+#endif // TWOBLUECUBES_CATCH_META_HPP_INCLUDED\ndiff --git a/include/internal/catch_preprocessor.hpp b/include/internal/catch_preprocessor.hpp\n--- a/include/internal/catch_preprocessor.hpp\n+++ b/include/internal/catch_preprocessor.hpp\n@@ -71,4 +71,9 @@\n #define INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME(Name, ...) INTERNAL_CATCH_TEMPLATE_UNIQUE_NAME1(Name, INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))\n #endif\n \n+#define INTERNAL_CATCH_MAKE_TYPE_LIST(types) TypeList<INTERNAL_CATCH_REMOVE_PARENS(types)>\n+\n+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(types)\\\n+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,INTERNAL_CATCH_REMOVE_PARENS(types))\n+\n #endif // TWOBLUECUBES_CATCH_PREPROCESSOR_HPP_INCLUDED\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -118,6 +118,7 @@ set(INTERNAL_HEADERS\n         ${HEADER_DIR}/internal/catch_matchers_string.h\n         ${HEADER_DIR}/internal/catch_matchers_vector.h\n         ${HEADER_DIR}/internal/catch_message.h\n+        ${HEADER_DIR}/internal/catch_meta.hpp\n         ${HEADER_DIR}/internal/catch_objc.hpp\n         ${HEADER_DIR}/internal/catch_objc_arc.hpp\n         ${HEADER_DIR}/internal/catch_option.hpp\n",
        "test_patch": "diff --git a/docs/test-cases-and-sections.md b/docs/test-cases-and-sections.md\n--- a/docs/test-cases-and-sections.md\n+++ b/docs/test-cases-and-sections.md\n@@ -95,7 +95,8 @@ Other than the additional prefixes and the formatting in the console reporter th\n ## Type parametrised test cases\n \n In addition to `TEST_CASE`s, Catch2 also supports test cases parametrised\n-by type, in the form of `TEMPLATE_TEST_CASE`.\n+by types, in the form of `TEMPLATE_TEST_CASE` and\n+`TEMPLATE_PRODUCT_TEST_CASE`.\n \n * **TEMPLATE_TEST_CASE(** _test name_ , _tags_,  _type1_, _type2_, ..., _typen_ **)**\n \n@@ -147,9 +148,48 @@ TEMPLATE_TEST_CASE( \"vectors can be sized and resized\", \"[vector][template]\", in\n }\n ```\n \n+* **TEMPLATE_PRODUCT_TEST_CASE(** _test name_ , _tags_, (_template-type1_, _template-type2_, ..., _template-typen_), (_template-arg1_, _template-arg2_, ..., _template-argm_) **)**\n+\n+_template-type1_ through _template-typen_ is list of template template\n+types which should be combined with each of _template-arg1_ through\n+ _template-argm_, resulting in _n * m_ test cases. Inside the test case,\n+the resulting type is available under the name of `TestType`.\n+\n+To specify more than 1 type as a single _template-type_ or _template-arg_,\n+you must enclose the types in an additional set of parentheses, e.g.\n+`((int, float), (char, double))` specifies 2 template-args, each\n+consisting of 2 concrete types (`int`, `float` and `char`, `double`\n+respectively). You can also omit the outer set of parentheses if you\n+specify only one type as the full set of either the _template-types_,\n+or the _template-args_.\n+\n+\n+Example:\n+```\n+template< typename T>\n+struct Foo {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+```\n+\n+You can also have different arities in the _template-arg_ packs:\n+```\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    TestType x;\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+```\n+\n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE` or `TEMPLATE_PRODUCT_TEST_CASE`, the limit\n+is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/docs/test-fixtures.md b/docs/test-fixtures.md\n--- a/docs/test-fixtures.md\n+++ b/docs/test-fixtures.md\n@@ -31,16 +31,22 @@ class UniqueTestsFixture {\n The two test cases here will create uniquely-named derived classes of UniqueTestsFixture and thus can access the `getID()` protected method and `conn` member variables. This ensures that both the test cases are able to create a DBConnection using the same method (DRY principle) and that any ID's created are unique such that the order that tests are executed does not matter.\n \n \n-Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` that can be used together\n-with templated fixtures to perform tests for multiple different types.\n-However, unlike `TEST_CASE_METHOD`, `TEMPLATE_TEST_CASE_METHOD` requires\n-the tag specification to be non-empty, as it is followed by further macros\n-arguments.\n+Catch2 also provides `TEMPLATE_TEST_CASE_METHOD` and\n+`TEMPLATE_PRODUCT_TEST_CASE_METHOD` that can be used together\n+with templated fixtures and templated template fixtures to perform\n+tests for multiple different types. Unlike `TEST_CASE_METHOD`,\n+`TEMPLATE_TEST_CASE_METHOD` and `TEMPLATE_PRODUCT_TEST_CASE_METHOD` do\n+require the tag specification to be non-empty, as it is followed by\n+further macro arguments.\n \n Also note that, because of limitations of the C++ preprocessor, if you\n want to specify a type with multiple template parameters, you need to\n enclose it in parentheses, e.g. `std::map<int, std::string>` needs to be\n passed as `(std::map<int, std::string>)`.\n+In the case of `TEMPLATE_PRODUCT_TEST_CASE_METHOD`, if a member of the\n+type list should consist of more than single type, it needs to be enclosed\n+in another pair of parentheses, e.g. `(std::map, std::pair)` and\n+`((int, float), (char, double))`.\n \n Example:\n ```cpp\n@@ -54,11 +60,29 @@ struct Template_Fixture {\n TEMPLATE_TEST_CASE_METHOD(Template_Fixture,\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds\", \"[class][template]\", int, float, double) {\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n+\n+template<typename T>\n+struct Template_Template_Fixture {\n+    Template_Template_Fixture() {}\n+\n+    T m_a;\n+};\n+\n+template<typename T>\n+struct Foo_class {\n+    size_t size() {\n+        return 0;\n+    }\n+};\n+\n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Template_Fixture, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test succeeds\", \"[class][template]\", (Foo_class, std::vector), int) {\n+    REQUIRE( Template_Template_Fixture<TestType>::m_a.size() == 0 );\n+}\n ```\n \n _While there is an upper limit on the number of types you can specify\n-in single `TEMPLATE_TEST_CASE`, the limit is very high and should not\n-be encountered in practice._\n+in single `TEMPLATE_TEST_CASE_METHOD` or `TEMPLATE_PRODUCT_TEST_CASE_METHOD`,\n+the limit is very high and should not be encountered in practice._\n \n ---\n \ndiff --git a/include/internal/catch_test_registry.h b/include/internal/catch_test_registry.h\n--- a/include/internal/catch_test_registry.h\n+++ b/include/internal/catch_test_registry.h\n@@ -14,6 +14,7 @@\n #include \"catch_stringref.h\"\n #include \"catch_type_traits.hpp\"\n #include \"catch_preprocessor.hpp\"\n+#include \"catch_meta.hpp\"\n \n namespace Catch {\n \n@@ -150,6 +151,38 @@ struct AutoReg : NonCopyable {\n             return 0;\\\n         }();\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, TmplTypes, TypesList) \\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\\n+        template<typename TestType> static void TestFuncName();       \\\n+        namespace {                                                   \\\n+            template<typename... Types>                               \\\n+            struct TestName {                                         \\\n+                TestName() {                                          \\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)       \\\n+                    int index = 0;                                    \\\n+                    using expander = int[];                           \\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }                                                     \\\n+            };                                                        \\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)> \\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestName>::type; \\\n+                TestInit();                                           \\\n+                return 0;                                             \\\n+            }();                                                      \\\n+        }                                                             \\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS                    \\\n+        template<typename TestType>                                   \\\n+        static void TestFuncName()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ),Name,Tags,__VA_ARGS__)\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, ... ) \\\n         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n         namespace{ \\\n@@ -180,4 +213,39 @@ struct AutoReg : NonCopyable {\n         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, __VA_ARGS__ ) )\n #endif\n \n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, TmplTypes, TypesList)\\\n+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \\\n+                void test();\\\n+            };\\\n+        namespace {\\\n+            template<typename...Types>\\\n+            struct TestNameClass{\\\n+                TestNameClass(){\\\n+                    CATCH_INTERNAL_CHECK_UNIQUE_TYPES(Types...)\\\n+                    int index = 0;\\\n+                    using expander = int[];\\\n+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name \" - \" + Catch::StringMaker<int>::convert(index++), Tags } ), 0)... };/* NOLINT */ \\\n+                }\\\n+            };\\\n+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\\\n+                using TestInit = combine<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>\\\n+                            ::with_types<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(TypesList)>::into<TestNameClass>::type;\\\n+                TestInit();\\\n+                return 0;\\\n+            }(); \\\n+        }\\\n+        CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS \\\n+        template<typename TestType> \\\n+        void TestName<TestType>::test()\n+\n+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ )\n+#else\n+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\\n+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, __VA_ARGS__ ) )\n+#endif\n+\n #endif // TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED\ndiff --git a/projects/SelfTest/UsageTests/Class.tests.cpp b/projects/SelfTest/UsageTests/Class.tests.cpp\n--- a/projects/SelfTest/UsageTests/Class.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Class.tests.cpp\n@@ -46,6 +46,18 @@ struct Template_Fixture {\n     T m_a;\n };\n \n+template<typename T>\n+struct Template_Fixture_2 {\n+    Template_Fixture_2() {}\n+\n+    T m_a;\n+};\n+\n+template< typename T>\n+struct Template_Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n \n@@ -62,6 +74,11 @@ TEMPLATE_TEST_CASE_METHOD(Template_Fixture, \"A TEMPLATE_TEST_CASE_METHOD based t\n     REQUIRE( Template_Fixture<TestType>::m_a == 1 );\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that succeeds\",\"[class][template][product]\",(std::vector,Template_Foo),(int,float))\n+{\n+    REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 0 );\n+}\n+\n // We should be able to write our tests within a different namespace\n namespace Inner\n {\n@@ -74,6 +91,11 @@ namespace Inner\n     {\n         REQUIRE( Template_Fixture<TestType>::m_a == 2 );\n     }\n+\n+    TEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Fixture_2, \"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test run that fails\",\"[.][class][template][product][failing]\",(std::vector,Template_Foo),(int,float))\n+    {\n+        REQUIRE( Template_Fixture_2<TestType>::m_a.size() == 1 );\n+    }\n }\n \n \ndiff --git a/projects/SelfTest/UsageTests/Misc.tests.cpp b/projects/SelfTest/UsageTests/Misc.tests.cpp\n--- a/projects/SelfTest/UsageTests/Misc.tests.cpp\n+++ b/projects/SelfTest/UsageTests/Misc.tests.cpp\n@@ -61,6 +61,11 @@ CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\n static AutoTestReg autoTestReg;\n CATCH_INTERNAL_UNSUPPRESS_GLOBALS_WARNINGS\n \n+template<typename T>\n+struct Foo {\n+    size_t size() { return 0; }\n+};\n+\n #endif\n \n TEST_CASE( \"random SECTION tests\", \"[.][sections][failing]\" ) {\n@@ -301,6 +306,15 @@ TEMPLATE_TEST_CASE( \"TemplateTest: vectors can be sized and resized\", \"[vector][\n     }\n }\n \n+TEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\n+    TestType x;\n+    REQUIRE(x.size() == 0);\n+}\n+\n+TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\n+    REQUIRE(std::tuple_size<TestType>::value >= 1);\n+}\n+\n // https://github.com/philsquared/Catch/issues/166\n TEST_CASE(\"A couple of nested sections followed by a failure\", \"[failing][.]\") {\n     SECTION(\"Outer\")\n",
        "problem_statement": "TEMPLATE_TEST_CASE does not support template templates\n## Description\r\nTEMPLATE_TEST_CASE only supports substitution of simple types, and not template templates.\r\n\r\n### Steps to reproduce\r\n\r\n```cpp\r\ntemplate <template <typename> typename T>\r\nstruct Foo { };\r\n\r\nTEMPLATE_TEST_CASE(\"instantiate a template template with int\", \"\", Foo) {\r\n     using T = TestType<int>;  // ... or something\r\n}\r\n```\n",
        "hints_text": "@porpoises in your example you probably wanted to do\r\n```c++\r\ntemplate<typename T>\r\nstruct Foo {};\r\n```\r\nin linked PR #1457 i added support for this kind of types. For this kind of tests you will have to use\r\n`TEMPLATE_TEMPLATE_TEST_CASE`.\r\n\nAwesome, thanks!",
        "created_at": "2018-12-06T19:16:07Z",
        "version": "2.5"
    }
}