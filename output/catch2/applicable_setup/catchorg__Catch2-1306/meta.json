{
    "task_id": "catchorg__Catch2-1306",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-1306_2025-06-26_16-39-18",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 1306,
        "instance_id": "catchorg__Catch2-1306",
        "issue_numbers": [
            "1285",
            "1285"
        ],
        "base_commit": "021fcee63667e346c619e04bbae932bcea562334",
        "patch": "diff --git a/include/internal/catch_tostring.h b/include/internal/catch_tostring.h\n--- a/include/internal/catch_tostring.h\n+++ b/include/internal/catch_tostring.h\n@@ -105,7 +105,9 @@ namespace Catch {\n         typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\n             convert(const Fake& value) {\n                 ReusableStringStream rss;\n-                rss << value;\n+                // NB: call using the function-like syntax to avoid ambiguity with\n+                // user-defined templated operator<< under clang.\n+                rss.operator<<(value);\n                 return rss.str();\n         }\n \n",
        "test_patch": "diff --git a/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp b/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n--- a/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n+++ b/projects/SelfTest/UsageTests/ToStringWhich.tests.cpp\n@@ -20,6 +20,7 @@ struct has_operator { };\n struct has_maker {};\n struct has_maker_and_operator {};\n struct has_neither {};\n+struct has_template_operator {};\n \n std::ostream& operator<<(std::ostream& os, const has_operator&) {\n     os << \"operator<<( has_operator )\";\n@@ -31,6 +32,12 @@ std::ostream& operator<<(std::ostream& os, const has_maker_and_operator&) {\n     return os;\n }\n \n+template <typename StreamT>\n+StreamT& operator<<(StreamT& os, const has_template_operator&) {\n+    os << \"operator<<( has_template_operator )\";\n+    return os;\n+}\n+\n namespace Catch {\n     template<>\n     struct StringMaker<has_maker> {\n@@ -69,6 +76,12 @@ TEST_CASE(\"stringify( has_neither )\", \"[toString]\") {\n     REQUIRE( ::Catch::Detail::stringify(item) == \"{ !!! }\" );\n }\n \n+// Call the templated operator\n+TEST_CASE( \"stringify( has_template_operator )\", \"[toString]\" ) {\n+    has_template_operator item;\n+    REQUIRE( ::Catch::Detail::stringify( item ) == \"operator<<( has_template_operator )\" );\n+}\n+\n \n // Vectors...\n \n",
        "problem_statement": "Clang compilation fails when using REQUIRE with custom string classes that overload the << operator\n## Description\r\n\r\nWe have our own custom string class that overloads the << operator, and it's causing issues when using the REQUIRE macro and compiling under Clang in Linux.\r\n\r\nThe REQUIRE line looks like this:\r\n\r\nREQUIRE(str1 == \"Item1\");\r\n\r\nThe error we get is the following:\r\n\r\n19>project_path\\catch.hpp(810,21): error : use of overloaded operator '<<' is ambiguous (with operand types 'Catch::ReusableStringStream' and 'const MyCustomStringClass<char>')\r\n19>                rss << value;\r\n19>                ~~~ ^  ~~~~~\r\n19>project_path\\catch.hpp(829,114): note: in instantiation of function template specialization 'Catch::StringMaker<type, void>::convert<MyCustomStringClass<char> >' requested here\r\n19>            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\r\n19>                                                                                                                 ^\r\n19>project_path\\catch.hpp(1325,42): note: in instantiation of function template specialization 'Catch::Detail::stringify<MyCustomStringClass<char> >' requested here\r\n19>                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\r\n19>                                         ^\r\n19>project_path\\MyCppFile.cpp(243,75): note: in instantiation of member function 'Catch::BinaryExpr<const MyCustomStringClass<char> &, char const &[6]>::streamReconstructedExpression' requested here\r\n19>                    REQUIRE(str1 == \"Item1\");\r\n\r\n\r\n### Extra information\r\n  Disabling stringification with CATCH_CONFIG_DISABLE_STRINGIFICATION does not help solve this issue.\r\n\r\n   Commenting out the following line in catch.hpp fixes the compilation error:\r\n   This code starts in line 801:\r\n\r\n    template <typename T, typename = void>\r\n    struct StringMaker {\r\n        template <typename Fake = T>\r\n        static\r\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\r\n            convert(const Fake& value) {\r\n                ReusableStringStream rss;\r\n\r\n                // this line causes the problem\r\n                // rss << value;\r\n\r\n                return rss.str();\r\n        }\r\n\r\n\r\n* Catch version: **v2.2.2**\r\n* Operating System: **Linux**\r\n* Compiler+version: **Clang**\r\n\nClang compilation fails when using REQUIRE with custom string classes that overload the << operator\n## Description\r\n\r\nWe have our own custom string class that overloads the << operator, and it's causing issues when using the REQUIRE macro and compiling under Clang in Linux.\r\n\r\nThe REQUIRE line looks like this:\r\n\r\nREQUIRE(str1 == \"Item1\");\r\n\r\nThe error we get is the following:\r\n\r\n19>project_path\\catch.hpp(810,21): error : use of overloaded operator '<<' is ambiguous (with operand types 'Catch::ReusableStringStream' and 'const MyCustomStringClass<char>')\r\n19>                rss << value;\r\n19>                ~~~ ^  ~~~~~\r\n19>project_path\\catch.hpp(829,114): note: in instantiation of function template specialization 'Catch::StringMaker<type, void>::convert<MyCustomStringClass<char> >' requested here\r\n19>            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);\r\n19>                                                                                                                 ^\r\n19>project_path\\catch.hpp(1325,42): note: in instantiation of function template specialization 'Catch::Detail::stringify<MyCustomStringClass<char> >' requested here\r\n19>                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\r\n19>                                         ^\r\n19>project_path\\MyCppFile.cpp(243,75): note: in instantiation of member function 'Catch::BinaryExpr<const MyCustomStringClass<char> &, char const &[6]>::streamReconstructedExpression' requested here\r\n19>                    REQUIRE(str1 == \"Item1\");\r\n\r\n\r\n### Extra information\r\n  Disabling stringification with CATCH_CONFIG_DISABLE_STRINGIFICATION does not help solve this issue.\r\n\r\n   Commenting out the following line in catch.hpp fixes the compilation error:\r\n   This code starts in line 801:\r\n\r\n    template <typename T, typename = void>\r\n    struct StringMaker {\r\n        template <typename Fake = T>\r\n        static\r\n        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type\r\n            convert(const Fake& value) {\r\n                ReusableStringStream rss;\r\n\r\n                // this line causes the problem\r\n                // rss << value;\r\n\r\n                return rss.str();\r\n        }\r\n\r\n\r\n* Catch version: **v2.2.2**\r\n* Operating System: **Linux**\r\n* Compiler+version: **Clang**\r\n\n",
        "hints_text": "This seems to be the case when operator<< is templated. Otherwise there should be no ambiguity.\r\nSpecializing StringMaker<> for the type works around the issue.\nThis seems to be the case when operator<< is templated. Otherwise there should be no ambiguity.\r\nSpecializing StringMaker<> for the type works around the issue.",
        "created_at": "2018-06-05T04:30:07Z",
        "version": "2.2"
    }
}