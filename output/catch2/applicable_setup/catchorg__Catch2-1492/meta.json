{
    "task_id": "catchorg__Catch2-1492",
    "setup_info": {
        "repo_path": "testbed/catchorg__Catch2-1492_2025-06-26_18-55-36",
        "repo_cache_path": "testbed/catchorg/Catch2_cache"
    },
    "task_info": {
        "repo": "catchorg/Catch2",
        "pull_number": 1492,
        "instance_id": "catchorg__Catch2-1492",
        "issue_numbers": [
            "1394",
            "1394",
            "1394"
        ],
        "base_commit": "0387fb64ced7c3626b3164207c2d29aadb9ceaf2",
        "patch": "diff --git a/misc/coverage-helper.cpp b/misc/coverage-helper.cpp\n--- a/misc/coverage-helper.cpp\n+++ b/misc/coverage-helper.cpp\n@@ -9,6 +9,38 @@\n #include <string>\n #include <vector>\n \n+std::string escape_arg(const std::string& arg) {\n+    if (arg.empty() == false &&\n+        arg.find_first_of(\" \\t\\n\\v\\\"\") == arg.npos) {\n+        return arg;\n+    }\n+\n+    std::string escaped;\n+    escaped.push_back('\"');\n+    for (auto it = arg.begin(); ; ++it) {\n+        int num_backslashes = 0;\n+\n+        while (it != arg.end() && *it == '\\\\') {\n+            ++it;\n+            ++num_backslashes;\n+        }\n+\n+        if (it == arg.end()) {\n+            escaped.append(num_backslashes * 2, '\\\\');\n+            break;\n+        } else if (*it == '\"') {\n+            escaped.append(num_backslashes * 2 + 1, '\\\\');\n+            escaped.push_back(*it);\n+        } else {\n+            escaped.append(num_backslashes, '\\\\');\n+            escaped.push_back(*it);\n+        }\n+    }\n+    escaped.push_back('\"');\n+\n+    return escaped;\n+}\n+\n \n void create_empty_file(std::string const& path) {\n     std::ofstream ofs(path);\n@@ -60,8 +92,9 @@ std::string windowsify_path(std::string path) {\n void exec_cmd(std::string const& cmd, int log_num, std::string const& path) {\n     std::array<char, 128> buffer;\n #if defined(_WIN32)\n+    // cmd has already been escaped outside this function.\n     auto real_cmd = \"OpenCppCoverage --export_type binary:cov-report\" + std::to_string(log_num)\n-        + \".bin --quiet \" + \"--sources \" + path + \" --cover_children -- \" + cmd;\n+        + \".bin --quiet \" + \"--sources \" + escape_arg(path) + \" --cover_children -- \" + cmd;\n     std::cout << \"=== Marker ===: Cmd: \" << real_cmd << '\\n';\n     std::shared_ptr<FILE> pipe(_popen(real_cmd.c_str(), \"r\"), _pclose);\n #else // Just for testing, in the real world we will always work under WIN32\n@@ -91,9 +124,9 @@ int main(int argc, char** argv) {\n     assert(sep - begin(args) == 2 && \"Structure differs from expected!\");\n \n     auto num = parse_log_file_arg(args[1]);\n-\n+    \n     auto cmdline = std::accumulate(++sep, end(args), std::string{}, [] (const std::string& lhs, const std::string& rhs) {\n-        return lhs + ' ' + rhs;\n+        return lhs + ' ' + escape_arg(rhs);\n     });\n \n     try {\ndiff --git a/projects/CMakeLists.txt b/projects/CMakeLists.txt\n--- a/projects/CMakeLists.txt\n+++ b/projects/CMakeLists.txt\n@@ -345,10 +345,16 @@ set_tests_properties(NoAssertions PROPERTIES PASS_REGULAR_EXPRESSION \"No asserti\n add_test(NAME NoTest COMMAND $<TARGET_FILE:SelfTest> -w NoTests \"___nonexistent_test___\")\n set_tests_properties(NoTest PROPERTIES PASS_REGULAR_EXPRESSION \"No test cases matched\")\n \n+add_test(NAME FilteredSection-1 COMMAND $<TARGET_FILE:SelfTest> \\#1394 -c RunSection)\n+set_tests_properties(FilteredSection-1 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+add_test(NAME FilteredSection-2 COMMAND $<TARGET_FILE:SelfTest> \\#1394\\ nested -c NestedRunSection -c s1)\n+set_tests_properties(FilteredSection-2 PROPERTIES FAIL_REGULAR_EXPRESSION \"No tests ran\")\n+\n # AppVeyor has a Python 2.7 in path, but doesn't have .py files as autorunnable\n add_test(NAME ApprovalTests COMMAND ${PYTHON_EXECUTABLE} ${CATCH_DIR}/scripts/approvalTests.py $<TARGET_FILE:SelfTest>)\n set_tests_properties(ApprovalTests PROPERTIES FAIL_REGULAR_EXPRESSION \"Results differed\")\n \n+\n if (CATCH_USE_VALGRIND)\n     add_test(NAME ValgrindRunTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest>)\n     add_test(NAME ValgrindListTests COMMAND valgrind --leak-check=full --error-exitcode=1 $<TARGET_FILE:SelfTest> --list-tests --verbosity high)\n",
        "test_patch": "diff --git a/include/internal/catch_test_case_tracker.cpp b/include/internal/catch_test_case_tracker.cpp\n--- a/include/internal/catch_test_case_tracker.cpp\n+++ b/include/internal/catch_test_case_tracker.cpp\n@@ -190,6 +190,17 @@ namespace TestCaseTracking {\n         }\n     }\n \n+    bool SectionTracker::isComplete() const {\n+        bool complete = true;\n+\n+        if ((m_filters.empty() || m_filters[0] == \"\") ||\n+             std::find(m_filters.begin(), m_filters.end(),\n+                       m_nameAndLocation.name) != m_filters.end())\n+            complete = TrackerBase::isComplete();\n+        return complete;\n+\n+    }\n+\n     bool SectionTracker::isSectionTracker() const { return true; }\n \n     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {\ndiff --git a/include/internal/catch_test_case_tracker.h b/include/internal/catch_test_case_tracker.h\n--- a/include/internal/catch_test_case_tracker.h\n+++ b/include/internal/catch_test_case_tracker.h\n@@ -140,6 +140,8 @@ namespace TestCaseTracking {\n \n         bool isSectionTracker() const override;\n \n+        bool isComplete() const override;\n+\n         static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );\n \n         void tryOpen();\ndiff --git a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n--- a/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n+++ b/projects/SelfTest/IntrospectiveTests/PartTracker.tests.cpp\n@@ -324,3 +324,33 @@ TEST_CASE( \"Tracker\" ) {\n         //   two sections within a generator\n     }\n }\n+\n+static bool previouslyRun = false;\n+static bool previouslyRunNested = false;\n+\n+TEST_CASE( \"#1394\", \"[.][approvals][tracker]\" ) {\n+    // -- Don't re-run after specified section is done\n+    REQUIRE(previouslyRun == false);\n+\n+    SECTION( \"RunSection\" ) {\n+        previouslyRun = true;\n+    }\n+    SECTION( \"SkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n+\n+TEST_CASE( \"#1394 nested\", \"[.][approvals][tracker]\" ) {\n+    REQUIRE(previouslyRunNested == false);\n+\n+    SECTION( \"NestedRunSection\" ) {\n+        SECTION( \"s1\" ) {\n+            previouslyRunNested = true;\n+        }\n+    }\n+    SECTION( \"NestedSkipSection\" ) {\n+        // cause an error if this section is called because it shouldn't be\n+        REQUIRE(1 == 0);\n+    }\n+}\n",
        "problem_statement": "If a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\nIf a specific section is specified, actually two test runs are carried out\n## Description\r\nIf I like a test in a specific section to be run, I can do this with this command:\r\n`./MyExe Test -c sa`\r\n\r\nSurprisingly, this causes two test runs:\r\n1. Test \"Test\" with section \"sa\"\r\n2. Test \"Test\" without any sections\r\n\r\nIs there a reason for the second empty test run? In my application where the initialisation for the test case is lengthy this behaviour is inconvenient.\r\n\r\n### Steps to reproduce\r\nPut some log output in the test case \"Test\" outside any sections.\n",
        "hints_text": "I agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.\nI agree, that shouldn't happen by default.\r\n\r\nIs section \"sa\" failing? (basically, does it run into the same problem #1389 does?)\nNo, section \"sa\" is not failing. (I saw issue  #1389 before I opened this new issue and, at first sight, it seemed similar. But because \"sa\" was not failing I thought this would be something different.)\nThen this is a bug, the first run should provide all the information we need to avoid doing a second one.",
        "created_at": "2019-01-08T13:45:01Z",
        "version": "2.5"
    }
}