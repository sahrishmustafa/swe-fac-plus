{
    "task_id": "simdjson__simdjson-1274",
    "setup_info": {
        "repo_path": "testbed/simdjson__simdjson-1274_2025-07-08_04-24-15",
        "repo_cache_path": "testbed/simdjson/simdjson_cache"
    },
    "task_info": {
        "repo": "simdjson/simdjson",
        "pull_number": 1274,
        "instance_id": "simdjson__simdjson-1274",
        "issue_numbers": [
            "1273"
        ],
        "base_commit": "265db2e533d4cdc8f7548717b911a92b6a7c9ec9",
        "patch": "diff --git a/include/simdjson/generic/numberparsing.h b/include/simdjson/generic/numberparsing.h\n--- a/include/simdjson/generic/numberparsing.h\n+++ b/include/simdjson/generic/numberparsing.h\n@@ -42,6 +42,8 @@ simdjson_really_inline double to_double(uint64_t mantissa, uint64_t real_exponen\n // We assume that power is in the [smallest_power,\n // largest_power] interval: the caller is responsible for this check.\n simdjson_really_inline bool compute_float_64(int64_t power, uint64_t i, bool negative, double &d) {\n+  assert(power>=simdjson::internal::smallest_power);\n+  assert(power<=simdjson::internal::largest_power);\n   // we start with a fast path\n   // It was described in\n   // Clinger WD. How to read floating point numbers accurately.\n@@ -734,11 +736,12 @@ simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(cons\n     if (p-start_exp_digits == 0 || p-start_exp_digits > 19) { return NUMBER_ERROR; }\n \n     exponent += exp_neg ? 0-exp : exp;\n-    overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\n   }\n \n   if (jsoncharutils::is_not_structural_or_whitespace(*p)) { return NUMBER_ERROR; }\n \n+  overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\n+\n   //\n   // Assemble (or slow-parse) the float\n   //\n",
        "test_patch": "diff --git a/tests/ondemand/ondemand_basictests.cpp b/tests/ondemand/ondemand_basictests.cpp\n--- a/tests/ondemand/ondemand_basictests.cpp\n+++ b/tests/ondemand/ondemand_basictests.cpp\n@@ -326,10 +326,25 @@ namespace number_tests {\n     printf(\"Powers of 10 can be parsed.\\n\");\n     return true;\n   }\n+\n+  void github_issue_1273() {\n+    padded_string bad(std::string_view(\"0.0300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000122978293824\"));\n+    simdjson::builtin::ondemand::parser parser;\n+    simdjson_unused auto blah=parser.iterate(bad);\n+    double x;\n+    simdjson_unused auto blah2=blah.get(x);\n+  }\n+\n+  bool old_crashes() {\n+    github_issue_1273();\n+    return true;\n+  }\n+\n   bool run() {\n     return small_integers() &&\n            powers_of_two() &&\n-           powers_of_ten();\n+           powers_of_ten() &&\n+           old_crashes();\n   }\n }\n \n",
        "problem_statement": "generic/numberparsing.h compute_float_64() invoked with out of range power\nThe CI fuzzer found a crash (segfault, out of bound read), which I reduced to compute_float_64() being invoked with power outside of the stated legal range, eventually leading to the out of bounds read.\r\n\r\nThe following reproduces the problem (the asserts will trigger):\r\n```diff\r\ndiff --git a/include/simdjson/generic/numberparsing.h b/include/simdjson/generic/numberparsing.h\r\nindex 934e57e3..9490f1c1 100644\r\n--- a/include/simdjson/generic/numberparsing.h\r\n+++ b/include/simdjson/generic/numberparsing.h\r\n@@ -42,6 +42,8 @@ simdjson_really_inline double to_double(uint64_t mantissa, uint64_t real_exponen\r\n // We assume that power is in the [smallest_power,\r\n // largest_power] interval: the caller is responsible for this check.\r\n simdjson_really_inline bool compute_float_64(int64_t power, uint64_t i, bool negative, double &d) {\r\n+  assert(power>=simdjson::internal::smallest_power);\r\n+  assert(power<=simdjson::internal::largest_power);\r\n   // we start with a fast path\r\n   // It was described in\r\n   // Clinger WD. How to read floating point numbers accurately.\r\ndiff --git a/tests/ondemand/ondemand_basictests.cpp b/tests/ondemand/ondemand_basictests.cpp\r\nindex 58766088..5e669f33 100644\r\n--- a/tests/ondemand/ondemand_basictests.cpp\r\n+++ b/tests/ondemand/ondemand_basictests.cpp\r\n@@ -326,8 +326,19 @@ namespace number_tests {\r\n     printf(\"Powers of 10 can be parsed.\\n\");\r\n     return true;\r\n   }\r\n+\r\n+  bool weird_case() {\r\n+    padded_string bad(std::string_view(\"0.0300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000122978293824\"));\r\n+    simdjson::builtin::ondemand::parser parser;\r\n+    simdjson_unused auto blah=parser.iterate(bad);\r\n+    double x;\r\n+    simdjson_unused auto blah2=blah.get(x);\r\n+    return true;\r\n+  }\r\n+\r\n   bool run() {\r\n-    return small_integers() &&\r\n+    return weird_case() &&\r\n+           small_integers() &&\r\n            powers_of_two() &&\r\n            powers_of_ten();\r\n   }\r\n```\r\n\r\nThe proposed fix solves the problem:\r\n```diff\r\ndiff --git a/include/simdjson/generic/numberparsing.h b/include/simdjson/generic/numberparsing.h\r\nindex 9490f1c1..098a90b0 100644\r\n--- a/include/simdjson/generic/numberparsing.h\r\n+++ b/include/simdjson/generic/numberparsing.h\r\n@@ -736,11 +736,12 @@ simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(cons\r\n     if (p-start_exp_digits == 0 || p-start_exp_digits > 19) { return NUMBER_ERROR; }\r\n \r\n     exponent += exp_neg ? 0-exp : exp;\r\n-    overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\r\n   }\r\n \r\n   if (jsoncharutils::is_not_structural_or_whitespace(*p)) { return NUMBER_ERROR; }\r\n \r\n+  overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\r\n+\r\n   //\r\n   // Assemble (or slow-parse) the float\r\n   //\r\n```\n",
        "hints_text": "",
        "created_at": "2020-11-01T09:06:42Z",
        "version": "0.6"
    }
}