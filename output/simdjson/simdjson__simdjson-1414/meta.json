{
    "task_id": "simdjson__simdjson-1414",
    "setup_info": {
        "repo_path": "testbed/simdjson__simdjson-1414_2025-07-08_04-24-15",
        "repo_cache_path": "testbed/simdjson/simdjson_cache"
    },
    "task_info": {
        "repo": "simdjson/simdjson",
        "pull_number": 1414,
        "instance_id": "simdjson__simdjson-1414",
        "issue_numbers": [
            "1409",
            "1409"
        ],
        "base_commit": "c96ff018fedc7fe087b6f898442458a31a240a28",
        "patch": "diff --git a/include/simdjson/generic/numberparsing.h b/include/simdjson/generic/numberparsing.h\n--- a/include/simdjson/generic/numberparsing.h\n+++ b/include/simdjson/generic/numberparsing.h\n@@ -423,7 +423,7 @@ simdjson_really_inline error_code parse_exponent(simdjson_unused const uint8_t *\n   return SUCCESS;\n }\n \n-simdjson_really_inline int significant_digits(const uint8_t * start_digits, int digit_count) {\n+simdjson_really_inline size_t significant_digits(const uint8_t * start_digits, size_t digit_count) {\n   // It is possible that the integer had an overflow.\n   // We have to handle the case where we have 0.0000somenumber.\n   const uint8_t *start = start_digits;\n@@ -431,11 +431,11 @@ simdjson_really_inline int significant_digits(const uint8_t * start_digits, int\n     start++;\n   }\n   // we over-decrement by one when there is a '.'\n-  return digit_count - int(start - start_digits);\n+  return digit_count - size_t(start - start_digits);\n }\n \n template<typename W>\n-simdjson_really_inline error_code write_float(const uint8_t *const src, bool negative, uint64_t i, const uint8_t * start_digits, int digit_count, int64_t exponent, W &writer) {\n+simdjson_really_inline error_code write_float(const uint8_t *const src, bool negative, uint64_t i, const uint8_t * start_digits, size_t digit_count, int64_t exponent, W &writer) {\n   // If we frequently had to deal with long strings of digits,\n   // we could extend our code by using a 128-bit integer instead\n   // of a 64-bit integer. However, this is uncommon in practice.\n@@ -529,7 +529,8 @@ simdjson_really_inline error_code parse_number(const uint8_t *const src, W &writ\n   while (parse_digit(*p, i)) { p++; }\n \n   // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n-  int digit_count = int(p - start_digits);\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n   if (digit_count == 0 || ('0' == *start_digits && digit_count > 1)) { return INVALID_NUMBER(src); }\n \n   //\n@@ -549,23 +550,23 @@ simdjson_really_inline error_code parse_number(const uint8_t *const src, W &writ\n     SIMDJSON_TRY( parse_exponent(src, p, exponent) );\n   }\n   if (is_float) {\n-    const bool clean_end = jsoncharutils::is_structural_or_whitespace(*p);\n+    const bool dirty_end = jsoncharutils::is_not_structural_or_whitespace(*p);\n     SIMDJSON_TRY( write_float(src, negative, i, start_digits, digit_count, exponent, writer) );\n-    if (!clean_end) { return INVALID_NUMBER(src); }\n+    if (dirty_end) { return INVALID_NUMBER(src); }\n     return SUCCESS;\n   }\n \n   // The longest negative 64-bit number is 19 digits.\n   // The longest positive 64-bit number is 20 digits.\n   // We do it this way so we don't trigger this branch unless we must.\n-  int longest_digit_count = negative ? 19 : 20;\n+  size_t longest_digit_count = negative ? 19 : 20;\n   if (digit_count > longest_digit_count) { return INVALID_NUMBER(src); }\n   if (digit_count == longest_digit_count) {\n     if (negative) {\n       // Anything negative above INT64_MAX+1 is invalid\n       if (i > uint64_t(INT64_MAX)+1) { return INVALID_NUMBER(src);  }\n       WRITE_INTEGER(~i+1, src, writer);\n-      if (!jsoncharutils::is_structural_or_whitespace(*p)) { return INVALID_NUMBER(src); }\n+      if (jsoncharutils::is_not_structural_or_whitespace(*p)) { return INVALID_NUMBER(src); }\n       return SUCCESS;\n     // Positive overflow check:\n     // - A 20 digit number starting with 2-9 is overflow, because 18,446,744,073,709,551,615 is the\n@@ -588,16 +589,81 @@ simdjson_really_inline error_code parse_number(const uint8_t *const src, W &writ\n   } else {\n     WRITE_INTEGER(negative ? (~i+1) : i, src, writer);\n   }\n-  if (!jsoncharutils::is_structural_or_whitespace(*p)) { return INVALID_NUMBER(src); }\n+  if (jsoncharutils::is_not_structural_or_whitespace(*p)) { return INVALID_NUMBER(src); }\n   return SUCCESS;\n }\n \n-// SAX functions\n+// Inlineable functions\n namespace {\n+\n+// This table can be used to characterize the final character of an integer\n+// string. For JSON structural character and allowable white space characters,\n+// we return SUCCESS. For 'e', '.' and 'E', we return INCORRECT_TYPE. Otherwise\n+// we return NUMBER_ERROR.\n+// Optimization note: we could easily reduce the size of the table by half (to 128)\n+// at the cost of an extra branch.\n+// Optimization note: we want the values to use at most 8 bits (not, e.g., 32 bits):\n+static_assert(error_code(uint8_t(NUMBER_ERROR))== NUMBER_ERROR, \"bad NUMBER_ERROR cast\");\n+static_assert(error_code(uint8_t(SUCCESS))== SUCCESS, \"bad NUMBER_ERROR cast\");\n+static_assert(error_code(uint8_t(INCORRECT_TYPE))== INCORRECT_TYPE, \"bad NUMBER_ERROR cast\");\n+\n+const uint8_t integer_string_finisher[256] = {\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, SUCCESS,\n+    SUCCESS,      NUMBER_ERROR,   NUMBER_ERROR, SUCCESS,      NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   SUCCESS,      NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, SUCCESS,\n+    NUMBER_ERROR, INCORRECT_TYPE, NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, SUCCESS,      NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, INCORRECT_TYPE,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, SUCCESS,        NUMBER_ERROR, SUCCESS,      NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, INCORRECT_TYPE, NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, SUCCESS,      NUMBER_ERROR,\n+    SUCCESS,      NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR, NUMBER_ERROR,   NUMBER_ERROR, NUMBER_ERROR, NUMBER_ERROR,\n+    NUMBER_ERROR};\n+\n // Parse any number from 0 to 18,446,744,073,709,551,615\n simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(const uint8_t * const src) noexcept {\n   const uint8_t *p = src;\n-\n   //\n   // Parse the integer part.\n   //\n@@ -607,13 +673,23 @@ simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(\n   while (parse_digit(*p, i)) { p++; }\n \n   // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n-  int digit_count = int(p - start_digits);\n-  if (digit_count == 0 || ('0' == *start_digits && digit_count > 1)) { return NUMBER_ERROR; }\n-  if (!jsoncharutils::is_structural_or_whitespace(*p)) { return NUMBER_ERROR; }\n-\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n   // The longest positive 64-bit number is 20 digits.\n   // We do it this way so we don't trigger this branch unless we must.\n-  if (digit_count > 20) { return NUMBER_ERROR; }\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > 20))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > 20)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if (integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n+\n   if (digit_count == 20) {\n     // Positive overflow check:\n     // - A 20 digit number starting with 2-9 is overflow, because 18,446,744,073,709,551,615 is the\n@@ -627,7 +703,7 @@ simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(\n     // - Therefore, if the number is positive and lower than that, it's overflow.\n     // - The value we are looking at is less than or equal to 9,223,372,036,854,775,808 (INT64_MAX).\n     //\n-    if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return NUMBER_ERROR; }\n+    if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n   }\n \n   return i;\n@@ -650,19 +726,28 @@ simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(co\n   while (parse_digit(*p, i)) { p++; }\n \n   // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n-  int digit_count = int(p - start_digits);\n-  if (digit_count == 0 || ('0' == *start_digits && digit_count > 1)) { return NUMBER_ERROR; }\n-  if (!jsoncharutils::is_structural_or_whitespace(*p)) { return NUMBER_ERROR; }\n-\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n   // The longest negative 64-bit number is 19 digits.\n   // The longest positive 64-bit number is 20 digits.\n   // We do it this way so we don't trigger this branch unless we must.\n-  int longest_digit_count = negative ? 19 : 20;\n-  if (digit_count > longest_digit_count) { return NUMBER_ERROR; }\n+  size_t longest_digit_count = negative ? 19 : 20;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if(integer_string_finisher[*p] != SUCCESS) { return error_code(integer_string_finisher[*p]); }\n   if (digit_count == longest_digit_count) {\n-    if(negative) {\n+    if (negative) {\n       // Anything negative above INT64_MAX+1 is invalid\n-      if (i > uint64_t(INT64_MAX)+1) { return NUMBER_ERROR; }\n+      if (i > uint64_t(INT64_MAX)+1) { return INCORRECT_TYPE; }\n       return ~i+1;\n \n     // Positive overflow check:\n@@ -677,7 +762,7 @@ simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(co\n     // - Therefore, if the number is positive and lower than that, it's overflow.\n     // - The value we are looking at is less than or equal to 9,223,372,036,854,775,808 (INT64_MAX).\n     //\n-    } else if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return NUMBER_ERROR; }\n+    } else if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n   }\n \n   return negative ? (~i+1) : i;\n@@ -699,7 +784,8 @@ simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(cons\n   bool leading_zero = (i == 0);\n   while (parse_digit(*p, i)) { p++; }\n   // no integer digits, or 0123 (zero must be solo)\n-  if ( p == src || (leading_zero && p != src+1)) { return NUMBER_ERROR; }\n+  if ( p == src ) { return INCORRECT_TYPE; }\n+  if ( (leading_zero && p != src+1)) { return NUMBER_ERROR; }\n \n   //\n   // Parse the decimal part.\ndiff --git a/include/simdjson/generic/ondemand/array-inl.h b/include/simdjson/generic/ondemand/array-inl.h\n--- a/include/simdjson/generic/ondemand/array-inl.h\n+++ b/include/simdjson/generic/ondemand/array-inl.h\n@@ -50,11 +50,6 @@ simdjson_really_inline simdjson_result<array> array::start(value_iterator &iter)\n   SIMDJSON_TRY( iter.start_array().get(has_value) );\n   return array(iter);\n }\n-simdjson_really_inline simdjson_result<array> array::try_start(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value;\n-  SIMDJSON_TRY( iter.try_start_array().get(has_value) );\n-  return array(iter);\n-}\n simdjson_really_inline array array::started(value_iterator &iter) noexcept {\n   simdjson_unused bool has_value = iter.started_array();\n   return array(iter);\ndiff --git a/include/simdjson/generic/ondemand/array.h b/include/simdjson/generic/ondemand/array.h\n--- a/include/simdjson/generic/ondemand/array.h\n+++ b/include/simdjson/generic/ondemand/array.h\n@@ -41,14 +41,6 @@ class array {\n    * @error INCORRECT_TYPE if the iterator is not at [.\n    */\n   static simdjson_really_inline simdjson_result<array> start(value_iterator &iter) noexcept;\n-  /**\n-   * Begin array iteration.\n-   *\n-   * @param iter The iterator. Must be where the initial [ is expected. Will be *moved* into the\n-   *        resulting array.\n-   * @error INCORRECT_TYPE if the iterator is not at [.\n-   */\n-  static simdjson_really_inline simdjson_result<array> try_start(value_iterator &iter) noexcept;\n   /**\n    * Begin array iteration.\n    *\ndiff --git a/include/simdjson/generic/ondemand/logger-inl.h b/include/simdjson/generic/ondemand/logger-inl.h\n--- a/include/simdjson/generic/ondemand/logger-inl.h\n+++ b/include/simdjson/generic/ondemand/logger-inl.h\n@@ -21,20 +21,28 @@ static simdjson_really_inline char printable_char(char c) {\n simdjson_really_inline void log_event(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"\", type, detail, delta, depth_delta);\n }\n+\n+simdjson_really_inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n+  log_line(iter, index, depth, \"\", type, detail);\n+}\n simdjson_really_inline void log_value(const json_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"\", type, detail, delta, depth_delta);\n }\n-simdjson_really_inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n-  log_line(iter, index, depth, \"\", type, detail);\n+\n+simdjson_really_inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail) noexcept {\n+  log_line(iter, index, depth, \"+\", type, detail);\n+  if (LOG_ENABLED) { log_depth++; }\n }\n simdjson_really_inline void log_start_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_line(iter, \"+\", type, \"\", delta, depth_delta);\n-  log_depth++;\n+  if (LOG_ENABLED) { log_depth++; }\n }\n+\n simdjson_really_inline void log_end_value(const json_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n-  log_depth--;\n+  if (LOG_ENABLED) { log_depth--; }\n   log_line(iter, \"-\", type, \"\", delta, depth_delta);\n }\n+\n simdjson_really_inline void log_error(const json_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n   log_line(iter, \"ERROR: \", error, detail, delta, depth_delta);\n }\n@@ -45,22 +53,26 @@ simdjson_really_inline void log_error(const json_iterator &iter, token_position\n simdjson_really_inline void log_event(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_event(iter.json_iter(), type, detail, delta, depth_delta);\n }\n+\n simdjson_really_inline void log_value(const value_iterator &iter, const char *type, std::string_view detail, int delta, int depth_delta) noexcept {\n   log_value(iter.json_iter(), type, detail, delta, depth_delta);\n }\n+\n simdjson_really_inline void log_start_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_start_value(iter.json_iter(), type, delta, depth_delta);\n }\n+\n simdjson_really_inline void log_end_value(const value_iterator &iter, const char *type, int delta, int depth_delta) noexcept {\n   log_end_value(iter.json_iter(), type, delta, depth_delta);\n }\n+\n simdjson_really_inline void log_error(const value_iterator &iter, const char *error, const char *detail, int delta, int depth_delta) noexcept {\n   log_error(iter.json_iter(), error, detail, delta, depth_delta);\n }\n \n simdjson_really_inline void log_headers() noexcept {\n-  log_depth = 0;\n   if (LOG_ENABLED) {\n+    log_depth = 0;\n     printf(\"\\n\");\n     printf(\"| %-*s \", LOG_EVENT_LEN,        \"Event\");\n     printf(\"| %-*s \", LOG_BUFFER_LEN,       \"Buffer\");\ndiff --git a/include/simdjson/generic/ondemand/logger.h b/include/simdjson/generic/ondemand/logger.h\n--- a/include/simdjson/generic/ondemand/logger.h\n+++ b/include/simdjson/generic/ondemand/logger.h\n@@ -14,15 +14,16 @@ namespace logger {\n #endif\n \n static simdjson_really_inline void log_headers() noexcept;\n-static simdjson_really_inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept;\n static simdjson_really_inline void log_line(const json_iterator &iter, token_position index, depth_t depth, const char *title_prefix, const char *title, std::string_view detail) noexcept;\n+static simdjson_really_inline void log_line(const json_iterator &iter, const char *title_prefix, const char *title, std::string_view detail, int delta, int depth_delta) noexcept;\n static simdjson_really_inline void log_event(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_value(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n static simdjson_really_inline void log_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n+static simdjson_really_inline void log_value(const json_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n+static simdjson_really_inline void log_start_value(const json_iterator &iter, token_position index, depth_t depth, const char *type, std::string_view detail=\"\") noexcept;\n static simdjson_really_inline void log_start_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n static simdjson_really_inline void log_end_value(const json_iterator &iter, const char *type, int delta=-1, int depth_delta=0) noexcept;\n-static simdjson_really_inline void log_error(const json_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n static simdjson_really_inline void log_error(const json_iterator &iter, token_position index, depth_t depth, const char *error, const char *detail=\"\") noexcept;\n+static simdjson_really_inline void log_error(const json_iterator &iter, const char *error, const char *detail=\"\", int delta=-1, int depth_delta=0) noexcept;\n \n static simdjson_really_inline void log_event(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=0, int depth_delta=0) noexcept;\n static simdjson_really_inline void log_value(const value_iterator &iter, const char *type, std::string_view detail=\"\", int delta=-1, int depth_delta=0) noexcept;\ndiff --git a/include/simdjson/generic/ondemand/object-inl.h b/include/simdjson/generic/ondemand/object-inl.h\n--- a/include/simdjson/generic/ondemand/object-inl.h\n+++ b/include/simdjson/generic/ondemand/object-inl.h\n@@ -38,11 +38,6 @@ simdjson_really_inline simdjson_result<object> object::start(value_iterator &ite\n   SIMDJSON_TRY( iter.start_object().get(has_value) );\n   return object(iter);\n }\n-simdjson_really_inline simdjson_result<object> object::try_start(value_iterator &iter) noexcept {\n-  simdjson_unused bool has_value;\n-  SIMDJSON_TRY( iter.try_start_object().get(has_value) );\n-  return object(iter);\n-}\n simdjson_really_inline object object::started(value_iterator &iter) noexcept {\n   simdjson_unused bool has_value = iter.started_object();\n   return iter;\ndiff --git a/include/simdjson/generic/ondemand/object.h b/include/simdjson/generic/ondemand/object.h\n--- a/include/simdjson/generic/ondemand/object.h\n+++ b/include/simdjson/generic/ondemand/object.h\n@@ -72,7 +72,6 @@ class object {\n \n protected:\n   static simdjson_really_inline simdjson_result<object> start(value_iterator &iter) noexcept;\n-  static simdjson_really_inline simdjson_result<object> try_start(value_iterator &iter) noexcept;\n   static simdjson_really_inline object started(value_iterator &iter) noexcept;\n   static simdjson_really_inline object resume(const value_iterator &iter) noexcept;\n   simdjson_really_inline object(const value_iterator &iter) noexcept;\ndiff --git a/include/simdjson/generic/ondemand/value-inl.h b/include/simdjson/generic/ondemand/value-inl.h\n--- a/include/simdjson/generic/ondemand/value-inl.h\n+++ b/include/simdjson/generic/ondemand/value-inl.h\n@@ -13,26 +13,13 @@ simdjson_really_inline value value::resume(const value_iterator &iter) noexcept\n   return iter;\n }\n \n-simdjson_really_inline simdjson_result<array> value::get_array() && noexcept {\n+simdjson_really_inline simdjson_result<array> value::get_array() noexcept {\n   return array::start(iter);\n }\n-simdjson_really_inline simdjson_result<array> value::get_array() & noexcept {\n-  return array::try_start(iter);\n-}\n-simdjson_really_inline simdjson_result<object> value::get_object() && noexcept {\n+simdjson_really_inline simdjson_result<object> value::get_object() noexcept {\n   return object::start(iter);\n }\n-simdjson_really_inline simdjson_result<object> value::get_object() & noexcept {\n-  return object::try_start(iter);\n-}\n-simdjson_really_inline simdjson_result<object> value::start_or_resume_object() & noexcept {\n-  if (iter.at_start()) {\n-    return get_object();\n-  } else {\n-    return object::resume(iter);\n-  }\n-}\n-simdjson_really_inline simdjson_result<object> value::start_or_resume_object() && noexcept {\n+simdjson_really_inline simdjson_result<object> value::start_or_resume_object() noexcept {\n   if (iter.at_start()) {\n     return get_object();\n   } else {\n@@ -62,44 +49,25 @@ simdjson_really_inline bool value::is_null() noexcept {\n   return iter.is_null();\n }\n \n-template<> simdjson_really_inline simdjson_result<array> value::get() & noexcept { return get_array(); }\n-template<> simdjson_really_inline simdjson_result<object> value::get() & noexcept { return get_object(); }\n-template<> simdjson_really_inline simdjson_result<raw_json_string> value::get() & noexcept { return get_raw_json_string(); }\n-template<> simdjson_really_inline simdjson_result<std::string_view> value::get() & noexcept { return get_string(); }\n-template<> simdjson_really_inline simdjson_result<double> value::get() & noexcept { return get_double(); }\n-template<> simdjson_really_inline simdjson_result<uint64_t> value::get() & noexcept { return get_uint64(); }\n-template<> simdjson_really_inline simdjson_result<int64_t> value::get() & noexcept { return get_int64(); }\n-template<> simdjson_really_inline simdjson_result<bool> value::get() & noexcept { return get_bool(); }\n-\n-template<> simdjson_really_inline simdjson_result<value> value::get() && noexcept { return std::forward<value>(*this); }\n-template<> simdjson_really_inline simdjson_result<array> value::get() && noexcept { return std::forward<value>(*this).get_array(); }\n-template<> simdjson_really_inline simdjson_result<object> value::get() && noexcept { return std::forward<value>(*this).get_object(); }\n-template<> simdjson_really_inline simdjson_result<raw_json_string> value::get() && noexcept { return std::forward<value>(*this).get_raw_json_string(); }\n-template<> simdjson_really_inline simdjson_result<std::string_view> value::get() && noexcept { return std::forward<value>(*this).get_string(); }\n-template<> simdjson_really_inline simdjson_result<double> value::get() && noexcept { return std::forward<value>(*this).get_double(); }\n-template<> simdjson_really_inline simdjson_result<uint64_t> value::get() && noexcept { return std::forward<value>(*this).get_uint64(); }\n-template<> simdjson_really_inline simdjson_result<int64_t> value::get() && noexcept { return std::forward<value>(*this).get_int64(); }\n-template<> simdjson_really_inline simdjson_result<bool> value::get() && noexcept { return std::forward<value>(*this).get_bool(); }\n+template<> simdjson_really_inline simdjson_result<array> value::get() noexcept { return get_array(); }\n+template<> simdjson_really_inline simdjson_result<object> value::get() noexcept { return get_object(); }\n+template<> simdjson_really_inline simdjson_result<raw_json_string> value::get() noexcept { return get_raw_json_string(); }\n+template<> simdjson_really_inline simdjson_result<std::string_view> value::get() noexcept { return get_string(); }\n+template<> simdjson_really_inline simdjson_result<double> value::get() noexcept { return get_double(); }\n+template<> simdjson_really_inline simdjson_result<uint64_t> value::get() noexcept { return get_uint64(); }\n+template<> simdjson_really_inline simdjson_result<int64_t> value::get() noexcept { return get_int64(); }\n+template<> simdjson_really_inline simdjson_result<bool> value::get() noexcept { return get_bool(); }\n \n-template<typename T> simdjson_really_inline error_code value::get(T &out) & noexcept {\n+template<typename T> simdjson_really_inline error_code value::get(T &out) noexcept {\n   return get<T>().get(out);\n }\n-template<typename T> simdjson_really_inline error_code value::get(T &out) && noexcept {\n-  return std::forward<value>(*this).get<T>().get(out);\n-}\n \n #if SIMDJSON_EXCEPTIONS\n-simdjson_really_inline value::operator array() && noexcept(false) {\n-  return std::forward<value>(*this).get_array();\n-}\n-simdjson_really_inline value::operator array() & noexcept(false) {\n-  return std::forward<value>(*this).get_array();\n-}\n-simdjson_really_inline value::operator object() && noexcept(false) {\n-  return std::forward<value>(*this).get_object();\n+simdjson_really_inline value::operator array() noexcept(false) {\n+  return get_array();\n }\n-simdjson_really_inline value::operator object() & noexcept(false) {\n-  return std::forward<value>(*this).get_object();\n+simdjson_really_inline value::operator object() noexcept(false) {\n+  return get_object();\n }\n simdjson_really_inline value::operator uint64_t() noexcept(false) {\n   return get_uint64();\n@@ -128,44 +96,26 @@ simdjson_really_inline simdjson_result<array_iterator> value::end() & noexcept {\n   return {};\n }\n \n-simdjson_really_inline simdjson_result<value> value::find_field(std::string_view key) & noexcept {\n+simdjson_really_inline simdjson_result<value> value::find_field(std::string_view key) noexcept {\n   return start_or_resume_object().find_field(key);\n }\n-simdjson_really_inline simdjson_result<value> value::find_field(std::string_view key) && noexcept {\n-  return std::forward<value>(*this).start_or_resume_object().find_field(key);\n-}\n-simdjson_really_inline simdjson_result<value> value::find_field(const char *key) & noexcept {\n+simdjson_really_inline simdjson_result<value> value::find_field(const char *key) noexcept {\n   return start_or_resume_object().find_field(key);\n }\n-simdjson_really_inline simdjson_result<value> value::find_field(const char *key) && noexcept {\n-  return std::forward<value>(*this).start_or_resume_object().find_field(key);\n-}\n \n-simdjson_really_inline simdjson_result<value> value::find_field_unordered(std::string_view key) & noexcept {\n+simdjson_really_inline simdjson_result<value> value::find_field_unordered(std::string_view key) noexcept {\n   return start_or_resume_object().find_field_unordered(key);\n }\n-simdjson_really_inline simdjson_result<value> value::find_field_unordered(std::string_view key) && noexcept {\n-  return std::forward<value>(*this).start_or_resume_object().find_field_unordered(key);\n-}\n-simdjson_really_inline simdjson_result<value> value::find_field_unordered(const char *key) & noexcept {\n+simdjson_really_inline simdjson_result<value> value::find_field_unordered(const char *key) noexcept {\n   return start_or_resume_object().find_field_unordered(key);\n }\n-simdjson_really_inline simdjson_result<value> value::find_field_unordered(const char *key) && noexcept {\n-  return std::forward<value>(*this).start_or_resume_object().find_field_unordered(key);\n-}\n \n-simdjson_really_inline simdjson_result<value> value::operator[](std::string_view key) & noexcept {\n+simdjson_really_inline simdjson_result<value> value::operator[](std::string_view key) noexcept {\n   return start_or_resume_object()[key];\n }\n-simdjson_really_inline simdjson_result<value> value::operator[](std::string_view key) && noexcept {\n-  return std::forward<value>(*this).start_or_resume_object()[key];\n-}\n-simdjson_really_inline simdjson_result<value> value::operator[](const char *key) & noexcept {\n+simdjson_really_inline simdjson_result<value> value::operator[](const char *key) noexcept {\n   return start_or_resume_object()[key];\n }\n-simdjson_really_inline simdjson_result<value> value::operator[](const char *key) && noexcept {\n-  return std::forward<value>(*this).start_or_resume_object()[key];\n-}\n \n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n@@ -197,73 +147,41 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_\n   return {};\n }\n \n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field(std::string_view key) & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field(std::string_view key) noexcept {\n   if (error()) { return error(); }\n   return first.find_field(key);\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field(std::string_view key) && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).find_field(key);\n-}\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field(const char *key) & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field(const char *key) noexcept {\n   if (error()) { return error(); }\n   return first.find_field(key);\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field(const char *key) && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).find_field(key);\n-}\n \n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field_unordered(std::string_view key) & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field_unordered(std::string_view key) noexcept {\n   if (error()) { return error(); }\n   return first.find_field_unordered(key);\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field_unordered(std::string_view key) && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).find_field_unordered(key);\n-}\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field_unordered(const char *key) & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field_unordered(const char *key) noexcept {\n   if (error()) { return error(); }\n   return first.find_field_unordered(key);\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::find_field_unordered(const char *key) && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).find_field_unordered(key);\n-}\n \n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator[](std::string_view key) & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator[](std::string_view key) noexcept {\n   if (error()) { return error(); }\n   return first[key];\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator[](std::string_view key) && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first)[key];\n-}\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator[](const char *key) & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator[](const char *key) noexcept {\n   if (error()) { return error(); }\n   return first[key];\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator[](const char *key) && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first)[key];\n-}\n \n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_array() & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_array() noexcept {\n   if (error()) { return error(); }\n   return first.get_array();\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_array() && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).get_array();\n-}\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_object() & noexcept {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_object() noexcept {\n   if (error()) { return error(); }\n   return first.get_object();\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_object() && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).get_object();\n-}\n simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_uint64() noexcept {\n   if (error()) { return error(); }\n   return first.get_uint64();\n@@ -293,59 +211,34 @@ simdjson_really_inline bool simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::v\n   return first.is_null();\n }\n \n-template<typename T> simdjson_really_inline simdjson_result<T> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get() & noexcept {\n+template<typename T> simdjson_really_inline simdjson_result<T> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get() noexcept {\n   if (error()) { return error(); }\n   return first.get<T>();\n }\n-template<typename T> simdjson_really_inline simdjson_result<T> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get() && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).get<T>();\n-}\n-template<typename T> simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get(T &out) & noexcept {\n+template<typename T> simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get(T &out) noexcept {\n   if (error()) { return error(); }\n   return first.get<T>(out);\n }\n-template<typename T> simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get(T &out) && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first).get<T>(out);\n-}\n \n-template<> simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get<SIMDJSON_IMPLEMENTATION::ondemand::value>() & noexcept  {\n+template<> simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get<SIMDJSON_IMPLEMENTATION::ondemand::value>() noexcept  {\n   if (error()) { return error(); }\n   return std::move(first);\n }\n-template<> simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get<SIMDJSON_IMPLEMENTATION::ondemand::value>() && noexcept {\n-  if (error()) { return error(); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first);\n-}\n-template<> simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get<SIMDJSON_IMPLEMENTATION::ondemand::value>(SIMDJSON_IMPLEMENTATION::ondemand::value &out) & noexcept {\n+template<> simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get<SIMDJSON_IMPLEMENTATION::ondemand::value>(SIMDJSON_IMPLEMENTATION::ondemand::value &out) noexcept {\n   if (error()) { return error(); }\n   out = first;\n   return SUCCESS;\n }\n-template<> simdjson_really_inline error_code simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get<SIMDJSON_IMPLEMENTATION::ondemand::value>(SIMDJSON_IMPLEMENTATION::ondemand::value &out) && noexcept {\n-  if (error()) { return error(); }\n-  out = std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first);\n-  return SUCCESS;\n-}\n \n #if SIMDJSON_EXCEPTIONS\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false) {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() noexcept(false) {\n   if (error()) { throw simdjson_error(error()); }\n   return first;\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::array() && noexcept(false) {\n-  if (error()) { throw simdjson_error(error()); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first);\n-}\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::object() & noexcept(false) {\n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::object() noexcept(false) {\n   if (error()) { throw simdjson_error(error()); }\n   return first;\n }\n-simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator SIMDJSON_IMPLEMENTATION::ondemand::object() && noexcept(false) {\n-  if (error()) { throw simdjson_error(error()); }\n-  return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::value>(first);\n-}\n simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::operator uint64_t() noexcept(false) {\n   if (error()) { throw simdjson_error(error()); }\n   return first;\ndiff --git a/include/simdjson/generic/ondemand/value.h b/include/simdjson/generic/ondemand/value.h\n--- a/include/simdjson/generic/ondemand/value.h\n+++ b/include/simdjson/generic/ondemand/value.h\n@@ -30,9 +30,7 @@ class value {\n    * @returns A value of the given type, parsed from the JSON.\n    * @returns INCORRECT_TYPE If the JSON value is not the given type.\n    */\n-  template<typename T> simdjson_really_inline simdjson_result<T> get() & noexcept;\n-  /** @overload template<typename T> simdjson_result<T> get() & noexcept */\n-  template<typename T> simdjson_really_inline simdjson_result<T> get() && noexcept;\n+  template<typename T> simdjson_really_inline simdjson_result<T> get() noexcept;\n \n   /**\n    * Get this value as the given type.\n@@ -43,9 +41,7 @@ class value {\n    * @returns INCORRECT_TYPE If the JSON value is not an object.\n    * @returns SUCCESS If the parse succeeded and the out parameter was set to the value.\n    */\n-  template<typename T> simdjson_really_inline error_code get(T &out) & noexcept;\n-  /** @overload template<typename T> error_code get(T &out) & noexcept */\n-  template<typename T> simdjson_really_inline error_code get(T &out) && noexcept;\n+  template<typename T> simdjson_really_inline error_code get(T &out) noexcept;\n \n   /**\n    * Cast this JSON value to an array.\n@@ -53,9 +49,7 @@ class value {\n    * @returns An object that can be used to iterate the array.\n    * @returns INCORRECT_TYPE If the JSON value is not an array.\n    */\n-  simdjson_really_inline simdjson_result<array> get_array() && noexcept;\n-  /** @overload simdjson_really_inline operator get_array() && noexcept(false); */\n-  simdjson_really_inline simdjson_result<array> get_array() & noexcept;\n+  simdjson_really_inline simdjson_result<array> get_array() noexcept;\n \n   /**\n    * Cast this JSON value to an object.\n@@ -63,9 +57,7 @@ class value {\n    * @returns An object that can be used to look up or iterate fields.\n    * @returns INCORRECT_TYPE If the JSON value is not an object.\n    */\n-  simdjson_really_inline simdjson_result<object> get_object() && noexcept;\n-  /** @overload simdjson_really_inline operator object() && noexcept(false); */\n-  simdjson_really_inline simdjson_result<object> get_object() & noexcept;\n+  simdjson_really_inline simdjson_result<object> get_object() noexcept;\n \n   /**\n    * Cast this JSON value to an unsigned integer.\n@@ -136,18 +128,14 @@ class value {\n    * @returns An object that can be used to iterate the array.\n    * @exception simdjson_error(INCORRECT_TYPE) If the JSON value is not an array.\n    */\n-  simdjson_really_inline operator array() && noexcept(false);\n-  /** @overload simdjson_really_inline operator array() && noexcept(false); */\n-  simdjson_really_inline operator array() & noexcept(false);\n+  simdjson_really_inline operator array() noexcept(false);\n   /**\n    * Cast this JSON value to an object.\n    *\n    * @returns An object that can be used to look up or iterate fields.\n    * @exception simdjson_error(INCORRECT_TYPE) If the JSON value is not an object.\n    */\n-  simdjson_really_inline operator object() && noexcept(false);\n-  /** @overload simdjson_really_inline operator object() && noexcept(false); */\n-  simdjson_really_inline operator object() & noexcept(false);\n+  simdjson_really_inline operator object() noexcept(false);\n   /**\n    * Cast this JSON value to an unsigned integer.\n    *\n@@ -234,13 +222,9 @@ class value {\n    * @param key The key to look up.\n    * @returns The value of the field, or NO_SUCH_FIELD if the field is not in the object.\n    */\n-  simdjson_really_inline simdjson_result<value> find_field(std::string_view key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> find_field(std::string_view key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> find_field(const char *key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> find_field(const char *key) && noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field(std::string_view key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<value> find_field(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<value> find_field(const char *key) noexcept;\n \n   /**\n    * Look up a field by name on an object, without regard to key order.\n@@ -261,21 +245,13 @@ class value {\n    * @param key The key to look up.\n    * @returns The value of the field, or NO_SUCH_FIELD if the field is not in the object.\n    */\n-  simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> find_field_unordered(const char *key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> find_field_unordered(const char *key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> operator[](std::string_view key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> operator[](std::string_view key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> operator[](const char *key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<value> operator[](const char *key) && noexcept;\n+  simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<value> find_field_unordered(const char *key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<value> operator[](std::string_view key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<value> operator[](const char *key) noexcept;\n \n protected:\n   /**\n@@ -303,9 +279,7 @@ class value {\n   /**\n    * Get the object, starting or resuming it as necessary\n    */\n-  simdjson_really_inline simdjson_result<object> start_or_resume_object() & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<object> start_or_resume_object() & noexcept; */\n-  simdjson_really_inline simdjson_result<object> start_or_resume_object() && noexcept;\n+  simdjson_really_inline simdjson_result<object> start_or_resume_object() noexcept;\n \n   // simdjson_really_inline void log_value(const char *type) const noexcept;\n   // simdjson_really_inline void log_error(const char *message) const noexcept;\n@@ -334,11 +308,8 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n   simdjson_really_inline simdjson_result(error_code error) noexcept; ///< @private\n   simdjson_really_inline simdjson_result() noexcept = default;\n \n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> get_array() && noexcept;\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> get_array() & noexcept;\n-\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() && noexcept;\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> get_array() noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() noexcept;\n \n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n@@ -348,17 +319,13 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n   simdjson_really_inline bool is_null() noexcept;\n \n-  template<typename T> simdjson_really_inline simdjson_result<T> get() & noexcept;\n-  template<typename T> simdjson_really_inline simdjson_result<T> get() && noexcept;\n+  template<typename T> simdjson_really_inline simdjson_result<T> get() noexcept;\n \n-  template<typename T> simdjson_really_inline error_code get(T &out) & noexcept;\n-  template<typename T> simdjson_really_inline error_code get(T &out) && noexcept;\n+  template<typename T> simdjson_really_inline error_code get(T &out) noexcept;\n \n #if SIMDJSON_EXCEPTIONS\n-  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::array() && noexcept(false);\n-  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::array() & noexcept(false);\n-  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::object() && noexcept(false);\n-  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::object() & noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::array() noexcept(false);\n+  simdjson_really_inline operator SIMDJSON_IMPLEMENTATION::ondemand::object() noexcept(false);\n   simdjson_really_inline operator uint64_t() noexcept(false);\n   simdjson_really_inline operator int64_t() noexcept(false);\n   simdjson_really_inline operator double() noexcept(false);\n@@ -390,13 +357,9 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n    * @param key The key to look up.\n    * @returns The value of the field, or NO_SUCH_FIELD if the field is not in the object.\n    */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(const char *key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(const char *key) && noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field(const char *key) noexcept;\n \n   /**\n    * Look up a field by name on an object, without regard to key order.\n@@ -417,21 +380,13 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n    * @param key The key to look up.\n    * @returns The value of the field, or NO_SUCH_FIELD if the field is not in the object.\n    */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(const char *key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(const char *key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) && noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](const char *key) & noexcept;\n-  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) & noexcept; */\n-  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](const char *key) && noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(const char *key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) noexcept;\n+  /** @overload simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) noexcept; */\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](const char *key) noexcept;\n };\n \n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/value_iterator-inl.h b/include/simdjson/generic/ondemand/value_iterator-inl.h\n--- a/include/simdjson/generic/ondemand/value_iterator-inl.h\n+++ b/include/simdjson/generic/ondemand/value_iterator-inl.h\n@@ -10,20 +10,12 @@ simdjson_really_inline value_iterator::value_iterator(json_iterator *json_iter,\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_object() noexcept {\n-  assert_at_start();\n-\n-  if (*_json_iter->advance() != '{') { logger::log_error(*_json_iter, \"Not an object\"); return INCORRECT_TYPE; }\n-  return started_object();\n-}\n-simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::try_start_object() noexcept {\n-  assert_at_start();\n-\n-  if (*_json_iter->peek() != '{') { logger::log_error(*_json_iter, \"Not an object\"); return INCORRECT_TYPE; }\n-  _json_iter->advance();\n+  if (*advance_container_start(\"object\") != '{') { return incorrect_type_error(\"Not an object\"); }\n   return started_object();\n }\n \n simdjson_warn_unused simdjson_really_inline bool value_iterator::started_object() noexcept {\n+  assert_at_container_start();\n   if (*_json_iter->peek() == '}') {\n     logger::log_value(*_json_iter, \"empty object\");\n     _json_iter->advance();\n@@ -256,21 +248,12 @@ simdjson_warn_unused simdjson_really_inline error_code value_iterator::field_val\n }\n \n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::start_array() noexcept {\n-  assert_at_start();\n-\n-  if (*_json_iter->advance() != '[') { logger::log_error(*_json_iter, \"Not an array\"); return INCORRECT_TYPE; }\n-  return started_array();\n-}\n-\n-simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::try_start_array() noexcept {\n-  assert_at_start();\n-\n-  if (*_json_iter->peek() != '[') { logger::log_error(*_json_iter, \"Not an array\"); return INCORRECT_TYPE; }\n-  _json_iter->advance();\n+  if (*advance_container_start(\"array\") != '[') { return incorrect_type_error(\"Not an array\"); }\n   return started_array();\n }\n \n simdjson_warn_unused simdjson_really_inline bool value_iterator::started_array() noexcept {\n+  assert_at_container_start();\n   if (*_json_iter->peek() == ']') {\n     logger::log_value(*_json_iter, \"empty array\");\n     _json_iter->advance();\n@@ -313,7 +296,7 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> va\n   return get_raw_json_string().unescape(_json_iter->string_buf_loc());\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> value_iterator::get_raw_json_string() noexcept {\n-  auto json = advance_scalar(\"string\");\n+  auto json = advance_start(\"string\");\n   if (*json != '\"') { return incorrect_type_error(\"Not a string\"); }\n   return raw_json_string(json+1);\n }\n@@ -342,21 +325,21 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> val\n   return get_raw_json_string();\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_root_uint64() noexcept {\n-  auto max_len = peek_scalar_length();\n+  auto max_len = peek_start_length();\n   auto json = advance_root_scalar(\"uint64\");\n   uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n   if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 20 characters\"); return NUMBER_ERROR; }\n   return numberparsing::parse_unsigned(tmpbuf);\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_root_int64() noexcept {\n-  auto max_len = peek_scalar_length();\n+  auto max_len = peek_start_length();\n   auto json = advance_root_scalar(\"int64\");\n   uint8_t tmpbuf[20+1]; // -<19 digits> is the longest possible integer\n   if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { logger::log_error(*_json_iter, _start_position, depth(), \"Root number more than 20 characters\"); return NUMBER_ERROR; }\n   return numberparsing::parse_integer(tmpbuf);\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_root_double() noexcept {\n-  auto max_len = peek_scalar_length();\n+  auto max_len = peek_start_length();\n   auto json = advance_root_scalar(\"double\");\n   // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/, 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest number: -0.<fraction>e-308.\n   uint8_t tmpbuf[1074+8+1];\n@@ -364,14 +347,14 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterat\n   return numberparsing::parse_double(tmpbuf);\n }\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::get_root_bool() noexcept {\n-  auto max_len = peek_scalar_length();\n+  auto max_len = peek_start_length();\n   auto json = advance_root_scalar(\"bool\");\n   uint8_t tmpbuf[5+1];\n   if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) { return incorrect_type_error(\"Not a boolean\"); }\n   return parse_bool(tmpbuf);\n }\n simdjson_really_inline bool value_iterator::is_root_null() noexcept {\n-  auto max_len = peek_scalar_length();\n+  auto max_len = peek_start_length();\n   auto json = advance_root_scalar(\"null\");\n   return max_len >= 4 && !atomparsing::str4ncmp(json, \"null\") &&\n          (max_len == 4 || jsoncharutils::is_structural_or_whitespace(json[5]));\n@@ -427,17 +410,17 @@ simdjson_warn_unused simdjson_really_inline json_iterator &value_iterator::json_\n   return *_json_iter;\n }\n \n-simdjson_really_inline const uint8_t *value_iterator::peek_scalar() const noexcept {\n+simdjson_really_inline const uint8_t *value_iterator::peek_start() const noexcept {\n   return _json_iter->peek(_start_position);\n }\n-simdjson_really_inline uint32_t value_iterator::peek_scalar_length() const noexcept {\n+simdjson_really_inline uint32_t value_iterator::peek_start_length() const noexcept {\n   return _json_iter->peek_length(_start_position);\n }\n \n-simdjson_really_inline const uint8_t *value_iterator::advance_scalar(const char *type) const noexcept {\n+simdjson_really_inline const uint8_t *value_iterator::advance_start(const char *type) const noexcept {\n   logger::log_value(*_json_iter, _start_position, depth(), type);\n   // If we're not at the position anymore, we don't want to advance the cursor.\n-  if (!is_at_start()) { return peek_scalar(); }\n+  if (!is_at_start()) { return peek_start(); }\n \n   // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n   assert_at_start();\n@@ -445,9 +428,19 @@ simdjson_really_inline const uint8_t *value_iterator::advance_scalar(const char\n   _json_iter->ascend_to(depth()-1);\n   return result;\n }\n+simdjson_really_inline const uint8_t *value_iterator::advance_container_start(const char *type) const noexcept {\n+  // If we're not at the position anymore, we don't want to advance the cursor.\n+  if (is_at_container_start()) { return peek_start(); }\n+\n+  logger::log_start_value(*_json_iter, _start_position, depth(), type);\n+\n+  // Get the JSON and advance the cursor, decreasing depth to signify that we have retrieved the value.\n+  assert_at_start();\n+  return _json_iter->advance();\n+}\n simdjson_really_inline const uint8_t *value_iterator::advance_root_scalar(const char *type) const noexcept {\n   logger::log_value(*_json_iter, _start_position, depth(), type);\n-  if (!is_at_start()) { return peek_scalar(); }\n+  if (!is_at_start()) { return peek_start(); }\n \n   assert_at_root();\n   auto result = _json_iter->advance();\n@@ -456,7 +449,7 @@ simdjson_really_inline const uint8_t *value_iterator::advance_root_scalar(const\n }\n simdjson_really_inline const uint8_t *value_iterator::advance_non_root_scalar(const char *type) const noexcept {\n   logger::log_value(*_json_iter, _start_position, depth(), type);\n-  if (!is_at_start()) { return peek_scalar(); }\n+  if (!is_at_start()) { return peek_start(); }\n \n   assert_at_non_root_start();\n   auto result = _json_iter->advance();\n@@ -472,6 +465,9 @@ simdjson_really_inline error_code value_iterator::incorrect_type_error(const cha\n simdjson_really_inline bool value_iterator::is_at_start() const noexcept {\n   return _json_iter->token.index == _start_position;\n }\n+simdjson_really_inline bool value_iterator::is_at_container_start() const noexcept {\n+  return _json_iter->token.index == _start_position + 1;\n+}\n \n simdjson_really_inline void value_iterator::assert_at_start() const noexcept {\n   SIMDJSON_ASSUME( _json_iter->token.index == _start_position );\n@@ -479,6 +475,12 @@ simdjson_really_inline void value_iterator::assert_at_start() const noexcept {\n   SIMDJSON_ASSUME( _depth > 0 );\n }\n \n+simdjson_really_inline void value_iterator::assert_at_container_start() const noexcept {\n+  SIMDJSON_ASSUME( _json_iter->token.index == _start_position + 1 );\n+  SIMDJSON_ASSUME( _json_iter->_depth == _depth );\n+  SIMDJSON_ASSUME( _depth > 0 );\n+}\n+\n simdjson_really_inline void value_iterator::assert_at_next() const noexcept {\n   SIMDJSON_ASSUME( _json_iter->token.index > _start_position );\n   SIMDJSON_ASSUME( _json_iter->_depth == _depth );\ndiff --git a/include/simdjson/generic/ondemand/value_iterator.h b/include/simdjson/generic/ondemand/value_iterator.h\n--- a/include/simdjson/generic/ondemand/value_iterator.h\n+++ b/include/simdjson/generic/ondemand/value_iterator.h\n@@ -208,13 +208,6 @@ class value_iterator {\n    * @error INCORRECT_TYPE If there is no [.\n    */\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> start_array() noexcept;\n-  /**\n-   * Check for an opening [ and start an array iteration.\n-   *\n-   * @returns Whether the array had any elements (returns false for empty).\n-   * @error INCORRECT_TYPE If there is no [.\n-   */\n-  simdjson_warn_unused simdjson_really_inline simdjson_result<bool> try_start_array() noexcept;\n \n   /**\n    * Start an array iteration after the user has already checked and moved past the [.\n@@ -278,16 +271,19 @@ class value_iterator {\n   simdjson_really_inline bool parse_null(const uint8_t *json) const noexcept;\n   simdjson_really_inline simdjson_result<bool> parse_bool(const uint8_t *json) const noexcept;\n \n-  simdjson_really_inline const uint8_t *peek_scalar() const noexcept;\n-  simdjson_really_inline uint32_t peek_scalar_length() const noexcept;\n-  simdjson_really_inline const uint8_t *advance_scalar(const char *type) const noexcept;\n+  simdjson_really_inline const uint8_t *peek_start() const noexcept;\n+  simdjson_really_inline uint32_t peek_start_length() const noexcept;\n+  simdjson_really_inline const uint8_t *advance_start(const char *type) const noexcept;\n+  simdjson_really_inline const uint8_t *advance_container_start(const char *type) const noexcept;\n   simdjson_really_inline const uint8_t *advance_root_scalar(const char *type) const noexcept;\n   simdjson_really_inline const uint8_t *advance_non_root_scalar(const char *type) const noexcept;\n \n   simdjson_really_inline error_code incorrect_type_error(const char *message) const noexcept;\n \n   simdjson_really_inline bool is_at_start() const noexcept;\n+  simdjson_really_inline bool is_at_container_start() const noexcept;\n   simdjson_really_inline void assert_at_start() const noexcept;\n+  simdjson_really_inline void assert_at_container_start() const noexcept;\n   simdjson_really_inline void assert_at_root() const noexcept;\n   simdjson_really_inline void assert_at_child() const noexcept;\n   simdjson_really_inline void assert_at_next() const noexcept;\n",
        "test_patch": "diff --git a/tests/ondemand/CMakeLists.txt b/tests/ondemand/CMakeLists.txt\n--- a/tests/ondemand/CMakeLists.txt\n+++ b/tests/ondemand/CMakeLists.txt\n@@ -4,14 +4,16 @@ include_directories(..)\n add_subdirectory(compilation_failure_tests)\n \n add_cpp_test(ondemand_active_tests      LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_array_tests       LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_compilation_tests LABELS ondemand acceptance per_implementation)\n-add_cpp_test(ondemand_dom_api_tests     LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_error_tests       LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_key_string_tests  LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_number_tests      LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_object_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_ordering_tests    LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_parse_api_tests   LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_readme_examples   LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_scalar_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_twitter_tests     LABELS ondemand acceptance per_implementation)\n \n if(HAVE_POSIX_FORK AND HAVE_POSIX_WAIT) # assert tests use fork and wait, which aren't on MSVC\n@@ -20,8 +22,8 @@ endif()\n \n # Copy the simdjson dll into the tests directory\n if(MSVC)\n-  add_custom_command(TARGET ondemand_dom_api_tests POST_BUILD        # Adds a post-build event\n+  add_custom_command(TARGET ondemand_parse_api_tests POST_BUILD        # Adds a post-build event\n     COMMAND ${CMAKE_COMMAND} -E copy_if_different  # which executes \"cmake -E copy_if_different...\"\n         \"$<TARGET_FILE:simdjson>\"      # <--this is in-file\n-        \"$<TARGET_FILE_DIR:ondemand_dom_api_tests>\")                 # <--this is out-file path\n+        \"$<TARGET_FILE_DIR:ondemand_parse_api_tests>\")                 # <--this is out-file path\n endif(MSVC)\ndiff --git a/tests/ondemand/ondemand_array_tests.cpp b/tests/ondemand/ondemand_array_tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ondemand/ondemand_array_tests.cpp\n@@ -0,0 +1,275 @@\n+#include \"simdjson.h\"\n+#include \"test_ondemand.h\"\n+\n+using namespace simdjson;\n+\n+namespace array_tests {\n+  using namespace std;\n+\n+  bool iterate_array() {\n+    TEST_START();\n+    const auto json = R\"([ 1, 10, 100 ])\"_padded;\n+    const uint64_t expected_value[] = { 1, 10, 100 };\n+\n+    SUBTEST(\"ondemand::array\", test_ondemand_doc(json, [&](auto doc_result) {\n+      ondemand::array array;\n+      ASSERT_SUCCESS( doc_result.get(array) );\n+\n+      size_t i=0;\n+      for (auto value : array) {\n+        int64_t actual;\n+        ASSERT_SUCCESS( value.get(actual) );\n+        ASSERT_EQUAL(actual, expected_value[i]);\n+        i++;\n+      }\n+      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n+      return true;\n+    }));\n+    SUBTEST(\"simdjson_result<ondemand::array>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      simdjson_result<ondemand::array> array = doc_result.get_array();\n+      size_t i=0;\n+      for (simdjson_unused auto value : array) { int64_t actual; ASSERT_SUCCESS( value.get(actual) ); ASSERT_EQUAL(actual, expected_value[i]); i++; }\n+      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n+      return true;\n+    }));\n+    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc_result) {\n+      ondemand::document doc;\n+      ASSERT_SUCCESS( std::move(doc_result).get(doc) );\n+      size_t i=0;\n+      for (simdjson_unused auto value : doc) { int64_t actual; ASSERT_SUCCESS( value.get(actual) ); ASSERT_EQUAL(actual, expected_value[i]); i++; }\n+      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n+      return true;\n+    }));\n+    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      size_t i=0;\n+      for (simdjson_unused auto value : doc_result) { int64_t actual; ASSERT_SUCCESS( value.get(actual) ); ASSERT_EQUAL(actual, expected_value[i]); i++; }\n+      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n+      return true;\n+    }));\n+    TEST_SUCCEED();\n+  }\n+\n+  bool iterate_array_partial_children() {\n+    TEST_START();\n+    auto json = R\"(\n+      [\n+        0,\n+        [],\n+        {},\n+        { \"x\": 3, \"y\": 33 },\n+        { \"x\": 4, \"y\": 44 },\n+        { \"x\": 5, \"y\": 55 },\n+        { \"x\": 6, \"y\": 66 },\n+        [ 7, 77, 777 ],\n+        [ 8, 88, 888 ],\n+        { \"a\": [ { \"b\": [ 9, 99 ], \"c\": 999 }, 9999 ], \"d\": 99999 },\n+        10\n+      ]\n+    )\"_padded;\n+    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      size_t i = 0;\n+      for (auto value : doc_result) {\n+        ASSERT_SUCCESS(value);\n+\n+        switch (i) {\n+          case 0: {\n+            std::cout << \"  - After ignoring empty scalar ...\" << std::endl;\n+            break;\n+          }\n+          case 1: {\n+            std::cout << \"  - After ignoring empty array ...\" << std::endl;\n+            break;\n+          }\n+          case 2: {\n+            std::cout << \"  - After ignoring empty object ...\" << std::endl;\n+            break;\n+          }\n+          // Break after using first value in child object\n+          case 3: {\n+            for (auto [ child_field, error ] : value.get_object()) {\n+              ASSERT_SUCCESS(error);\n+              ASSERT_EQUAL(child_field.key(), \"x\");\n+              uint64_t x;\n+              ASSERT_SUCCESS( child_field.value().get(x) );\n+              ASSERT_EQUAL(x, 3);\n+              break; // Break after the first value\n+            }\n+            std::cout << \"  - After using first value in child object ...\" << std::endl;\n+            break;\n+          }\n+\n+          // Break without using first value in child object\n+          case 4: {\n+            for (auto [ child_field, error ] : value.get_object()) {\n+              ASSERT_SUCCESS(error);\n+              ASSERT_EQUAL(child_field.key(), \"x\");\n+              break;\n+            }\n+            std::cout << \"  - After reaching (but not using) first value in child object ...\" << std::endl;\n+            break;\n+          }\n+\n+          // Only look up one field in child object\n+          case 5: {\n+            uint64_t x;\n+            ASSERT_SUCCESS( value[\"x\"].get(x) );\n+            ASSERT_EQUAL( x, 5 );\n+            std::cout << \"  - After looking up one field in child object ...\" << std::endl;\n+            break;\n+          }\n+\n+          // Only look up one field in child object, but don't use it\n+          case 6: {\n+            ASSERT_SUCCESS( value[\"x\"] );\n+            std::cout << \"  - After looking up (but not using) one field in child object ...\" << std::endl;\n+            break;\n+          }\n+\n+          // Break after first value in child array\n+          case 7: {\n+            for (auto [ child_value, error ] : value) {\n+              ASSERT_SUCCESS(error);\n+              uint64_t x;\n+              ASSERT_SUCCESS( child_value.get(x) );\n+              ASSERT_EQUAL( x, 7 );\n+              break;\n+            }\n+            std::cout << \"  - After using first value in child array ...\" << std::endl;\n+            break;\n+          }\n+\n+          // Break without using first value in child array\n+          case 8: {\n+            for (auto child_value : value) {\n+              ASSERT_SUCCESS(child_value);\n+              break;\n+            }\n+            std::cout << \"  - After reaching (but not using) first value in child array ...\" << std::endl;\n+            break;\n+          }\n+\n+          // Break out of multiple child loops\n+          case 9: {\n+            for (auto child1 : value.get_object()) {\n+              for (auto child2 : child1.value().get_array()) {\n+                for (auto child3 : child2.get_object()) {\n+                  for (auto child4 : child3.value().get_array()) {\n+                    uint64_t x;\n+                    ASSERT_SUCCESS( child4.get(x) );\n+                    ASSERT_EQUAL( x, 9 );\n+                    break;\n+                  }\n+                  break;\n+                }\n+                break;\n+              }\n+              break;\n+            }\n+            std::cout << \"  - After breaking out of quadruply-nested arrays and objects ...\" << std::endl;\n+            break;\n+          }\n+\n+          // Test the actual value\n+          case 10: {\n+            uint64_t actual_value;\n+            ASSERT_SUCCESS( value.get(actual_value) );\n+            ASSERT_EQUAL( actual_value, 10 );\n+            break;\n+          }\n+        }\n+\n+        i++;\n+      }\n+      ASSERT_EQUAL( i, 11 ); // Make sure we found all the keys we expected\n+      return true;\n+    }));\n+    return true;\n+  }\n+\n+  bool iterate_empty_array() {\n+    TEST_START();\n+    auto json = \"[]\"_padded;\n+    SUBTEST(\"ondemand::array\", test_ondemand_doc(json, [&](auto doc_result) {\n+      ondemand::array array;\n+      ASSERT_SUCCESS( doc_result.get(array) );\n+      for (simdjson_unused auto value : array) { TEST_FAIL(\"Unexpected value\"); }\n+      return true;\n+    }));\n+    SUBTEST(\"simdjson_result<ondemand::array>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      simdjson_result<ondemand::array> array_result = doc_result.get_array();\n+      for (simdjson_unused auto value : array_result) { TEST_FAIL(\"Unexpected value\"); }\n+      return true;\n+    }));\n+    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc_result) {\n+      ondemand::document doc;\n+      ASSERT_SUCCESS( std::move(doc_result).get(doc) );\n+      for (simdjson_unused auto value : doc) { TEST_FAIL(\"Unexpected value\"); }\n+      return true;\n+    }));\n+    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      for (simdjson_unused auto value : doc_result) { TEST_FAIL(\"Unexpected value\"); }\n+      return true;\n+    }));\n+    TEST_SUCCEED();\n+  }\n+\n+#if SIMDJSON_EXCEPTIONS\n+\n+  bool iterate_array_exception() {\n+    TEST_START();\n+    auto json = R\"([ 1, 10, 100 ])\"_padded;\n+    const uint64_t expected_value[] = { 1, 10, 100 };\n+\n+    ASSERT_TRUE(test_ondemand_doc(json, [&](auto doc_result) {\n+      size_t i=0;\n+      for (int64_t actual : doc_result) { ASSERT_EQUAL(actual, expected_value[i]); i++; }\n+      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n+      return true;\n+    }));\n+    TEST_SUCCEED();\n+  }\n+\n+  bool iterate_empty_object_exception() {\n+    TEST_START();\n+    auto json = R\"({})\"_padded;\n+\n+    ASSERT_TRUE(test_ondemand_doc(json, [&](auto doc_result) {\n+      for (simdjson_unused ondemand::field field : doc_result.get_object()) {\n+        TEST_FAIL(\"Unexpected field\");\n+      }\n+      return true;\n+    }));\n+\n+    TEST_SUCCEED();\n+  }\n+\n+  bool iterate_empty_array_exception() {\n+    TEST_START();\n+    auto json = \"[]\"_padded;\n+\n+    ASSERT_TRUE(test_ondemand_doc(json, [&](auto doc_result) {\n+      for (simdjson_unused ondemand::value value : doc_result) { TEST_FAIL(\"Unexpected value\"); }\n+      return true;\n+    }));\n+\n+    TEST_SUCCEED();\n+  }\n+\n+#endif // SIMDJSON_EXCEPTIONS\n+\n+  bool run() {\n+    return\n+           iterate_array() &&\n+           iterate_empty_array() &&\n+           iterate_array_partial_children() &&\n+#if SIMDJSON_EXCEPTIONS\n+           iterate_array_exception() &&\n+#endif // SIMDJSON_EXCEPTIONS\n+           true;\n+  }\n+\n+} // namespace dom_api_tests\n+\n+int main(int argc, char *argv[]) {\n+  return test_main(argc, argv, array_tests::run);\n+}\ndiff --git a/tests/ondemand/ondemand_error_tests.cpp b/tests/ondemand/ondemand_error_tests.cpp\n--- a/tests/ondemand/ondemand_error_tests.cpp\n+++ b/tests/ondemand/ondemand_error_tests.cpp\n@@ -39,9 +39,9 @@ namespace error_tests {\n       TEST_START();\n       TEST_CAST_ERROR(\"[]\", object, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"[]\", bool, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"[]\", int64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"[]\", uint64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"[]\", double, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"[]\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"[]\", uint64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"[]\", double, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"[]\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"[]\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -51,9 +51,9 @@ namespace error_tests {\n       TEST_START();\n       TEST_CAST_ERROR(\"{}\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"{}\", bool, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"{}\", int64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"{}\", uint64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"{}\", double, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"{}\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"{}\", uint64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"{}\", double, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"{}\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"{}\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -63,9 +63,9 @@ namespace error_tests {\n       TEST_START();\n       TEST_CAST_ERROR(\"true\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"true\", object, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"true\", int64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"true\", uint64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"true\", double, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"true\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"true\", uint64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"true\", double, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"true\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"true\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -75,9 +75,9 @@ namespace error_tests {\n       TEST_START();\n       TEST_CAST_ERROR(\"false\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"false\", object, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"false\", int64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"false\", uint64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"false\", double, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"false\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"false\", uint64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"false\", double, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"false\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"false\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -87,9 +87,9 @@ namespace error_tests {\n       TEST_START();\n       TEST_CAST_ERROR(\"null\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"null\", object, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"null\", int64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"null\", uint64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"null\", double, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"null\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"null\", uint64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"null\", double, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"null\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"null\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -110,7 +110,7 @@ namespace error_tests {\n       TEST_CAST_ERROR(\"-1\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-1\", object, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-1\", bool, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"-1\", uint64, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"-1\", uint64, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-1\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-1\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -121,8 +121,8 @@ namespace error_tests {\n       TEST_CAST_ERROR(\"1.1\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"1.1\", object, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"1.1\", bool, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"1.1\", int64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"1.1\", uint64, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"1.1\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"1.1\", uint64, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"1.1\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"1.1\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -133,8 +133,8 @@ namespace error_tests {\n       TEST_CAST_ERROR(\"-9223372036854775809\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-9223372036854775809\", object, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-9223372036854775809\", bool, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"-9223372036854775809\", int64, NUMBER_ERROR);\n-      TEST_CAST_ERROR(\"-9223372036854775809\", uint64, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"-9223372036854775809\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"-9223372036854775809\", uint64, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-9223372036854775809\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"-9223372036854775809\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -146,7 +146,7 @@ namespace error_tests {\n       TEST_CAST_ERROR(\"9223372036854775808\", object, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"9223372036854775808\", bool, INCORRECT_TYPE);\n       // TODO BUG: this should be an error but is presently not\n-      // TEST_CAST_ERROR(\"9223372036854775808\", int64, NUMBER_ERROR);\n+      // TEST_CAST_ERROR(\"9223372036854775808\", int64, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"9223372036854775808\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"9223372036854775808\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -157,9 +157,8 @@ namespace error_tests {\n       TEST_CAST_ERROR(\"18446744073709551616\", array, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"18446744073709551616\", object, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"18446744073709551616\", bool, INCORRECT_TYPE);\n-      TEST_CAST_ERROR(\"18446744073709551616\", int64, NUMBER_ERROR);\n-      // TODO BUG: this should be an error but is presently not\n-      // TEST_CAST_ERROR(\"18446744073709551616\", uint64, NUMBER_ERROR);\n+      TEST_CAST_ERROR(\"18446744073709551616\", int64, INCORRECT_TYPE);\n+      TEST_CAST_ERROR(\"18446744073709551616\", uint64, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"18446744073709551616\", string, INCORRECT_TYPE);\n       TEST_CAST_ERROR(\"18446744073709551616\", raw_json_string, INCORRECT_TYPE);\n       TEST_SUCCEED();\n@@ -238,43 +237,43 @@ namespace error_tests {\n   bool top_level_array_iterate_error() {\n     TEST_START();\n     ONDEMAND_SUBTEST(\"missing comma\", \"[1 1]\",  assert_iterate(doc, { int64_t(1) }, { TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"extra comma  \", \"[1,,1]\", assert_iterate(doc, { int64_t(1) }, { NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"extra comma  \", \"[,]\",    assert_iterate(doc,                 { NUMBER_ERROR }));\n-    ONDEMAND_SUBTEST(\"extra comma  \", \"[,,]\",   assert_iterate(doc,                 { NUMBER_ERROR, NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"extra comma  \", \"[1,,1]\", assert_iterate(doc, { int64_t(1) }, { INCORRECT_TYPE, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"extra comma  \", \"[,]\",    assert_iterate(doc,                 { INCORRECT_TYPE }));\n+    ONDEMAND_SUBTEST(\"extra comma  \", \"[,,]\",   assert_iterate(doc,                 { INCORRECT_TYPE, INCORRECT_TYPE, TAPE_ERROR }));\n     TEST_SUCCEED();\n   }\n   bool top_level_array_iterate_unclosed_error() {\n     TEST_START();\n-    ONDEMAND_SUBTEST(\"unclosed extra comma\", \"[,\", assert_iterate(doc,                 { NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"unclosed     \", \"[1 \",    assert_iterate(doc, { int64_t(1) }, { TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed extra comma\", \"[,\", assert_iterate(doc,                 { INCORRECT_TYPE, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed     \", \"[1 \",       assert_iterate(doc, { int64_t(1) }, { TAPE_ERROR }));\n     // TODO These pass the user values that may run past the end of the buffer if they aren't careful\n     // In particular, if the padding is decorated with the wrong values, we could cause overrun!\n-    ONDEMAND_SUBTEST(\"unclosed extra comma\", \"[,,\", assert_iterate(doc,                 { NUMBER_ERROR, NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"unclosed     \", \"[1,\",    assert_iterate(doc, { int64_t(1) }, { NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"unclosed     \", \"[1\",     assert_iterate(doc,                 { NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"unclosed     \", \"[\",      assert_iterate(doc,                 { NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed extra comma\", \"[,,\", assert_iterate(doc,                 { INCORRECT_TYPE, INCORRECT_TYPE, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed     \", \"[1,\",        assert_iterate(doc, { int64_t(1) }, { INCORRECT_TYPE, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed     \", \"[1\",         assert_iterate(doc,                 { NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed     \", \"[\",          assert_iterate(doc,                 { INCORRECT_TYPE, TAPE_ERROR }));\n     TEST_SUCCEED();\n   }\n \n   bool array_iterate_error() {\n     TEST_START();\n     ONDEMAND_SUBTEST(\"missing comma\", R\"({ \"a\": [1 1] })\",  assert_iterate(doc[\"a\"], { int64_t(1) }, { TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [1,,1] })\", assert_iterate(doc[\"a\"], { int64_t(1) }, { NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [1,,] })\",  assert_iterate(doc[\"a\"], { int64_t(1) }, { NUMBER_ERROR }));\n-    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [,] })\",    assert_iterate(doc[\"a\"],                 { NUMBER_ERROR }));\n-    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [,,] })\",   assert_iterate(doc[\"a\"],                 { NUMBER_ERROR, NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [1,,1] })\", assert_iterate(doc[\"a\"], { int64_t(1) }, { INCORRECT_TYPE, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [1,,] })\",  assert_iterate(doc[\"a\"], { int64_t(1) }, { INCORRECT_TYPE }));\n+    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [,] })\",    assert_iterate(doc[\"a\"],                 { INCORRECT_TYPE }));\n+    ONDEMAND_SUBTEST(\"extra comma  \", R\"({ \"a\": [,,] })\",   assert_iterate(doc[\"a\"],                 { INCORRECT_TYPE, INCORRECT_TYPE, TAPE_ERROR }));\n     TEST_SUCCEED();\n   }\n   bool array_iterate_unclosed_error() {\n     TEST_START();\n-    ONDEMAND_SUBTEST(\"unclosed extra comma\", R\"({ \"a\": [,)\",  assert_iterate(doc[\"a\"],                 { NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"unclosed extra comma\", R\"({ \"a\": [,,)\", assert_iterate(doc[\"a\"],                 { NUMBER_ERROR, NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed extra comma\", R\"({ \"a\": [,)\",  assert_iterate(doc[\"a\"],                 { INCORRECT_TYPE, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed extra comma\", R\"({ \"a\": [,,)\", assert_iterate(doc[\"a\"],                 { INCORRECT_TYPE, INCORRECT_TYPE, TAPE_ERROR }));\n     ONDEMAND_SUBTEST(\"unclosed     \", R\"({ \"a\": [1 )\",        assert_iterate(doc[\"a\"], { int64_t(1) }, { TAPE_ERROR }));\n     // TODO These pass the user values that may run past the end of the buffer if they aren't careful\n     // In particular, if the padding is decorated with the wrong values, we could cause overrun!\n-    ONDEMAND_SUBTEST(\"unclosed     \", R\"({ \"a\": [1,)\",        assert_iterate(doc[\"a\"], { int64_t(1) }, { NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed     \", R\"({ \"a\": [1,)\",        assert_iterate(doc[\"a\"], { int64_t(1) }, { INCORRECT_TYPE, TAPE_ERROR }));\n     ONDEMAND_SUBTEST(\"unclosed     \", R\"({ \"a\": [1)\",         assert_iterate(doc[\"a\"],                 { NUMBER_ERROR, TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"unclosed     \", R\"({ \"a\": [)\",          assert_iterate(doc[\"a\"],                 { NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed     \", R\"({ \"a\": [)\",          assert_iterate(doc[\"a\"],                 { INCORRECT_TYPE, TAPE_ERROR }));\n     TEST_SUCCEED();\n   }\n \n@@ -317,7 +316,7 @@ namespace error_tests {\n     TEST_START();\n     ONDEMAND_SUBTEST(\"missing colon\", R\"({ \"a\"  1, \"b\": 2 })\",    assert_iterate_object(doc.get_object(),                          { TAPE_ERROR }));\n     ONDEMAND_SUBTEST(\"missing key  \", R\"({    : 1, \"b\": 2 })\",    assert_iterate_object(doc.get_object(),                          { TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"missing value\", R\"({ \"a\":  , \"b\": 2 })\",    assert_iterate_object(doc.get_object(),                          { NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"missing value\", R\"({ \"a\":  , \"b\": 2 })\",    assert_iterate_object(doc.get_object(),                          { INCORRECT_TYPE, TAPE_ERROR }));\n     ONDEMAND_SUBTEST(\"missing comma\", R\"({ \"a\": 1  \"b\": 2 })\",    assert_iterate_object(doc.get_object(), { \"a\" }, { int64_t(1) }, { TAPE_ERROR }));\n     TEST_SUCCEED();\n   }\n@@ -337,7 +336,7 @@ namespace error_tests {\n     // TODO These next two pass the user a value that may run past the end of the buffer if they aren't careful.\n     // In particular, if the padding is decorated with the wrong values, we could cause overrun!\n     ONDEMAND_SUBTEST(\"unclosed\", R\"({ \"a\": 1          )\",    assert_iterate_object(doc.get_object(), { \"a\" }, { int64_t(1) }, { TAPE_ERROR }));\n-    ONDEMAND_SUBTEST(\"unclosed\", R\"({ \"a\":            )\",    assert_iterate_object(doc.get_object(),                          { NUMBER_ERROR, TAPE_ERROR }));\n+    ONDEMAND_SUBTEST(\"unclosed\", R\"({ \"a\":            )\",    assert_iterate_object(doc.get_object(),                          { INCORRECT_TYPE, TAPE_ERROR }));\n     ONDEMAND_SUBTEST(\"unclosed\", R\"({ \"a\"             )\",    assert_iterate_object(doc.get_object(),                          { TAPE_ERROR }));\n     ONDEMAND_SUBTEST(\"unclosed\", R\"({                 )\",    assert_iterate_object(doc.get_object(),                          { TAPE_ERROR }));\n     TEST_SUCCEED();\n@@ -399,6 +398,177 @@ namespace error_tests {\n     TEST_SUCCEED();\n   }\n \n+  bool get_fail_then_succeed_bool() {\n+    TEST_START();\n+    auto json = R\"({ \"val\" : true })\"_padded;\n+    SUBTEST(\"simdjson_result<ondemand::value>\", test_ondemand_doc(json, [&](auto doc) {\n+      simdjson_result<ondemand::value> val = doc[\"val\"];\n+      // Get everything that can fail in both forward and backwards order\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_SUCCESS( val.get_bool() );\n+      TEST_SUCCEED();\n+    }));\n+    SUBTEST(\"ondemand::value\", test_ondemand_doc(json, [&](auto doc) {\n+      ondemand::value val;\n+      ASSERT_SUCCESS( doc[\"val\"].get(val) );\n+      // Get everything that can fail in both forward and backwards order\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_SUCCESS( val.get_bool() );\n+      TEST_SUCCEED();\n+    }));\n+    json = R\"(true)\"_padded;\n+    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](simdjson_result<ondemand::document> val) {\n+      // Get everything that can fail in both forward and backwards order\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_SUCCESS( val.get_bool());\n+      TEST_SUCCEED();\n+    }));\n+    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc) {\n+      ondemand::document val;\n+      ASSERT_SUCCESS( std::move(doc).get(val) );      // Get everything that can fail in both forward and backwards order\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), false );\n+      ASSERT_SUCCESS( val.get_bool() );\n+      TEST_SUCCEED();\n+    }));\n+\n+    TEST_SUCCEED();\n+  }\n+\n+  bool get_fail_then_succeed_null() {\n+    TEST_START();\n+    auto json = R\"({ \"val\" : null })\"_padded;\n+    SUBTEST(\"simdjson_result<ondemand::value>\", test_ondemand_doc(json, [&](auto doc) {\n+      simdjson_result<ondemand::value> val = doc[\"val\"];\n+      // Get everything that can fail in both forward and backwards order\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), true );\n+      TEST_SUCCEED();\n+    }));\n+    SUBTEST(\"ondemand::value\", test_ondemand_doc(json, [&](auto doc) {\n+      ondemand::value val;\n+      ASSERT_SUCCESS( doc[\"val\"].get(val) );\n+      // Get everything that can fail in both forward and backwards order\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), true );\n+      TEST_SUCCEED();\n+    }));\n+    json = R\"(null)\"_padded;\n+    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](simdjson_result<ondemand::document> val) {\n+      // Get everything that can fail in both forward and backwards order\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), true );\n+      TEST_SUCCEED();\n+    }));\n+    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc) {\n+      ondemand::document val;\n+      ASSERT_SUCCESS( std::move(doc).get(val) );      // Get everything that can fail in both forward and backwards order\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_object(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_int64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_uint64(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_double(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_string(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_array(), INCORRECT_TYPE );\n+      ASSERT_ERROR( val.get_bool(), INCORRECT_TYPE );\n+      ASSERT_EQUAL( val.is_null(), true );\n+      TEST_SUCCEED();\n+    }));\n+\n+    //\n+    // Do it again for bool\n+    //\n+    TEST_SUCCEED();\n+  }\n+\n   bool run() {\n     return\n            empty_document_error() &&\n@@ -416,6 +586,8 @@ namespace error_tests {\n            object_lookup_miss_unclosed_error() &&\n            object_lookup_miss_wrong_key_type_error() &&\n            object_lookup_miss_next_error() &&\n+           get_fail_then_succeed_bool() &&\n+           get_fail_then_succeed_null() &&\n            true;\n   }\n }\ndiff --git a/tests/ondemand/ondemand_dom_api_tests.cpp b/tests/ondemand/ondemand_object_tests.cpp\nsimilarity index 62%\nrename from tests/ondemand/ondemand_dom_api_tests.cpp\nrename to tests/ondemand/ondemand_object_tests.cpp\n--- a/tests/ondemand/ondemand_dom_api_tests.cpp\n+++ b/tests/ondemand/ondemand_object_tests.cpp\n@@ -3,7 +3,7 @@\n \n using namespace simdjson;\n \n-namespace dom_api_tests {\n+namespace object_tests {\n   using namespace std;\n \n   bool iterate_object() {\n@@ -39,48 +39,6 @@ namespace dom_api_tests {\n     TEST_SUCCEED();\n   }\n \n-  bool iterate_array() {\n-    TEST_START();\n-    const auto json = R\"([ 1, 10, 100 ])\"_padded;\n-    const uint64_t expected_value[] = { 1, 10, 100 };\n-\n-    SUBTEST(\"ondemand::array\", test_ondemand_doc(json, [&](auto doc_result) {\n-      ondemand::array array;\n-      ASSERT_SUCCESS( doc_result.get(array) );\n-      size_t i=0;\n-      for (auto value : array) {\n-        int64_t actual;\n-        ASSERT_SUCCESS( value.get(actual) );\n-        ASSERT_EQUAL(actual, expected_value[i]);\n-        i++;\n-      }\n-      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n-      return true;\n-    }));\n-    SUBTEST(\"simdjson_result<ondemand::array>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      simdjson_result<ondemand::array> array = doc_result.get_array();\n-      size_t i=0;\n-      for (simdjson_unused auto value : array) { int64_t actual; ASSERT_SUCCESS( value.get(actual) ); ASSERT_EQUAL(actual, expected_value[i]); i++; }\n-      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n-      return true;\n-    }));\n-    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc_result) {\n-      ondemand::document doc;\n-      ASSERT_SUCCESS( std::move(doc_result).get(doc) );\n-      size_t i=0;\n-      for (simdjson_unused auto value : doc) { int64_t actual; ASSERT_SUCCESS( value.get(actual) ); ASSERT_EQUAL(actual, expected_value[i]); i++; }\n-      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n-      return true;\n-    }));\n-    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      size_t i=0;\n-      for (simdjson_unused auto value : doc_result) { int64_t actual; ASSERT_SUCCESS( value.get(actual) ); ASSERT_EQUAL(actual, expected_value[i]); i++; }\n-      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n-      return true;\n-    }));\n-    TEST_SUCCEED();\n-  }\n-\n   bool iterate_object_partial_children() {\n     TEST_START();\n     auto json = R\"(\n@@ -235,143 +193,6 @@ namespace dom_api_tests {\n     return true;\n   }\n \n-  bool iterate_array_partial_children() {\n-    TEST_START();\n-    auto json = R\"(\n-      [\n-        0,\n-        [],\n-        {},\n-        { \"x\": 3, \"y\": 33 },\n-        { \"x\": 4, \"y\": 44 },\n-        { \"x\": 5, \"y\": 55 },\n-        { \"x\": 6, \"y\": 66 },\n-        [ 7, 77, 777 ],\n-        [ 8, 88, 888 ],\n-        { \"a\": [ { \"b\": [ 9, 99 ], \"c\": 999 }, 9999 ], \"d\": 99999 },\n-        10\n-      ]\n-    )\"_padded;\n-    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      size_t i = 0;\n-      for (auto value : doc_result) {\n-        ASSERT_SUCCESS(value);\n-\n-        switch (i) {\n-          case 0: {\n-            std::cout << \"  - After ignoring empty scalar ...\" << std::endl;\n-            break;\n-          }\n-          case 1: {\n-            std::cout << \"  - After ignoring empty array ...\" << std::endl;\n-            break;\n-          }\n-          case 2: {\n-            std::cout << \"  - After ignoring empty object ...\" << std::endl;\n-            break;\n-          }\n-          // Break after using first value in child object\n-          case 3: {\n-            for (auto [ child_field, error ] : value.get_object()) {\n-              ASSERT_SUCCESS(error);\n-              ASSERT_EQUAL(child_field.key(), \"x\");\n-              uint64_t x;\n-              ASSERT_SUCCESS( child_field.value().get(x) );\n-              ASSERT_EQUAL(x, 3);\n-              break; // Break after the first value\n-            }\n-            std::cout << \"  - After using first value in child object ...\" << std::endl;\n-            break;\n-          }\n-\n-          // Break without using first value in child object\n-          case 4: {\n-            for (auto [ child_field, error ] : value.get_object()) {\n-              ASSERT_SUCCESS(error);\n-              ASSERT_EQUAL(child_field.key(), \"x\");\n-              break;\n-            }\n-            std::cout << \"  - After reaching (but not using) first value in child object ...\" << std::endl;\n-            break;\n-          }\n-\n-          // Only look up one field in child object\n-          case 5: {\n-            uint64_t x;\n-            ASSERT_SUCCESS( value[\"x\"].get(x) );\n-            ASSERT_EQUAL( x, 5 );\n-            std::cout << \"  - After looking up one field in child object ...\" << std::endl;\n-            break;\n-          }\n-\n-          // Only look up one field in child object, but don't use it\n-          case 6: {\n-            ASSERT_SUCCESS( value[\"x\"] );\n-            std::cout << \"  - After looking up (but not using) one field in child object ...\" << std::endl;\n-            break;\n-          }\n-\n-          // Break after first value in child array\n-          case 7: {\n-            for (auto [ child_value, error ] : value) {\n-              ASSERT_SUCCESS(error);\n-              uint64_t x;\n-              ASSERT_SUCCESS( child_value.get(x) );\n-              ASSERT_EQUAL( x, 7 );\n-              break;\n-            }\n-            std::cout << \"  - After using first value in child array ...\" << std::endl;\n-            break;\n-          }\n-\n-          // Break without using first value in child array\n-          case 8: {\n-            for (auto child_value : value) {\n-              ASSERT_SUCCESS(child_value);\n-              break;\n-            }\n-            std::cout << \"  - After reaching (but not using) first value in child array ...\" << std::endl;\n-            break;\n-          }\n-\n-          // Break out of multiple child loops\n-          case 9: {\n-            for (auto child1 : value.get_object()) {\n-              for (auto child2 : child1.value().get_array()) {\n-                for (auto child3 : child2.get_object()) {\n-                  for (auto child4 : child3.value().get_array()) {\n-                    uint64_t x;\n-                    ASSERT_SUCCESS( child4.get(x) );\n-                    ASSERT_EQUAL( x, 9 );\n-                    break;\n-                  }\n-                  break;\n-                }\n-                break;\n-              }\n-              break;\n-            }\n-            std::cout << \"  - After breaking out of quadruply-nested arrays and objects ...\" << std::endl;\n-            break;\n-          }\n-\n-          // Test the actual value\n-          case 10: {\n-            uint64_t actual_value;\n-            ASSERT_SUCCESS( value.get(actual_value) );\n-            ASSERT_EQUAL( actual_value, 10 );\n-            break;\n-          }\n-        }\n-\n-        i++;\n-      }\n-      ASSERT_EQUAL( i, 11 ); // Make sure we found all the keys we expected\n-      return true;\n-    }));\n-    return true;\n-  }\n-\n   bool object_index_partial_children() {\n     TEST_START();\n     auto json = R\"(\n@@ -635,234 +456,6 @@ namespace dom_api_tests {\n     TEST_SUCCEED();\n   }\n \n-  bool iterate_empty_array() {\n-    TEST_START();\n-    auto json = \"[]\"_padded;\n-    SUBTEST(\"ondemand::array\", test_ondemand_doc(json, [&](auto doc_result) {\n-      ondemand::array array;\n-      ASSERT_SUCCESS( doc_result.get(array) );\n-      for (simdjson_unused auto value : array) { TEST_FAIL(\"Unexpected value\"); }\n-      return true;\n-    }));\n-    SUBTEST(\"simdjson_result<ondemand::array>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      simdjson_result<ondemand::array> array_result = doc_result.get_array();\n-      for (simdjson_unused auto value : array_result) { TEST_FAIL(\"Unexpected value\"); }\n-      return true;\n-    }));\n-    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc_result) {\n-      ondemand::document doc;\n-      ASSERT_SUCCESS( std::move(doc_result).get(doc) );\n-      for (simdjson_unused auto value : doc) { TEST_FAIL(\"Unexpected value\"); }\n-      return true;\n-    }));\n-    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      for (simdjson_unused auto value : doc_result) { TEST_FAIL(\"Unexpected value\"); }\n-      return true;\n-    }));\n-    TEST_SUCCEED();\n-  }\n-\n-  template<typename T>\n-  bool test_scalar_value(const padded_string &json, const T &expected, bool test_twice=true) {\n-    std::cout << \"- JSON: \" << json << endl;\n-    SUBTEST( \"simdjson_result<document>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      T actual;\n-      ASSERT_SUCCESS( doc_result.get(actual) );\n-      ASSERT_EQUAL( expected, actual );\n-      // Test it twice (scalars can be retrieved more than once)\n-      if (test_twice) {\n-        ASSERT_SUCCESS( doc_result.get(actual) );\n-        ASSERT_EQUAL( expected, actual );\n-      }\n-      return true;\n-    }));\n-    SUBTEST( \"document\", test_ondemand_doc(json, [&](auto doc_result) {\n-      T actual;\n-      ASSERT_SUCCESS( doc_result.get(actual) );\n-      ASSERT_EQUAL( expected, actual );\n-      // Test it twice (scalars can be retrieved more than once)\n-      if (test_twice) {\n-        ASSERT_SUCCESS( doc_result.get(actual) );\n-        ASSERT_EQUAL( expected, actual );\n-      }\n-      return true;\n-    }));\n-\n-    {\n-      padded_string whitespace_json = std::string(json) + \" \";\n-      std::cout << \"- JSON: \" << whitespace_json << endl;\n-      SUBTEST( \"simdjson_result<document>\", test_ondemand_doc(whitespace_json, [&](auto doc_result) {\n-        T actual;\n-        ASSERT_SUCCESS( doc_result.get(actual) );\n-        ASSERT_EQUAL( expected, actual );\n-        // Test it twice (scalars can be retrieved more than once)\n-        if (test_twice) {\n-          ASSERT_SUCCESS( doc_result.get(actual) );\n-          ASSERT_EQUAL( expected, actual );\n-        }\n-        return true;\n-      }));\n-      SUBTEST( \"document\", test_ondemand_doc(whitespace_json, [&](auto doc_result) {\n-        T actual;\n-        ASSERT_SUCCESS( doc_result.get(actual) );\n-        ASSERT_EQUAL( expected, actual );\n-        // Test it twice (scalars can be retrieved more than once)\n-        if (test_twice) {\n-          ASSERT_SUCCESS( doc_result.get(actual) );\n-          ASSERT_EQUAL( expected, actual );\n-        }\n-        return true;\n-      }));\n-    }\n-\n-    {\n-      padded_string array_json = std::string(\"[\") + std::string(json) + \"]\";\n-      std::cout << \"- JSON: \" << array_json << endl;\n-      SUBTEST( \"simdjson_result<value>\", test_ondemand_doc(array_json, [&](auto doc_result) {\n-        int count = 0;\n-        for (simdjson_result<ondemand::value> val_result : doc_result) {\n-          T actual;\n-          ASSERT_SUCCESS( val_result.get(actual) );\n-          ASSERT_EQUAL(expected, actual);\n-          // Test it twice (scalars can be retrieved more than once)\n-          if (test_twice) {\n-            ASSERT_SUCCESS( val_result.get(actual) );\n-            ASSERT_EQUAL(expected, actual);\n-          }\n-          count++;\n-        }\n-        ASSERT_EQUAL(count, 1);\n-        return true;\n-      }));\n-      SUBTEST( \"value\", test_ondemand_doc(array_json, [&](auto doc_result) {\n-        int count = 0;\n-        for (simdjson_result<ondemand::value> val_result : doc_result) {\n-          ondemand::value val;\n-          ASSERT_SUCCESS( val_result.get(val) );\n-          T actual;\n-          ASSERT_SUCCESS( val.get(actual) );\n-          ASSERT_EQUAL(expected, actual);\n-          // Test it twice (scalars can be retrieved more than once)\n-          if (test_twice) {\n-            ASSERT_SUCCESS( val.get(actual) );\n-            ASSERT_EQUAL(expected, actual);\n-          }\n-          count++;\n-        }\n-        ASSERT_EQUAL(count, 1);\n-        return true;\n-      }));\n-    }\n-\n-    {\n-      padded_string whitespace_array_json = std::string(\"[\") + std::string(json) + \" ]\";\n-      std::cout << \"- JSON: \" << whitespace_array_json << endl;\n-      SUBTEST( \"simdjson_result<value>\", test_ondemand_doc(whitespace_array_json, [&](auto doc_result) {\n-        int count = 0;\n-        for (simdjson_result<ondemand::value> val_result : doc_result) {\n-          T actual;\n-          ASSERT_SUCCESS( val_result.get(actual) );\n-          ASSERT_EQUAL(expected, actual);\n-          // Test it twice (scalars can be retrieved more than once)\n-          if (test_twice) {\n-            ASSERT_SUCCESS( val_result.get(actual) );\n-            ASSERT_EQUAL(expected, actual);\n-          }\n-          count++;\n-        }\n-        ASSERT_EQUAL(count, 1);\n-        return true;\n-      }));\n-      SUBTEST( \"value\", test_ondemand_doc(whitespace_array_json, [&](auto doc_result) {\n-        int count = 0;\n-        for (simdjson_result<ondemand::value> val_result : doc_result) {\n-          ondemand::value val;\n-          ASSERT_SUCCESS( val_result.get(val) );\n-          T actual;\n-          ASSERT_SUCCESS( val.get(actual) );\n-          ASSERT_EQUAL(expected, actual);\n-          // Test it twice (scalars can be retrieved more than once)\n-          if (test_twice) {\n-            ASSERT_SUCCESS( val.get(actual) );\n-            ASSERT_EQUAL(expected, actual);\n-          }\n-          count++;\n-        }\n-        ASSERT_EQUAL(count, 1);\n-        return true;\n-      }));\n-    }\n-\n-    TEST_SUCCEED();\n-  }\n-\n-  bool string_value() {\n-    TEST_START();\n-    // We can't retrieve a small string twice because it will blow out the string buffer\n-    if (!test_scalar_value(R\"(\"hi\")\"_padded, std::string_view(\"hi\"), false)) { return false; }\n-    // ... unless the document is big enough to have a big string buffer :)\n-    if (!test_scalar_value(R\"(\"hi\"        )\"_padded, std::string_view(\"hi\"))) { return false; }\n-    TEST_SUCCEED();\n-  }\n-\n-  bool numeric_values() {\n-    TEST_START();\n-    if (!test_scalar_value<int64_t> (\"0\"_padded,   0)) { return false; }\n-    if (!test_scalar_value<uint64_t>(\"0\"_padded,   0)) { return false; }\n-    if (!test_scalar_value<double>  (\"0\"_padded,   0)) { return false; }\n-    if (!test_scalar_value<int64_t> (\"1\"_padded,   1)) { return false; }\n-    if (!test_scalar_value<uint64_t>(\"1\"_padded,   1)) { return false; }\n-    if (!test_scalar_value<double>  (\"1\"_padded,   1)) { return false; }\n-    if (!test_scalar_value<int64_t> (\"-1\"_padded,  -1)) { return false; }\n-    if (!test_scalar_value<double>  (\"-1\"_padded,  -1)) { return false; }\n-    if (!test_scalar_value<double>  (\"1.1\"_padded, 1.1)) { return false; }\n-    TEST_SUCCEED();\n-  }\n-\n-  bool boolean_values() {\n-    TEST_START();\n-    if (!test_scalar_value<bool> (\"true\"_padded,  true)) { return false; }\n-    if (!test_scalar_value<bool> (\"false\"_padded, false)) { return false; }\n-    TEST_SUCCEED();\n-  }\n-\n-  bool null_value() {\n-    TEST_START();\n-    auto json = \"null\"_padded;\n-    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc_result) {\n-      ondemand::document doc;\n-      ASSERT_SUCCESS( std::move(doc_result).get(doc) );\n-      ASSERT_EQUAL( doc.is_null(), true );\n-      return true;\n-    }));\n-    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      ASSERT_EQUAL( doc_result.is_null(), true );\n-      return true;\n-    }));\n-    json = \"[null]\"_padded;\n-    SUBTEST(\"ondemand::value\", test_ondemand_doc(json, [&](auto doc_result) {\n-      int count = 0;\n-      for (auto value_result : doc_result) {\n-        ondemand::value value;\n-        ASSERT_SUCCESS( value_result.get(value) );\n-        ASSERT_EQUAL( value.is_null(), true );\n-        count++;\n-      }\n-      ASSERT_EQUAL( count, 1 );\n-      return true;\n-    }));\n-    SUBTEST(\"simdjson_result<ondemand::value>\", test_ondemand_doc(json, [&](auto doc_result) {\n-      int count = 0;\n-      for (auto value_result : doc_result) {\n-        ASSERT_EQUAL( value_result.is_null(), true );\n-        count++;\n-      }\n-      ASSERT_EQUAL( count, 1 );\n-      return true;\n-    }));\n-    return true;\n-  }\n-\n   bool object_index() {\n     TEST_START();\n     auto json = R\"({ \"a\": 1, \"b\": 2, \"c/d\": 3})\"_padded;\n@@ -1140,20 +733,6 @@ namespace dom_api_tests {\n     TEST_SUCCEED();\n   }\n \n-  bool iterate_array_exception() {\n-    TEST_START();\n-    auto json = R\"([ 1, 10, 100 ])\"_padded;\n-    const uint64_t expected_value[] = { 1, 10, 100 };\n-\n-    ASSERT_TRUE(test_ondemand_doc(json, [&](auto doc_result) {\n-      size_t i=0;\n-      for (int64_t actual : doc_result) { ASSERT_EQUAL(actual, expected_value[i]); i++; }\n-      ASSERT_EQUAL(i*sizeof(uint64_t), sizeof(expected_value));\n-      return true;\n-    }));\n-    TEST_SUCCEED();\n-  }\n-\n   bool iterate_empty_object_exception() {\n     TEST_START();\n     auto json = R\"({})\"_padded;\n@@ -1168,65 +747,6 @@ namespace dom_api_tests {\n     TEST_SUCCEED();\n   }\n \n-  bool iterate_empty_array_exception() {\n-    TEST_START();\n-    auto json = \"[]\"_padded;\n-\n-    ASSERT_TRUE(test_ondemand_doc(json, [&](auto doc_result) {\n-      for (simdjson_unused ondemand::value value : doc_result) { TEST_FAIL(\"Unexpected value\"); }\n-      return true;\n-    }));\n-\n-    TEST_SUCCEED();\n-  }\n-\n-  template<typename T>\n-  bool test_scalar_value_exception(const padded_string &json, const T &expected) {\n-    std::cout << \"- JSON: \" << json << endl;\n-    SUBTEST( \"document\", test_ondemand_doc(json, [&](auto doc_result) {\n-      ASSERT_EQUAL( expected, T(doc_result) );\n-      return true;\n-    }));\n-    padded_string array_json = std::string(\"[\") + std::string(json) + \"]\";\n-    std::cout << \"- JSON: \" << array_json << endl;\n-    SUBTEST( \"value\", test_ondemand_doc(array_json, [&](auto doc_result) {\n-      int count = 0;\n-      for (T actual : doc_result) {\n-        ASSERT_EQUAL( expected, actual );\n-        count++;\n-      }\n-      ASSERT_EQUAL(count, 1);\n-      return true;\n-    }));\n-    TEST_SUCCEED();\n-  }\n-  bool string_value_exception() {\n-    TEST_START();\n-    return test_scalar_value_exception(R\"(\"hi\")\"_padded, std::string_view(\"hi\"));\n-  }\n-\n-  bool numeric_values_exception() {\n-    TEST_START();\n-    if (!test_scalar_value_exception<int64_t> (\"0\"_padded,   0)) { return false; }\n-    if (!test_scalar_value_exception<uint64_t>(\"0\"_padded,   0)) { return false; }\n-    if (!test_scalar_value_exception<double>  (\"0\"_padded,   0)) { return false; }\n-    if (!test_scalar_value_exception<int64_t> (\"1\"_padded,   1)) { return false; }\n-    if (!test_scalar_value_exception<uint64_t>(\"1\"_padded,   1)) { return false; }\n-    if (!test_scalar_value_exception<double>  (\"1\"_padded,   1)) { return false; }\n-    if (!test_scalar_value_exception<int64_t> (\"-1\"_padded,  -1)) { return false; }\n-    if (!test_scalar_value_exception<double>  (\"-1\"_padded,  -1)) { return false; }\n-    if (!test_scalar_value_exception<double>  (\"1.1\"_padded, 1.1)) { return false; }\n-    TEST_SUCCEED();\n-  }\n-\n-  bool boolean_values_exception() {\n-    TEST_START();\n-    if (!test_scalar_value_exception<bool> (\"true\"_padded,  true)) { return false; }\n-    if (!test_scalar_value_exception<bool> (\"false\"_padded, false)) { return false; }\n-    TEST_SUCCEED();\n-  }\n-\n-\n   bool object_index_exception() {\n     TEST_START();\n     auto json = R\"({ \"a\": 1, \"b\": 2, \"c/d\": 3})\"_padded;\n@@ -1255,35 +775,24 @@ namespace dom_api_tests {\n \n   bool run() {\n     return\n-           iterate_array() &&\n-           iterate_empty_array() &&\n            iterate_object() &&\n            iterate_empty_object() &&\n-           string_value() &&\n-           numeric_values() &&\n-           boolean_values() &&\n-           null_value() &&\n            object_index() &&\n            object_find_field_unordered() &&\n            object_find_field() &&\n            nested_object_index() &&\n            iterate_object_partial_children() &&\n-           iterate_array_partial_children() &&\n            object_index_partial_children() &&\n #if SIMDJSON_EXCEPTIONS\n            iterate_object_exception() &&\n-           iterate_array_exception() &&\n-           string_value_exception() &&\n-           numeric_values_exception() &&\n-           boolean_values_exception() &&\n            object_index_exception() &&\n            nested_object_index_exception() &&\n #endif // SIMDJSON_EXCEPTIONS\n            true;\n   }\n \n-} // namespace dom_api_tests\n+} // namespace object_tests\n \n int main(int argc, char *argv[]) {\n-  return test_main(argc, argv, dom_api_tests::run);\n+  return test_main(argc, argv, object_tests::run);\n }\ndiff --git a/tests/ondemand/ondemand_scalar_tests.cpp b/tests/ondemand/ondemand_scalar_tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ondemand/ondemand_scalar_tests.cpp\n@@ -0,0 +1,278 @@\n+#include \"simdjson.h\"\n+#include \"test_ondemand.h\"\n+\n+using namespace simdjson;\n+\n+namespace scalar_tests {\n+  using namespace std;\n+\n+  template<typename T>\n+  bool test_scalar_value(const padded_string &json, const T &expected, bool test_twice=true) {\n+    std::cout << \"- JSON: \" << json << endl;\n+    SUBTEST( \"simdjson_result<document>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      T actual;\n+      ASSERT_SUCCESS( doc_result.get(actual) );\n+      ASSERT_EQUAL( expected, actual );\n+      // Test it twice (scalars can be retrieved more than once)\n+      if (test_twice) {\n+        ASSERT_SUCCESS( doc_result.get(actual) );\n+        ASSERT_EQUAL( expected, actual );\n+      }\n+      return true;\n+    }));\n+    SUBTEST( \"document\", test_ondemand_doc(json, [&](auto doc_result) {\n+      T actual;\n+      ASSERT_SUCCESS( doc_result.get(actual) );\n+      ASSERT_EQUAL( expected, actual );\n+      // Test it twice (scalars can be retrieved more than once)\n+      if (test_twice) {\n+        ASSERT_SUCCESS( doc_result.get(actual) );\n+        ASSERT_EQUAL( expected, actual );\n+      }\n+      return true;\n+    }));\n+\n+    {\n+      padded_string whitespace_json = std::string(json) + \" \";\n+      std::cout << \"- JSON: \" << whitespace_json << endl;\n+      SUBTEST( \"simdjson_result<document>\", test_ondemand_doc(whitespace_json, [&](auto doc_result) {\n+        T actual;\n+        ASSERT_SUCCESS( doc_result.get(actual) );\n+        ASSERT_EQUAL( expected, actual );\n+        // Test it twice (scalars can be retrieved more than once)\n+        if (test_twice) {\n+          ASSERT_SUCCESS( doc_result.get(actual) );\n+          ASSERT_EQUAL( expected, actual );\n+        }\n+        return true;\n+      }));\n+      SUBTEST( \"document\", test_ondemand_doc(whitespace_json, [&](auto doc_result) {\n+        T actual;\n+        ASSERT_SUCCESS( doc_result.get(actual) );\n+        ASSERT_EQUAL( expected, actual );\n+        // Test it twice (scalars can be retrieved more than once)\n+        if (test_twice) {\n+          ASSERT_SUCCESS( doc_result.get(actual) );\n+          ASSERT_EQUAL( expected, actual );\n+        }\n+        return true;\n+      }));\n+    }\n+\n+    {\n+      padded_string array_json = std::string(\"[\") + std::string(json) + \"]\";\n+      std::cout << \"- JSON: \" << array_json << endl;\n+      SUBTEST( \"simdjson_result<value>\", test_ondemand_doc(array_json, [&](auto doc_result) {\n+        int count = 0;\n+        for (simdjson_result<ondemand::value> val_result : doc_result) {\n+          T actual;\n+          ASSERT_SUCCESS( val_result.get(actual) );\n+          ASSERT_EQUAL(expected, actual);\n+          // Test it twice (scalars can be retrieved more than once)\n+          if (test_twice) {\n+            ASSERT_SUCCESS( val_result.get(actual) );\n+            ASSERT_EQUAL(expected, actual);\n+          }\n+          count++;\n+        }\n+        ASSERT_EQUAL(count, 1);\n+        return true;\n+      }));\n+      SUBTEST( \"value\", test_ondemand_doc(array_json, [&](auto doc_result) {\n+        int count = 0;\n+        for (simdjson_result<ondemand::value> val_result : doc_result) {\n+          ondemand::value val;\n+          ASSERT_SUCCESS( val_result.get(val) );\n+          T actual;\n+          ASSERT_SUCCESS( val.get(actual) );\n+          ASSERT_EQUAL(expected, actual);\n+          // Test it twice (scalars can be retrieved more than once)\n+          if (test_twice) {\n+            ASSERT_SUCCESS( val.get(actual) );\n+            ASSERT_EQUAL(expected, actual);\n+          }\n+          count++;\n+        }\n+        ASSERT_EQUAL(count, 1);\n+        return true;\n+      }));\n+    }\n+\n+    {\n+      padded_string whitespace_array_json = std::string(\"[\") + std::string(json) + \" ]\";\n+      std::cout << \"- JSON: \" << whitespace_array_json << endl;\n+      SUBTEST( \"simdjson_result<value>\", test_ondemand_doc(whitespace_array_json, [&](auto doc_result) {\n+        int count = 0;\n+        for (simdjson_result<ondemand::value> val_result : doc_result) {\n+          T actual;\n+          ASSERT_SUCCESS( val_result.get(actual) );\n+          ASSERT_EQUAL(expected, actual);\n+          // Test it twice (scalars can be retrieved more than once)\n+          if (test_twice) {\n+            ASSERT_SUCCESS( val_result.get(actual) );\n+            ASSERT_EQUAL(expected, actual);\n+          }\n+          count++;\n+        }\n+        ASSERT_EQUAL(count, 1);\n+        return true;\n+      }));\n+      SUBTEST( \"value\", test_ondemand_doc(whitespace_array_json, [&](auto doc_result) {\n+        int count = 0;\n+        for (simdjson_result<ondemand::value> val_result : doc_result) {\n+          ondemand::value val;\n+          ASSERT_SUCCESS( val_result.get(val) );\n+          T actual;\n+          ASSERT_SUCCESS( val.get(actual) );\n+          ASSERT_EQUAL(expected, actual);\n+          // Test it twice (scalars can be retrieved more than once)\n+          if (test_twice) {\n+            ASSERT_SUCCESS( val.get(actual) );\n+            ASSERT_EQUAL(expected, actual);\n+          }\n+          count++;\n+        }\n+        ASSERT_EQUAL(count, 1);\n+        return true;\n+      }));\n+    }\n+\n+    TEST_SUCCEED();\n+  }\n+\n+  bool string_value() {\n+    TEST_START();\n+    // We can't retrieve a small string twice because it will blow out the string buffer\n+    if (!test_scalar_value(R\"(\"hi\")\"_padded, std::string_view(\"hi\"), false)) { return false; }\n+    // ... unless the document is big enough to have a big string buffer :)\n+    if (!test_scalar_value(R\"(\"hi\"        )\"_padded, std::string_view(\"hi\"))) { return false; }\n+    TEST_SUCCEED();\n+  }\n+\n+  bool numeric_values() {\n+    TEST_START();\n+    if (!test_scalar_value<int64_t> (\"0\"_padded,   0)) { return false; }\n+    if (!test_scalar_value<uint64_t>(\"0\"_padded,   0)) { return false; }\n+    if (!test_scalar_value<double>  (\"0\"_padded,   0)) { return false; }\n+    if (!test_scalar_value<int64_t> (\"1\"_padded,   1)) { return false; }\n+    if (!test_scalar_value<uint64_t>(\"1\"_padded,   1)) { return false; }\n+    if (!test_scalar_value<double>  (\"1\"_padded,   1)) { return false; }\n+    if (!test_scalar_value<int64_t> (\"-1\"_padded,  -1)) { return false; }\n+    if (!test_scalar_value<double>  (\"-1\"_padded,  -1)) { return false; }\n+    if (!test_scalar_value<double>  (\"1.1\"_padded, 1.1)) { return false; }\n+    TEST_SUCCEED();\n+  }\n+\n+  bool boolean_values() {\n+    TEST_START();\n+    if (!test_scalar_value<bool> (\"true\"_padded,  true)) { return false; }\n+    if (!test_scalar_value<bool> (\"false\"_padded, false)) { return false; }\n+    TEST_SUCCEED();\n+  }\n+\n+  bool null_value() {\n+    TEST_START();\n+    auto json = \"null\"_padded;\n+    SUBTEST(\"ondemand::document\", test_ondemand_doc(json, [&](auto doc_result) {\n+      ondemand::document doc;\n+      ASSERT_SUCCESS( std::move(doc_result).get(doc) );\n+      ASSERT_EQUAL( doc.is_null(), true );\n+      return true;\n+    }));\n+    SUBTEST(\"simdjson_result<ondemand::document>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      ASSERT_EQUAL( doc_result.is_null(), true );\n+      return true;\n+    }));\n+    json = \"[null]\"_padded;\n+    SUBTEST(\"ondemand::value\", test_ondemand_doc(json, [&](auto doc_result) {\n+      int count = 0;\n+      for (auto value_result : doc_result) {\n+        ondemand::value value;\n+        ASSERT_SUCCESS( value_result.get(value) );\n+        ASSERT_EQUAL( value.is_null(), true );\n+        count++;\n+      }\n+      ASSERT_EQUAL( count, 1 );\n+      return true;\n+    }));\n+    SUBTEST(\"simdjson_result<ondemand::value>\", test_ondemand_doc(json, [&](auto doc_result) {\n+      int count = 0;\n+      for (auto value_result : doc_result) {\n+        ASSERT_EQUAL( value_result.is_null(), true );\n+        count++;\n+      }\n+      ASSERT_EQUAL( count, 1 );\n+      return true;\n+    }));\n+    return true;\n+  }\n+\n+#if SIMDJSON_EXCEPTIONS\n+\n+  template<typename T>\n+  bool test_scalar_value_exception(const padded_string &json, const T &expected) {\n+    std::cout << \"- JSON: \" << json << endl;\n+    SUBTEST( \"document\", test_ondemand_doc(json, [&](auto doc_result) {\n+      ASSERT_EQUAL( expected, T(doc_result) );\n+      return true;\n+    }));\n+    padded_string array_json = std::string(\"[\") + std::string(json) + \"]\";\n+    std::cout << \"- JSON: \" << array_json << endl;\n+    SUBTEST( \"value\", test_ondemand_doc(array_json, [&](auto doc_result) {\n+      int count = 0;\n+      for (T actual : doc_result) {\n+        ASSERT_EQUAL( expected, actual );\n+        count++;\n+      }\n+      ASSERT_EQUAL(count, 1);\n+      return true;\n+    }));\n+    TEST_SUCCEED();\n+  }\n+  bool string_value_exception() {\n+    TEST_START();\n+    return test_scalar_value_exception(R\"(\"hi\")\"_padded, std::string_view(\"hi\"));\n+  }\n+\n+  bool numeric_values_exception() {\n+    TEST_START();\n+    if (!test_scalar_value_exception<int64_t> (\"0\"_padded,   0)) { return false; }\n+    if (!test_scalar_value_exception<uint64_t>(\"0\"_padded,   0)) { return false; }\n+    if (!test_scalar_value_exception<double>  (\"0\"_padded,   0)) { return false; }\n+    if (!test_scalar_value_exception<int64_t> (\"1\"_padded,   1)) { return false; }\n+    if (!test_scalar_value_exception<uint64_t>(\"1\"_padded,   1)) { return false; }\n+    if (!test_scalar_value_exception<double>  (\"1\"_padded,   1)) { return false; }\n+    if (!test_scalar_value_exception<int64_t> (\"-1\"_padded,  -1)) { return false; }\n+    if (!test_scalar_value_exception<double>  (\"-1\"_padded,  -1)) { return false; }\n+    if (!test_scalar_value_exception<double>  (\"1.1\"_padded, 1.1)) { return false; }\n+    TEST_SUCCEED();\n+  }\n+\n+  bool boolean_values_exception() {\n+    TEST_START();\n+    if (!test_scalar_value_exception<bool> (\"true\"_padded,  true)) { return false; }\n+    if (!test_scalar_value_exception<bool> (\"false\"_padded, false)) { return false; }\n+    TEST_SUCCEED();\n+  }\n+\n+#endif // SIMDJSON_EXCEPTIONS\n+\n+  bool run() {\n+    return\n+           string_value() &&\n+           numeric_values() &&\n+           boolean_values() &&\n+           null_value() &&\n+#if SIMDJSON_EXCEPTIONS\n+           string_value_exception() &&\n+           numeric_values_exception() &&\n+           boolean_values_exception() &&\n+#endif // SIMDJSON_EXCEPTIONS\n+           true;\n+  }\n+\n+} // namespace scalar_tests\n+\n+int main(int argc, char *argv[]) {\n+  return test_main(argc, argv, scalar_tests::run);\n+}\ndiff --git a/tests/test_macros.h b/tests/test_macros.h\n--- a/tests/test_macros.h\n+++ b/tests/test_macros.h\n@@ -48,7 +48,7 @@ template<typename T>\n simdjson_really_inline bool assert_success(const T &actual, const char *operation = \"result\") {\n   simdjson::error_code error = to_error_code(actual);\n   if (error) {\n-    std::cerr << \"FAIL: \" << operation << \" returned error: \" << error << std::endl;\n+    std::cerr << \"FAIL: \" << operation << \" returned error: \" << error << \" (\" << int(error) << \")\" << std::endl;\n     return false;\n   }\n   return true;\n",
        "problem_statement": "ondemand::parser::get command reordering leads to segfault\nThis simple example causes an segfault.\r\nThe first loop-run works, the second causes a segfault\r\nswitch the two get statements leads to an segfault in the first run.\r\nCan somebody reproduce this behaviour?\r\n\r\nTested on:\r\nLinux ubuntu 20.04 gcc9 and gcc10\r\nWindows 10 64 bit gcc9\r\nCPU: amd and intel\r\n\r\n```\r\n#include <singleheader/simdjson.h>\r\n\r\nint main()\r\n{\r\n    using namespace simdjson;\r\n    auto const abstract_json= R\"(\r\n                              { \"str\" : 123 }\r\n                              )\"_padded;\r\n\r\n    for ( int i= 0; i < 2; ++i )\r\n    {\r\n        ondemand::parser parser;\r\n        auto doc = parser.iterate( abstract_json );\r\n        ondemand::value val= doc[\"str\"];\r\n        if ( i == 0 )\r\n        {\r\n            auto a= val.get<ondemand::array>();\r\n            auto s= val.get<std::string_view>();\r\n        }\r\n        else\r\n        {\r\n            auto s= val.get<std::string_view>();\r\n            auto a= val.get<ondemand::array>(); //<-- segfault\r\n        }\r\n#if 0\r\n        auto d= val.get<double>();\r\n        auto u= val.get<uint64_t>();\r\n        auto i= val.get<int64_t>();\r\n        auto b= val.get<bool>();\r\n        auto o= val.get<ondemand::object>();\r\n#endif\r\n    }\r\n    return 0;\r\n}\r\n```\nondemand::parser::get command reordering leads to segfault\nThis simple example causes an segfault.\r\nThe first loop-run works, the second causes a segfault\r\nswitch the two get statements leads to an segfault in the first run.\r\nCan somebody reproduce this behaviour?\r\n\r\nTested on:\r\nLinux ubuntu 20.04 gcc9 and gcc10\r\nWindows 10 64 bit gcc9\r\nCPU: amd and intel\r\n\r\n```\r\n#include <singleheader/simdjson.h>\r\n\r\nint main()\r\n{\r\n    using namespace simdjson;\r\n    auto const abstract_json= R\"(\r\n                              { \"str\" : 123 }\r\n                              )\"_padded;\r\n\r\n    for ( int i= 0; i < 2; ++i )\r\n    {\r\n        ondemand::parser parser;\r\n        auto doc = parser.iterate( abstract_json );\r\n        ondemand::value val= doc[\"str\"];\r\n        if ( i == 0 )\r\n        {\r\n            auto a= val.get<ondemand::array>();\r\n            auto s= val.get<std::string_view>();\r\n        }\r\n        else\r\n        {\r\n            auto s= val.get<std::string_view>();\r\n            auto a= val.get<ondemand::array>(); //<-- segfault\r\n        }\r\n#if 0\r\n        auto d= val.get<double>();\r\n        auto u= val.get<uint64_t>();\r\n        auto i= val.get<int64_t>();\r\n        auto b= val.get<bool>();\r\n        auto o= val.get<ondemand::object>();\r\n#endif\r\n    }\r\n    return 0;\r\n}\r\n```\n",
        "hints_text": "@jkeiser Can you comment?\r\n\nOh, I was just looking at this! I think I know what it is. Since we changed scalars to skip ahead, but *not* arrays and objects, failing to get a scalar and then looking at an array afterwards will cause everything to go wonky.\r\n\r\nWorkaround is to check array and object before any scalars (string/number/bool/null). We will absolutely fix.\nit seems that the order of the `get()` and `is_null()` functions and if an value matched the `get()` quuery causes the problem.\r\nafter calling `is_null()` every call also causes a segfault.\r\n\r\n\r\nhere is a simple program to test different ordering cases, needs to compile with >= c++14\r\nand UNKNOWN= 0 hat to be added to element_type enum in simdjson.h\r\n\r\n```\r\n#include <singleheader/simdjson.h>\r\n\r\nusing namespace simdjson;\r\n\r\nclass ValueConst\r\n{\r\n    using t= simdjson::dom::element_type;\r\npublic:\r\n\r\n    ValueConst( int64_t const i )\r\n        : m_type{ t::INT64 }\r\n    {\r\n        m_data.l= i;\r\n    }\r\n\r\n    ValueConst( ondemand::array const a )\r\n        : m_type{ t::ARRAY }\r\n    {\r\n        m_data.a= a;\r\n    }\r\n\r\n    ValueConst( ondemand::object const o )\r\n        : m_type{ t::INT64 }\r\n    {\r\n        m_data.o= o;\r\n    }\r\n\r\n    ValueConst( uint64_t const u )\r\n        : m_type{ t::UINT64 }\r\n    {\r\n        m_data.u= u;\r\n    }\r\n\r\n    ValueConst( double const d )\r\n        : m_type{ t::DOUBLE }\r\n    {\r\n        m_data.d= d;\r\n    }\r\n\r\n    ValueConst( bool const t )\r\n        : m_type{ t::BOOL }\r\n    {\r\n        m_data.l= t;\r\n    }\r\n\r\n    ValueConst( std::string_view const s )\r\n        : m_type{ t::STRING }\r\n    {\r\n        m_data.s= s;\r\n    }\r\n\r\n    ValueConst( void const*const /*ptr*/)\r\n        : m_type{ t::NULL_VALUE }\r\n    {\r\n        m_data.ptr= nullptr;\r\n    }\r\n\r\n    ValueConst()\r\n        : m_type{ t::UNKNOWN }\r\n    {\r\n    }\r\n\r\n    t getType() const\r\n    {\r\n        return m_type;\r\n    };\r\n\r\n    bool getBool() const\r\n    {\r\n        if ( m_type != t::BOOL )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return ( m_data.l != 0 );\r\n    }\r\n\r\n    int64_t getInt64() const\r\n    {\r\n        if ( m_type != t::INT64 )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.l;\r\n    }\r\n\r\n    uint64_t getUInt64() const\r\n    {\r\n        if ( m_type != t::UINT64 )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.u;\r\n    }\r\n\r\n    uint64_t getDouble() const\r\n    {\r\n        if ( m_type != t::DOUBLE )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.d;\r\n    }\r\n\r\n    std::string_view getStringView() const\r\n    {\r\n        if ( m_type != t::DOUBLE )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.s;\r\n    }\r\n\r\n    std::string getString() const\r\n    {\r\n        if ( m_type != t::STRING )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return std::string(m_data.s);\r\n    }\r\n\r\n    ondemand::array getArray() const\r\n    {\r\n        if ( m_type != t::ARRAY )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.a;\r\n    }\r\n\r\n    ondemand::object getObject() const\r\n    {\r\n        if ( m_type != t::OBJECT )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.o;\r\n    }\r\n\r\n    bool isNull() const noexcept\r\n    {\r\n        return ( m_type == t::NULL_VALUE );\r\n    }\r\n\r\n    bool hasType() const noexcept\r\n    {\r\n        return ( m_type != t::UNKNOWN );\r\n    }\r\n\r\n    bool hasError() const noexcept\r\n    {\r\n        return ( m_type == t::UNKNOWN );\r\n    }\r\n\r\nprivate:\r\n    static constexpr uint64_t create_check( char const*const text )\r\n    {\r\n        using t= simdjson::dom::element_type;\r\n        uint64_t ret= 0;\r\n        size_t shift= 0;\r\n        for ( size_t i= 0; i < 8; ++i )\r\n        {\r\n            char const c = text[i];\r\n            auto const rt= static_cast<t>( c );\r\n            switch( rt )\r\n            {\r\n            case t::ARRAY : [[fallthrough]];\r\n            case t::STRING : [[fallthrough]];\r\n            case t::UINT64: [[fallthrough]];\r\n            case t::INT64: [[fallthrough]];\r\n            case t::DOUBLE: [[fallthrough]];\r\n            case t::OBJECT: [[fallthrough]];\r\n            case t::BOOL: [[fallthrough]];\r\n            case t::NULL_VALUE:\r\n                ret += (static_cast<size_t>(c) << shift);\r\n                //ret += c;\r\n                shift += 8;\r\n                break;\r\n\r\n            case t::UNKNOWN :\r\n            default:\r\n                break;\r\n\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\npublic:\r\n\r\n    static ValueConst create( ondemand::value &val, char const*const text )\r\n    {\r\n        uint64_t const check= create_check( text );\r\n        return create( val, check );\r\n    }\r\n\r\n    static ValueConst create( ondemand::value &val, uint64_t const check=0x6E74646C75737B5B )\r\n    {\r\n        using t= simdjson::dom::element_type;\r\n        ValueConst ret;\r\n        bool check_null = false;\r\n        simdjson::error_code error = simdjson::INCORRECT_TYPE;\r\n        for ( uint64_t run = check; run > 0 ; run >>= 8 )\r\n        {\r\n            ValueConst rt;\r\n            char const c= 0xFF & run;\r\n            rt.m_type= static_cast<t>( c );\r\n            switch( rt.m_type )\r\n            {\r\n            case t::UNKNOWN :\r\n                run = 0;\r\n                break;\r\n\r\n            case t::ARRAY : {\r\n                error= val.get( rt.m_data.a );\r\n                break;\r\n            }\r\n\r\n            case t::STRING : {\r\n                error= val.get(rt.m_data.s);\r\n                break;\r\n            }\r\n\r\n            case t::UINT64: {\r\n                error= val.get(rt.m_data.u);\r\n                break;\r\n            }\r\n\r\n            case t::INT64: {\r\n                error= val.get(rt.m_data.l);\r\n                break;\r\n            }\r\n\r\n            case t::DOUBLE: {\r\n                error= val.get(rt.m_data.d);\r\n                break;\r\n            }\r\n\r\n            case t::OBJECT: {\r\n                error= val.get(rt.m_data.o);\r\n                break;\r\n            }\r\n\r\n            case t::BOOL: {\r\n                bool t;\r\n                error= val.get( t );\r\n                rt.m_data.l = t;\r\n                break;\r\n            }\r\n\r\n            case t::NULL_VALUE: {\r\n                check_null = true;\r\n                break;\r\n\r\n            }\r\n\r\n            default:\r\n                throw \"PANIC: Unknown Type\";\r\n            }\r\n            if ( error == simdjson::SUCCESS )\r\n            {\r\n                return rt;\r\n                //run = 0;// break;\r\n            }\r\n        }\r\n\r\n        if ( error != simdjson::SUCCESS && check_null == true )\r\n        {\r\n            bool const null= val.is_null();\r\n            if ( null )\r\n            {\r\n                ret.m_type= t::NULL_VALUE;\r\n                ret.m_data.ptr= nullptr;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\nprivate:\r\n    t m_type= t::UNKNOWN;\r\n    union type_u\r\n    {\r\n        void * ptr;\r\n        //bool t;\r\n        double d;\r\n        std::string_view s;\r\n        int64_t l;\r\n        uint64_t u;\r\n        ondemand::array a;\r\n        ondemand::object o;\r\n    };\r\n    type_u m_data = {nullptr};\r\n};\r\n\r\n\r\nint test_order( simdjson::padded_string const& abstract_json, std::string const& order)\r\n{\r\n\r\n    ondemand::parser parser;\r\n\r\n    auto doc = parser.iterate(abstract_json);\r\n\r\n    ondemand::value val;\r\n    simdjson::error_code error= simdjson::SUCCESS;\r\n    doc[\"str\"][\"123\"][\"abc\"].tie(val, error);\r\n    auto const ele= ValueConst::create( val, order.c_str() );\r\n\r\n    using t= simdjson::dom::element_type;\r\n    switch ( ele.getType() )\r\n    {\r\n    case t::STRING :\r\n        std::cout << ele.getString();\r\n        break;\r\n    case t::OBJECT: break;\r\n    default :\r\n        break;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\nint main()\r\n{\r\n    auto const abstract_json = R\"(\r\n                         { \"str\" : { \"123\" : {\"abc\" : 3.14 } }, \"1\":\"{}\" }\r\n                         )\"_padded;\r\n\r\n    test_order( abstract_json, \"[{\\\"uldtn\" ); // okay\r\n    test_order( abstract_json, \"\\\"u[{ldtn\" ); // segfault\r\n    return 0;\r\n}\r\n\r\n\r\n```\r\n\nAh, you are right! is null has the same constraints. Will fix too.\r\n\r\nI am so appreciative that you are finding these things and reporting them. On Demand, as far as we can tell, is an entirely new kind of api, and we figured some subtle things would take time to get right.\r\n\r\n\r\nAlso, you're doing something I feel is necessary for 1.0: testing recursion and DOM generation. You could probably turn this into a benchmark--I don't think we can ship without knowing and comparing performance in this important scenario. (I am fairly sure we can do specific things to make it much faster, too!)\nNote that regarding the original issue (code sample), it should not crash when compiled in debug mode. I think you should get an assertion error.\r\n\r\nThis is still a bug, but it is a bit better than it appears.\nCreated an repo with the modified code for a simple test of checking permutated orders of .get( ) calls for different json objects.\r\nIt's a kind of bruteforce, but for quick and dirty tests very helpful.\r\n[https://github.com/Tibbel/simdjson_selftest](https://github.com/Tibbel/simdjson_selftest)\nThanks! I've got the start of something worked up, but might not be finished with it today.\n@jkeiser Can you comment?\r\n\nOh, I was just looking at this! I think I know what it is. Since we changed scalars to skip ahead, but *not* arrays and objects, failing to get a scalar and then looking at an array afterwards will cause everything to go wonky.\r\n\r\nWorkaround is to check array and object before any scalars (string/number/bool/null). We will absolutely fix.\nit seems that the order of the `get()` and `is_null()` functions and if an value matched the `get()` quuery causes the problem.\r\nafter calling `is_null()` every call also causes a segfault.\r\n\r\n\r\nhere is a simple program to test different ordering cases, needs to compile with >= c++14\r\nand UNKNOWN= 0 hat to be added to element_type enum in simdjson.h\r\n\r\n```\r\n#include <singleheader/simdjson.h>\r\n\r\nusing namespace simdjson;\r\n\r\nclass ValueConst\r\n{\r\n    using t= simdjson::dom::element_type;\r\npublic:\r\n\r\n    ValueConst( int64_t const i )\r\n        : m_type{ t::INT64 }\r\n    {\r\n        m_data.l= i;\r\n    }\r\n\r\n    ValueConst( ondemand::array const a )\r\n        : m_type{ t::ARRAY }\r\n    {\r\n        m_data.a= a;\r\n    }\r\n\r\n    ValueConst( ondemand::object const o )\r\n        : m_type{ t::INT64 }\r\n    {\r\n        m_data.o= o;\r\n    }\r\n\r\n    ValueConst( uint64_t const u )\r\n        : m_type{ t::UINT64 }\r\n    {\r\n        m_data.u= u;\r\n    }\r\n\r\n    ValueConst( double const d )\r\n        : m_type{ t::DOUBLE }\r\n    {\r\n        m_data.d= d;\r\n    }\r\n\r\n    ValueConst( bool const t )\r\n        : m_type{ t::BOOL }\r\n    {\r\n        m_data.l= t;\r\n    }\r\n\r\n    ValueConst( std::string_view const s )\r\n        : m_type{ t::STRING }\r\n    {\r\n        m_data.s= s;\r\n    }\r\n\r\n    ValueConst( void const*const /*ptr*/)\r\n        : m_type{ t::NULL_VALUE }\r\n    {\r\n        m_data.ptr= nullptr;\r\n    }\r\n\r\n    ValueConst()\r\n        : m_type{ t::UNKNOWN }\r\n    {\r\n    }\r\n\r\n    t getType() const\r\n    {\r\n        return m_type;\r\n    };\r\n\r\n    bool getBool() const\r\n    {\r\n        if ( m_type != t::BOOL )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return ( m_data.l != 0 );\r\n    }\r\n\r\n    int64_t getInt64() const\r\n    {\r\n        if ( m_type != t::INT64 )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.l;\r\n    }\r\n\r\n    uint64_t getUInt64() const\r\n    {\r\n        if ( m_type != t::UINT64 )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.u;\r\n    }\r\n\r\n    uint64_t getDouble() const\r\n    {\r\n        if ( m_type != t::DOUBLE )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.d;\r\n    }\r\n\r\n    std::string_view getStringView() const\r\n    {\r\n        if ( m_type != t::DOUBLE )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.s;\r\n    }\r\n\r\n    std::string getString() const\r\n    {\r\n        if ( m_type != t::STRING )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return std::string(m_data.s);\r\n    }\r\n\r\n    ondemand::array getArray() const\r\n    {\r\n        if ( m_type != t::ARRAY )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.a;\r\n    }\r\n\r\n    ondemand::object getObject() const\r\n    {\r\n        if ( m_type != t::OBJECT )\r\n        {\r\n            throw __PRETTY_FUNCTION__;\r\n        }\r\n        return m_data.o;\r\n    }\r\n\r\n    bool isNull() const noexcept\r\n    {\r\n        return ( m_type == t::NULL_VALUE );\r\n    }\r\n\r\n    bool hasType() const noexcept\r\n    {\r\n        return ( m_type != t::UNKNOWN );\r\n    }\r\n\r\n    bool hasError() const noexcept\r\n    {\r\n        return ( m_type == t::UNKNOWN );\r\n    }\r\n\r\nprivate:\r\n    static constexpr uint64_t create_check( char const*const text )\r\n    {\r\n        using t= simdjson::dom::element_type;\r\n        uint64_t ret= 0;\r\n        size_t shift= 0;\r\n        for ( size_t i= 0; i < 8; ++i )\r\n        {\r\n            char const c = text[i];\r\n            auto const rt= static_cast<t>( c );\r\n            switch( rt )\r\n            {\r\n            case t::ARRAY : [[fallthrough]];\r\n            case t::STRING : [[fallthrough]];\r\n            case t::UINT64: [[fallthrough]];\r\n            case t::INT64: [[fallthrough]];\r\n            case t::DOUBLE: [[fallthrough]];\r\n            case t::OBJECT: [[fallthrough]];\r\n            case t::BOOL: [[fallthrough]];\r\n            case t::NULL_VALUE:\r\n                ret += (static_cast<size_t>(c) << shift);\r\n                //ret += c;\r\n                shift += 8;\r\n                break;\r\n\r\n            case t::UNKNOWN :\r\n            default:\r\n                break;\r\n\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\npublic:\r\n\r\n    static ValueConst create( ondemand::value &val, char const*const text )\r\n    {\r\n        uint64_t const check= create_check( text );\r\n        return create( val, check );\r\n    }\r\n\r\n    static ValueConst create( ondemand::value &val, uint64_t const check=0x6E74646C75737B5B )\r\n    {\r\n        using t= simdjson::dom::element_type;\r\n        ValueConst ret;\r\n        bool check_null = false;\r\n        simdjson::error_code error = simdjson::INCORRECT_TYPE;\r\n        for ( uint64_t run = check; run > 0 ; run >>= 8 )\r\n        {\r\n            ValueConst rt;\r\n            char const c= 0xFF & run;\r\n            rt.m_type= static_cast<t>( c );\r\n            switch( rt.m_type )\r\n            {\r\n            case t::UNKNOWN :\r\n                run = 0;\r\n                break;\r\n\r\n            case t::ARRAY : {\r\n                error= val.get( rt.m_data.a );\r\n                break;\r\n            }\r\n\r\n            case t::STRING : {\r\n                error= val.get(rt.m_data.s);\r\n                break;\r\n            }\r\n\r\n            case t::UINT64: {\r\n                error= val.get(rt.m_data.u);\r\n                break;\r\n            }\r\n\r\n            case t::INT64: {\r\n                error= val.get(rt.m_data.l);\r\n                break;\r\n            }\r\n\r\n            case t::DOUBLE: {\r\n                error= val.get(rt.m_data.d);\r\n                break;\r\n            }\r\n\r\n            case t::OBJECT: {\r\n                error= val.get(rt.m_data.o);\r\n                break;\r\n            }\r\n\r\n            case t::BOOL: {\r\n                bool t;\r\n                error= val.get( t );\r\n                rt.m_data.l = t;\r\n                break;\r\n            }\r\n\r\n            case t::NULL_VALUE: {\r\n                check_null = true;\r\n                break;\r\n\r\n            }\r\n\r\n            default:\r\n                throw \"PANIC: Unknown Type\";\r\n            }\r\n            if ( error == simdjson::SUCCESS )\r\n            {\r\n                return rt;\r\n                //run = 0;// break;\r\n            }\r\n        }\r\n\r\n        if ( error != simdjson::SUCCESS && check_null == true )\r\n        {\r\n            bool const null= val.is_null();\r\n            if ( null )\r\n            {\r\n                ret.m_type= t::NULL_VALUE;\r\n                ret.m_data.ptr= nullptr;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\nprivate:\r\n    t m_type= t::UNKNOWN;\r\n    union type_u\r\n    {\r\n        void * ptr;\r\n        //bool t;\r\n        double d;\r\n        std::string_view s;\r\n        int64_t l;\r\n        uint64_t u;\r\n        ondemand::array a;\r\n        ondemand::object o;\r\n    };\r\n    type_u m_data = {nullptr};\r\n};\r\n\r\n\r\nint test_order( simdjson::padded_string const& abstract_json, std::string const& order)\r\n{\r\n\r\n    ondemand::parser parser;\r\n\r\n    auto doc = parser.iterate(abstract_json);\r\n\r\n    ondemand::value val;\r\n    simdjson::error_code error= simdjson::SUCCESS;\r\n    doc[\"str\"][\"123\"][\"abc\"].tie(val, error);\r\n    auto const ele= ValueConst::create( val, order.c_str() );\r\n\r\n    using t= simdjson::dom::element_type;\r\n    switch ( ele.getType() )\r\n    {\r\n    case t::STRING :\r\n        std::cout << ele.getString();\r\n        break;\r\n    case t::OBJECT: break;\r\n    default :\r\n        break;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\nint main()\r\n{\r\n    auto const abstract_json = R\"(\r\n                         { \"str\" : { \"123\" : {\"abc\" : 3.14 } }, \"1\":\"{}\" }\r\n                         )\"_padded;\r\n\r\n    test_order( abstract_json, \"[{\\\"uldtn\" ); // okay\r\n    test_order( abstract_json, \"\\\"u[{ldtn\" ); // segfault\r\n    return 0;\r\n}\r\n\r\n\r\n```\r\n\nAh, you are right! is null has the same constraints. Will fix too.\r\n\r\nI am so appreciative that you are finding these things and reporting them. On Demand, as far as we can tell, is an entirely new kind of api, and we figured some subtle things would take time to get right.\r\n\r\n\r\nAlso, you're doing something I feel is necessary for 1.0: testing recursion and DOM generation. You could probably turn this into a benchmark--I don't think we can ship without knowing and comparing performance in this important scenario. (I am fairly sure we can do specific things to make it much faster, too!)\nNote that regarding the original issue (code sample), it should not crash when compiled in debug mode. I think you should get an assertion error.\r\n\r\nThis is still a bug, but it is a bit better than it appears.\nCreated an repo with the modified code for a simple test of checking permutated orders of .get( ) calls for different json objects.\r\nIt's a kind of bruteforce, but for quick and dirty tests very helpful.\r\n[https://github.com/Tibbel/simdjson_selftest](https://github.com/Tibbel/simdjson_selftest)\nThanks! I've got the start of something worked up, but might not be finished with it today.",
        "created_at": "2021-01-26T23:03:49Z",
        "version": "0.8"
    }
}