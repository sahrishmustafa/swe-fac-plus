{
    "task_id": "simdjson__simdjson-1667",
    "setup_info": {
        "repo_path": "testbed/simdjson__simdjson-1667_2025-07-08_04-24-15",
        "repo_cache_path": "testbed/simdjson/simdjson_cache"
    },
    "task_info": {
        "repo": "simdjson/simdjson",
        "pull_number": 1667,
        "instance_id": "simdjson__simdjson-1667",
        "issue_numbers": [
            "1481"
        ],
        "base_commit": "47a62db55936e29e1966a26a9aadb5f28237ae37",
        "patch": "diff --git a/include/simdjson/generic/numberparsing.h b/include/simdjson/generic/numberparsing.h\n--- a/include/simdjson/generic/numberparsing.h\n+++ b/include/simdjson/generic/numberparsing.h\n@@ -513,6 +513,9 @@ simdjson_really_inline error_code parse_number(const uint8_t *const, W &writer)\n simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(const uint8_t * const src) noexcept { return 0; }\n simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t * const src) noexcept { return 0; }\n simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer_in_string(const uint8_t * const src) noexcept { return 0; }\n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double_in_string(const uint8_t * const src) noexcept { return 0; }\n \n #else\n \n@@ -773,6 +776,54 @@ simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned(\n   return i;\n }\n \n+// Parse any number from 0 to 18,446,744,073,709,551,615\n+simdjson_unused simdjson_really_inline simdjson_result<uint64_t> parse_unsigned_in_string(const uint8_t * const src) noexcept {\n+  const uint8_t *p = src + 1;\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while (parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // The longest positive 64-bit number is 20 digits.\n+  // We do it this way so we don't trigger this branch unless we must.\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > 20))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > 20)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if (*p != '\"') { return NUMBER_ERROR; }\n+\n+  if (digit_count == 20) {\n+    // Positive overflow check:\n+    // - A 20 digit number starting with 2-9 is overflow, because 18,446,744,073,709,551,615 is the\n+    //   biggest uint64_t.\n+    // - A 20 digit number starting with 1 is overflow if it is less than INT64_MAX.\n+    //   If we got here, it's a 20 digit number starting with the digit \"1\".\n+    // - If a 20 digit number starting with 1 overflowed (i*10+digit), the result will be smaller\n+    //   than 1,553,255,926,290,448,384.\n+    // - That is smaller than the smallest possible 20-digit number the user could write:\n+    //   10,000,000,000,000,000,000.\n+    // - Therefore, if the number is positive and lower than that, it's overflow.\n+    // - The value we are looking at is less than or equal to 9,223,372,036,854,775,808 (INT64_MAX).\n+    //\n+    if (src[0] != uint8_t('1') || i <= uint64_t(INT64_MAX)) { return INCORRECT_TYPE; }\n+  }\n+\n+  return i;\n+}\n+\n // Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(const uint8_t *src) noexcept {\n   //\n@@ -859,6 +910,48 @@ simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer(co\n   return negative ? (~i+1) : i;\n }\n \n+// Parse any number from  -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+simdjson_unused simdjson_really_inline simdjson_result<int64_t> parse_integer_in_string(const uint8_t *src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*(src + 1) == '-');\n+  const uint8_t *p = src + negative + 1;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  // PERF NOTE: we don't use is_made_of_eight_digits_fast because large integers like 123456789 are rare\n+  const uint8_t *const start_digits = p;\n+  uint64_t i = 0;\n+  while (parse_digit(*p, i)) { p++; }\n+\n+  // If there were no digits, or if the integer starts with 0 and has more than one digit, it's an error.\n+  // Optimization note: size_t is expected to be unsigned.\n+  size_t digit_count = size_t(p - start_digits);\n+  // We go from\n+  // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\n+  // so we can never represent numbers that have more than 19 digits.\n+  size_t longest_digit_count = 19;\n+  // Optimization note: the compiler can probably merge\n+  // ((digit_count == 0) || (digit_count > longest_digit_count))\n+  // into a single  branch since digit_count is unsigned.\n+  if ((digit_count == 0) || (digit_count > longest_digit_count)) { return INCORRECT_TYPE; }\n+  // Here digit_count > 0.\n+  if (('0' == *start_digits) && (digit_count > 1)) { return NUMBER_ERROR; }\n+  // We can do the following...\n+  // if (!jsoncharutils::is_structural_or_whitespace(*p)) {\n+  //  return (*p == '.' || *p == 'e' || *p == 'E') ? INCORRECT_TYPE : NUMBER_ERROR;\n+  // }\n+  // as a single table lookup:\n+  if(*p != '\"') { return NUMBER_ERROR; }\n+  // Negative numbers have can go down to - INT64_MAX - 1 whereas positive numbers are limited to INT64_MAX.\n+  // Performance note: This check is only needed when digit_count == longest_digit_count but it is\n+  // so cheap that we might as well always make it.\n+  if(i > uint64_t(INT64_MAX) + uint64_t(negative)) { return INCORRECT_TYPE; }\n+  return negative ? (~i+1) : i;\n+}\n+\n simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(const uint8_t * src) noexcept {\n   //\n   // Check for minus sign\n@@ -1020,6 +1113,83 @@ simdjson_unused simdjson_really_inline simdjson_result<double> parse_double(cons\n   return d;\n }\n \n+simdjson_unused simdjson_really_inline simdjson_result<double> parse_double_in_string(const uint8_t * src) noexcept {\n+  //\n+  // Check for minus sign\n+  //\n+  bool negative = (*(src + 1) == '-');\n+  src += negative + 1;\n+\n+  //\n+  // Parse the integer part.\n+  //\n+  uint64_t i = 0;\n+  const uint8_t *p = src;\n+  p += parse_digit(*p, i);\n+  bool leading_zero = (i == 0);\n+  while (parse_digit(*p, i)) { p++; }\n+  // no integer digits, or 0123 (zero must be solo)\n+  if ( p == src ) { return INCORRECT_TYPE; }\n+  if ( (leading_zero && p != src+1)) { return NUMBER_ERROR; }\n+\n+  //\n+  // Parse the decimal part.\n+  //\n+  int64_t exponent = 0;\n+  bool overflow;\n+  if (simdjson_likely(*p == '.')) {\n+    p++;\n+    const uint8_t *start_decimal_digits = p;\n+    if (!parse_digit(*p, i)) { return NUMBER_ERROR; } // no decimal digits\n+    p++;\n+    while (parse_digit(*p, i)) { p++; }\n+    exponent = -(p - start_decimal_digits);\n+\n+    // Overflow check. More than 19 digits (minus the decimal) may be overflow.\n+    overflow = p-src-1 > 19;\n+    if (simdjson_unlikely(overflow && leading_zero)) {\n+      // Skip leading 0.00000 and see if it still overflows\n+      const uint8_t *start_digits = src + 2;\n+      while (*start_digits == '0') { start_digits++; }\n+      overflow = start_digits-src > 19;\n+    }\n+  } else {\n+    overflow = p-src > 19;\n+  }\n+\n+  //\n+  // Parse the exponent\n+  //\n+  if (*p == 'e' || *p == 'E') {\n+    p++;\n+    bool exp_neg = *p == '-';\n+    p += exp_neg || *p == '+';\n+\n+    uint64_t exp = 0;\n+    const uint8_t *start_exp_digits = p;\n+    while (parse_digit(*p, exp)) { p++; }\n+    // no exp digits, or 20+ exp digits\n+    if (p-start_exp_digits == 0 || p-start_exp_digits > 19) { return NUMBER_ERROR; }\n+\n+    exponent += exp_neg ? 0-exp : exp;\n+  }\n+\n+  if (*p != '\"') { return NUMBER_ERROR; }\n+\n+  overflow = overflow || exponent < simdjson::internal::smallest_power || exponent > simdjson::internal::largest_power;\n+\n+  //\n+  // Assemble (or slow-parse) the float\n+  //\n+  double d;\n+  if (simdjson_likely(!overflow)) {\n+    if (compute_float_64(exponent, i, negative, d)) { return d; }\n+  }\n+  if (!parse_float_fallback(src-negative, &d)) {\n+    return NUMBER_ERROR;\n+  }\n+  return d;\n+}\n } //namespace {}\n #endif // SIMDJSON_SKIPNUMBERPARSING\n \ndiff --git a/include/simdjson/generic/ondemand/document-inl.h b/include/simdjson/generic/ondemand/document-inl.h\n--- a/include/simdjson/generic/ondemand/document-inl.h\n+++ b/include/simdjson/generic/ondemand/document-inl.h\n@@ -64,12 +64,21 @@ simdjson_really_inline simdjson_result<object> document::get_object() & noexcept\n simdjson_really_inline simdjson_result<uint64_t> document::get_uint64() noexcept {\n   return get_root_value_iterator().get_root_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> document::get_uint64_in_string() noexcept {\n+  return get_root_value_iterator().get_root_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> document::get_int64() noexcept {\n   return get_root_value_iterator().get_root_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> document::get_int64_in_string() noexcept {\n+  return get_root_value_iterator().get_root_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<double> document::get_double() noexcept {\n   return get_root_value_iterator().get_root_double();\n }\n+simdjson_really_inline simdjson_result<double> document::get_double_in_string() noexcept {\n+  return get_root_value_iterator().get_root_double_in_string();\n+}\n simdjson_really_inline simdjson_result<std::string_view> document::get_string() noexcept {\n   return get_root_value_iterator().get_root_string();\n }\ndiff --git a/include/simdjson/generic/ondemand/document.h b/include/simdjson/generic/ondemand/document.h\n--- a/include/simdjson/generic/ondemand/document.h\n+++ b/include/simdjson/generic/ondemand/document.h\n@@ -53,6 +53,13 @@ class document {\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n    */\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  /**\n+   * Cast this JSON value (inside string) to an unsigned integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n+   */\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   /**\n    * Cast this JSON value to a signed integer.\n    *\n@@ -60,6 +67,13 @@ class document {\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n    */\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  /**\n+   * Cast this JSON value (inside string) to a signed integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n+   */\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   /**\n    * Cast this JSON value to a double.\n    *\n@@ -67,6 +81,14 @@ class document {\n    * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n    */\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+\n+  /**\n+   * Cast this JSON value (inside string) to a double.\n+   *\n+   * @returns A double.\n+   * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n+   */\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   /**\n    * Cast this JSON value to a string.\n    *\n@@ -408,6 +430,7 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double_from_string() noexcept;\n   simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\ndiff --git a/include/simdjson/generic/ondemand/value-inl.h b/include/simdjson/generic/ondemand/value-inl.h\n--- a/include/simdjson/generic/ondemand/value-inl.h\n+++ b/include/simdjson/generic/ondemand/value-inl.h\n@@ -36,12 +36,21 @@ simdjson_really_inline simdjson_result<std::string_view> value::get_string() noe\n simdjson_really_inline simdjson_result<double> value::get_double() noexcept {\n   return iter.get_double();\n }\n+simdjson_really_inline simdjson_result<double> value::get_double_in_string() noexcept {\n+  return iter.get_double_in_string();\n+}\n simdjson_really_inline simdjson_result<uint64_t> value::get_uint64() noexcept {\n   return iter.get_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> value::get_uint64_in_string() noexcept {\n+  return iter.get_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> value::get_int64() noexcept {\n   return iter.get_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> value::get_int64_in_string() noexcept {\n+  return iter.get_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<bool> value::get_bool() noexcept {\n   return iter.get_bool();\n }\n@@ -221,14 +230,26 @@ simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEM\n   if (error()) { return error(); }\n   return first.get_uint64();\n }\n+simdjson_really_inline simdjson_result<uint64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_uint64_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_uint64_in_string();\n+}\n simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_int64() noexcept {\n   if (error()) { return error(); }\n   return first.get_int64();\n }\n+simdjson_really_inline simdjson_result<int64_t> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_int64_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_int64_in_string();\n+}\n simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_double() noexcept {\n   if (error()) { return error(); }\n   return first.get_double();\n }\n+simdjson_really_inline simdjson_result<double> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_double_in_string() noexcept {\n+  if (error()) { return error(); }\n+  return first.get_double_in_string();\n+}\n simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::get_string() noexcept {\n   if (error()) { return error(); }\n   return first.get_string();\ndiff --git a/include/simdjson/generic/ondemand/value.h b/include/simdjson/generic/ondemand/value.h\n--- a/include/simdjson/generic/ondemand/value.h\n+++ b/include/simdjson/generic/ondemand/value.h\n@@ -69,11 +69,19 @@ class value {\n   /**\n    * Cast this JSON value to an unsigned integer.\n    *\n-   * @returns A signed 64-bit integer.\n+   * @returns A unsigned 64-bit integer.\n    * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n    */\n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a unsigned integer.\n+   *\n+   * @returns A unsigned 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit unsigned integer.\n+   */\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a signed integer.\n    *\n@@ -82,6 +90,14 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a signed integer.\n+   *\n+   * @returns A signed 64-bit integer.\n+   * @returns INCORRECT_TYPE If the JSON value is not a 64-bit integer.\n+   */\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a double.\n    *\n@@ -90,6 +106,14 @@ class value {\n    */\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n \n+  /**\n+   * Cast this JSON value (inside string) to a double\n+   *\n+   * @returns A double.\n+   * @returns INCORRECT_TYPE If the JSON value is not a valid floating-point number.\n+   */\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n+\n   /**\n    * Cast this JSON value to a string.\n    *\n@@ -416,8 +440,11 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> get_object() noexcept;\n \n   simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::raw_json_string> get_raw_json_string() noexcept;\n   simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\ndiff --git a/include/simdjson/generic/ondemand/value_iterator-inl.h b/include/simdjson/generic/ondemand/value_iterator-inl.h\n--- a/include/simdjson/generic/ondemand/value_iterator-inl.h\n+++ b/include/simdjson/generic/ondemand/value_iterator-inl.h\n@@ -452,16 +452,31 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iter\n   if(result.error() != INCORRECT_TYPE) { advance_non_root_scalar(\"uint64\"); }\n   return result;\n }\n+simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_uint64_in_string() noexcept {\n+  auto result = numberparsing::parse_unsigned_in_string(peek_non_root_scalar(\"uint64\"));\n+  if(result.error() != INCORRECT_TYPE) { advance_non_root_scalar(\"uint64\"); }\n+  return result;\n+}\n simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_int64() noexcept {\n   auto result = numberparsing::parse_integer(peek_non_root_scalar(\"int64\"));\n   if(result.error() != INCORRECT_TYPE) { advance_non_root_scalar(\"int64\"); }\n   return result;\n }\n+simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_int64_in_string() noexcept {\n+  auto result = numberparsing::parse_integer_in_string(peek_non_root_scalar(\"int64\"));\n+  if(result.error() != INCORRECT_TYPE) { advance_non_root_scalar(\"int64\"); }\n+  return result;\n+}\n simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_double() noexcept {\n   auto result = numberparsing::parse_double(peek_non_root_scalar(\"double\"));\n   if(result.error() != INCORRECT_TYPE) { advance_non_root_scalar(\"double\"); }\n   return result;\n }\n+simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_double_in_string() noexcept {\n+  auto result = numberparsing::parse_double_in_string(peek_non_root_scalar(\"double\"));\n+  if(result.error() != INCORRECT_TYPE) { advance_non_root_scalar(\"double\"); }\n+  return result;\n+}\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::get_bool() noexcept {\n   auto result = parse_bool(peek_non_root_scalar(\"bool\"));\n   if(result.error() != INCORRECT_TYPE) { advance_non_root_scalar(\"bool\"); }\n@@ -493,6 +508,18 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iter\n   if(result.error() != INCORRECT_TYPE) { advance_root_scalar(\"uint64\"); }\n   return result;\n }\n+simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> value_iterator::get_root_uint64_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"uint64\");\n+  uint8_t tmpbuf[20+1]; // <20 digits> is the longest possible unsigned integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_unsigned_in_string(tmpbuf);\n+  if(result.error() != INCORRECT_TYPE) { advance_root_scalar(\"uint64\"); }\n+  return result;\n+}\n simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_root_int64() noexcept {\n   auto max_len = peek_start_length();\n   auto json = peek_root_scalar(\"int64\");\n@@ -506,6 +533,19 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_itera\n   if(result.error() != INCORRECT_TYPE) { advance_root_scalar(\"int64\"); }\n   return result;\n }\n+simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> value_iterator::get_root_int64_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"int64\");\n+  uint8_t tmpbuf[20+1]; // -<19 digits> is the longest possible integer\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 20 characters\");\n+    return NUMBER_ERROR;\n+  }\n+\n+  auto result = numberparsing::parse_integer_in_string(tmpbuf);\n+  if(result.error() != INCORRECT_TYPE) { advance_root_scalar(\"int64\"); }\n+  return result;\n+}\n simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_root_double() noexcept {\n   auto max_len = peek_start_length();\n   auto json = peek_root_scalar(\"double\");\n@@ -521,6 +561,21 @@ simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterat\n   if(result.error() != INCORRECT_TYPE) { advance_root_scalar(\"double\"); }\n   return result;\n }\n+simdjson_warn_unused simdjson_really_inline simdjson_result<double> value_iterator::get_root_double_in_string() noexcept {\n+  auto max_len = peek_start_length();\n+  auto json = peek_root_scalar(\"double\");\n+  // Per https://www.exploringbinary.com/maximum-number-of-decimal-digits-in-binary-floating-point-numbers/,\n+  // 1074 is the maximum number of significant fractional digits. Add 8 more digits for the biggest\n+  // number: -0.<fraction>e-308.\n+  uint8_t tmpbuf[1074+8+1];\n+  if (!_json_iter->copy_to_buffer(json, max_len, tmpbuf)) {\n+    logger::log_error(*_json_iter, start_position(), depth(), \"Root number more than 1082 characters\");\n+    return NUMBER_ERROR;\n+  }\n+  auto result = numberparsing::parse_double_in_string(tmpbuf);\n+  if(result.error() != INCORRECT_TYPE) { advance_root_scalar(\"double\"); }\n+  return result;\n+}\n simdjson_warn_unused simdjson_really_inline simdjson_result<bool> value_iterator::get_root_bool() noexcept {\n   auto max_len = peek_start_length();\n   auto json = peek_root_scalar(\"bool\");\ndiff --git a/include/simdjson/generic/ondemand/value_iterator.h b/include/simdjson/generic/ondemand/value_iterator.h\n--- a/include/simdjson/generic/ondemand/value_iterator.h\n+++ b/include/simdjson/generic/ondemand/value_iterator.h\n@@ -283,16 +283,22 @@ class value_iterator {\n   simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> get_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> get_raw_json_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_uint64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_uint64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_int64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_int64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_double() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_double_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> get_bool() noexcept;\n   simdjson_really_inline bool is_null() noexcept;\n \n   simdjson_warn_unused simdjson_really_inline simdjson_result<std::string_view> get_root_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<raw_json_string> get_root_raw_json_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_root_uint64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<uint64_t> get_root_uint64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_root_int64() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<int64_t> get_root_int64_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_root_double() noexcept;\n+  simdjson_warn_unused simdjson_really_inline simdjson_result<double> get_root_double_in_string() noexcept;\n   simdjson_warn_unused simdjson_really_inline simdjson_result<bool> get_root_bool() noexcept;\n   simdjson_really_inline bool is_root_null() noexcept;\n \n",
        "test_patch": "diff --git a/tests/ondemand/CMakeLists.txt b/tests/ondemand/CMakeLists.txt\n--- a/tests/ondemand/CMakeLists.txt\n+++ b/tests/ondemand/CMakeLists.txt\n@@ -13,6 +13,7 @@ add_cpp_test(ondemand_json_pointer_tests     LABELS ondemand acceptance per_impl\n add_cpp_test(ondemand_key_string_tests       LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_misc_tests             LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_number_tests           LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_number_in_string_tests LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_error_tests     LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_ordering_tests         LABELS ondemand acceptance per_implementation)\ndiff --git a/tests/ondemand/ondemand_number_in_string_tests.cpp b/tests/ondemand/ondemand_number_in_string_tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ondemand/ondemand_number_in_string_tests.cpp\n@@ -0,0 +1,273 @@\n+#include \"simdjson.h\"\n+#include \"test_ondemand.h\"\n+#include <string>\n+\n+using namespace simdjson;\n+\n+namespace number_in_string_tests {\n+    const padded_string CRYPTO_JSON = R\"(\n+    {\n+        \"ticker\":{\n+            \"base\":\"BTC\",\n+            \"target\":\"USD\",\n+            \"price\":\"443.7807865468\",\n+            \"volume\":\"31720.1493969300\",\n+            \"change\":\"Infinity\",\n+            \"markets\":[\n+                {\n+                    \"market\":\"bitfinex\",\n+                    \"price\":\"447.5000000000\",\n+                    \"volume\":\"10559.5293639000\"\n+                },\n+                {\n+                    \"market\":\"bitstamp\",\n+                    \"price\":\"448.5400000000\",\n+                    \"volume\":\"11628.2880079300\"\n+                },\n+                {\n+                    \"market\":\"btce\",\n+                    \"price\":\"432.8900000000\",\n+                    \"volume\":\"8561.0563600000\"\n+                }\n+            ]\n+        },\n+        \"timestamp\":1399490941,\n+        \"timestampstr\":\"1399490941\"\n+    }\n+    )\"_padded;\n+\n+    bool array_double() {\n+        TEST_START();\n+        auto json = R\"([\"1.2\",\"2.3\",\"-42.3\",\"2.43442e3\", \"-1.234e3\"])\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        size_t counter{0};\n+        std::vector<double> expected = {1.2, 2.3, -42.3, 2434.42, -1234};\n+        double d;\n+        for (auto value : doc) {\n+            ASSERT_SUCCESS(value.get_double_in_string().get(d));\n+            ASSERT_EQUAL(d,expected[counter++]);\n+        }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool array_int() {\n+        TEST_START();\n+        auto json = R\"([\"1\", \"2\", \"-3\", \"1000\", \"-7844\"])\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        size_t counter{0};\n+        std::vector<int> expected = {1, 2, -3, 1000, -7844};\n+        int64_t i;\n+        for (auto value : doc) {\n+            ASSERT_SUCCESS(value.get_int64_in_string().get(i));\n+            ASSERT_EQUAL(i,expected[counter++]);\n+        }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool array_unsigned() {\n+        TEST_START();\n+        auto json = R\"([\"1\", \"2\", \"24\", \"9000\", \"156934\"])\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        size_t counter{0};\n+        std::vector<int> expected = {1, 2, 24, 9000, 156934};\n+        uint64_t u;\n+        for (auto value : doc) {\n+            ASSERT_SUCCESS(value.get_uint64_in_string().get(u));\n+            ASSERT_EQUAL(u,expected[counter++]);\n+        }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool object() {\n+        TEST_START();\n+        auto json = R\"({\"a\":\"1.2\", \"b\":\"-2.342e2\", \"c\":\"22\", \"d\":\"-112358\", \"e\":\"1080\", \"f\":\"123456789\"})\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        size_t counter{0};\n+        std::vector<double> expected = {1.2, -234.2, 22, -112358, 1080, 123456789};\n+        double d;\n+        int64_t i;\n+        uint64_t u;\n+        // Doubles\n+        ASSERT_SUCCESS(doc.find_field(\"a\").get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,expected[counter++]);\n+        ASSERT_SUCCESS(doc.find_field(\"b\").get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,expected[counter++]);\n+        // Integers\n+        ASSERT_SUCCESS(doc.find_field(\"c\").get_int64_in_string().get(i));\n+        ASSERT_EQUAL(i,expected[counter++]);\n+        ASSERT_SUCCESS(doc.find_field(\"d\").get_int64_in_string().get(i));\n+        ASSERT_EQUAL(i,expected[counter++]);\n+        // Unsigned integers\n+        ASSERT_SUCCESS(doc.find_field(\"e\").get_uint64_in_string().get(u));\n+        ASSERT_EQUAL(u,expected[counter++]);\n+        ASSERT_SUCCESS(doc.find_field(\"f\").get_uint64_in_string().get(u));\n+        ASSERT_EQUAL(u,expected[counter++]);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool docs() {\n+        TEST_START();\n+        auto double_doc = R\"( \"-1.23e1\" )\"_padded;\n+        auto int_doc = R\"( \"-243\" )\"_padded;\n+        auto uint_doc = R\"( \"212213\" )\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        double d;\n+        int64_t i;\n+        uint64_t u;\n+        // Double\n+        ASSERT_SUCCESS(parser.iterate(double_doc).get(doc));\n+        ASSERT_SUCCESS(doc.get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,-12.3);\n+        // Integer\n+        ASSERT_SUCCESS(parser.iterate(int_doc).get(doc));\n+        ASSERT_SUCCESS(doc.get_int64_in_string().get(i));\n+        ASSERT_EQUAL(i,-243);\n+        // Unsinged integer\n+        ASSERT_SUCCESS(parser.iterate(uint_doc).get(doc));\n+        ASSERT_SUCCESS(doc.get_uint64_in_string().get(u));\n+        ASSERT_EQUAL(u,212213);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool number_parsing_error() {\n+        TEST_START();\n+        auto json = R\"( [\"13.06.54\", \"1.0e\", \"2e3r4,,.\"])\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        size_t counter{0};\n+        std::string expected[3] = {\"13.06.54\", \"1.0e\", \"2e3r4,,.\"};\n+        for (auto value : doc) {\n+            double d;\n+            std::string_view view;\n+            ASSERT_ERROR(value.get_double_in_string().get(d),NUMBER_ERROR);\n+            ASSERT_SUCCESS(value.get_string().get(view));\n+            ASSERT_EQUAL(view,expected[counter++]);\n+        }\n+        ASSERT_EQUAL(counter,3);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool incorrect_type_error() {\n+        TEST_START();\n+        auto json = R\"( [\"e\", \"i\", \"pi\", \"one\", \"zero\"])\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        size_t counter{0};\n+        std::string expected[5] = {\"e\", \"i\", \"pi\", \"one\", \"zero\"};\n+        for (auto value : doc) {\n+            double d;\n+            std::string_view view;\n+            ASSERT_ERROR(value.get_double_in_string().get(d),INCORRECT_TYPE);\n+            ASSERT_SUCCESS(value.get_string().get(view));\n+            ASSERT_EQUAL(view,expected[counter++]);\n+        }\n+        ASSERT_EQUAL(counter,5);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool json_pointer_test() {\n+        TEST_START();\n+        auto json = R\"( [\"12.34\", { \"a\":[\"3\",\"5.6\"], \"b\":{\"c\":\"1.23e1\"} }, [\"1\", \"3.5\"] ])\"_padded;\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        std::vector<double> expected = {12.34, 5.6, 12.3, 1, 3.5};\n+        size_t counter{0};\n+        double d;\n+        ASSERT_SUCCESS(doc.at_pointer(\"/0\").get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,expected[counter++]);\n+        ASSERT_SUCCESS(doc.at_pointer(\"/1/a/1\").get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,expected[counter++]);\n+        ASSERT_SUCCESS(doc.at_pointer(\"/1/b/c\").get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,expected[counter++]);\n+        ASSERT_SUCCESS(doc.at_pointer(\"/2/0\").get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,expected[counter++]);\n+        ASSERT_SUCCESS(doc.at_pointer(\"/2/1\").get_double_in_string().get(d));\n+        ASSERT_EQUAL(d,expected[counter++]);\n+        ASSERT_EQUAL(counter,5);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool crypto_timestamp() {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(CRYPTO_JSON).get(doc));\n+        uint64_t u;\n+        ASSERT_SUCCESS(doc.at_pointer(\"/timestampstr\").get_uint64_in_string().get(u));\n+        ASSERT_EQUAL(u,1399490941);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool crypto_market() {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(CRYPTO_JSON).get(doc));\n+        ondemand::array markets;\n+        ASSERT_SUCCESS(doc.find_field(\"ticker\").find_field(\"markets\").get_array().get(markets));\n+        std::string_view expected_views[3] = {\"bitfinex\", \"bitstamp\", \"btce\"};\n+        double expected_prices[3] = {447.5, 448.54, 432.89};\n+        double expected_volumes[3] = {10559.5293639, 11628.28800793, 8561.05636};\n+        size_t counter{0};\n+        for (auto value : markets) {\n+            std::string_view view;\n+            double price;\n+            double volume;\n+            ASSERT_SUCCESS(value.find_field(\"market\").get_string().get(view));\n+            ASSERT_EQUAL(view,expected_views[counter]);\n+            ASSERT_SUCCESS(value.find_field(\"price\").get_double_in_string().get(price));\n+            ASSERT_EQUAL(price,expected_prices[counter]);\n+            ASSERT_SUCCESS(value.find_field(\"volume\").get_double_in_string().get(volume));\n+            ASSERT_EQUAL(volume,expected_volumes[counter]);\n+            counter++;\n+        }\n+        ASSERT_EQUAL(counter,3);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool crypto_infinity() {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(CRYPTO_JSON).get(doc));\n+        ondemand::value value;\n+        double d;\n+        std::string_view view;\n+        ASSERT_SUCCESS(doc.find_field(\"ticker\").find_field(\"change\").get(value));\n+        ASSERT_ERROR(value.get_double_in_string().get(d), INCORRECT_TYPE);\n+        ASSERT_SUCCESS(value.get_string().get(view));\n+        ASSERT_EQUAL(view,\"Infinity\");\n+        TEST_SUCCEED();\n+    }\n+\n+    bool run() {\n+        return  array_double() &&\n+                array_int() &&\n+                array_unsigned() &&\n+                object() &&\n+                docs() &&\n+                number_parsing_error() &&\n+                incorrect_type_error() &&\n+                json_pointer_test() &&\n+                crypto_timestamp() &&\n+                crypto_market() &&\n+                crypto_infinity() &&\n+                true;\n+    }\n+}   // number_in_string_tests\n+\n+int main(int argc, char *argv[]) {\n+  return test_main(argc, argv, number_in_string_tests::run);\n+}\n\\ No newline at end of file\n",
        "problem_statement": "Provide the ability to decode strings as values (double/uint64 etc)\n**Is your feature request related to a problem? Please describe.**\r\nFor most crypto exchanges, they have some values (doubles) that are enclosed in quotes. The type of those values are therefore defined as strings with a value in it and I would have to extract the string and run a method on the value outside of the API.\r\n\r\n**Describe the solution you'd like**\r\nEither add a way to tell the api that it should remove the quotes when applying the decoder or add a wrapper function that removes the quotes for the string which can then be decoded by the get_double().\r\nBy allowing this within the API, I don't have to resort to copying the string around for decoding in other libraries.\r\n\r\n**Describe alternatives you've considered**\r\nI can always use std::stof or the likes, but that is not as elegant. Ie there are tons of methods to convert strings to doubles or ints, but ideally I don't have to use something outside of the library for this.\r\n\r\n**Additional context**\r\nI don't think this is needed, the problem is pretty self explanatory.\r\n\r\n** Are you willing to contribute code or documentation toward this new feature? **\r\nYes but you probably wouldn't find my code good enough.:) But for sure I could make a wrapper method that shrinks the stringview on either side of the view by a character which is then passed to the get_double method.\n",
        "hints_text": "With the On Demand API, we're getting you at least a step closer to this: you can do `value.get_raw_json_string().raw()`, which gets you a const char* to the first character after the \". Then you can parse that as a number. Not ideal, obviously, because you'd probably rather use our number parser! But at least then you don't have to incur the overhead of copying and decoding the string, when numbers won't have escape characters in them.\r\n\r\nI wouldn't mind if raw_json_string() itself had a get_double() / get_integer() / get_bool() etc. methods inside it, which might be a reasonable way to skin that cat ... contributions welcome!\n@jkeiser It is easy enough do `simdjson::parse_double(std::string(element))`. It is not quite as fast as working directly on the input buffer... but we do have to validate the input string...\r\n\r\nIndeed, one can call\r\n\r\n```C++\r\nsimdjson_result<double> simdjson::parse_double(const uint8_t * src);\r\n```\r\n\r\nor \r\n\r\n```C++\r\nsimdjson_result< int64_t> simdjson::parse_integer(const uint8_t * src);\r\n```\r\n\r\n\r\nor \r\n\r\n```C++\r\nsimdjson_result< int64_t> simdjson::parse_unsigned(const uint8_t * src);\r\n```\r\n\r\n\r\n\r\n\n@lemire For raw strings, I think our internal `simdjson::builtin::numberparsing::parse_double` / etc. will do the job absolutely perfectly ... we're guaranteed it terminates in a quote, so there's no chance of buffer overrun.\n@jkeiser Can't the end users already do ?\nBesides the fact that they aren't exposed api, yes :)\r\n\r\nI think it's perfectly reasonable and a good idea to keep these functions separate from raw_json_string!\nDoesn't work. It stops on\r\n\r\n```cpp\r\nif (jsoncharutils::is_not_structural_or_whitespace(*p)) { return NUMBER_ERROR; }\r\n```\r\n\r\nline for input \"1234.4\".\r\n\r\nIt tries dereference a null pointer p.\r\n\r\nThe way I use it:\r\n\r\n```cpp\r\nsimdjson::builtin::numberparsing::parse_double(reinterpret_cast<const uint8_t *>(value.get_c_str().value()));\r\n```\n@ivan-volnov Would you consider producing a pull request ? Then we can work out the issues with you using actual code. It is a bit difficult to reason in the abstract.\n@lemire Please consider the following example:\r\n\r\n```cpp\r\nusing namespace simdjson;\r\n\r\nauto json_string = R\"({\"abc\": \"1234.5\"})\"_padded;\r\n\r\ndom::parser parser;\r\n\r\nauto json = parser.parse(json_string);\r\n\r\n// Can't do this:\r\nstd::cout << json[\"abc\"].get_double() << '\\n';\r\n// Got exception: The JSON element does not have the requested type.\r\n\r\n// This doesn't work too:\r\ndouble value = builtin::numberparsing::parse_double(\r\n        reinterpret_cast<const uint8_t *>(\r\n                json[\"abc\"].get_c_str().value()));\r\nstd::cout << value << '\\n';\r\n// Got exception: Problem while parsing a number\r\n```\r\n\r\nWhile debugging I found out the problem [starts here](https://github.com/simdjson/simdjson/blob/master/include/simdjson/generic/numberparsing.h#L815)\r\n\r\nI can use my own parser or even use yours [fast_double_parser](https://github.com/lemire/fast_double_parser) but I found out that fast_double_parser is already a part of simdjson. So I'd rather use simdjson's internal one. But builtin::numberparsing::parse_double doesn't work correctly in my case.\nRight, this cannot work right now...\r\n\r\n```C++\r\n// Can't do this:\r\nstd::cout << json[\"abc\"].get_double() << '\\n';\r\n```\r\n\r\nI am not sure we'd ever want that to work out of the box because you are really dealing with a string... so maybe we could do...\r\n\r\n```C++\r\n// Can't do this:\r\nstd::cout << json[\"abc\"].get_double_from_string() << '\\n';\r\n```\r\n\r\n> While debugging I found out the problem starts here\r\n\r\nBecause a number in a JSON document cannot contain a quote character. We expect `,`, `]`, `}`, but not `\"`.\r\n\r\n> But builtin::numberparsing::parse_double doesn't work correctly in my case.\r\n\r\nI think here we can correct @jkeiser who wrote that they would work \"perfectly\". It is more correct to say that \"we are almost there\". What we need are modified versions of these functions that expect a quote terminated number. As you can imagine, it is not very difficult to pull off hence why I am inviting a pull request.\n@rkarlsson \r\n\r\n> For most crypto exchanges, they have some values (doubles) that are enclosed in quotes. The type of those values are therefore defined as strings with a value in it and I would have to extract the string and run a method on the value outside of the API.\r\n\r\nI find it puzzling that people would enclose 64-bit floating-point values in strings. But they do...\r\n\r\n```JSON\r\n{\"ticker\":{\"base\":\"BTC\",\"target\":\"USD\",\"price\":\"443.7807865468\",\"volume\":\"31720.1493969300\",\"change\":\"0.3766203596\",\"markets\":[{\"market\":\"bitfinex\",\"price\":\"447.5000000000\",\"volume\":\"10559.5293639000\"},{\"market\":\"bitstamp\",\"price\":\"448.5400000000\",\"volume\":\"11628.2880079300\"},{\"market\":\"btce\",\"price\":\"432.8900000000\",\"volume\":\"8561.0563600000\"},{\"market\":\"cryptotrade\",\"price\":\"436.9999989900\",\"volume\":\"0.3640623100\"},{\"market\":\"exmoney\",\"price\":\"428.0000000000\",\"volume\":\"7.9020328400\"},{\"market\":\"hitbtc\",\"price\":\"442.6200000000\",\"volume\":\"750.5900000000\"},{\"market\":\"justcoin\",\"price\":\"453.4920000000\",\"volume\":\"10.2583700000\"},{\"market\":\"kraken\",\"price\":\"452.7042200000\",\"volume\":\"17.7767076800\"},{\"market\":\"therocktrading\",\"price\":\"440.0000000000\",\"volume\":\"178.9300000000\"},{\"market\":\"vaultofsatoshi\",\"price\":\"450.6428600000\",\"volume\":\"5.3209840100\"},{\"market\":\"vircurex\",\"price\":\"460.0000000000\",\"volume\":\"0.1335082600\"}]},\"timestamp\":1399490941,\"success\":true,\"error\":\"\"}\r\n```\n@rkarlsson I am trying to understand what is going on... \r\n\r\nAre you sure that these values are meant to be 64-bit doubles? If they are, why on Earth would you put them in quotes.\nMay be they try to distinguish doubles from decimals because use them internally. Who knows? Crypto exchanges APIs are far from perfection.\n@lemire I would love to help with this task but I completely don't have time these days. Anyway, if you implemented get_double_from_string() It would be extremely handy right now.\r\n\r\nBy the way, a set of get_X_from_string() would be a great idea too.\n@ivan-volnov I am trying to understand the problem first.\r\n\r\nOnce we implement a feature, it is hard to take it away, so before we do, we want to make sure that it is a worthwhile feature.\r\n\r\nI see two possibilities.\r\n\r\n1. These are double values represented as 15-digit floats. If so, then whoever puts them in quotes does not know what they are doing. All JSON parser can deal with double values. Or, at least, I have not yet seen a JSON parser that cannot. It is even right there in the JSON specification.\r\n2. They are in quotes because they are supposed to be some other type. If so then it is *not* a good idea to map them to double values.\r\n\r\nWhich is it?\r\n\r\n\r\nWhat would make sense as a feature would be to take a string and interpret it as a big integer (at least uin64_t). But I cannot make sense of anyone ever serializing a double as a string. It makes no sense.\r\n\r\n\n@lemire I suppose the first one. But the second is an option too. See below:\r\n\r\nI see a couple of reasons:\r\n1. They don't relay on json parsers, because json parsers are slow in common.\r\n2. The best format for money values is decimal. So, they try to avoid any value corruption because of double. In this case as end users we have two options: Parse into double anyway, parse into decimal by a custom library.\r\n\r\nIf we need speed, use double, if we need 100% correct precision, use decimal.\r\n\nI expect the doubles are in quotes (perhaps incorrectly) for reasons like \"I noticed twitter has to put their integer IDs in quotes, so maybe we should too\" :)\r\n\r\nSorry to mislead you about parse_number! I forgot that our number parsing expects to end on `{}[],:` and whitespace, rather than \"anything that isn't a number.\"\r\n\r\nI feel like we want to decouple these things--we shouldn't have methods that treat strings as numbers in raw simdjson, but we should make it easy for you to use simdjson's parsing on them. It's a slippery slope thing, but a real one :) APIs are stronger when they rely on composition.\n@jkeiser The twitter crowd seemed to think that a major reason has to do with the numbers needing to be interpreted as decimal types. Because JSON parsers will treat numbers as IEEE binary64 values, if you do not put them in quotes, you end up with JSON characters -> binary64 -> decimal. Given that decimal types do not have the same range of values, at least in theory, you introduce a lossy process that might be undesirable. Furthermore, it is probably slower and less efficient than it could be.\r\n\r\nAs far as I can tell, in the examples I found, they could be represented exactly in binary64 format since they are mode of only 15 digits. So I do not expect the result to be lossy in practice.",
        "created_at": "2021-07-22T21:29:04Z",
        "version": "0.9"
    }
}