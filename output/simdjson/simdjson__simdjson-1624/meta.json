{
    "task_id": "simdjson__simdjson-1624",
    "setup_info": {
        "repo_path": "testbed/simdjson__simdjson-1624_2025-07-08_04-24-15",
        "repo_cache_path": "testbed/simdjson/simdjson_cache"
    },
    "task_info": {
        "repo": "simdjson/simdjson",
        "pull_number": 1624,
        "instance_id": "simdjson__simdjson-1624",
        "issue_numbers": [
            "1622"
        ],
        "base_commit": "6cd04aa858f2d92105c0fbd65cdafb96428db002",
        "patch": "diff --git a/include/simdjson/generic/ondemand/array.h b/include/simdjson/generic/ondemand/array.h\n--- a/include/simdjson/generic/ondemand/array.h\n+++ b/include/simdjson/generic/ondemand/array.h\n@@ -54,7 +54,7 @@ class array {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"/0/foo/a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n    * @return The value associated with the given JSON pointer, or:\n    *         - NO_SUCH_FIELD if a field does not exist in an object\ndiff --git a/include/simdjson/generic/ondemand/document-inl.h b/include/simdjson/generic/ondemand/document-inl.h\n--- a/include/simdjson/generic/ondemand/document-inl.h\n+++ b/include/simdjson/generic/ondemand/document-inl.h\n@@ -135,6 +135,7 @@ simdjson_really_inline simdjson_result<std::string_view> document::raw_json_toke\n }\n \n simdjson_really_inline simdjson_result<value> document::at_pointer(std::string_view json_pointer) noexcept {\n+  rewind(); // Rewind the document each time at_pointer is called\n   if (json_pointer.empty()) {\n     return this->resume_value();\n   }\ndiff --git a/include/simdjson/generic/ondemand/document.h b/include/simdjson/generic/ondemand/document.h\n--- a/include/simdjson/generic/ondemand/document.h\n+++ b/include/simdjson/generic/ondemand/document.h\n@@ -335,7 +335,7 @@ class document {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"//a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n    *\n    * @return The value associated with the given JSON pointer, or:\ndiff --git a/include/simdjson/generic/ondemand/object.h b/include/simdjson/generic/ondemand/object.h\n--- a/include/simdjson/generic/ondemand/object.h\n+++ b/include/simdjson/generic/ondemand/object.h\n@@ -91,7 +91,7 @@ class object {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"//a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n    *\n    * @return The value associated with the given JSON pointer, or:\ndiff --git a/include/simdjson/generic/ondemand/value.h b/include/simdjson/generic/ondemand/value.h\n--- a/include/simdjson/generic/ondemand/value.h\n+++ b/include/simdjson/generic/ondemand/value.h\n@@ -330,7 +330,7 @@ class value {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"//a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n    *\n    * @return The value associated with the given JSON pointer, or:\n",
        "test_patch": "diff --git a/tests/ondemand/ondemand_json_pointer_tests.cpp b/tests/ondemand/ondemand_json_pointer_tests.cpp\n--- a/tests/ondemand/ondemand_json_pointer_tests.cpp\n+++ b/tests/ondemand/ondemand_json_pointer_tests.cpp\n@@ -117,7 +117,6 @@ namespace json_pointer_tests {\n             std::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n             ASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n             measured.push_back(x);\n-            cars.rewind();\n         }\n \n         std::vector<double> expected = {39.9, 31, 30};\n",
        "problem_statement": "at_pointer in On Demand should automatically rewind\nCurrently, users of the On Demand API who use at_pointer (JSON Pointer) have to manually rewind.\r\n\r\nWhy don't we make that automatic?\n",
        "hints_text": "Ping @erichutchins\nI can't see a reason why not. There may be performance optimizations in the future where we don't rewind immediately (like we do in find_field_unordered), but that wouldn't change the API.\nWhen @NicolasJiaxin comes back, we will discuss it and hopefully resolve this issue.\r\n\r\nI would rather not have to document the need to rewind, and the fact that @erichutchins found it error prone has been worried enough.\nI agree that automatic rewinding would be a good idea. It would give even more of that DOM feeling with the faster approach that is On Demand. And also, it is not like the first time that this *rewinding* idea is used in On Demand (like when calling `end()` with arrays). \nIf @lemire and @jkeiser  don't see any immediate issues with this, I will start implementing the automatic rewinding for On Demand, and then after, I will update the documentation (relating to #1618 and #1623).\n@NicolasJiaxin Please do.\nOne gotcha I just encountered is that rewinding before you access some values in the document can cause an error. Should at_pointer rewind at the *beginning* of its execution rather than at the end?\r\n\r\n```cpp\r\nauto jsonstr = R\"( {\"hello\": [0,1,2,3], \"test\": \"foo\", \"bool\": true, \"num\":1234, \"success\":\"yes\"} )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\n\r\nfor (auto jp: {\"/num\", \"/hello\"}) {\r\n    val = doc.at_pointer(jp);\r\n    // rewind *before* accessing value\r\n    doc.rewind();\r\n    std::cout << \"at_pointer \" << jp << \": \" << val << std::endl;\r\n}\r\n```\r\n\r\nTrying to access the `val` on the second iteration crashes.\r\n```\r\nat_pointer /num: 1234\r\nterminate called after throwing an instance of 'simdjson::simdjson_error'\r\n  what():  Objects and arrays can only be iterated when they are first encountered.\r\nAborted (core dumped)\r\n```\r\n\r\nFor scalar values, rewinding first doesn\u2019t cause a problem.\r\n```cpp\r\nfor (auto jp: {\"/num\", \"/test\", \"/hello/2\"}) {\r\n    val = doc.at_pointer(jp);\r\n    doc.rewind();\r\n    std::cout << \"at_pointer \" << jp << \": \" << val << std::endl;\r\n}\r\n```\r\n\r\n```\r\nat_pointer /num: 1234\r\nat_pointer /test: \"foo\"\r\nat_pointer /hello/2: 2\r\n```\r\n\n@erichutchins Yes indeed. Right now, you should *access*/*read* the value you parsed before rewinding the document. And as you pointed out, this causes trouble for non-scalar values (i.e. arrays and objects). I am currently trying to find a way around this issue because in order to automatically rewind, we would have to rewind before accessing the value each time `at_pointer` is called.\nMaybe @lemire could explain what really happens with this issue here.\nThe issue is that we have exactly one cursor into the document which can be used to iterate arrays and objects; resetting means you can't iterate that array anymore. The reason we do this is we need some kind of *shared* cursor so that when you finish iterating a child array or object, the parent array or object can \"pick up where it left off.\"\ni.e. often if you iterate through a child object or array you actually consume most or all of it and therefore you want the parent to not have to repeat that work.\n@jkeiser I see, thanks! But then, if I want to save the child object/array before resetting, I would need to copy it separately? Would that be a valid approach for this issue?\nThe `rewind` calls invalidates everything expect for the numbers, the nuls, the bools.\r\n\r\n@NicolasJiaxin I do not think it makes sense to save the array or object. You are supposed to consume it before the next query. Once rewind is called, you previous values are invalid. You had to extract the information you needed. This is not DOM... it is up to the user to materialize the result.\n@erichutchins  \r\n\r\nThe `rewind` calls invalidates the values. If you do `\"/num\"`, then you get back an integer, which you can copy. If you get an array, you have to copy it. You get a `string_view`, you have to copy it. The On Demand front-end won't do it for you.\r\n\r\nIt is really like an input stream... Think about reading data from a file. You don't want to carry around a pointer to a location inside a file. You want to take the data and make a copy of it.\nI am a little bit stuck @lemire. The issue that I am having is that we want both to return a value through `at_pointer` and also automatically `rewind` when `at_pointer` is called. But then, if we rewind when `at_pointer` is called, it would invalidate the value returned by that same call (if that value is an object or an array. Any hints or things that I am missing?\nThe documentation should be very clear on this. We need to make sure people understand that there is no string, there is no array there... If you want hold on the array or the string, you have to construct an instance, as the user. \r\n\r\nThe following, for example, would not work...\r\n\r\n```C++\r\nauto jsonstr = R\"( {\"hello\": \"foo1\", \"test\": \"foo\"} )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\n\r\nstd::string_view val1 = doc.at_pointer(\"test\");\r\ndoc.rewind();\r\nstd::string_view val2 = doc.at_pointer(\"hellow\");\r\n}\r\n```\r\n\r\nYou would need to do something like this...\r\n\r\n\r\n```C++\r\nauto jsonstr = R\"( {\"hello\": \"foo1\", \"test\": \"foo\"} )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\n\r\nstd::string val1 = doc.at_pointer(\"test\"); // copy to my own instance\r\ndoc.rewind();\r\nstd::string val2 = doc.at_pointer(\"hello\"); // copy to my own instance\r\n}\r\n```\r\n\r\nThat's because we write the unescaped strings to a string buffer. The `rewind` call will reset this buffer. If we did not do that, then you could, eventually, use an infinite amount of memory just by constantly unescaping strings again and again. You would end up, effectively, with a memory leak.\r\n\r\nThe problem with \"keeping a reference to an array\" is that if you have all these references around, they all share the same string buffer.\r\n\r\n\r\nA way around that would be to ask people to provide string buffers, or to duplicate our own string buffer... but this would have tradeoffs of its own.\n> But then, if we rewind when at_pointer is called, it would invalidate the value returned by that same call (if that value is an object or an array). Any hints or things that I am missing?\r\n\r\nNumbers, bools and nulls do not get invalidated because they get copied to a new instance. Everything else (`string_view`, `ondemand::object`, `ondemand::value`, `ondemand::array`) is invalidated. So you have to consume it *before* the next call to rewind. If, for example, you have an array of integers, then you should store them into an array of your own and not rely on the `ondemand::array` as a storage container.\r\n\r\nIt is not that we could not make it work, it is that it creates a whole set of other expectations. We do not want people to hold on to these instances from `on::demand` in their systems (`string_view`, `ondemand::object`, `ondemand::value`, `ondemand::array`). We want people to dump the data into their own data structures.\r\n\r\nThe idea with On Demand is that people should consume the values. In practice, this may mean making copies.\n>  if you want to save the child object/array before resetting, I would need to copy it separately? Would that be a valid approach for this issue?\r\n\r\nYes. And, in fact, we would like to document it this way.\r\n\r\nSo if take @erichutchins's issue. He has this array there `[0,1,2,3]`. You can do...\r\n\r\n```C++\r\nstd::vector<int64_t> vals;\r\nfor(auto i : array) { vals.push_back(i); }\r\n```\r\n\r\n(This might not be the best code example.)\r\n\r\nAnd then you have your `std::vector<int64_t>`. You can then do away with the `parser` instance, you are done. If you have an object\u00a0instance, you almost surely want to map the keys to some attribute or variables in your system. Like in this example...\r\n\r\n```C++\r\nauto jsonstr = R\"( {\"user\": {\"name\":\"Joe\", \"age\":37 )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\nauto val = doc.at_pointer(\"user\");\r\nmy_user_class user(val[\"Joe\"],val[\"age\")); // consume the object\r\n// you now have your user instance and you can do away with the JSON stuff\r\n```\r\n\r\n\r\nKeeping around the `ondemand::value` or `ondemand::object` is not something we want users to do. We want then to consume the values and be done with the JSON part as quickly as possible.\n@NicolasJiaxin @erichutchins \r\n\r\nI should stress that your objections are very much warranted. What we need to do is be very clear about the right way to use On Demand. We should have good examples.",
        "created_at": "2021-06-21T19:06:44Z",
        "version": "0.9"
    }
}