{
    "task_id": "simdjson__simdjson-1615",
    "setup_info": {
        "repo_path": "testbed/simdjson__simdjson-1615_2025-07-08_04-24-15",
        "repo_cache_path": "testbed/simdjson/simdjson_cache"
    },
    "task_info": {
        "repo": "simdjson/simdjson",
        "pull_number": 1615,
        "instance_id": "simdjson__simdjson-1615",
        "issue_numbers": [
            "1427"
        ],
        "base_commit": "40cba172ed66584cf670c98202ed474a316667e3",
        "patch": "diff --git a/include/simdjson/generic/ondemand/array-inl.h b/include/simdjson/generic/ondemand/array-inl.h\n--- a/include/simdjson/generic/ondemand/array-inl.h\n+++ b/include/simdjson/generic/ondemand/array-inl.h\n@@ -93,6 +93,51 @@ simdjson_really_inline simdjson_result<size_t> array::count_elements() & noexcep\n   return count;\n }\n \n+inline simdjson_result<value> array::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  // - means \"the append position\" or \"the element after the end of the array\"\n+  // We don't support this, because we're returning a real element, not a position.\n+  if (json_pointer == \"-\") { return INDEX_OUT_OF_BOUNDS; }\n+\n+  // Read the array index\n+  size_t array_index = 0;\n+  size_t i;\n+  for (i = 0; i < json_pointer.length() && json_pointer[i] != '/'; i++) {\n+    uint8_t digit = uint8_t(json_pointer[i] - '0');\n+    // Check for non-digit in array index. If it's there, we're trying to get a field in an object\n+    if (digit > 9) { return INCORRECT_TYPE; }\n+    array_index = array_index*10 + digit;\n+  }\n+\n+  // 0 followed by other digits is invalid\n+  if (i > 1 && json_pointer[0] == '0') { return INVALID_JSON_POINTER; } // \"JSON pointer array index has other characters after 0\"\n+\n+  // Empty string is invalid; so is a \"/\" with no digits before it\n+  if (i == 0) { return INVALID_JSON_POINTER; } // \"Empty string in JSON pointer array index\"\n+  // Get the child\n+  auto child = at(array_index);\n+  // If there is an error, it ends here\n+  if(child.error()) {\n+    return child;\n+  }\n+\n+  // If there is a /, we're not done yet, call recursively.\n+  if (i < json_pointer.length()) {\n+    child = child.at_pointer(json_pointer.substr(i));\n+  }\n+  return child;\n+}\n+\n+simdjson_really_inline simdjson_result<value> array::at(size_t index) noexcept {\n+  size_t i=0;\n+  for (auto value : *this) {\n+    if (i == index) { return value; }\n+    i++;\n+  }\n+  return INDEX_OUT_OF_BOUNDS;\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -126,4 +171,8 @@ simdjson_really_inline  simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEME\n   if (error()) { return error(); }\n   return first.count_elements();\n }\n+simdjson_really_inline  simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/array.h b/include/simdjson/generic/ondemand/array.h\n--- a/include/simdjson/generic/ondemand/array.h\n+++ b/include/simdjson/generic/ondemand/array.h\n@@ -43,6 +43,27 @@ class array {\n    * safe to continue.\n    */\n   simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"([ { \"foo\": { \"a\": [ 10, 20, 30 ] }} ])\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/0/foo/a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   /**\n    * Begin array iteration.\n@@ -80,6 +101,15 @@ class array {\n    */\n   simdjson_really_inline array(const value_iterator &iter) noexcept;\n \n+  /**\n+   * Get the value at the given index. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) noexcept;\n+\n   /**\n    * Iterator marking current position.\n    *\n@@ -110,6 +140,7 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> : public SIMDJS\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() noexcept;\n   simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/document-inl.h b/include/simdjson/generic/ondemand/document-inl.h\n--- a/include/simdjson/generic/ondemand/document-inl.h\n+++ b/include/simdjson/generic/ondemand/document-inl.h\n@@ -134,6 +134,23 @@ simdjson_really_inline simdjson_result<std::string_view> document::raw_json_toke\n   return std::string_view(reinterpret_cast<const char*>(_iter.peek_start()), _iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> document::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer.empty()) {\n+    return this->resume_value();\n+  }\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -311,4 +328,9 @@ simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSO\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/document.h b/include/simdjson/generic/ondemand/document.h\n--- a/include/simdjson/generic/ondemand/document.h\n+++ b/include/simdjson/generic/ondemand/document.h\n@@ -318,6 +318,34 @@ class document {\n    * Returns debugging information.\n    */\n   inline std::string to_debug_string() noexcept;\n+\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   simdjson_really_inline document(ondemand::json_iterator &&iter) noexcept;\n   simdjson_really_inline const uint8_t *text(uint32_t idx) const noexcept;\n@@ -396,6 +424,8 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n \n   /** @copydoc simdjson_really_inline std::string_view document::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/object-inl.h b/include/simdjson/generic/ondemand/object-inl.h\n--- a/include/simdjson/generic/ondemand/object-inl.h\n+++ b/include/simdjson/generic/ondemand/object-inl.h\n@@ -68,6 +68,46 @@ simdjson_really_inline simdjson_result<object_iterator> object::end() noexcept {\n   return object_iterator(iter);\n }\n \n+inline simdjson_result<value> object::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  size_t slash = json_pointer.find('/');\n+  std::string_view key = json_pointer.substr(0, slash);\n+  // Grab the child with the given key\n+  simdjson_result<value> child;\n+\n+  // If there is an escape character in the key, unescape it and then get the child.\n+  size_t escape = key.find('~');\n+  if (escape != std::string_view::npos) {\n+    // Unescape the key\n+    std::string unescaped(key);\n+    do {\n+      switch (unescaped[escape+1]) {\n+        case '0':\n+          unescaped.replace(escape, 2, \"~\");\n+          break;\n+        case '1':\n+          unescaped.replace(escape, 2, \"/\");\n+          break;\n+        default:\n+          return INVALID_JSON_POINTER; // \"Unexpected ~ escape character in JSON pointer\");\n+      }\n+      escape = unescaped.find('~', escape+1);\n+    } while (escape != std::string::npos);\n+    child = find_field(unescaped);  // Take note find_field does not unescape keys when matching\n+  } else {\n+    child = find_field(key);\n+  }\n+  if(child.error()) {\n+    return child; // we do not continue if there was an error\n+  }\n+  // If there is a /, we have to recurse and look up more of the path\n+  if (slash != std::string_view::npos) {\n+    child = child.at_pointer(json_pointer.substr(slash));\n+  }\n+  return child;\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -112,4 +152,9 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>\n   return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::object>(first).find_field(key);\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/object.h b/include/simdjson/generic/ondemand/object.h\n--- a/include/simdjson/generic/ondemand/object.h\n+++ b/include/simdjson/generic/ondemand/object.h\n@@ -74,6 +74,34 @@ class object {\n   /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n   simdjson_really_inline simdjson_result<value> operator[](std::string_view key) && noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer. We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   static simdjson_really_inline simdjson_result<object> start(value_iterator &iter) noexcept;\n   static simdjson_really_inline simdjson_result<object> start_root(value_iterator &iter) noexcept;\n@@ -111,6 +139,7 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> : public SIMDJ\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) && noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) && noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/value-inl.h b/include/simdjson/generic/ondemand/value-inl.h\n--- a/include/simdjson/generic/ondemand/value-inl.h\n+++ b/include/simdjson/generic/ondemand/value-inl.h\n@@ -135,6 +135,20 @@ simdjson_really_inline std::string_view value::raw_json_token() noexcept {\n   return std::string_view(reinterpret_cast<const char*>(iter.peek_start()), iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> value::at_pointer(std::string_view json_pointer) noexcept {\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -296,4 +310,9 @@ simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSO\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/value.h b/include/simdjson/generic/ondemand/value.h\n--- a/include/simdjson/generic/ondemand/value.h\n+++ b/include/simdjson/generic/ondemand/value.h\n@@ -314,6 +314,33 @@ class value {\n    */\n   simdjson_really_inline std::string_view raw_json_token() noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   /**\n    * Create a value.\n@@ -459,6 +486,8 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n \n   /** @copydoc simdjson_really_inline std::string_view value::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\n",
        "test_patch": "diff --git a/tests/ondemand/CMakeLists.txt b/tests/ondemand/CMakeLists.txt\n--- a/tests/ondemand/CMakeLists.txt\n+++ b/tests/ondemand/CMakeLists.txt\n@@ -2,14 +2,15 @@\n link_libraries(simdjson)\n include_directories(..)\n add_subdirectory(compilation_failure_tests)\n-add_cpp_test(ondemand_tostring_tests           LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_tostring_tests         LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_active_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_array_tests            LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_array_error_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_compilation_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_error_tests            LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_json_pointer_tests     LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_key_string_tests       LABELS ondemand acceptance per_implementation)\n-add_cpp_test(ondemand_misc_tests           LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_misc_tests             LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_number_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_error_tests     LABELS ondemand acceptance per_implementation)\ndiff --git a/tests/ondemand/ondemand_json_pointer_tests.cpp b/tests/ondemand/ondemand_json_pointer_tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ondemand/ondemand_json_pointer_tests.cpp\n@@ -0,0 +1,168 @@\n+#include \"simdjson.h\"\n+#include \"test_ondemand.h\"\n+#include <string>\n+\n+using namespace simdjson;\n+\n+namespace json_pointer_tests {\n+    const padded_string TEST_JSON = R\"(\n+    {\n+        \"/~01abc\": [\n+        0,\n+        {\n+            \"\\\\\\\" 0\": [\n+            \"value0\",\n+            \"value1\"\n+            ]\n+        }\n+        ],\n+        \"0\": \"0 ok\",\n+        \"01\": \"01 ok\",\n+        \"\": \"empty ok\",\n+        \"arr\": []\n+    }\n+    )\"_padded;\n+\n+    const padded_string TEST_RFC_JSON = R\"(\n+    {\n+        \"foo\": [\"bar\", \"baz\"],\n+        \"\": 0,\n+        \"a/b\": 1,\n+        \"c%d\": 2,\n+        \"e^f\": 3,\n+        \"g|h\": 4,\n+        \"i\\\\j\": 5,\n+        \"k\\\"l\": 6,\n+        \" \": 7,\n+        \"m~n\": 8\n+    }\n+    )\"_padded;\n+\n+    bool run_success_test(const padded_string & json,std::string_view json_pointer,std::string expected) {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ondemand::value val;\n+        std::string actual;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        ASSERT_SUCCESS(doc.at_pointer(json_pointer).get(val));\n+        ASSERT_SUCCESS(simdjson::to_string(val).get(actual));\n+        ASSERT_EQUAL(actual,expected);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool run_failure_test(const padded_string & json,std::string_view json_pointer,error_code expected) {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        ASSERT_EQUAL(doc.at_pointer(json_pointer).error(),expected);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool demo_test() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        double x;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        ASSERT_SUCCESS(cars.at_pointer(\"/0/tire_pressure/1\").get(x));\n+        ASSERT_EQUAL(x,39.9);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool demo_relative_path() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        std::vector<double> measured;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        for (auto car_element : cars) {\n+            double x;\n+            ASSERT_SUCCESS(car_element.at_pointer(\"/tire_pressure/1\").get(x));\n+            measured.push_back(x);\n+        }\n+\n+        std::vector<double> expected = {39.9, 31, 30};\n+        if (measured != expected) { return false; }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool many_json_pointers() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        std::vector<double> measured;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        for (int i = 0; i < 3; i++) {\n+            double x;\n+            std::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n+            ASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n+            measured.push_back(x);\n+            cars.rewind();\n+        }\n+\n+        std::vector<double> expected = {39.9, 31, 30};\n+        if (measured != expected) { return false; }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool run() {\n+        return\n+                demo_test() &&\n+                demo_relative_path() &&\n+                run_success_test(TEST_RFC_JSON,\"\",R\"({\"foo\":[\"bar\",\"baz\"],\"\":0,\"a/b\":1,\"c%d\":2,\"e^f\":3,\"g|h\":4,\"i\\\\j\":5,\"k\\\"l\":6,\" \":7,\"m~n\":8})\") &&\n+                run_success_test(TEST_RFC_JSON,\"/foo\",R\"([\"bar\",\"baz\"])\") &&\n+                run_success_test(TEST_RFC_JSON,\"/foo/0\",R\"(\"bar\")\") &&\n+                run_success_test(TEST_RFC_JSON,\"/\",R\"(0)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/a~1b\",R\"(1)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/c%d\",R\"(2)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/e^f\",R\"(3)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/g|h\",R\"(4)\") &&\n+                run_success_test(TEST_RFC_JSON,R\"(/i\\\\j)\",R\"(5)\") &&\n+                run_success_test(TEST_RFC_JSON,R\"(/k\\\"l)\",R\"(6)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/ \",R\"(7)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/m~0n\",R\"(8)\") &&\n+                run_success_test(TEST_JSON, \"\", R\"({\"/~01abc\":[0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}],\"0\":\"0 ok\",\"01\":\"01 ok\",\"\":\"empty ok\",\"arr\":[]})\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc)\", R\"([0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}])\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1)\", R\"({\"\\\\\\\" 0\":[\"value0\",\"value1\"]})\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0)\", R\"([\"value0\",\"value1\"])\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/0)\", \"\\\"value0\\\"\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/1)\", \"\\\"value1\\\"\") &&\n+                run_success_test(TEST_JSON, \"/arr\", R\"([])\") &&\n+                run_success_test(TEST_JSON, \"/0\", \"\\\"0 ok\\\"\") &&\n+                run_success_test(TEST_JSON, \"/01\", \"\\\"01 ok\\\"\") &&\n+                run_success_test(TEST_JSON, \"\", R\"({\"/~01abc\":[0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}],\"0\":\"0 ok\",\"01\":\"01 ok\",\"\":\"empty ok\",\"arr\":[]})\") &&\n+                run_failure_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/2)\", INDEX_OUT_OF_BOUNDS) &&\n+                run_failure_test(TEST_JSON, \"/arr/0\", INDEX_OUT_OF_BOUNDS) &&\n+                run_failure_test(TEST_JSON, \"~1~001abc\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~01abc\", NO_SUCH_FIELD) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/01\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/-\", INDEX_OUT_OF_BOUNDS) &&\n+                many_json_pointers() &&\n+                true;\n+    }\n+}   // json_pointer_tests\n+\n+int main(int argc, char *argv[]) {\n+  return test_main(argc, argv, json_pointer_tests::run);\n+}\n\\ No newline at end of file\n",
        "problem_statement": "Implement JSON Pointer on top of On Demand\n[Currently our JSON Pointer API assumes a DOM tree](https://github.com/simdjson/simdjson/blob/c5def8f7060a7e9519c7f38e2c4ddf2dc784d6a8/doc/basics.md#json-pointer), but it is obvious that we can do it with On Demand.\r\n\r\n\r\nIf the pointer points at an array or an object, you'd like to be able to do...\r\n\r\n```C++\r\n    auto doc = parser.iterate(json);\r\n    for (auto x : doc.at_pointer(insert json pointer expression)) {\r\n     \r\n    }\r\n```\r\n\r\nIt could have substantial performance gains.\r\n\r\n[The `at_pointer` functions in our DOM API have a rather clean implementation](https://github.com/simdjson/simdjson/blob/95b4870e20be5f97d9dcf63b23b1c6f520c366c1/include/simdjson/dom/object.h). It is then a matter of 'porting' them to the On Demand front-end. There will be some fun challenges.\n",
        "hints_text": "",
        "created_at": "2021-06-09T20:11:26Z",
        "version": "0.9"
    }
}