[
  {
    "repo": "simdjson/simdjson",
    "pull_number": 1615,
    "instance_id": "simdjson__simdjson-1615",
    "issue_numbers": [
      "1427"
    ],
    "base_commit": "40cba172ed66584cf670c98202ed474a316667e3",
    "patch": "diff --git a/include/simdjson/generic/ondemand/array-inl.h b/include/simdjson/generic/ondemand/array-inl.h\n--- a/include/simdjson/generic/ondemand/array-inl.h\n+++ b/include/simdjson/generic/ondemand/array-inl.h\n@@ -93,6 +93,51 @@ simdjson_really_inline simdjson_result<size_t> array::count_elements() & noexcep\n   return count;\n }\n \n+inline simdjson_result<value> array::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  // - means \"the append position\" or \"the element after the end of the array\"\n+  // We don't support this, because we're returning a real element, not a position.\n+  if (json_pointer == \"-\") { return INDEX_OUT_OF_BOUNDS; }\n+\n+  // Read the array index\n+  size_t array_index = 0;\n+  size_t i;\n+  for (i = 0; i < json_pointer.length() && json_pointer[i] != '/'; i++) {\n+    uint8_t digit = uint8_t(json_pointer[i] - '0');\n+    // Check for non-digit in array index. If it's there, we're trying to get a field in an object\n+    if (digit > 9) { return INCORRECT_TYPE; }\n+    array_index = array_index*10 + digit;\n+  }\n+\n+  // 0 followed by other digits is invalid\n+  if (i > 1 && json_pointer[0] == '0') { return INVALID_JSON_POINTER; } // \"JSON pointer array index has other characters after 0\"\n+\n+  // Empty string is invalid; so is a \"/\" with no digits before it\n+  if (i == 0) { return INVALID_JSON_POINTER; } // \"Empty string in JSON pointer array index\"\n+  // Get the child\n+  auto child = at(array_index);\n+  // If there is an error, it ends here\n+  if(child.error()) {\n+    return child;\n+  }\n+\n+  // If there is a /, we're not done yet, call recursively.\n+  if (i < json_pointer.length()) {\n+    child = child.at_pointer(json_pointer.substr(i));\n+  }\n+  return child;\n+}\n+\n+simdjson_really_inline simdjson_result<value> array::at(size_t index) noexcept {\n+  size_t i=0;\n+  for (auto value : *this) {\n+    if (i == index) { return value; }\n+    i++;\n+  }\n+  return INDEX_OUT_OF_BOUNDS;\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -126,4 +171,8 @@ simdjson_really_inline  simdjson_result<size_t> simdjson_result<SIMDJSON_IMPLEME\n   if (error()) { return error(); }\n   return first.count_elements();\n }\n+simdjson_really_inline  simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/array.h b/include/simdjson/generic/ondemand/array.h\n--- a/include/simdjson/generic/ondemand/array.h\n+++ b/include/simdjson/generic/ondemand/array.h\n@@ -43,6 +43,27 @@ class array {\n    * safe to continue.\n    */\n   simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"([ { \"foo\": { \"a\": [ 10, 20, 30 ] }} ])\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/0/foo/a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   /**\n    * Begin array iteration.\n@@ -80,6 +101,15 @@ class array {\n    */\n   simdjson_really_inline array(const value_iterator &iter) noexcept;\n \n+  /**\n+   * Get the value at the given index. This function has linear-time complexity.\n+   * This function should only be called once as the array iterator is not reset between each call.\n+   *\n+   * @return The value at the given index, or:\n+   *         - INDEX_OUT_OF_BOUNDS if the array index is larger than an array length\n+   */\n+  simdjson_really_inline simdjson_result<value> at(size_t index) noexcept;\n+\n   /**\n    * Iterator marking current position.\n    *\n@@ -110,6 +140,7 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array> : public SIMDJS\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> begin() noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::array_iterator> end() noexcept;\n   simdjson_really_inline simdjson_result<size_t> count_elements() & noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/document-inl.h b/include/simdjson/generic/ondemand/document-inl.h\n--- a/include/simdjson/generic/ondemand/document-inl.h\n+++ b/include/simdjson/generic/ondemand/document-inl.h\n@@ -134,6 +134,23 @@ simdjson_really_inline simdjson_result<std::string_view> document::raw_json_toke\n   return std::string_view(reinterpret_cast<const char*>(_iter.peek_start()), _iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> document::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer.empty()) {\n+    return this->resume_value();\n+  }\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -311,4 +328,9 @@ simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSO\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/document.h b/include/simdjson/generic/ondemand/document.h\n--- a/include/simdjson/generic/ondemand/document.h\n+++ b/include/simdjson/generic/ondemand/document.h\n@@ -318,6 +318,34 @@ class document {\n    * Returns debugging information.\n    */\n   inline std::string to_debug_string() noexcept;\n+\n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   simdjson_really_inline document(ondemand::json_iterator &&iter) noexcept;\n   simdjson_really_inline const uint8_t *text(uint32_t idx) const noexcept;\n@@ -396,6 +424,8 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::document> : public SIM\n \n   /** @copydoc simdjson_really_inline std::string_view document::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/object-inl.h b/include/simdjson/generic/ondemand/object-inl.h\n--- a/include/simdjson/generic/ondemand/object-inl.h\n+++ b/include/simdjson/generic/ondemand/object-inl.h\n@@ -68,6 +68,46 @@ simdjson_really_inline simdjson_result<object_iterator> object::end() noexcept {\n   return object_iterator(iter);\n }\n \n+inline simdjson_result<value> object::at_pointer(std::string_view json_pointer) noexcept {\n+  if (json_pointer[0] != '/') { return INVALID_JSON_POINTER; }\n+  json_pointer = json_pointer.substr(1);\n+  size_t slash = json_pointer.find('/');\n+  std::string_view key = json_pointer.substr(0, slash);\n+  // Grab the child with the given key\n+  simdjson_result<value> child;\n+\n+  // If there is an escape character in the key, unescape it and then get the child.\n+  size_t escape = key.find('~');\n+  if (escape != std::string_view::npos) {\n+    // Unescape the key\n+    std::string unescaped(key);\n+    do {\n+      switch (unescaped[escape+1]) {\n+        case '0':\n+          unescaped.replace(escape, 2, \"~\");\n+          break;\n+        case '1':\n+          unescaped.replace(escape, 2, \"/\");\n+          break;\n+        default:\n+          return INVALID_JSON_POINTER; // \"Unexpected ~ escape character in JSON pointer\");\n+      }\n+      escape = unescaped.find('~', escape+1);\n+    } while (escape != std::string::npos);\n+    child = find_field(unescaped);  // Take note find_field does not unescape keys when matching\n+  } else {\n+    child = find_field(key);\n+  }\n+  if(child.error()) {\n+    return child; // we do not continue if there was an error\n+  }\n+  // If there is a /, we have to recurse and look up more of the path\n+  if (slash != std::string_view::npos) {\n+    child = child.at_pointer(json_pointer.substr(slash));\n+  }\n+  return child;\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -112,4 +152,9 @@ simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>\n   return std::forward<SIMDJSON_IMPLEMENTATION::ondemand::object>(first).find_field(key);\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/object.h b/include/simdjson/generic/ondemand/object.h\n--- a/include/simdjson/generic/ondemand/object.h\n+++ b/include/simdjson/generic/ondemand/object.h\n@@ -74,6 +74,34 @@ class object {\n   /** @overload simdjson_really_inline simdjson_result<value> find_field_unordered(std::string_view key) & noexcept; */\n   simdjson_really_inline simdjson_result<value> operator[](std::string_view key) && noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer. We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard, interpreting the current node\n+   * as the root of its own JSON document.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   static simdjson_really_inline simdjson_result<object> start(value_iterator &iter) noexcept;\n   static simdjson_really_inline simdjson_result<object> start_root(value_iterator &iter) noexcept;\n@@ -111,6 +139,7 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::object> : public SIMDJ\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> find_field_unordered(std::string_view key) && noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) & noexcept;\n   simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> operator[](std::string_view key) && noexcept;\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/value-inl.h b/include/simdjson/generic/ondemand/value-inl.h\n--- a/include/simdjson/generic/ondemand/value-inl.h\n+++ b/include/simdjson/generic/ondemand/value-inl.h\n@@ -135,6 +135,20 @@ simdjson_really_inline std::string_view value::raw_json_token() noexcept {\n   return std::string_view(reinterpret_cast<const char*>(iter.peek_start()), iter.peek_start_length());\n }\n \n+simdjson_really_inline simdjson_result<value> value::at_pointer(std::string_view json_pointer) noexcept {\n+  json_type t;\n+  SIMDJSON_TRY(type().get(t));\n+  switch (t)\n+  {\n+    case json_type::array:\n+      return (*this).get_array().at_pointer(json_pointer);\n+    case json_type::object:\n+      return (*this).get_object().at_pointer(json_pointer);\n+    default:\n+      return INVALID_JSON_POINTER;\n+  }\n+}\n+\n } // namespace ondemand\n } // namespace SIMDJSON_IMPLEMENTATION\n } // namespace simdjson\n@@ -296,4 +310,9 @@ simdjson_really_inline simdjson_result<std::string_view> simdjson_result<SIMDJSO\n   return first.raw_json_token();\n }\n \n+simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value>::at_pointer(std::string_view json_pointer) noexcept {\n+  if (error()) { return error(); }\n+  return first.at_pointer(json_pointer);\n+}\n+\n } // namespace simdjson\ndiff --git a/include/simdjson/generic/ondemand/value.h b/include/simdjson/generic/ondemand/value.h\n--- a/include/simdjson/generic/ondemand/value.h\n+++ b/include/simdjson/generic/ondemand/value.h\n@@ -314,6 +314,33 @@ class value {\n    */\n   simdjson_really_inline std::string_view raw_json_token() noexcept;\n \n+  /**\n+   * Get the value associated with the given JSON pointer.  We use the RFC 6901\n+   * https://tools.ietf.org/html/rfc6901 standard.\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"foo\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"/foo/a/1\") == 20\n+   *\n+   * It is allowed for a key to be the empty string:\n+   *\n+   *   ondemand::parser parser;\n+   *   auto json = R\"({ \"\": { \"a\": [ 10, 20, 30 ] }})\"_padded;\n+   *   auto doc = parser.iterate(json);\n+   *   doc.at_pointer(\"//a/1\") == 20\n+   *\n+   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n+   *\n+   * @return The value associated with the given JSON pointer, or:\n+   *         - NO_SUCH_FIELD if a field does not exist in an object\n+   *         - INDEX_OUT_OF_BOUNDS if an array index is larger than an array length\n+   *         - INCORRECT_TYPE if a non-integer is used to access an array\n+   *         - INVALID_JSON_POINTER if the JSON pointer is invalid and cannot be parsed\n+   */\n+  simdjson_really_inline simdjson_result<value> at_pointer(std::string_view json_pointer) noexcept;\n+\n protected:\n   /**\n    * Create a value.\n@@ -459,6 +486,8 @@ struct simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> : public SIMDJS\n \n   /** @copydoc simdjson_really_inline std::string_view value::raw_json_token() const noexcept */\n   simdjson_really_inline simdjson_result<std::string_view> raw_json_token() noexcept;\n+\n+  simdjson_really_inline simdjson_result<SIMDJSON_IMPLEMENTATION::ondemand::value> at_pointer(std::string_view json_pointer) noexcept;\n };\n \n } // namespace simdjson\n",
    "test_patch": "diff --git a/tests/ondemand/CMakeLists.txt b/tests/ondemand/CMakeLists.txt\n--- a/tests/ondemand/CMakeLists.txt\n+++ b/tests/ondemand/CMakeLists.txt\n@@ -2,14 +2,15 @@\n link_libraries(simdjson)\n include_directories(..)\n add_subdirectory(compilation_failure_tests)\n-add_cpp_test(ondemand_tostring_tests           LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_tostring_tests         LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_active_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_array_tests            LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_array_error_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_compilation_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_error_tests            LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_json_pointer_tests     LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_key_string_tests       LABELS ondemand acceptance per_implementation)\n-add_cpp_test(ondemand_misc_tests           LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_misc_tests             LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_number_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_error_tests     LABELS ondemand acceptance per_implementation)\ndiff --git a/tests/ondemand/ondemand_json_pointer_tests.cpp b/tests/ondemand/ondemand_json_pointer_tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ondemand/ondemand_json_pointer_tests.cpp\n@@ -0,0 +1,168 @@\n+#include \"simdjson.h\"\n+#include \"test_ondemand.h\"\n+#include <string>\n+\n+using namespace simdjson;\n+\n+namespace json_pointer_tests {\n+    const padded_string TEST_JSON = R\"(\n+    {\n+        \"/~01abc\": [\n+        0,\n+        {\n+            \"\\\\\\\" 0\": [\n+            \"value0\",\n+            \"value1\"\n+            ]\n+        }\n+        ],\n+        \"0\": \"0 ok\",\n+        \"01\": \"01 ok\",\n+        \"\": \"empty ok\",\n+        \"arr\": []\n+    }\n+    )\"_padded;\n+\n+    const padded_string TEST_RFC_JSON = R\"(\n+    {\n+        \"foo\": [\"bar\", \"baz\"],\n+        \"\": 0,\n+        \"a/b\": 1,\n+        \"c%d\": 2,\n+        \"e^f\": 3,\n+        \"g|h\": 4,\n+        \"i\\\\j\": 5,\n+        \"k\\\"l\": 6,\n+        \" \": 7,\n+        \"m~n\": 8\n+    }\n+    )\"_padded;\n+\n+    bool run_success_test(const padded_string & json,std::string_view json_pointer,std::string expected) {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ondemand::value val;\n+        std::string actual;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        ASSERT_SUCCESS(doc.at_pointer(json_pointer).get(val));\n+        ASSERT_SUCCESS(simdjson::to_string(val).get(actual));\n+        ASSERT_EQUAL(actual,expected);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool run_failure_test(const padded_string & json,std::string_view json_pointer,error_code expected) {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        ASSERT_EQUAL(doc.at_pointer(json_pointer).error(),expected);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool demo_test() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        double x;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        ASSERT_SUCCESS(cars.at_pointer(\"/0/tire_pressure/1\").get(x));\n+        ASSERT_EQUAL(x,39.9);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool demo_relative_path() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        std::vector<double> measured;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        for (auto car_element : cars) {\n+            double x;\n+            ASSERT_SUCCESS(car_element.at_pointer(\"/tire_pressure/1\").get(x));\n+            measured.push_back(x);\n+        }\n+\n+        std::vector<double> expected = {39.9, 31, 30};\n+        if (measured != expected) { return false; }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool many_json_pointers() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        std::vector<double> measured;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        for (int i = 0; i < 3; i++) {\n+            double x;\n+            std::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n+            ASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n+            measured.push_back(x);\n+            cars.rewind();\n+        }\n+\n+        std::vector<double> expected = {39.9, 31, 30};\n+        if (measured != expected) { return false; }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool run() {\n+        return\n+                demo_test() &&\n+                demo_relative_path() &&\n+                run_success_test(TEST_RFC_JSON,\"\",R\"({\"foo\":[\"bar\",\"baz\"],\"\":0,\"a/b\":1,\"c%d\":2,\"e^f\":3,\"g|h\":4,\"i\\\\j\":5,\"k\\\"l\":6,\" \":7,\"m~n\":8})\") &&\n+                run_success_test(TEST_RFC_JSON,\"/foo\",R\"([\"bar\",\"baz\"])\") &&\n+                run_success_test(TEST_RFC_JSON,\"/foo/0\",R\"(\"bar\")\") &&\n+                run_success_test(TEST_RFC_JSON,\"/\",R\"(0)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/a~1b\",R\"(1)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/c%d\",R\"(2)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/e^f\",R\"(3)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/g|h\",R\"(4)\") &&\n+                run_success_test(TEST_RFC_JSON,R\"(/i\\\\j)\",R\"(5)\") &&\n+                run_success_test(TEST_RFC_JSON,R\"(/k\\\"l)\",R\"(6)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/ \",R\"(7)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/m~0n\",R\"(8)\") &&\n+                run_success_test(TEST_JSON, \"\", R\"({\"/~01abc\":[0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}],\"0\":\"0 ok\",\"01\":\"01 ok\",\"\":\"empty ok\",\"arr\":[]})\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc)\", R\"([0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}])\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1)\", R\"({\"\\\\\\\" 0\":[\"value0\",\"value1\"]})\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0)\", R\"([\"value0\",\"value1\"])\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/0)\", \"\\\"value0\\\"\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/1)\", \"\\\"value1\\\"\") &&\n+                run_success_test(TEST_JSON, \"/arr\", R\"([])\") &&\n+                run_success_test(TEST_JSON, \"/0\", \"\\\"0 ok\\\"\") &&\n+                run_success_test(TEST_JSON, \"/01\", \"\\\"01 ok\\\"\") &&\n+                run_success_test(TEST_JSON, \"\", R\"({\"/~01abc\":[0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}],\"0\":\"0 ok\",\"01\":\"01 ok\",\"\":\"empty ok\",\"arr\":[]})\") &&\n+                run_failure_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/2)\", INDEX_OUT_OF_BOUNDS) &&\n+                run_failure_test(TEST_JSON, \"/arr/0\", INDEX_OUT_OF_BOUNDS) &&\n+                run_failure_test(TEST_JSON, \"~1~001abc\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~01abc\", NO_SUCH_FIELD) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/01\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/-\", INDEX_OUT_OF_BOUNDS) &&\n+                many_json_pointers() &&\n+                true;\n+    }\n+}   // json_pointer_tests\n+\n+int main(int argc, char *argv[]) {\n+  return test_main(argc, argv, json_pointer_tests::run);\n+}\n\\ No newline at end of file\n",
    "problem_statement": "Implement JSON Pointer on top of On Demand\n[Currently our JSON Pointer API assumes a DOM tree](https://github.com/simdjson/simdjson/blob/c5def8f7060a7e9519c7f38e2c4ddf2dc784d6a8/doc/basics.md#json-pointer), but it is obvious that we can do it with On Demand.\r\n\r\n\r\nIf the pointer points at an array or an object, you'd like to be able to do...\r\n\r\n```C++\r\n    auto doc = parser.iterate(json);\r\n    for (auto x : doc.at_pointer(insert json pointer expression)) {\r\n     \r\n    }\r\n```\r\n\r\nIt could have substantial performance gains.\r\n\r\n[The `at_pointer` functions in our DOM API have a rather clean implementation](https://github.com/simdjson/simdjson/blob/95b4870e20be5f97d9dcf63b23b1c6f520c366c1/include/simdjson/dom/object.h). It is then a matter of 'porting' them to the On Demand front-end. There will be some fun challenges.\n",
    "hints_text": "",
    "created_at": "2021-06-09T20:11:26Z",
    "version": "0.9",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container (Required)\nFROM ubuntu:20.04\n\n# Set environment variables for non-interactive apt operations and timezone\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime (Required)\n# Update package lists, upgrade existing packages, and install necessary packages:\n# - build-essential: Provides essential tools like make, gcc, and g++ for compiling C++ projects.\n# - git: Required for cloning the target repository.\n# - python3: Included as mentioned in the context for certain scripts, though not directly for test execution.\n# - wget, gnupg, software-properties-common: For adding APT repositories and managing keys, as suggested by the context.\n# - cmake: The build system used by simdjson. Ubuntu 20.04 provides CMake 3.16.3, which satisfies simdjson's minimum requirement of 3.15.\n# - g++-8: The specific C++ compiler version explicitly requested and noted to be used in Travis CI.\nRUN apt update && apt upgrade -y && \\\n    apt install -y \\\n    build-essential \\\n    git \\\n    python3 \\\n    wget \\\n    gnupg \\\n    software-properties-common \\\n    cmake \\\n    g++-8 && \\\n    rm -rf /var/lib/apt/lists/*\n\n# Configure g++-8 as the default G++ and GCC compiler using update-alternatives.\n# This step ensures that CMake and other build tools automatically pick version 8 of\n# the compiler, matching the project's dependency requirements.\n# A priority of 800 is used to make it the preferred default choice.\nRUN update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 800 --slave /usr/bin/gcov gcov /usr/bin/gcov-8 && \\\n    update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/gcov-tool gcov-tool /usr/bin/gcov-tool-8\n\n# Set the working directory inside the container\nWORKDIR /testbed/\n\n# Target Project setup. Clones the source code, checks out the specified commit SHA.\n# The repository is cloned into /testbed/.\nRUN git clone https://github.com/simdjson/simdjson.git /testbed/ && \\\n    cd /testbed/ && \\\n    git checkout 40cba172ed66584cf670c98202ed474a316667e3 && \\\n    git remote remove origin\n\n# Configure and build the project.\n# Create a build directory, navigate into it, and perform CMake configuration\n# with SIMDJSON_DEVELOPER_MODE=ON to ensure tests and examples are included.\n# Then, build the entire project. This prepares the environment for running tests.\n# The '-j4' flag is used to limit parallel compilation jobs to 4, preventing\n# potential out-of-memory errors experienced with '-j$(nproc)'.\nRUN cd /testbed/ && \\\n    mkdir build && \\\n    cd build && \\\n    cmake .. -DSIMDJSON_DEVELOPER_MODE=ON && \\\n    cmake --build . -j4\n\n# Apply global read/write permissions for the testbed directory (including build artifacts)\n# This ensures that any subsequent operations by the eval script have full access.\nRUN chmod -R 777 /testbed",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned\ncd /testbed\n\n# Checkout the specific target test file to its original state before applying any patch.\n# This ensures a clean base for the patch application.\ngit checkout 40cba172ed66584cf670c98202ed474a316667e3 \"tests/ondemand/CMakeLists.txt\"\n\n# Apply the test patch to modify/add tests.\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/tests/ondemand/CMakeLists.txt b/tests/ondemand/CMakeLists.txt\n--- a/tests/ondemand/CMakeLists.txt\n+++ b/tests/ondemand/CMakeLists.txt\n@@ -2,14 +2,15 @@\n link_libraries(simdjson)\n include_directories(..)\n add_subdirectory(compilation_failure_tests)\n-add_cpp_test(ondemand_tostring_tests           LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_tostring_tests         LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_active_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_array_tests            LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_array_error_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_compilation_tests      LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_error_tests            LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_json_pointer_tests     LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_key_string_tests       LABELS ondemand acceptance per_implementation)\n-add_cpp_test(ondemand_misc_tests           LABELS ondemand acceptance per_implementation)\n+add_cpp_test(ondemand_misc_tests             LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_number_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_tests           LABELS ondemand acceptance per_implementation)\n add_cpp_test(ondemand_object_error_tests     LABELS ondemand acceptance per_implementation)\ndiff --git a/tests/ondemand/ondemand_json_pointer_tests.cpp b/tests/ondemand/ondemand_json_pointer_tests.cpp\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ondemand/ondemand_json_pointer_tests.cpp\n@@ -0,0 +1,168 @@\n+#include \"simdjson.h\"\n+#include \"test_ondemand.h\"\n+#include <string>\n+\n+using namespace simdjson;\n+\n+namespace json_pointer_tests {\n+    const padded_string TEST_JSON = R\"(\n+    {\n+        \"/~01abc\": [\n+        0,\n+        {\n+            \"\\\\\\\" 0\": [\n+            \"value0\",\n+            \"value1\"\n+            ]\n+        }\n+        ],\n+        \"0\": \"0 ok\",\n+        \"01\": \"01 ok\",\n+        \"\": \"empty ok\",\n+        \"arr\": []\n+    }\n+    )\"_padded;\n+\n+    const padded_string TEST_RFC_JSON = R\"(\n+    {\n+        \"foo\": [\"bar\", \"baz\"],\n+        \"\": 0,\n+        \"a/b\": 1,\n+        \"c%d\": 2,\n+        \"e^f\": 3,\n+        \"g|h\": 4,\n+        \"i\\\\j\": 5,\n+        \"k\\\"l\": 6,\n+        \" \": 7,\n+        \"m~n\": 8\n+    }\n+    )\"_padded;\n+\n+    bool run_success_test(const padded_string & json,std::string_view json_pointer,std::string expected) {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ondemand::value val;\n+        std::string actual;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        ASSERT_SUCCESS(doc.at_pointer(json_pointer).get(val));\n+        ASSERT_SUCCESS(simdjson::to_string(val).get(actual));\n+        ASSERT_EQUAL(actual,expected);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool run_failure_test(const padded_string & json,std::string_view json_pointer,error_code expected) {\n+        TEST_START();\n+        ondemand::parser parser;\n+        ondemand::document doc;\n+        ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+        ASSERT_EQUAL(doc.at_pointer(json_pointer).error(),expected);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool demo_test() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        double x;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        ASSERT_SUCCESS(cars.at_pointer(\"/0/tire_pressure/1\").get(x));\n+        ASSERT_EQUAL(x,39.9);\n+        TEST_SUCCEED();\n+    }\n+\n+    bool demo_relative_path() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        std::vector<double> measured;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        for (auto car_element : cars) {\n+            double x;\n+            ASSERT_SUCCESS(car_element.at_pointer(\"/tire_pressure/1\").get(x));\n+            measured.push_back(x);\n+        }\n+\n+        std::vector<double> expected = {39.9, 31, 30};\n+        if (measured != expected) { return false; }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool many_json_pointers() {\n+        TEST_START();\n+        auto cars_json = R\"( [\n+        { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+        { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+        { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+        ] )\"_padded;\n+\n+        ondemand::parser parser;\n+        ondemand::document cars;\n+        std::vector<double> measured;\n+        ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+        for (int i = 0; i < 3; i++) {\n+            double x;\n+            std::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n+            ASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n+            measured.push_back(x);\n+            cars.rewind();\n+        }\n+\n+        std::vector<double> expected = {39.9, 31, 30};\n+        if (measured != expected) { return false; }\n+        TEST_SUCCEED();\n+    }\n+\n+    bool run() {\n+        return\n+                demo_test() &&\n+                demo_relative_path() &&\n+                run_success_test(TEST_RFC_JSON,\"\",R\"({\"foo\":[\"bar\",\"baz\"],\"\":0,\"a/b\":1,\"c%d\":2,\"e^f\":3,\"g|h\":4,\"i\\\\j\":5,\"k\\\"l\":6,\" \":7,\"m~n\":8})\") &&\n+                run_success_test(TEST_RFC_JSON,\"/foo\",R\"([\"bar\",\"baz\"])\") &&\n+                run_success_test(TEST_RFC_JSON,\"/foo/0\",R\"(\"bar\")\") &&\n+                run_success_test(TEST_RFC_JSON,\"/\",R\"(0)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/a~1b\",R\"(1)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/c%d\",R\"(2)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/e^f\",R\"(3)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/g|h\",R\"(4)\") &&\n+                run_success_test(TEST_RFC_JSON,R\"(/i\\\\j)\",R\"(5)\") &&\n+                run_success_test(TEST_RFC_JSON,R\"(/k\\\"l)\",R\"(6)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/ \",R\"(7)\") &&\n+                run_success_test(TEST_RFC_JSON,\"/m~0n\",R\"(8)\") &&\n+                run_success_test(TEST_JSON, \"\", R\"({\"/~01abc\":[0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}],\"0\":\"0 ok\",\"01\":\"01 ok\",\"\":\"empty ok\",\"arr\":[]})\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc)\", R\"([0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}])\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1)\", R\"({\"\\\\\\\" 0\":[\"value0\",\"value1\"]})\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0)\", R\"([\"value0\",\"value1\"])\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/0)\", \"\\\"value0\\\"\") &&\n+                run_success_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/1)\", \"\\\"value1\\\"\") &&\n+                run_success_test(TEST_JSON, \"/arr\", R\"([])\") &&\n+                run_success_test(TEST_JSON, \"/0\", \"\\\"0 ok\\\"\") &&\n+                run_success_test(TEST_JSON, \"/01\", \"\\\"01 ok\\\"\") &&\n+                run_success_test(TEST_JSON, \"\", R\"({\"/~01abc\":[0,{\"\\\\\\\" 0\":[\"value0\",\"value1\"]}],\"0\":\"0 ok\",\"01\":\"01 ok\",\"\":\"empty ok\",\"arr\":[]})\") &&\n+                run_failure_test(TEST_JSON, R\"(/~1~001abc/1/\\\\\\\" 0/2)\", INDEX_OUT_OF_BOUNDS) &&\n+                run_failure_test(TEST_JSON, \"/arr/0\", INDEX_OUT_OF_BOUNDS) &&\n+                run_failure_test(TEST_JSON, \"~1~001abc\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~01abc\", NO_SUCH_FIELD) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/01\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/\", INVALID_JSON_POINTER) &&\n+                run_failure_test(TEST_JSON, \"/~1~001abc/-\", INDEX_OUT_OF_BOUNDS) &&\n+                many_json_pointers() &&\n+                true;\n+    }\n+}   // json_pointer_tests\n+\n+int main(int argc, char *argv[]) {\n+  return test_main(argc, argv, json_pointer_tests::run);\n+}\n\\ No newline at end of file\nEOF_114329324912\n\n# Navigate to the build directory.\n# The Dockerfile has already run `cmake ..` and `cmake --build .` from /testbed,\n# so the `build` directory should already exist and contain the compiled project.\ncd build\n\n# Set the SIMDJSON_DEVELOPER_MODE environment variable.\n# This is crucial for CMake to configure and build tests, examples, and benchmarks.\n# While CMake might have already configured with this, ensuring it's set before\n# a rebuild is a good practice.\nexport SIMDJSON_DEVELOPER_MODE=ON\n\n# Rebuild the project after applying the patch.\n# This step is critical to ensure that any new or modified tests from the patch\n# are compiled and included in the test executable.\n# Changed from -j$(nproc) to -j4 to prevent Out-Of-Memory errors during compilation.\ncmake --build . -j4\n\n# Check the exit code of the build command. If the build fails, exit early.\nif [ $? -ne 0 ]; then\n    echo \"Build failed after patch application. Exiting.\"\n    rc=1\n    echo \"OMNIGRIL_EXIT_CODE=$rc\"\n    exit $rc\nfi\n\n# Execute only the specified target tests.\n# The target file is tests/ondemand/CMakeLists.txt.\n# CTest does not directly run a CMakeLists.txt file. Instead, it runs tests\n# discovered by CMake within the build directory.\n# To adhere to the \"execute only the specified target test files\" requirement,\n# we use --tests-regex with a pattern that attempts to match tests\n# originating from or logically belonging to the 'ondemand' module.\n# The regex \".*ondemand.*\" is a best effort to capture such tests, assuming\n# their full CTest name includes 'ondemand' or a related identifier.\nctest --output-on-failure --tests-regex \".*ondemand.*\"\nrc=$?\n\n# Capture the exit code immediately after running the tests.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the testbed root directory for cleanup.\ncd /testbed\n\n# Clean up: Undo any changes made to the target test file.\n# This ensures that the repository remains in its original state after the test run.\ngit checkout 40cba172ed66584cf670c98202ed474a316667e3 \"tests/ondemand/CMakeLists.txt\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned\ncd /testbed\n\n# Checkout the specific target test file to its original state before applying any patch.\n# This ensures a clean base for the patch application.\ngit checkout 40cba172ed66584cf670c98202ed474a316667e3 \"tests/ondemand/CMakeLists.txt\"\n\n# Apply the test patch to modify/add tests.\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate to the build directory.\n# The Dockerfile has already run `cmake ..` and `cmake --build .` from /testbed,\n# so the `build` directory should already exist and contain the compiled project.\ncd build\n\n# Set the SIMDJSON_DEVELOPER_MODE environment variable.\n# This is crucial for CMake to configure and build tests, examples, and benchmarks.\n# While CMake might have already configured with this, ensuring it's set before\n# a rebuild is a good practice.\nexport SIMDJSON_DEVELOPER_MODE=ON\n\n# Rebuild the project after applying the patch.\n# This step is critical to ensure that any new or modified tests from the patch\n# are compiled and included in the test executable.\n# Changed from -j$(nproc) to -j4 to prevent Out-Of-Memory errors during compilation.\ncmake --build . -j4\n\n# Check the exit code of the build command. If the build fails, exit early.\nif [ $? -ne 0 ]; then\n    echo \"Build failed after patch application. Exiting.\"\n    rc=1\n    echo \"OMNIGRIL_EXIT_CODE=$rc\"\n    exit $rc\nfi\n\n# Execute only the specified target tests.\n# The target file is tests/ondemand/CMakeLists.txt.\n# CTest does not directly run a CMakeLists.txt file. Instead, it runs tests\n# discovered by CMake within the build directory.\n# To adhere to the \"execute only the specified target test files\" requirement,\n# we use --tests-regex with a pattern that attempts to match tests\n# originating from or logically belonging to the 'ondemand' module.\n# The regex \".*ondemand.*\" is a best effort to capture such tests, assuming\n# their full CTest name includes 'ondemand' or a related identifier.\nctest --output-on-failure --tests-regex \".*ondemand.*\"\nrc=$?\n\n# Capture the exit code immediately after running the tests.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the testbed root directory for cleanup.\ncd /testbed\n\n# Clean up: Undo any changes made to the target test file.\n# This ensures that the repository remains in its original state after the test run.\ngit checkout 40cba172ed66584cf670c98202ed474a316667e3 \"tests/ondemand/CMakeLists.txt\""
  },
  {
    "repo": "simdjson/simdjson",
    "pull_number": 1618,
    "instance_id": "simdjson__simdjson-1618",
    "issue_numbers": [
      "1616"
    ],
    "base_commit": "1c01fc35ebce2d50ea6c279002ca949784d71ad4",
    "patch": "diff --git a/include/simdjson/generic/ondemand/document.h b/include/simdjson/generic/ondemand/document.h\n--- a/include/simdjson/generic/ondemand/document.h\n+++ b/include/simdjson/generic/ondemand/document.h\n@@ -341,6 +341,7 @@ class document {\n    * are invalidated. After calling at_pointer, you need to consume the result: string values\n    * should be stored in your own variables, arrays should be decoded and stored in your own array-like\n    * structures and so forth.\n+   *\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n    *\n    * @return The value associated with the given JSON pointer, or:\n",
    "test_patch": "diff --git a/tests/ondemand/ondemand_readme_examples.cpp b/tests/ondemand/ondemand_readme_examples.cpp\n--- a/tests/ondemand/ondemand_readme_examples.cpp\n+++ b/tests/ondemand/ondemand_readme_examples.cpp\n@@ -292,6 +292,63 @@ bool using_the_parsed_json_6() {\n   TEST_SUCCEED();\n }\n \n+const padded_string cars_json = R\"( [\n+  { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+  { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+  { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+] )\"_padded;\n+\n+bool json_pointer_simple() {\n+    TEST_START();\n+    ondemand::parser parser;\n+    ondemand::document cars;\n+    double x;\n+    ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+    ASSERT_SUCCESS(cars.at_pointer(\"/0/tire_pressure/1\").get(x));\n+    ASSERT_EQUAL(x,39.9);\n+    TEST_SUCCEED();\n+}\n+\n+bool json_pointer_multiple() {\n+\tTEST_START();\n+\tondemand::parser parser;\n+\tondemand::document cars;\n+\tsize_t size;\n+\tASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+\tASSERT_SUCCESS(cars.count_elements().get(size));\n+\tdouble expected[] = {39.9, 31, 30};\n+\tfor (size_t i = 0; i < size; i++) {\n+\t\tstd::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n+\t\tdouble x;\n+\t\tASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n+\t\tASSERT_EQUAL(x,expected[i]);\n+\t}\n+\tTEST_SUCCEED();\n+}\n+\n+bool json_pointer_rewind() {\n+  TEST_START();\n+  auto json = R\"( {\n+  \"k0\": 27,\n+  \"k1\": [13,26],\n+  \"k2\": true\n+  } )\"_padded;\n+\n+  ondemand::parser parser;\n+  ondemand::document doc;\n+  uint64_t i;\n+  bool b;\n+  ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+  ASSERT_SUCCESS(doc.at_pointer(\"/k1/1\").get(i));\n+  ASSERT_EQUAL(i,26);\n+  ASSERT_SUCCESS(doc.at_pointer(\"/k2\").get(b));\n+  ASSERT_EQUAL(b,true);\n+  doc.rewind();\t// Need to manually rewind to be able to use find_field properly from start of document\n+  ASSERT_SUCCESS(doc.find_field(\"k0\").get(i));\n+  ASSERT_EQUAL(i,27);\n+  TEST_SUCCEED();\n+}\n+\n int main() {\n   if (\n     true\n@@ -312,6 +369,9 @@ int main() {\n     && using_the_parsed_json_5()\n #endif\n     && using_the_parsed_json_6()\n+    && json_pointer_simple()\n+    && json_pointer_multiple()\n+    && json_pointer_rewind()\n   ) {\n     return 0;\n   } else {\n",
    "problem_statement": "Document new On Demand JSON Pointer\nWe have a JSON Pointer API on top of OnDemand.  See https://github.com/simdjson/simdjson/pull/1615\r\n\r\nWe now need to updated our documentation. Currently, it relies on the DOM backend:\r\n\r\nhttps://github.com/simdjson/simdjson/blob/master/doc/basics.md#json-pointer\r\n\r\nThis should get updated with tested examples that are relying on your new work. This new documentation should state that our json pointer implementation relies on `find_field`. Importantly, we need to document how one can issue multiple JSON Pointer queries on the same document.\n",
    "hints_text": "cc @NicolasJiaxin ",
    "created_at": "2021-06-11T20:02:56Z",
    "version": "0.9",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container (Required)\nFROM ubuntu:20.04\n\n# Set environment variables for non-interactive apt operations and timezone\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime (Required)\n# Update package lists, upgrade existing packages, and install necessary packages:\n# - build-essential: Provides essential tools like make, gcc, and g++ for compiling C++ projects.\n# - git: Required for cloning the target repository.\n# - wget: Common utility for downloading files.\n# - cmake: The build system used by simdjson. Ubuntu 20.04 provides CMake 3.16.3, which satisfies simdjson's minimum requirement of 3.14.\n# - g++-8: The specific C++ compiler version, satisfies the requirement of g++ version 7 or better.\nRUN apt update && apt upgrade -y && \\\n    apt install -y \\\n    build-essential \\\n    git \\\n    wget \\\n    cmake \\\n    g++-8 && \\\n    rm -rf /var/lib/apt/lists/*\n\n# Configure g++-8 as the default G++ and GCC compiler using update-alternatives.\n# This step ensures that CMake and other build tools automatically pick version 8 of\n# the compiler, matching the project's dependency requirements.\n# A priority of 800 is used to make it the preferred default choice.\nRUN update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 800 --slave /usr/bin/gcov gcov /usr/bin/gcov-8 && \\\n    update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/gcov-tool gcov-tool /usr/bin/gcov-tool-8\n\n# Set the working directory inside the container\nWORKDIR /testbed/\n\n# Target Project setup. Clones the source code, checks out the specified commit SHA.\n# The repository is cloned into /testbed/.\nRUN git clone https://github.com/simdjson/simdjson.git /testbed/ && \\\n    cd /testbed/ && \\\n    git checkout 1c01fc35ebce2d50ea6c279002ca949784d71ad4 && \\\n    git remote remove origin\n\n# Configure and build the project.\n# Create a build directory, navigate into it, and perform CMake configuration\n# with SIMDJSON_DEVELOPER_MODE=ON to ensure tests and examples are included.\n# Then, build the entire project. This prepares the environment for running tests.\n# The '-j4' flag is used to limit parallel compilation jobs to 4, preventing\n# potential out-of-memory errors.\nRUN cd /testbed/ && \\\n    mkdir build && \\\n    cd build && \\\n    cmake .. -DSIMDJSON_DEVELOPER_MODE=ON && \\\n    cmake --build . -j4\n\n# Apply global read/write permissions for the testbed directory (including build artifacts)\n# This ensures that any subsequent operations by the eval script have full access.\nRUN chmod -R 777 /testbed",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned\ncd /testbed\n\n# Checkout the specific target test file to its original state before applying any patch.\n# This ensures a clean base for the patch application.\n# The commit SHA and file path are directly from the provided info and skeleton.\ngit checkout 1c01fc35ebce2d50ea6c279002ca949784d71ad4 \"tests/ondemand/ondemand_readme_examples.cpp\"\n\n# Apply the test patch to modify/add tests.\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/tests/ondemand/ondemand_readme_examples.cpp b/tests/ondemand/ondemand_readme_examples.cpp\n--- a/tests/ondemand/ondemand_readme_examples.cpp\n+++ b/tests/ondemand/ondemand_readme_examples.cpp\n@@ -292,6 +292,63 @@ bool using_the_parsed_json_6() {\n   TEST_SUCCEED();\n }\n \n+const padded_string cars_json = R\"( [\n+  { \"make\": \"Toyota\", \"model\": \"Camry\",  \"year\": 2018, \"tire_pressure\": [ 40.1, 39.9, 37.7, 40.4 ] },\n+  { \"make\": \"Kia\",    \"model\": \"Soul\",   \"year\": 2012, \"tire_pressure\": [ 30.1, 31.0, 28.6, 28.7 ] },\n+  { \"make\": \"Toyota\", \"model\": \"Tercel\", \"year\": 1999, \"tire_pressure\": [ 29.8, 30.0, 30.2, 30.5 ] }\n+] )\"_padded;\n+\n+bool json_pointer_simple() {\n+    TEST_START();\n+    ondemand::parser parser;\n+    ondemand::document cars;\n+    double x;\n+    ASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+    ASSERT_SUCCESS(cars.at_pointer(\"/0/tire_pressure/1\").get(x));\n+    ASSERT_EQUAL(x,39.9);\n+    TEST_SUCCEED();\n+}\n+\n+bool json_pointer_multiple() {\n+\tTEST_START();\n+\tondemand::parser parser;\n+\tondemand::document cars;\n+\tsize_t size;\n+\tASSERT_SUCCESS(parser.iterate(cars_json).get(cars));\n+\tASSERT_SUCCESS(cars.count_elements().get(size));\n+\tdouble expected[] = {39.9, 31, 30};\n+\tfor (size_t i = 0; i < size; i++) {\n+\t\tstd::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n+\t\tdouble x;\n+\t\tASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n+\t\tASSERT_EQUAL(x,expected[i]);\n+\t}\n+\tTEST_SUCCEED();\n+}\n+\n+bool json_pointer_rewind() {\n+  TEST_START();\n+  auto json = R\"( {\n+  \"k0\": 27,\n+  \"k1\": [13,26],\n+  \"k2\": true\n+  } )\"_padded;\n+\n+  ondemand::parser parser;\n+  ondemand::document doc;\n+  uint64_t i;\n+  bool b;\n+  ASSERT_SUCCESS(parser.iterate(json).get(doc));\n+  ASSERT_SUCCESS(doc.at_pointer(\"/k1/1\").get(i));\n+  ASSERT_EQUAL(i,26);\n+  ASSERT_SUCCESS(doc.at_pointer(\"/k2\").get(b));\n+  ASSERT_EQUAL(b,true);\n+  doc.rewind();\t// Need to manually rewind to be able to use find_field properly from start of document\n+  ASSERT_SUCCESS(doc.find_field(\"k0\").get(i));\n+  ASSERT_EQUAL(i,27);\n+  TEST_SUCCEED();\n+}\n+\n int main() {\n   if (\n     true\n@@ -312,6 +369,9 @@ int main() {\n     && using_the_parsed_json_5()\n #endif\n     && using_the_parsed_json_6()\n+    && json_pointer_simple()\n+    && json_pointer_multiple()\n+    && json_pointer_rewind()\n   ) {\n     return 0;\n   } else {\nEOF_114329324912\n\n# Navigate to the build directory.\n# The Dockerfile has already run `cmake ..` and `cmake --build .` from /testbed,\n# so the `build` directory should already exist and contain the compiled project.\ncd build\n\n# Set the SIMDJSON_DEVELOPER_MODE environment variable.\n# While CMake might have already configured with this, ensuring it's set before\n# a rebuild is a good practice, especially if the patch modified CMake files.\nexport SIMDJSON_DEVELOPER_MODE=ON\n\n# Rebuild the project after applying the patch.\n# This step is critical to ensure that any new or modified tests from the patch\n# are compiled and included in the test executable.\n# Changed from -j$(nproc) to -j4 to prevent potential Out-Of-Memory errors during compilation,\n# matching the Dockerfile's build command.\ncmake --build . -j4\n\n# Check the exit code of the build command. If the build fails, exit early.\nif [ $? -ne 0 ]; then\n    echo \"Build failed after patch application. Exiting.\"\n    rc=1\n    echo \"OMNIGRIL_EXIT_CODE=$rc\"\n    exit $rc\nfi\n\n# Execute only the specified target tests.\n# The target file is tests/ondemand/ondemand_readme_examples.cpp.\n# CTest runs tests discovered by CMake within the build directory.\n# We use -R \"ondemand_readme_examples\" to specifically target tests generated from this file,\n# as per the collected context information.\nctest --output-on-failure -R \"ondemand_readme_examples\"\nrc=$?\n\n# Capture the exit code immediately after running the tests.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the testbed root directory for cleanup.\ncd /testbed\n\n# Clean up: Undo any changes made to the target test file.\n# This ensures that the repository remains in its original state after the test run.\ngit checkout 1c01fc35ebce2d50ea6c279002ca949784d71ad4 \"tests/ondemand/ondemand_readme_examples.cpp\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned\ncd /testbed\n\n# Checkout the specific target test file to its original state before applying any patch.\n# This ensures a clean base for the patch application.\n# The commit SHA and file path are directly from the provided info and skeleton.\ngit checkout 1c01fc35ebce2d50ea6c279002ca949784d71ad4 \"tests/ondemand/ondemand_readme_examples.cpp\"\n\n# Apply the test patch to modify/add tests.\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate to the build directory.\n# The Dockerfile has already run `cmake ..` and `cmake --build .` from /testbed,\n# so the `build` directory should already exist and contain the compiled project.\ncd build\n\n# Set the SIMDJSON_DEVELOPER_MODE environment variable.\n# While CMake might have already configured with this, ensuring it's set before\n# a rebuild is a good practice, especially if the patch modified CMake files.\nexport SIMDJSON_DEVELOPER_MODE=ON\n\n# Rebuild the project after applying the patch.\n# This step is critical to ensure that any new or modified tests from the patch\n# are compiled and included in the test executable.\n# Changed from -j$(nproc) to -j4 to prevent potential Out-Of-Memory errors during compilation,\n# matching the Dockerfile's build command.\ncmake --build . -j4\n\n# Check the exit code of the build command. If the build fails, exit early.\nif [ $? -ne 0 ]; then\n    echo \"Build failed after patch application. Exiting.\"\n    rc=1\n    echo \"OMNIGRIL_EXIT_CODE=$rc\"\n    exit $rc\nfi\n\n# Execute only the specified target tests.\n# The target file is tests/ondemand/ondemand_readme_examples.cpp.\n# CTest runs tests discovered by CMake within the build directory.\n# We use -R \"ondemand_readme_examples\" to specifically target tests generated from this file,\n# as per the collected context information.\nctest --output-on-failure -R \"ondemand_readme_examples\"\nrc=$?\n\n# Capture the exit code immediately after running the tests.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the testbed root directory for cleanup.\ncd /testbed\n\n# Clean up: Undo any changes made to the target test file.\n# This ensures that the repository remains in its original state after the test run.\ngit checkout 1c01fc35ebce2d50ea6c279002ca949784d71ad4 \"tests/ondemand/ondemand_readme_examples.cpp\""
  },
  {
    "repo": "simdjson/simdjson",
    "pull_number": 1624,
    "instance_id": "simdjson__simdjson-1624",
    "issue_numbers": [
      "1622"
    ],
    "base_commit": "6cd04aa858f2d92105c0fbd65cdafb96428db002",
    "patch": "diff --git a/include/simdjson/generic/ondemand/array.h b/include/simdjson/generic/ondemand/array.h\n--- a/include/simdjson/generic/ondemand/array.h\n+++ b/include/simdjson/generic/ondemand/array.h\n@@ -54,7 +54,7 @@ class array {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"/0/foo/a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n    * @return The value associated with the given JSON pointer, or:\n    *         - NO_SUCH_FIELD if a field does not exist in an object\ndiff --git a/include/simdjson/generic/ondemand/document-inl.h b/include/simdjson/generic/ondemand/document-inl.h\n--- a/include/simdjson/generic/ondemand/document-inl.h\n+++ b/include/simdjson/generic/ondemand/document-inl.h\n@@ -135,6 +135,7 @@ simdjson_really_inline simdjson_result<std::string_view> document::raw_json_toke\n }\n \n simdjson_really_inline simdjson_result<value> document::at_pointer(std::string_view json_pointer) noexcept {\n+  rewind(); // Rewind the document each time at_pointer is called\n   if (json_pointer.empty()) {\n     return this->resume_value();\n   }\ndiff --git a/include/simdjson/generic/ondemand/document.h b/include/simdjson/generic/ondemand/document.h\n--- a/include/simdjson/generic/ondemand/document.h\n+++ b/include/simdjson/generic/ondemand/document.h\n@@ -335,7 +335,7 @@ class document {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"//a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n    *\n    * @return The value associated with the given JSON pointer, or:\ndiff --git a/include/simdjson/generic/ondemand/object.h b/include/simdjson/generic/ondemand/object.h\n--- a/include/simdjson/generic/ondemand/object.h\n+++ b/include/simdjson/generic/ondemand/object.h\n@@ -91,7 +91,7 @@ class object {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"//a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching.\n    *\n    * @return The value associated with the given JSON pointer, or:\ndiff --git a/include/simdjson/generic/ondemand/value.h b/include/simdjson/generic/ondemand/value.h\n--- a/include/simdjson/generic/ondemand/value.h\n+++ b/include/simdjson/generic/ondemand/value.h\n@@ -330,7 +330,7 @@ class value {\n    *   auto doc = parser.iterate(json);\n    *   doc.at_pointer(\"//a/1\") == 20\n    *\n-   * Note that at_pointer() does not automatically rewind between each call (call rewind() to reset).\n+   * Note that at_pointer() automatically calls rewind between each call.\n    * Also note that at_pointer() relies on find_field() which implies that we do not unescape keys when matching\n    *\n    * @return The value associated with the given JSON pointer, or:\n",
    "test_patch": "diff --git a/tests/ondemand/ondemand_json_pointer_tests.cpp b/tests/ondemand/ondemand_json_pointer_tests.cpp\n--- a/tests/ondemand/ondemand_json_pointer_tests.cpp\n+++ b/tests/ondemand/ondemand_json_pointer_tests.cpp\n@@ -117,7 +117,6 @@ namespace json_pointer_tests {\n             std::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n             ASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n             measured.push_back(x);\n-            cars.rewind();\n         }\n \n         std::vector<double> expected = {39.9, 31, 30};\n",
    "problem_statement": "at_pointer in On Demand should automatically rewind\nCurrently, users of the On Demand API who use at_pointer (JSON Pointer) have to manually rewind.\r\n\r\nWhy don't we make that automatic?\n",
    "hints_text": "Ping @erichutchins\nI can't see a reason why not. There may be performance optimizations in the future where we don't rewind immediately (like we do in find_field_unordered), but that wouldn't change the API.\nWhen @NicolasJiaxin comes back, we will discuss it and hopefully resolve this issue.\r\n\r\nI would rather not have to document the need to rewind, and the fact that @erichutchins found it error prone has been worried enough.\nI agree that automatic rewinding would be a good idea. It would give even more of that DOM feeling with the faster approach that is On Demand. And also, it is not like the first time that this *rewinding* idea is used in On Demand (like when calling `end()` with arrays). \nIf @lemire and @jkeiser  don't see any immediate issues with this, I will start implementing the automatic rewinding for On Demand, and then after, I will update the documentation (relating to #1618 and #1623).\n@NicolasJiaxin Please do.\nOne gotcha I just encountered is that rewinding before you access some values in the document can cause an error. Should at_pointer rewind at the *beginning* of its execution rather than at the end?\r\n\r\n```cpp\r\nauto jsonstr = R\"( {\"hello\": [0,1,2,3], \"test\": \"foo\", \"bool\": true, \"num\":1234, \"success\":\"yes\"} )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\n\r\nfor (auto jp: {\"/num\", \"/hello\"}) {\r\n    val = doc.at_pointer(jp);\r\n    // rewind *before* accessing value\r\n    doc.rewind();\r\n    std::cout << \"at_pointer \" << jp << \": \" << val << std::endl;\r\n}\r\n```\r\n\r\nTrying to access the `val` on the second iteration crashes.\r\n```\r\nat_pointer /num: 1234\r\nterminate called after throwing an instance of 'simdjson::simdjson_error'\r\n  what():  Objects and arrays can only be iterated when they are first encountered.\r\nAborted (core dumped)\r\n```\r\n\r\nFor scalar values, rewinding first doesn\u2019t cause a problem.\r\n```cpp\r\nfor (auto jp: {\"/num\", \"/test\", \"/hello/2\"}) {\r\n    val = doc.at_pointer(jp);\r\n    doc.rewind();\r\n    std::cout << \"at_pointer \" << jp << \": \" << val << std::endl;\r\n}\r\n```\r\n\r\n```\r\nat_pointer /num: 1234\r\nat_pointer /test: \"foo\"\r\nat_pointer /hello/2: 2\r\n```\r\n\n@erichutchins Yes indeed. Right now, you should *access*/*read* the value you parsed before rewinding the document. And as you pointed out, this causes trouble for non-scalar values (i.e. arrays and objects). I am currently trying to find a way around this issue because in order to automatically rewind, we would have to rewind before accessing the value each time `at_pointer` is called.\nMaybe @lemire could explain what really happens with this issue here.\nThe issue is that we have exactly one cursor into the document which can be used to iterate arrays and objects; resetting means you can't iterate that array anymore. The reason we do this is we need some kind of *shared* cursor so that when you finish iterating a child array or object, the parent array or object can \"pick up where it left off.\"\ni.e. often if you iterate through a child object or array you actually consume most or all of it and therefore you want the parent to not have to repeat that work.\n@jkeiser I see, thanks! But then, if I want to save the child object/array before resetting, I would need to copy it separately? Would that be a valid approach for this issue?\nThe `rewind` calls invalidates everything expect for the numbers, the nuls, the bools.\r\n\r\n@NicolasJiaxin I do not think it makes sense to save the array or object. You are supposed to consume it before the next query. Once rewind is called, you previous values are invalid. You had to extract the information you needed. This is not DOM... it is up to the user to materialize the result.\n@erichutchins  \r\n\r\nThe `rewind` calls invalidates the values. If you do `\"/num\"`, then you get back an integer, which you can copy. If you get an array, you have to copy it. You get a `string_view`, you have to copy it. The On Demand front-end won't do it for you.\r\n\r\nIt is really like an input stream... Think about reading data from a file. You don't want to carry around a pointer to a location inside a file. You want to take the data and make a copy of it.\nI am a little bit stuck @lemire. The issue that I am having is that we want both to return a value through `at_pointer` and also automatically `rewind` when `at_pointer` is called. But then, if we rewind when `at_pointer` is called, it would invalidate the value returned by that same call (if that value is an object or an array. Any hints or things that I am missing?\nThe documentation should be very clear on this. We need to make sure people understand that there is no string, there is no array there... If you want hold on the array or the string, you have to construct an instance, as the user. \r\n\r\nThe following, for example, would not work...\r\n\r\n```C++\r\nauto jsonstr = R\"( {\"hello\": \"foo1\", \"test\": \"foo\"} )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\n\r\nstd::string_view val1 = doc.at_pointer(\"test\");\r\ndoc.rewind();\r\nstd::string_view val2 = doc.at_pointer(\"hellow\");\r\n}\r\n```\r\n\r\nYou would need to do something like this...\r\n\r\n\r\n```C++\r\nauto jsonstr = R\"( {\"hello\": \"foo1\", \"test\": \"foo\"} )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\n\r\nstd::string val1 = doc.at_pointer(\"test\"); // copy to my own instance\r\ndoc.rewind();\r\nstd::string val2 = doc.at_pointer(\"hello\"); // copy to my own instance\r\n}\r\n```\r\n\r\nThat's because we write the unescaped strings to a string buffer. The `rewind` call will reset this buffer. If we did not do that, then you could, eventually, use an infinite amount of memory just by constantly unescaping strings again and again. You would end up, effectively, with a memory leak.\r\n\r\nThe problem with \"keeping a reference to an array\" is that if you have all these references around, they all share the same string buffer.\r\n\r\n\r\nA way around that would be to ask people to provide string buffers, or to duplicate our own string buffer... but this would have tradeoffs of its own.\n> But then, if we rewind when at_pointer is called, it would invalidate the value returned by that same call (if that value is an object or an array). Any hints or things that I am missing?\r\n\r\nNumbers, bools and nulls do not get invalidated because they get copied to a new instance. Everything else (`string_view`, `ondemand::object`, `ondemand::value`, `ondemand::array`) is invalidated. So you have to consume it *before* the next call to rewind. If, for example, you have an array of integers, then you should store them into an array of your own and not rely on the `ondemand::array` as a storage container.\r\n\r\nIt is not that we could not make it work, it is that it creates a whole set of other expectations. We do not want people to hold on to these instances from `on::demand` in their systems (`string_view`, `ondemand::object`, `ondemand::value`, `ondemand::array`). We want people to dump the data into their own data structures.\r\n\r\nThe idea with On Demand is that people should consume the values. In practice, this may mean making copies.\n>  if you want to save the child object/array before resetting, I would need to copy it separately? Would that be a valid approach for this issue?\r\n\r\nYes. And, in fact, we would like to document it this way.\r\n\r\nSo if take @erichutchins's issue. He has this array there `[0,1,2,3]`. You can do...\r\n\r\n```C++\r\nstd::vector<int64_t> vals;\r\nfor(auto i : array) { vals.push_back(i); }\r\n```\r\n\r\n(This might not be the best code example.)\r\n\r\nAnd then you have your `std::vector<int64_t>`. You can then do away with the `parser` instance, you are done. If you have an object\u00a0instance, you almost surely want to map the keys to some attribute or variables in your system. Like in this example...\r\n\r\n```C++\r\nauto jsonstr = R\"( {\"user\": {\"name\":\"Joe\", \"age\":37 )\"_padded;\r\n\r\nondemand::parser parser;\r\nondemand::document doc;\r\nondemand::value val;\r\n\r\ndoc = parser.iterate(jsonstr);\r\nauto val = doc.at_pointer(\"user\");\r\nmy_user_class user(val[\"Joe\"],val[\"age\")); // consume the object\r\n// you now have your user instance and you can do away with the JSON stuff\r\n```\r\n\r\n\r\nKeeping around the `ondemand::value` or `ondemand::object` is not something we want users to do. We want then to consume the values and be done with the JSON part as quickly as possible.\n@NicolasJiaxin @erichutchins \r\n\r\nI should stress that your objections are very much warranted. What we need to do is be very clear about the right way to use On Demand. We should have good examples.",
    "created_at": "2021-06-21T19:06:44Z",
    "version": "0.9",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container (Required)\nFROM ubuntu:20.04\n\n# Set environment variables for non-interactive apt operations and timezone\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime (Required)\n# Update package lists, upgrade existing packages, and install necessary packages:\n# - build-essential: Provides essential tools like make, gcc, and g++ for compiling C++ projects.\n# - git: Required for cloning the target repository.\n# - wget: Common utility for downloading files.\n# - cmake: The build system used by simdjson. Ubuntu 20.04 provides CMake 3.16.3, which satisfies simdjson's minimum requirement of 3.14.\n# - g++-8: The specific C++ compiler version, satisfies the requirement of g++ version 7 or better.\nRUN apt update && apt upgrade -y && \\\n    apt install -y \\\n    build-essential \\\n    git \\\n    wget \\\n    cmake \\\n    g++-8 && \\\n    rm -rf /var/lib/apt/lists/*\n\n# Configure g++-8 as the default G++ and GCC compiler using update-alternatives.\n# This step ensures that CMake and other build tools automatically pick version 8 of\n# the compiler, matching the project's dependency requirements.\n# A priority of 800 is used to make it the preferred default choice.\nRUN update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 800 --slave /usr/bin/gcov gcov /usr/bin/gcov-8 && \\\n    update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/gcov-tool gcov-tool /usr/bin/gcov-tool-8\n\n# Set the working directory inside the container\nWORKDIR /testbed/\n\n# Target Project setup. Clones the source code, checks out the specified commit SHA.\n# The repository is cloned into /testbed/.\nRUN git clone https://github.com/simdjson/simdjson.git /testbed/ && \\\n    cd /testbed/ && \\\n    git checkout 6cd04aa858f2d92105c0fbd65cdafb96428db002 && \\\n    git remote remove origin\n\n# Configure and build the project.\n# Create a build directory, navigate into it, and perform CMake configuration\n# with SIMDJSON_DEVELOPER_MODE=ON to ensure tests and examples are included.\n# Then, build the entire project. This prepares the environment for running tests.\n# The '-j4' flag is used to limit parallel compilation jobs to 4, preventing\n# potential out-of-memory errors, as observed in similar setups.\nRUN cd /testbed/ && \\\n    mkdir build && \\\n    cd build && \\\n    cmake .. -DSIMDJSON_DEVELOPER_MODE=ON && \\\n    cmake --build . -j4\n\n# Apply global read/write permissions for the testbed directory (including build artifacts)\n# This ensures that any subsequent operations by the eval script have full access.\nRUN chmod -R 777 /testbed",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned\ncd /testbed\n\n# Define variables for clarity and maintainability\nTARGET_COMMIT_SHA=\"6cd04aa858f2d92105c0fbd65cdafb96428db002\"\nTARGET_TEST_FILE=\"tests/ondemand/ondemand_json_pointer_tests.cpp\"\nTARGET_CTEST_NAME=\"ondemand_json_pointer_tests\" # Based on the file path, this is the derived CTest test name\n\n# Checkout the specific target test file to its original state before applying any patch.\n# This ensures a clean base for the patch application.\ngit checkout \"$TARGET_COMMIT_SHA\" \"$TARGET_TEST_FILE\"\n\n# Apply the test patch to modify/add tests.\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/tests/ondemand/ondemand_json_pointer_tests.cpp b/tests/ondemand/ondemand_json_pointer_tests.cpp\n--- a/tests/ondemand/ondemand_json_pointer_tests.cpp\n+++ b/tests/ondemand/ondemand_json_pointer_tests.cpp\n@@ -117,7 +117,6 @@ namespace json_pointer_tests {\n             std::string json_pointer = \"/\" + std::to_string(i) + \"/tire_pressure/1\";\n             ASSERT_SUCCESS(cars.at_pointer(json_pointer).get(x));\n             measured.push_back(x);\n-            cars.rewind();\n         }\n \n         std::vector<double> expected = {39.9, 31, 30};\nEOF_114329324912\n\n# Navigate to the build directory.\n# The Dockerfile has already run `cmake ..` and `cmake --build .` from /testbed,\n# so the `build` directory should already exist and contain the compiled project.\ncd build\n\n# Rebuild the project after applying the patch.\n# This step is critical to ensure that any new or modified tests from the patch\n# are compiled and included in the test executable.\n# Use -j4 for parallel compilation jobs, as specified in the Dockerfile.\necho \"Attempting to rebuild the project after patch application...\"\ncmake --build . -j4\n\n# Check the exit code of the build command. If the build fails, exit early.\nif [ $? -ne 0 ]; then\n    echo \"Build failed after patch application. Exiting.\"\n    rc=1\n    echo \"OMNIGRIL_EXIT_CODE=$rc\"\n    exit $rc\nfi\necho \"Project rebuilt successfully.\"\n\n# Execute only the specified target tests using CTest.\n# CTest runs tests discovered by CMake within the build directory.\n# We use -R (regular expression) to specifically target tests generated from the provided file.\necho \"Running target tests: $TARGET_CTEST_NAME\"\nctest --output-on-failure -R \"$TARGET_CTEST_NAME\"\nrc=$?\n\n# Capture the exit code immediately after running the tests.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the testbed root directory for cleanup.\ncd /testbed\n\n# Clean up: Undo any changes made to the target test file.\n# This ensures that the repository remains in its original state after the test run.\necho \"Cleaning up: reverting changes to $TARGET_TEST_FILE\"\ngit checkout \"$TARGET_COMMIT_SHA\" \"$TARGET_TEST_FILE\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the testbed directory where the repository is cloned\ncd /testbed\n\n# Define variables for clarity and maintainability\nTARGET_COMMIT_SHA=\"6cd04aa858f2d92105c0fbd65cdafb96428db002\"\nTARGET_TEST_FILE=\"tests/ondemand/ondemand_json_pointer_tests.cpp\"\nTARGET_CTEST_NAME=\"ondemand_json_pointer_tests\" # Based on the file path, this is the derived CTest test name\n\n# Checkout the specific target test file to its original state before applying any patch.\n# This ensures a clean base for the patch application.\ngit checkout \"$TARGET_COMMIT_SHA\" \"$TARGET_TEST_FILE\"\n\n# Apply the test patch to modify/add tests.\n# The content of the patch will be programmatically inserted here.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate to the build directory.\n# The Dockerfile has already run `cmake ..` and `cmake --build .` from /testbed,\n# so the `build` directory should already exist and contain the compiled project.\ncd build\n\n# Rebuild the project after applying the patch.\n# This step is critical to ensure that any new or modified tests from the patch\n# are compiled and included in the test executable.\n# Use -j4 for parallel compilation jobs, as specified in the Dockerfile.\necho \"Attempting to rebuild the project after patch application...\"\ncmake --build . -j4\n\n# Check the exit code of the build command. If the build fails, exit early.\nif [ $? -ne 0 ]; then\n    echo \"Build failed after patch application. Exiting.\"\n    rc=1\n    echo \"OMNIGRIL_EXIT_CODE=$rc\"\n    exit $rc\nfi\necho \"Project rebuilt successfully.\"\n\n# Execute only the specified target tests using CTest.\n# CTest runs tests discovered by CMake within the build directory.\n# We use -R (regular expression) to specifically target tests generated from the provided file.\necho \"Running target tests: $TARGET_CTEST_NAME\"\nctest --output-on-failure -R \"$TARGET_CTEST_NAME\"\nrc=$?\n\n# Capture the exit code immediately after running the tests.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Navigate back to the testbed root directory for cleanup.\ncd /testbed\n\n# Clean up: Undo any changes made to the target test file.\n# This ensures that the repository remains in its original state after the test run.\necho \"Cleaning up: reverting changes to $TARGET_TEST_FILE\"\ngit checkout \"$TARGET_COMMIT_SHA\" \"$TARGET_TEST_FILE\""
  }
]