{
    "task_id": "fmtlib__fmt-3727",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3727_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3727,
        "instance_id": "fmtlib__fmt-3727",
        "issue_numbers": [
            "3725",
            "3725"
        ],
        "base_commit": "06f1c0d725855861535e9e65cd4d502aca7c61ed",
        "patch": "diff --git a/include/fmt/chrono.h b/include/fmt/chrono.h\n--- a/include/fmt/chrono.h\n+++ b/include/fmt/chrono.h\n@@ -430,6 +430,51 @@ auto write(OutputIt out, const std::tm& time, const std::locale& loc,\n   return write_encoded_tm_str(out, string_view(buf.data(), buf.size()), loc);\n }\n \n+template <typename Rep1, typename Rep2>\n+struct is_same_arithmetic_type\n+    : public std::integral_constant<bool,\n+                                    (std::is_integral<Rep1>::value &&\n+                                     std::is_integral<Rep2>::value) ||\n+                                        (std::is_floating_point<Rep1>::value &&\n+                                         std::is_floating_point<Rep2>::value)> {\n+};\n+\n+template <\n+    typename To, typename FromRep, typename FromPeriod,\n+    FMT_ENABLE_IF(is_same_arithmetic_type<FromRep, typename To::rep>::value)>\n+To fmt_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {\n+#if FMT_SAFE_DURATION_CAST\n+  // throwing version of safe_duration_cast\n+  // only available for integer<->integer or float<->float casts\n+  int ec;\n+  To to = safe_duration_cast::safe_duration_cast<To>(from, ec);\n+  if (ec) FMT_THROW(format_error(\"cannot format duration\"));\n+  return to;\n+#else\n+  // standard duration cast, may overflow and invoke undefined behavior\n+  return std::chrono::duration_cast<To>(from);\n+#endif\n+}\n+\n+template <\n+    typename To, typename FromRep, typename FromPeriod,\n+    FMT_ENABLE_IF(!is_same_arithmetic_type<FromRep, typename To::rep>::value)>\n+To fmt_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {\n+  // mixed integer<->float cast is not supported with safe_duration_cast\n+  // fallback to standard duration cast in this case\n+  return std::chrono::duration_cast<To>(from);\n+}\n+\n+template <typename Duration>\n+std::time_t to_time_t(\n+    std::chrono::time_point<std::chrono::system_clock, Duration> time_point) {\n+  // cannot use std::chrono::system_clock::to_time_t() since this would first\n+  // require a cast to std::chrono::system_clock::time_point, which could\n+  // overflow.\n+  return fmt_duration_cast<std::chrono::duration<std::time_t>>(\n+             time_point.time_since_epoch())\n+      .count();\n+}\n }  // namespace detail\n \n FMT_BEGIN_EXPORT\n@@ -478,8 +523,8 @@ inline std::tm localtime(std::time_t time) {\n #if FMT_USE_LOCAL_TIME\n template <typename Duration>\n inline auto localtime(std::chrono::local_time<Duration> time) -> std::tm {\n-  return localtime(std::chrono::system_clock::to_time_t(\n-      std::chrono::current_zone()->to_sys(time)));\n+  return localtime(\n+      detail::to_time_t(std::chrono::current_zone()->to_sys(time)));\n }\n #endif\n \n@@ -523,9 +568,10 @@ inline std::tm gmtime(std::time_t time) {\n   return gt.tm_;\n }\n \n+template <typename Duration>\n inline std::tm gmtime(\n-    std::chrono::time_point<std::chrono::system_clock> time_point) {\n-  return gmtime(std::chrono::system_clock::to_time_t(time_point));\n+    std::chrono::time_point<std::chrono::system_clock, Duration> time_point) {\n+  return gmtime(detail::to_time_t(time_point));\n }\n \n namespace detail {\n@@ -1051,13 +1097,12 @@ void write_fractional_seconds(OutputIt& out, Duration d, int precision = -1) {\n                                 std::chrono::seconds::rep>::type,\n       std::ratio<1, detail::pow10(num_fractional_digits)>>;\n \n-  const auto fractional =\n-      d - std::chrono::duration_cast<std::chrono::seconds>(d);\n+  const auto fractional = d - fmt_duration_cast<std::chrono::seconds>(d);\n   const auto subseconds =\n       std::chrono::treat_as_floating_point<\n           typename subsecond_precision::rep>::value\n           ? fractional.count()\n-          : std::chrono::duration_cast<subsecond_precision>(fractional).count();\n+          : fmt_duration_cast<subsecond_precision>(fractional).count();\n   auto n = static_cast<uint32_or_64_or_128_t<long long>>(subseconds);\n   const int num_digits = detail::count_digits(n);\n \n@@ -1620,17 +1665,6 @@ template <typename T> struct make_unsigned_or_unchanged<T, true> {\n   using type = typename std::make_unsigned<T>::type;\n };\n \n-#if FMT_SAFE_DURATION_CAST\n-// throwing version of safe_duration_cast\n-template <typename To, typename FromRep, typename FromPeriod>\n-To fmt_safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {\n-  int ec;\n-  To to = safe_duration_cast::safe_duration_cast<To>(from, ec);\n-  if (ec) FMT_THROW(format_error(\"cannot format duration\"));\n-  return to;\n-}\n-#endif\n-\n template <typename Rep, typename Period,\n           FMT_ENABLE_IF(std::is_integral<Rep>::value)>\n inline std::chrono::duration<Rep, std::milli> get_milliseconds(\n@@ -1640,17 +1674,17 @@ inline std::chrono::duration<Rep, std::milli> get_milliseconds(\n #if FMT_SAFE_DURATION_CAST\n   using CommonSecondsType =\n       typename std::common_type<decltype(d), std::chrono::seconds>::type;\n-  const auto d_as_common = fmt_safe_duration_cast<CommonSecondsType>(d);\n+  const auto d_as_common = fmt_duration_cast<CommonSecondsType>(d);\n   const auto d_as_whole_seconds =\n-      fmt_safe_duration_cast<std::chrono::seconds>(d_as_common);\n+      fmt_duration_cast<std::chrono::seconds>(d_as_common);\n   // this conversion should be nonproblematic\n   const auto diff = d_as_common - d_as_whole_seconds;\n   const auto ms =\n-      fmt_safe_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);\n+      fmt_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);\n   return ms;\n #else\n-  auto s = std::chrono::duration_cast<std::chrono::seconds>(d);\n-  return std::chrono::duration_cast<std::chrono::milliseconds>(d - s);\n+  auto s = fmt_duration_cast<std::chrono::seconds>(d);\n+  return fmt_duration_cast<std::chrono::milliseconds>(d - s);\n #endif\n }\n \n@@ -1751,14 +1785,8 @@ struct chrono_formatter {\n \n     // this may overflow and/or the result may not fit in the\n     // target type.\n-#if FMT_SAFE_DURATION_CAST\n     // might need checked conversion (rep!=Rep)\n-    auto tmpval = std::chrono::duration<rep, Period>(val);\n-    s = fmt_safe_duration_cast<seconds>(tmpval);\n-#else\n-    s = std::chrono::duration_cast<seconds>(\n-        std::chrono::duration<rep, Period>(val));\n-#endif\n+    s = fmt_duration_cast<seconds>(std::chrono::duration<rep, Period>(val));\n   }\n \n   // returns true if nan or inf, writes to out.\n@@ -2082,25 +2110,22 @@ struct formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,\n             period::num != 1 || period::den != 1 ||\n             std::is_floating_point<typename Duration::rep>::value)) {\n       const auto epoch = val.time_since_epoch();\n-      auto subsecs = std::chrono::duration_cast<Duration>(\n-          epoch - std::chrono::duration_cast<std::chrono::seconds>(epoch));\n+      auto subsecs = detail::fmt_duration_cast<Duration>(\n+          epoch - detail::fmt_duration_cast<std::chrono::seconds>(epoch));\n \n       if (subsecs.count() < 0) {\n         auto second =\n-            std::chrono::duration_cast<Duration>(std::chrono::seconds(1));\n+            detail::fmt_duration_cast<Duration>(std::chrono::seconds(1));\n         if (epoch.count() < ((Duration::min)() + second).count())\n           FMT_THROW(format_error(\"duration is too small\"));\n         subsecs += second;\n         val -= second;\n       }\n \n-      return formatter<std::tm, Char>::do_format(\n-          gmtime(std::chrono::time_point_cast<std::chrono::seconds>(val)), ctx,\n-          &subsecs);\n+      return formatter<std::tm, Char>::do_format(gmtime(val), ctx, &subsecs);\n     }\n \n-    return formatter<std::tm, Char>::format(\n-        gmtime(std::chrono::time_point_cast<std::chrono::seconds>(val)), ctx);\n+    return formatter<std::tm, Char>::format(gmtime(val), ctx);\n   }\n };\n \n@@ -2119,17 +2144,13 @@ struct formatter<std::chrono::local_time<Duration>, Char>\n     if (period::num != 1 || period::den != 1 ||\n         std::is_floating_point<typename Duration::rep>::value) {\n       const auto epoch = val.time_since_epoch();\n-      const auto subsecs = std::chrono::duration_cast<Duration>(\n-          epoch - std::chrono::duration_cast<std::chrono::seconds>(epoch));\n+      const auto subsecs = detail::fmt_duration_cast<Duration>(\n+          epoch - detail::fmt_duration_cast<std::chrono::seconds>(epoch));\n \n-      return formatter<std::tm, Char>::do_format(\n-          localtime(std::chrono::time_point_cast<std::chrono::seconds>(val)),\n-          ctx, &subsecs);\n+      return formatter<std::tm, Char>::do_format(localtime(val), ctx, &subsecs);\n     }\n \n-    return formatter<std::tm, Char>::format(\n-        localtime(std::chrono::time_point_cast<std::chrono::seconds>(val)),\n-        ctx);\n+    return formatter<std::tm, Char>::format(localtime(val), ctx);\n   }\n };\n #endif\n",
        "test_patch": "diff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -874,6 +874,20 @@ TEST(chrono_test, timestamps_ratios) {\n       t4(std::chrono::duration<int, std::ratio<63>>(1));\n \n   EXPECT_EQ(fmt::format(\"{:%M:%S}\", t4), \"01:03\");\n+\n+  std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds>\n+      t5(std::chrono::seconds(32503680000));\n+\n+  EXPECT_EQ(fmt::format(\"{:%Y-%m-%d}\", t5), \"3000-01-01\");\n+\n+#if FMT_SAFE_DURATION_CAST\n+  using years = std::chrono::duration<std::int64_t, std::ratio<31556952>>;\n+  std::chrono::time_point<std::chrono::system_clock, years> t6(\n+      (years(std::numeric_limits<std::int64_t>::max())));\n+\n+  EXPECT_THROW_MSG((void)fmt::format(\"{:%Y-%m-%d}\", t6), fmt::format_error,\n+                   \"cannot format duration\");\n+#endif\n }\n \n TEST(chrono_test, timestamps_sub_seconds) {\n",
        "problem_statement": "Date overflow with std::chrono::time_point\n`std::chrono::system_clock::time_point` on linux platforms uses nanosecond resolution and a 64 bit signed counter, hence is unable to represent dates beyond year 2262. This can be circumvented by using a custom `time_point` with a lower time resolution when doing time calculations, such as\r\n```c++\r\nusing my_time_point = std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds>;\r\n```\r\n\r\nUnfortunately, it seems that fmtlib is unable to correctly format such time points despite the lower time resolution. Here is an example that reproduces the problem:\r\n\r\n```c++\r\n#include <chrono>\r\n#include <iostream>\r\n#include <fmt/chrono.h>\r\n\r\n#if defined(__cpp_lib_format) && __cpp_lib_format >= 202106L\r\n#define HAS_STD_FORMAT\r\n#endif\r\n\r\n#if defined(HAS_STD_FORMAT)\r\n#include <format>\r\n#endif\r\n\r\nint main() {\r\n    std::cout << \"fmt version: \" << FMT_VERSION << \"\\n\";\r\n\r\n    using TimePointBad = std::chrono::system_clock::time_point;\r\n    auto timeBad = TimePointBad{} + std::chrono::years{1030};\r\n    std::cout << \"bad time_point years:  \" <<\r\n        1970 + std::chrono::duration_cast<std::chrono::years>(timeBad.time_since_epoch()).count() << \"\\n\";\r\n    std::cout << \"fmt::format:           \" << fmt::format(\"{:%F %T}\", timeBad) << \"\\n\";\r\n    #if defined(HAS_STD_FORMAT)\r\n    std::cout << \"std::format:           \" << std::format(\"{:%F %T}\", timeBad) << \"\\n\";\r\n    #else\r\n    std::cout << \"std::format:           not available\\n\";\r\n    #endif\r\n\r\n    using TimePointGood = std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds>;\r\n    auto timeGood = TimePointGood{} + std::chrono::years{1030};\r\n    std::cout << \"good time_point years: \" <<\r\n        1970 + std::chrono::duration_cast<std::chrono::years>(timeGood.time_since_epoch()).count() << \"\\n\";\r\n    std::cout << \"fmt::format:           \" << fmt::format(\"{:%F %T}\", timeGood) << \"\\n\";\r\n    #if defined(HAS_STD_FORMAT)\r\n    std::cout << \"std::format:           \" << std::format(\"{:%F %T}\", timeGood) << \"\\n\";\r\n    #else\r\n    std::cout << \"std::format:           not available\\n\";\r\n    #endif\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nOutput from latest master commit on my system (Ubuntu GCC 11.4; doesn't have `<format>`):\r\n```\r\nfmt version: 100101\r\nbad time_point years:  1831\r\nfmt::format:           1830-11-22 19:26:52.580896768\r\nstd::format:           not available\r\ngood time_point years: 3000\r\nfmt::format:           1830-11-22 19:26:53.000\r\nstd::format:           not available\r\n```\r\n\r\nOutput lines 2 and 3 show the problem of the standard `std::chrono::system_clock::time_point`; this is the output I expect.\r\n\r\nOutput line 5 shows that, using `TimePointGood` with millisecond resolution, the time point itself is able to represent dates far in the future.\r\n\r\nOutput line 6 shows that fmtlib still overflows.\r\n\r\n[Godbolt link](https://godbolt.org/z/4MYETo4qo); this is running an older version of fmtlib but it also affected. Using gcc trunk with `std::format` shows that the standard `format` doesn't have the issue and outputs what one would expect:\r\n```\r\nfmt version: 90100\r\nbad time_point years:  1831\r\nfmt::format:           1830-11-22 19:26:53\r\nstd::format:           1830-11-22 19:26:52.580896768\r\ngood time_point years: 3000\r\nfmt::format:           1830-11-22 19:26:53\r\nstd::format:           2999-12-31 18:36:00.000\r\n```\r\n\nDate overflow with std::chrono::time_point\n`std::chrono::system_clock::time_point` on linux platforms uses nanosecond resolution and a 64 bit signed counter, hence is unable to represent dates beyond year 2262. This can be circumvented by using a custom `time_point` with a lower time resolution when doing time calculations, such as\r\n```c++\r\nusing my_time_point = std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds>;\r\n```\r\n\r\nUnfortunately, it seems that fmtlib is unable to correctly format such time points despite the lower time resolution. Here is an example that reproduces the problem:\r\n\r\n```c++\r\n#include <chrono>\r\n#include <iostream>\r\n#include <fmt/chrono.h>\r\n\r\n#if defined(__cpp_lib_format) && __cpp_lib_format >= 202106L\r\n#define HAS_STD_FORMAT\r\n#endif\r\n\r\n#if defined(HAS_STD_FORMAT)\r\n#include <format>\r\n#endif\r\n\r\nint main() {\r\n    std::cout << \"fmt version: \" << FMT_VERSION << \"\\n\";\r\n\r\n    using TimePointBad = std::chrono::system_clock::time_point;\r\n    auto timeBad = TimePointBad{} + std::chrono::years{1030};\r\n    std::cout << \"bad time_point years:  \" <<\r\n        1970 + std::chrono::duration_cast<std::chrono::years>(timeBad.time_since_epoch()).count() << \"\\n\";\r\n    std::cout << \"fmt::format:           \" << fmt::format(\"{:%F %T}\", timeBad) << \"\\n\";\r\n    #if defined(HAS_STD_FORMAT)\r\n    std::cout << \"std::format:           \" << std::format(\"{:%F %T}\", timeBad) << \"\\n\";\r\n    #else\r\n    std::cout << \"std::format:           not available\\n\";\r\n    #endif\r\n\r\n    using TimePointGood = std::chrono::time_point<std::chrono::system_clock, std::chrono::milliseconds>;\r\n    auto timeGood = TimePointGood{} + std::chrono::years{1030};\r\n    std::cout << \"good time_point years: \" <<\r\n        1970 + std::chrono::duration_cast<std::chrono::years>(timeGood.time_since_epoch()).count() << \"\\n\";\r\n    std::cout << \"fmt::format:           \" << fmt::format(\"{:%F %T}\", timeGood) << \"\\n\";\r\n    #if defined(HAS_STD_FORMAT)\r\n    std::cout << \"std::format:           \" << std::format(\"{:%F %T}\", timeGood) << \"\\n\";\r\n    #else\r\n    std::cout << \"std::format:           not available\\n\";\r\n    #endif\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nOutput from latest master commit on my system (Ubuntu GCC 11.4; doesn't have `<format>`):\r\n```\r\nfmt version: 100101\r\nbad time_point years:  1831\r\nfmt::format:           1830-11-22 19:26:52.580896768\r\nstd::format:           not available\r\ngood time_point years: 3000\r\nfmt::format:           1830-11-22 19:26:53.000\r\nstd::format:           not available\r\n```\r\n\r\nOutput lines 2 and 3 show the problem of the standard `std::chrono::system_clock::time_point`; this is the output I expect.\r\n\r\nOutput line 5 shows that, using `TimePointGood` with millisecond resolution, the time point itself is able to represent dates far in the future.\r\n\r\nOutput line 6 shows that fmtlib still overflows.\r\n\r\n[Godbolt link](https://godbolt.org/z/4MYETo4qo); this is running an older version of fmtlib but it also affected. Using gcc trunk with `std::format` shows that the standard `format` doesn't have the issue and outputs what one would expect:\r\n```\r\nfmt version: 90100\r\nbad time_point years:  1831\r\nfmt::format:           1830-11-22 19:26:53\r\nstd::format:           1830-11-22 19:26:52.580896768\r\ngood time_point years: 3000\r\nfmt::format:           1830-11-22 19:26:53\r\nstd::format:           2999-12-31 18:36:00.000\r\n```\r\n\n",
        "hints_text": "I think the issue is here:\r\nhttps://github.com/fmtlib/fmt/blob/dd6f657a79104101a2e4ea6ba90f69e0dc114822/include/fmt/chrono.h#L2097-L2103\r\nand here:\r\nhttps://github.com/fmtlib/fmt/blob/dd6f657a79104101a2e4ea6ba90f69e0dc114822/include/fmt/chrono.h#L526-L529\r\n\r\n1. The time point is converted to `seconds`; this could be dangerous since this is only required to hold at least 292 years worth of time, and we're asking for more in this case. In practice this works OK since `seconds` is typically implemented with a 64 bit signed integer, which gives plenty of space (a 32 bit signed integer would only provide 68 years worth of time, hence isn't allowed). But it's technically beyond what the standard guarantees. To be safe, we could use `std::chrono::duration<std::int64_t>` instead, which can hold up to 300 billions years worth of seconds.\r\n2. This is where the real issue is. `gmtime` implicitly converts the `time_point` back to the `system_clock::time_point`, which has nanosecond precision on linux, hence overflows. We can't use `system_clock::from_time_t`, since it always requires a `system_clock::time_point`. Thankfully, `system_clock` is defined to have the same epoch as `time_t` (only in C++20; but even though this wasn't defined pre-C++20, all implementations did this anyway). This means you can get a `time_t` by simply counting the number of seconds in the `time_point` since the epoch, which is what we have already.\r\n\r\nHence, simply using this alternative `gmtime` overload should solve the problem:\r\n```c++\r\ntemplate<typename Duration>\r\ninline std::tm gmtime(\r\n    std::chrono::time_point<std::chrono::system_clock, Duration> time_point) {\r\n  using large_seconds = std::chrono::duration<std::int64_t>;\r\n  return gmtime(std::chrono::time_point_cast<large_seconds>(time_point).time_since_epoch().count());\r\n}\r\n```\r\n(and we can remove the `time_point_cast` in the formatter)\r\n\r\nNB: this is assuming that `time_t` is 64 bit; if it's not, we're in deeper trouble :)\r\n\nI think the issue is here:\r\nhttps://github.com/fmtlib/fmt/blob/dd6f657a79104101a2e4ea6ba90f69e0dc114822/include/fmt/chrono.h#L2097-L2103\r\nand here:\r\nhttps://github.com/fmtlib/fmt/blob/dd6f657a79104101a2e4ea6ba90f69e0dc114822/include/fmt/chrono.h#L526-L529\r\n\r\n1. The time point is converted to `seconds`; this could be dangerous since this is only required to hold at least 292 years worth of time, and we're asking for more in this case. In practice this works OK since `seconds` is typically implemented with a 64 bit signed integer, which gives plenty of space (a 32 bit signed integer would only provide 68 years worth of time, hence isn't allowed). But it's technically beyond what the standard guarantees. To be safe, we could use `std::chrono::duration<std::int64_t>` instead, which can hold up to 300 billions years worth of seconds.\r\n2. This is where the real issue is. `gmtime` implicitly converts the `time_point` back to the `system_clock::time_point`, which has nanosecond precision on linux, hence overflows. We can't use `system_clock::from_time_t`, since it always requires a `system_clock::time_point`. Thankfully, `system_clock` is defined to have the same epoch as `time_t` (only in C++20; but even though this wasn't defined pre-C++20, all implementations did this anyway). This means you can get a `time_t` by simply counting the number of seconds in the `time_point` since the epoch, which is what we have already.\r\n\r\nHence, simply using this alternative `gmtime` overload should solve the problem:\r\n```c++\r\ntemplate<typename Duration>\r\ninline std::tm gmtime(\r\n    std::chrono::time_point<std::chrono::system_clock, Duration> time_point) {\r\n  using large_seconds = std::chrono::duration<std::int64_t>;\r\n  return gmtime(std::chrono::time_point_cast<large_seconds>(time_point).time_since_epoch().count());\r\n}\r\n```\r\n(and we can remove the `time_point_cast` in the formatter)\r\n\r\nNB: this is assuming that `time_t` is 64 bit; if it's not, we're in deeper trouble :)\r\n",
        "created_at": "2023-11-24T14:41:02Z",
        "version": "10.1"
    }
}