{
    "task_id": "fmtlib__fmt-4434",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-4434_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 4434,
        "instance_id": "fmtlib__fmt-4434",
        "issue_numbers": [
            "4424"
        ],
        "base_commit": "505ee058f7d5ec2a2a80eae82011ad48122b1551",
        "patch": "diff --git a/include/fmt/std.h b/include/fmt/std.h\n--- a/include/fmt/std.h\n+++ b/include/fmt/std.h\n@@ -713,9 +713,28 @@ template <typename T, typename Char> struct formatter<std::complex<T>, Char> {\n   }\n };\n \n+namespace detail {\n+template <typename T, typename Enable = void>\n+struct has_format_as : std::false_type {};\n+template <typename T>\n+struct has_format_as<T, void_t<decltype(format_as(std::declval<const T&>()))>>\n+    : std::true_type {};\n+\n+template <typename T, typename Enable = void>\n+struct has_format_as_member : std::false_type {};\n+template <typename T>\n+struct has_format_as_member<\n+    T, void_t<decltype(formatter<T>::format_as(std::declval<const T&>()))>>\n+    : std::true_type {};\n+}  // namespace detail\n+\n+// Guard against format_as because reference_wrappers are implicitly convertible\n+// to T&\n template <typename T, typename Char>\n struct formatter<std::reference_wrapper<T>, Char,\n-                 enable_if_t<is_formattable<remove_cvref_t<T>, Char>::value>>\n+                 enable_if_t<is_formattable<remove_cvref_t<T>, Char>::value &&\n+                             !detail::has_format_as<T>::value &&\n+                             !detail::has_format_as_member<T>::value>>\n     : formatter<remove_cvref_t<T>, Char> {\n   template <typename FormatContext>\n   auto format(std::reference_wrapper<T> ref, FormatContext& ctx) const\n",
        "test_patch": "diff --git a/test/std-test.cc b/test/std-test.cc\n--- a/test/std-test.cc\n+++ b/test/std-test.cc\n@@ -414,4 +414,36 @@ TEST(std_test, format_shared_ptr) {\n TEST(std_test, format_reference_wrapper) {\n   int num = 35;\n   EXPECT_EQ(\"35\", fmt::to_string(std::cref(num)));\n+  EXPECT_EQ(\"35\", fmt::to_string(std::ref(num)));\n+  EXPECT_EQ(\"35\", fmt::format(\"{}\", std::cref(num)));\n+  EXPECT_EQ(\"35\", fmt::format(\"{}\", std::ref(num)));\n+}\n+\n+// Regression test for https://github.com/fmtlib/fmt/issues/4424\n+struct type_with_format_as {\n+  int x;\n+};\n+\n+int format_as(const type_with_format_as& t) { return t.x; }\n+\n+TEST(std_test, format_reference_wrapper_with_format_as) {\n+  type_with_format_as t{20};\n+  EXPECT_EQ(\"20\", fmt::to_string(std::cref(t)));\n+  EXPECT_EQ(\"20\", fmt::to_string(std::ref(t)));\n+  EXPECT_EQ(\"20\", fmt::format(\"{}\", std::cref(t)));\n+  EXPECT_EQ(\"20\", fmt::format(\"{}\", std::ref(t)));\n+}\n+\n+struct type_with_format_as_string {\n+  std::string str;\n+};\n+\n+std::string format_as(const type_with_format_as_string& t) { return t.str; }\n+\n+TEST(std_test, format_reference_wrapper_with_format_as_string) {\n+  type_with_format_as_string t{\"foo\"};\n+  EXPECT_EQ(\"foo\", fmt::to_string(std::cref(t)));\n+  EXPECT_EQ(\"foo\", fmt::to_string(std::ref(t)));\n+  EXPECT_EQ(\"foo\", fmt::format(\"{}\", std::cref(t)));\n+  EXPECT_EQ(\"foo\", fmt::format(\"{}\", std::ref(t)));\n }\n",
        "problem_statement": "Formatter for `std::reference_wrapper<T>` results in an ambiguous template when `T` can be used with `format_as`\nFmt 11.1.0 added a formatter specialization for `std::reference_wrapper<T>`.\n\nhttps://github.com/fmtlib/fmt/blob/c7925241c76576dd610915f8120a055eedbe0ad7/include/fmt/std.h#L698-L707\n\nThis can result in errors due to ambiguous templates when `T` can be used with `format_as`:\n\n```cpp\n#include <fmt/format.h>\n#include <fmt/std.h>\n\n#include <functional>\n\nstruct S {\n    int x;\n};\n\nint format_as(S);\n\nint main() {\n    S s;\n    fmt::format(\"{}\", std::ref(s));\n}\n```\n\n```\n<source>:14:16:   in 'constexpr' expansion of 'fmt::v11::fstring<std::reference_wrapper<S> >(\"{}\")'\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/base.h:1119:52: error: ambiguous template instantiation for 'struct fmt::v11::formatter<std::reference_wrapper<S>, char, void>'\n 1119 |     remove_cvref_t<decltype(formatter<T>::format_as(std::declval<const T&>()))>;\n      |                             ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/format.h:3810:8: note: candidates are: 'template<class T, class Char> struct fmt::v11::formatter<T, Char, fmt::v11::void_t<typename std::remove_cv<typename std::remove_reference<decltype (format_as(declval<const T&>()))>::type>::type> > [with T = std::reference_wrapper<S>; Char = char]'\n 3810 | struct formatter<T, Char, void_t<detail::format_as_result<T>>>\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from <source>:2:\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/std.h:699:8: note:                 'template<class T, class Char> struct fmt::v11::formatter<std::reference_wrapper<_Tp>, Char, typename std::enable_if<std::integral_constant<bool, (! std::is_same<decltype (fmt::v11::detail::type_mapper<Char>::map(declval<typename std::conditional<std::is_void<typename std::remove_cv<typename std::remove_reference<_Tp>::type>::type>::value, int*, typename std::remove_cv<typename std::remove_reference<_Tp>::type>::type>::type&>())), void>::value)>::value, void>::type> [with T = S; Char = char]'\n  699 | struct formatter<std::reference_wrapper<T>, Char,\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  700 |                  enable_if_t<is_formattable<remove_cvref_t<T>, Char>::value>>\n      |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\nhttps://godbolt.org/z/r71vbP4KG\n\nThis is an unfortunate consequence of `std::reference_wrapper` having a non-explicit `operator T&` which allows a call like `format_as(std::ref(s))` to be valid.\n\nRepro without `fmt/std.h`, manually providing the specialization: https://godbolt.org/z/TeeP49x95.\n\nI can think of two possible solutions, I'm sure more exist:\n\nOne possible solution is to embrace `format_as` instead of specializing `fmt::formatter` for this:\n\n```cpp\ntemplate <typename T>\nT& format_as(std::reference_wrapper<T>);\n```\n\nThis solves the problem as naturally `int format_as(S);` is a better match https://godbolt.org/z/h173rEa6q\n\nAnother possible solution is to constrain `fmt::formatter<std::reference_wrapper<T>>` to types `T` which are not `format_as`-ible https://godbolt.org/z/j66Ko5Tzq.\n",
        "hints_text": "Thanks for reporting. I think switching to `format_as` for this is a good idea - a PR would be welcome.",
        "created_at": "2025-05-03T05:31:23Z",
        "version": "11.1"
    }
}