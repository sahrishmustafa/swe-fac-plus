[
  {
    "repo": "fmtlib/fmt",
    "pull_number": 1171,
    "instance_id": "fmtlib__fmt-1171",
    "issue_numbers": [
      "1169"
    ],
    "base_commit": "87fbc6f7566e4d3266bd3a2cd69f6c90e1aefa5d",
    "patch": "diff --git a/include/fmt/prepare.h b/include/fmt/prepare.h\n--- a/include/fmt/prepare.h\n+++ b/include/fmt/prepare.h\n@@ -217,7 +217,8 @@ class prepared_format {\n   std::basic_string<char_type> format(const Args&... args) const {\n     basic_memory_buffer<char_type> buffer;\n     typedef back_insert_range<internal::buffer<char_type>> range;\n-    this->vformat_to(range(buffer), make_args_checked(format_, args...));\n+    this->vformat_to(range(buffer), basic_format_args<context>{\n+                                        make_args_checked(format_, args...)});\n     return to_string(buffer);\n   }\n \n@@ -226,7 +227,8 @@ class prepared_format {\n       std::back_insert_iterator<Container> out, const Args&... args) const {\n     internal::container_buffer<Container> buffer(internal::get_container(out));\n     typedef back_insert_range<internal::buffer<char_type>> range;\n-    this->vformat_to(range(buffer), make_args_checked(format_, args...));\n+    this->vformat_to(range(buffer), basic_format_args<context>{\n+                                        make_args_checked(format_, args...)});\n     return out;\n   }\n \n@@ -242,18 +244,20 @@ class prepared_format {\n   inline typename buffer_context<char_type>::iterator format_to(\n       basic_memory_buffer<char_type, SIZE>& buf, const Args&... args) const {\n     typedef back_insert_range<internal::buffer<char_type>> range;\n-    return this->vformat_to(range(buf), make_args_checked(format_, args...));\n+    return this->vformat_to(\n+        range(buf),\n+        basic_format_args<context>{make_args_checked(format_, args...)});\n   }\n \n  private:\n   typedef buffer_context<char_type> context;\n \n-  template <typename Range>\n-  typename context::iterator vformat_to(Range out,\n-                                        basic_format_args<context> args) const {\n+  template <typename Range, typename Context>\n+  auto vformat_to(Range out, basic_format_args<Context> args) const ->\n+      typename Context::iterator {\n     const auto format_view = internal::to_string_view(format_);\n     basic_parse_context<char_type> parse_ctx(format_view);\n-    context ctx(out.begin(), args);\n+    Context ctx(out.begin(), args);\n \n     const auto& parts = parts_provider_.parts();\n     for (auto part_it = parts.begin(); part_it != parts.end(); ++part_it) {\n",
    "test_patch": "diff --git a/test/prepare-test.cc b/test/prepare-test.cc\n--- a/test/prepare-test.cc\n+++ b/test/prepare-test.cc\n@@ -475,7 +475,7 @@ TEST(PrepareTest, CopyPreparedFormat_InternalStringViewsAreNotInvalidated) {\n   }\n }\n \n-TEST(PepareTest, ReusedPreparedFormatType) {\n+TEST(PrepareTest, ReusedPreparedFormatType) {\n   typedef fmt::prepared_format<std::string, int>::type prepared_format;\n \n   prepared_format prepared = fmt::prepare<prepared_format>(\"The {} is {}.\");\n@@ -637,3 +637,58 @@ TEST(PrepareTest, PassUserTypeFormat) {\n   const auto prepared = fmt::prepare<int>(user_format(\"test {}\"));\n   EXPECT_EQ(\"test 42\", prepared.format(42));\n }\n+\n+TEST(PrepareTest, FormatToArrayOfChars) {\n+  char buffer[32] = {0};\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(buffer, 2);\n+  EXPECT_EQ(std::string(\"42\"), buffer);\n+  wchar_t wbuffer[32] = {0};\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(wbuffer, 2);\n+  EXPECT_EQ(std::wstring(L\"42\"), wbuffer);\n+}\n+\n+TEST(PrepareTest, FormatToIterator) {\n+  std::string s(2, ' ');\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(s.begin(), 2);\n+  EXPECT_EQ(\"42\", s);\n+  std::wstring ws(2, L' ');\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(ws.begin(), 2);\n+  EXPECT_EQ(L\"42\", ws);\n+}\n+\n+TEST(PrepareTest, FormatToBackInserter) {\n+  std::string s;\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(std::back_inserter(s), 2);\n+  EXPECT_EQ(\"42\", s);\n+  std::wstring ws;\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(std::back_inserter(ws), 2);\n+  EXPECT_EQ(L\"42\", ws);\n+}\n+\n+TEST(PrepareTest, FormatToBasicMemoryBuffer) {\n+  fmt::basic_memory_buffer<char, 100> buffer;\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(buffer, 2);\n+  EXPECT_EQ(\"42\", to_string(buffer));\n+  fmt::basic_memory_buffer<wchar_t, 100> wbuffer;\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(wbuffer, 2);\n+  EXPECT_EQ(L\"42\", to_string(wbuffer));\n+}\n+\n+TEST(PrepareTest, FormatToMemoryBuffer) {\n+  fmt::memory_buffer buffer;\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(buffer, 2);\n+  EXPECT_EQ(\"42\", to_string(buffer));\n+  fmt::wmemory_buffer wbuffer;\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(wbuffer, 2);\n+  EXPECT_EQ(L\"42\", to_string(wbuffer));\n+}\n",
    "problem_statement": "fmt::prepare fails to compile formatting to an array of chars\nIt's reproducible by such a simple code:\r\n```cpp\r\n#include <fmt/prepare.h>\r\n\r\nint main()\r\n{\r\n    char buffer[32];\r\n    auto prepared = fmt::prepare<int>(\"12{}\");\r\n    auto formatted = prepared.format_to(buffer, 3);\r\n}\r\n```\r\n\r\nSee an [example](https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:c%2B%2B,source:'%23include+%3Cfmt/prepare.h%3E%0A%0Aint+main()%0A%7B%0A++++char+buffer%5B32%5D%3B%0A++++auto+prepared+%3D+fmt::prepare%3Cint%3E(%2212%7B%7D%22)%3B%0A++++auto+formatted+%3D+prepared.format_to(buffer,+3)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:34.12334812716754,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:clang800,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'),lang:c%2B%2B,libs:!((name:boost,ver:'168'),(name:fmt,ver:trunk)),options:'-std%3Dgnu%2B%2B17+-O2',source:1),l:'5',n:'0',o:'x86-64+clang+8.0.0+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),k:28.69276284992644,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,wrap:'1'),l:'5',n:'0',o:'%231+with+x86-64+clang+8.0.0',t:'0')),k:37.183889022906065,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4)\n",
    "hints_text": "",
    "created_at": "2019-05-21T19:10:58Z",
    "version": "5.3",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container (Required)\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime (Required)\nRUN apt update && apt install -y \\\n    build-essential \\\n    clang \\\n    cmake \\\n    git \\\n    ninja-build \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to testbed. (Required)\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the taget version, configures it, and installs project-specific dependencies\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard 87fbc6f7566e4d3266bd3a2cd69f6c90e1aefa5d && \\\n    git remote remove origin",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Ensure the target test file is in its original state before applying any patch\ngit checkout 87fbc6f7566e4d3266bd3a2cd69f6c90e1aefa5d \"test/prepare-test.cc\"\n\n# Required: apply test patch to update target tests\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/prepare-test.cc b/test/prepare-test.cc\n--- a/test/prepare-test.cc\n+++ b/test/prepare-test.cc\n@@ -475,7 +475,7 @@ TEST(PrepareTest, CopyPreparedFormat_InternalStringViewsAreNotInvalidated) {\n   }\n }\n \n-TEST(PepareTest, ReusedPreparedFormatType) {\n+TEST(PrepareTest, ReusedPreparedFormatType) {\n   typedef fmt::prepared_format<std::string, int>::type prepared_format;\n \n   prepared_format prepared = fmt::prepare<prepared_format>(\"The {} is {}.\");\n@@ -637,3 +637,58 @@ TEST(PrepareTest, PassUserTypeFormat) {\n   const auto prepared = fmt::prepare<int>(user_format(\"test {}\"));\n   EXPECT_EQ(\"test 42\", prepared.format(42));\n }\n+\n+TEST(PrepareTest, FormatToArrayOfChars) {\n+  char buffer[32] = {0};\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(buffer, 2);\n+  EXPECT_EQ(std::string(\"42\"), buffer);\n+  wchar_t wbuffer[32] = {0};\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(wbuffer, 2);\n+  EXPECT_EQ(std::wstring(L\"42\"), wbuffer);\n+}\n+\n+TEST(PrepareTest, FormatToIterator) {\n+  std::string s(2, ' ');\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(s.begin(), 2);\n+  EXPECT_EQ(\"42\", s);\n+  std::wstring ws(2, L' ');\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(ws.begin(), 2);\n+  EXPECT_EQ(L\"42\", ws);\n+}\n+\n+TEST(PrepareTest, FormatToBackInserter) {\n+  std::string s;\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(std::back_inserter(s), 2);\n+  EXPECT_EQ(\"42\", s);\n+  std::wstring ws;\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(std::back_inserter(ws), 2);\n+  EXPECT_EQ(L\"42\", ws);\n+}\n+\n+TEST(PrepareTest, FormatToBasicMemoryBuffer) {\n+  fmt::basic_memory_buffer<char, 100> buffer;\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(buffer, 2);\n+  EXPECT_EQ(\"42\", to_string(buffer));\n+  fmt::basic_memory_buffer<wchar_t, 100> wbuffer;\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(wbuffer, 2);\n+  EXPECT_EQ(L\"42\", to_string(wbuffer));\n+}\n+\n+TEST(PrepareTest, FormatToMemoryBuffer) {\n+  fmt::memory_buffer buffer;\n+  const auto prepared = fmt::prepare<int>(\"4{}\");\n+  prepared.format_to(buffer, 2);\n+  EXPECT_EQ(\"42\", to_string(buffer));\n+  fmt::wmemory_buffer wbuffer;\n+  const auto wprepared = fmt::prepare<int>(L\"4{}\");\n+  wprepared.format_to(wbuffer, 2);\n+  EXPECT_EQ(L\"42\", to_string(wbuffer));\n+}\nEOF_114329324912\n\n# Build system setup\n# 1. Create the build directory\nmkdir build\n\n# 2. Configure CMake with tests enabled\ncmake -S . -B build -DFMT_TEST=ON\n\n# 3. Build the project\ncmake --build build\n\n# Test execution\n# Navigate into the build directory\ncd build\n\n# Run tests: ctest will execute all tests compiled as part of the FMT_TEST target,\n# which includes tests derived from test/prepare-test.cc.\nctest --output-on-failure\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test file\ncd /testbed # Ensure we are in the repository root for git checkout\ngit checkout 87fbc6f7566e4d3266bd3a2cd69f6c90e1aefa5d \"test/prepare-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Ensure the target test file is in its original state before applying any patch\ngit checkout 87fbc6f7566e4d3266bd3a2cd69f6c90e1aefa5d \"test/prepare-test.cc\"\n\n# Required: apply test patch to update target tests\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Build system setup\n# 1. Create the build directory\nmkdir build\n\n# 2. Configure CMake with tests enabled\ncmake -S . -B build -DFMT_TEST=ON\n\n# 3. Build the project\ncmake --build build\n\n# Test execution\n# Navigate into the build directory\ncd build\n\n# Run tests: ctest will execute all tests compiled as part of the FMT_TEST target,\n# which includes tests derived from test/prepare-test.cc.\nctest --output-on-failure\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test file\ncd /testbed # Ensure we are in the repository root for git checkout\ngit checkout 87fbc6f7566e4d3266bd3a2cd69f6c90e1aefa5d \"test/prepare-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 1360,
    "instance_id": "fmtlib__fmt-1360",
    "issue_numbers": [
      "1353"
    ],
    "base_commit": "96f91428c6ad2d19f1ce87ae160b78f52ed989fb",
    "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -657,6 +657,7 @@ enum type {\n   char_type,\n   last_integer_type = char_type,\n   // followed by floating-point types.\n+  float_type,\n   double_type,\n   long_double_type,\n   last_numeric_type = long_double_type,\n@@ -683,6 +684,7 @@ FMT_TYPE_CONSTANT(int128_t, int128_type);\n FMT_TYPE_CONSTANT(uint128_t, uint128_type);\n FMT_TYPE_CONSTANT(bool, bool_type);\n FMT_TYPE_CONSTANT(Char, char_type);\n+FMT_TYPE_CONSTANT(float, float_type);\n FMT_TYPE_CONSTANT(double, double_type);\n FMT_TYPE_CONSTANT(long double, long_double_type);\n FMT_TYPE_CONSTANT(const Char*, cstring_type);\n@@ -724,6 +726,7 @@ template <typename Context> class value {\n     uint128_t uint128_value;\n     bool bool_value;\n     char_type char_value;\n+    float float_value;\n     double double_value;\n     long double long_double_value;\n     const void* pointer;\n@@ -738,6 +741,7 @@ template <typename Context> class value {\n   value(unsigned long long val) : ulong_long_value(val) {}\n   value(int128_t val) : int128_value(val) {}\n   value(uint128_t val) : uint128_value(val) {}\n+  value(float val) : float_value(val) {}\n   value(double val) : double_value(val) {}\n   value(long double val) : long_double_value(val) {}\n   value(bool val) : bool_value(val) {}\n@@ -809,7 +813,7 @@ template <typename Context> struct arg_mapper {\n     return val;\n   }\n \n-  FMT_CONSTEXPR double map(float val) { return static_cast<double>(val); }\n+  FMT_CONSTEXPR float map(float val) { return val; }\n   FMT_CONSTEXPR double map(double val) { return val; }\n   FMT_CONSTEXPR long double map(long double val) { return val; }\n \n@@ -889,7 +893,11 @@ using mapped_type_constant =\n                   typename Context::char_type>;\n \n // Maximum number of arguments with packed types.\n-enum { max_packed_args = 15 };\n+enum {\n+  packed_arg_bitsize = 5,\n+  packed_arg_mask = (1 << packed_arg_bitsize) - 1,\n+  max_packed_args = 63 / packed_arg_bitsize,\n+};\n enum : unsigned long long { is_unpacked_bit = 1ull << 63 };\n \n template <typename Context> class arg_map;\n@@ -981,6 +989,8 @@ FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,\n     return vis(arg.value_.bool_value);\n   case internal::char_type:\n     return vis(arg.value_.char_value);\n+  case internal::float_type:\n+    return vis(arg.value_.float_value);\n   case internal::double_type:\n     return vis(arg.value_.double_value);\n   case internal::long_double_type:\n@@ -1052,7 +1062,7 @@ template <typename> constexpr unsigned long long encode_types() { return 0; }\n template <typename Context, typename Arg, typename... Args>\n constexpr unsigned long long encode_types() {\n   return mapped_type_constant<Arg, Context>::value |\n-         (encode_types<Context, Args...>() << 4);\n+         (encode_types<Context, Args...>() << packed_arg_bitsize);\n }\n \n template <typename Context, typename T>\n@@ -1197,8 +1207,8 @@ template <typename Context> class basic_format_args {\n   bool is_packed() const { return (types_ & internal::is_unpacked_bit) == 0; }\n \n   internal::type type(int index) const {\n-    int shift = index * 4;\n-    return static_cast<internal::type>((types_ & (0xfull << shift)) >> shift);\n+    int shift = index * internal::packed_arg_bitsize;\n+    return static_cast<internal::type>((types_ >> shift) & internal::packed_arg_mask);\n   }\n \n   friend class internal::arg_map<Context>;\ndiff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h\n--- a/include/fmt/format-inl.h\n+++ b/include/fmt/format-inl.h\n@@ -980,6 +980,13 @@ FMT_API bool grisu_format(Double value, buffer<char>& buf, int precision,\n   return true;\n }\n \n+template <>\n+char* sprintf_format<float>(float value, internal::buffer<char>& buf,\n+                            sprintf_specs specs) {\n+  // printf does not have a float format modifier, it only supports double.\n+  return sprintf_format<double>(value, buf, specs);\n+}\n+\n template <typename Double>\n char* sprintf_format(Double value, internal::buffer<char>& buf,\n                      sprintf_specs specs) {\ndiff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -1663,8 +1663,12 @@ template <typename Range> class basic_writer {\n                                    int_writer<T, Spec>(*this, value, spec));\n   }\n \n+  void write(float value, const format_specs& specs = format_specs()) {\n+    write_fp(value, specs);\n+  }\n+\n   void write(double value, const format_specs& specs = format_specs()) {\n-    write_double(value, specs);\n+    write_fp(value, specs);\n   }\n \n   /**\n@@ -1674,12 +1678,12 @@ template <typename Range> class basic_writer {\n     \\endrst\n    */\n   void write(long double value, const format_specs& specs = format_specs()) {\n-    write_double(value, specs);\n+    write_fp(value, specs);\n   }\n \n-  // Formats a floating-point number (double or long double).\n+  // Formats a floating-point number (float, double, or long double).\n   template <typename T, bool USE_GRISU = fmt::internal::use_grisu<T>()>\n-  void write_double(T value, const format_specs& specs);\n+  void write_fp(T value, const format_specs& specs);\n \n   /** Writes a character to the buffer. */\n   void write(char value) {\n@@ -1826,7 +1830,7 @@ class arg_formatter_base {\n \n   template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n   iterator operator()(T value) {\n-    writer_.write_double(value, specs_ ? *specs_ : format_specs());\n+    writer_.write_fp(value, specs_ ? *specs_ : format_specs());\n     return out();\n   }\n \n@@ -2766,8 +2770,8 @@ struct float_spec_handler {\n \n template <typename Range>\n template <typename T, bool USE_GRISU>\n-void internal::basic_writer<Range>::write_double(T value,\n-                                                 const format_specs& specs) {\n+void internal::basic_writer<Range>::write_fp(T value,\n+                                             const format_specs& specs) {\n   // Check type.\n   float_spec_handler handler(static_cast<char>(specs.type));\n   internal::handle_float_type_spec(handler.type, handler);\n@@ -3006,6 +3010,7 @@ struct formatter<T, Char,\n       handle_char_specs(\n           &specs_, internal::char_specs_checker<decltype(eh)>(specs_.type, eh));\n       break;\n+    case internal::float_type:\n     case internal::double_type:\n     case internal::long_double_type:\n       handle_float_type_spec(specs_.type,\n@@ -3061,7 +3066,6 @@ FMT_FORMAT_AS(short, int);\n FMT_FORMAT_AS(unsigned short, unsigned);\n FMT_FORMAT_AS(long, long long);\n FMT_FORMAT_AS(unsigned long, unsigned long long);\n-FMT_FORMAT_AS(float, double);\n FMT_FORMAT_AS(Char*, const Char*);\n FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);\n FMT_FORMAT_AS(std::nullptr_t, const void*);\n",
    "test_patch": "diff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -290,8 +290,6 @@ VISIT_TYPE(long, long long);\n VISIT_TYPE(unsigned long, unsigned long long);\n #endif\n \n-VISIT_TYPE(float, double);\n-\n #define CHECK_ARG_(Char, expected, value)                                     \\\n   {                                                                           \\\n     testing::StrictMock<mock_visitor<decltype(expected)>> visitor;            \\\ndiff --git a/test/locale-test.cc b/test/locale-test.cc\n--- a/test/locale-test.cc\n+++ b/test/locale-test.cc\n@@ -23,7 +23,7 @@ TEST(LocaleTest, DoubleDecimalPoint) {\n   fmt::internal::writer w(buf, fmt::internal::locale_ref(loc));\n   auto specs = fmt::format_specs();\n   specs.type = 'n';\n-  w.write_double<double, false>(1.23, specs);\n+  w.write_fp<double, false>(1.23, specs);\n   EXPECT_EQ(fmt::to_string(buf), \"1?23\");\n }\n \n",
    "problem_statement": "Cannot override float processing\nTried to override format for standard types according to documentation:\r\n\r\n`\r\nusing arg_formatter = fmt::arg_formatter<fmt::back_insert_range<fmt::internal::buffer>>;\r\n\r\nclass na_arg_formatter : public arg_formatter {\r\npublic:\r\n\tna_arg_formatter(fmt::format_context &ctx, fmt::format_specs *spec = nullptr)\r\n\t\t: arg_formatter(ctx, spec),\r\n\t\tm_na_formatter(ctx)\r\n\t{}\r\n\r\n\tusing arg_formatter::operator();\r\n\r\n\tauto operator()(double value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\n\tauto operator()(float value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\n\tauto operator()(unsigned value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\n\tauto operator()(int value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\nprivate:\r\n\targ_formatter m_na_formatter;\r\n};\r\n\r\ninline std::string na_vformat(fmt::string_view format_str, fmt::format_args args) {\r\n\tfmt::memory_buffer buffer;\r\n\t// Pass custom argument formatter as a template arg to vformat_to.\r\n\tfmt::vformat_to<na_arg_formatter>(buffer, format_str, args);\r\n\treturn fmt::to_string(buffer);\r\n}\r\n\r\ntemplate <typename ...Args>\r\ninline std::string na_format(\r\n\tfmt::string_view format_str, const Args &... args) {\r\n\treturn na_vformat(format_str, fmt::make_format_args(args...));\r\n}\r\n`\r\n\r\nFloat overloading is not working.\r\nDouble case is chosen.\r\n`\r\nna_format(\"{}\", 4.f);\r\n`\r\n\n",
    "hints_text": "This is effectively a subset of the issue reported in #1336 - we should stop promoting `float` to `double`.",
    "created_at": "2019-10-12T03:47:16Z",
    "version": "6.0",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ninja-build \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to testbed.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard 96f91428c6ad2d19f1ce87ae160b78f52ed989fb && \\\n    git remote remove origin && \\\n    mkdir build && \\\n    cd build && \\\n    cmake -DFMT_TEST=ON -DCMAKE_BUILD_TYPE=Release .. && \\\n    cmake --build .",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout 96f91428c6ad2d19f1ce87ae160b78f52ed989fb \"test/core-test.cc\" \"test/locale-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -290,8 +290,6 @@ VISIT_TYPE(long, long long);\n VISIT_TYPE(unsigned long, unsigned long long);\n #endif\n \n-VISIT_TYPE(float, double);\n-\n #define CHECK_ARG_(Char, expected, value)                                     \\\n   {                                                                           \\\n     testing::StrictMock<mock_visitor<decltype(expected)>> visitor;            \\\ndiff --git a/test/locale-test.cc b/test/locale-test.cc\n--- a/test/locale-test.cc\n+++ b/test/locale-test.cc\n@@ -23,7 +23,7 @@ TEST(LocaleTest, DoubleDecimalPoint) {\n   fmt::internal::writer w(buf, fmt::internal::locale_ref(loc));\n   auto specs = fmt::format_specs();\n   specs.type = 'n';\n-  w.write_double<double, false>(1.23, specs);\n+  w.write_fp<double, false>(1.23, specs);\n   EXPECT_EQ(fmt::to_string(buf), \"1?23\");\n }\n \nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\ncd build\n\n# Execute target tests using ctest, filtering by the specified test names.\n# The context indicates test names correspond to file names.\nctest --output-on-failure -R \"core-test|locale-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout 96f91428c6ad2d19f1ce87ae160b78f52ed989fb \"test/core-test.cc\" \"test/locale-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout 96f91428c6ad2d19f1ce87ae160b78f52ed989fb \"test/core-test.cc\" \"test/locale-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\ncd build\n\n# Execute target tests using ctest, filtering by the specified test names.\n# The context indicates test names correspond to file names.\nctest --output-on-failure -R \"core-test|locale-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout 96f91428c6ad2d19f1ce87ae160b78f52ed989fb \"test/core-test.cc\" \"test/locale-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 1361,
    "instance_id": "fmtlib__fmt-1361",
    "issue_numbers": [
      "1336"
    ],
    "base_commit": "a5abe5d95cb8a8015913be9748a9661f3e1fbda8",
    "patch": "diff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h\n--- a/include/fmt/format-inl.h\n+++ b/include/fmt/format-inl.h\n@@ -423,6 +423,18 @@ class fp {\n     lower.f <<= lower.e - upper.e;\n     lower.e = upper.e;\n   }\n+\n+  void compute_float_boundaries(fp& lower, fp& upper) const {\n+    constexpr int min_normal_e = std::numeric_limits<float>::min_exponent -\n+                                 std::numeric_limits<double>::digits;\n+    significand_type half_ulp = 1 << (std::numeric_limits<double>::digits -\n+                                      std::numeric_limits<float>::digits - 1);\n+    if (min_normal_e > e) half_ulp <<= min_normal_e - e;\n+    upper = normalize<0>(fp(f + half_ulp, e));\n+    lower = fp(f - (half_ulp >> (f == implicit_bit && e > min_normal_e)), e);\n+    lower.f <<= lower.e - upper.e;\n+    lower.e = upper.e;\n+  }\n };\n \n // Returns an fp number representing x - y. Result may not be normalized.\n@@ -1045,7 +1057,11 @@ bool grisu_format(Double value, buffer<char>& buf, int precision,\n     buf.resize(to_unsigned(handler.size));\n   } else {\n     fp lower, upper;  // w^- and w^+ in the Grisu paper.\n-    fp_value.compute_boundaries(lower, upper);\n+    if ((options & grisu_options::binary32) != 0)\n+      fp_value.compute_float_boundaries(lower, upper);\n+    else\n+      fp_value.compute_boundaries(lower, upper);\n+\n     // Find a cached power of 10 such that multiplying upper by it will bring\n     // the exponent in the range [min_exp, -32].\n     const auto cached_pow = get_cached_power(  // \\tilde{c}_{-k} in Grisu.\ndiff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -1111,7 +1111,7 @@ It grisu_prettify(const char* digits, int size, int exp, It it,\n }\n \n namespace grisu_options {\n-enum { fixed = 1, grisu2 = 2 };\n+enum { fixed = 1, grisu2 = 2, binary32 = 4 };\n }\n \n // Formats value using the Grisu algorithm:\n@@ -2809,12 +2809,16 @@ void internal::basic_writer<Range>::write_fp(T value,\n   memory_buffer buffer;\n   int exp = 0;\n   int precision = specs.precision >= 0 || !specs.type ? specs.precision : 6;\n+  unsigned options = 0;\n+  if (handler.fixed) options |= internal::grisu_options::fixed;\n+  if (sizeof(value) == sizeof(float))\n+    options |= internal::grisu_options::binary32;\n   bool use_grisu = USE_GRISU &&\n                    (specs.type != 'a' && specs.type != 'A' &&\n                     specs.type != 'e' && specs.type != 'E') &&\n                    internal::grisu_format(\n                        static_cast<double>(value), buffer, precision,\n-                       handler.fixed ? internal::grisu_options::fixed : 0, exp);\n+                       options, exp);\n   char* decimal_point_pos = nullptr;\n   if (!use_grisu)\n     decimal_point_pos = internal::sprintf_format(value, buffer, specs);\n",
    "test_patch": "diff --git a/test/format-impl-test.cc b/test/format-impl-test.cc\n--- a/test/format-impl-test.cc\n+++ b/test/format-impl-test.cc\n@@ -221,6 +221,36 @@ TEST(FPTest, ComputeBoundaries) {\n   EXPECT_EQ(31, upper.e);\n }\n \n+TEST(FPTest, ComputeFloatBoundaries) {\n+  struct {\n+    double x, lower, upper;\n+  } tests[] = {\n+      // regular\n+      {1.5f, 1.4999999403953552, 1.5000000596046448},\n+      // boundary\n+      {1.0f, 0.9999999701976776, 1.0000000596046448},\n+      // min normal\n+      {1.1754944e-38f, 1.1754942807573643e-38, 1.1754944208872107e-38},\n+      // max subnormal\n+      {1.1754942e-38f, 1.1754941406275179e-38, 1.1754942807573643e-38},\n+      // min subnormal\n+      {1e-45f, 7.006492321624085e-46, 2.1019476964872256e-45},\n+  };\n+  for (auto test : tests) {\n+    auto v = fp(test.x);\n+    fp vlower = normalize(fp(test.lower));\n+    fp vupper = normalize(fp(test.upper));\n+    vlower.f >>= vupper.e - vlower.e;\n+    vlower.e = vupper.e;\n+    fp lower, upper;\n+    v.compute_float_boundaries(lower, upper);\n+    EXPECT_EQ(vlower.f, lower.f);\n+    EXPECT_EQ(vlower.e, lower.e);\n+    EXPECT_EQ(vupper.f, upper.f);\n+    EXPECT_EQ(vupper.e, upper.e);\n+  }\n+}\n+\n TEST(FPTest, Subtract) {\n   auto v = fp(123, 1) - fp(102, 1);\n   EXPECT_EQ(v.f, 21u);\ndiff --git a/test/grisu-test.cc b/test/grisu-test.cc\n--- a/test/grisu-test.cc\n+++ b/test/grisu-test.cc\n@@ -52,6 +52,8 @@ TEST(GrisuTest, Prettify) {\n   EXPECT_EQ(\"12340000000.0\", fmt::format(\"{}\", 1234e7));\n   EXPECT_EQ(\"12.34\", fmt::format(\"{}\", 1234e-2));\n   EXPECT_EQ(\"0.001234\", fmt::format(\"{}\", 1234e-6));\n+  EXPECT_EQ(\"0.1\", fmt::format(\"{}\", 0.1f));\n+  EXPECT_EQ(\"0.10000000149011612\", fmt::format(\"{}\", double(0.1f)));\n }\n \n TEST(GrisuTest, ZeroPrecision) { EXPECT_EQ(\"1\", fmt::format(\"{:.0}\", 1.0)); }\n",
    "problem_statement": "Support single precision floats in grisu formatting\nCurrently `fmt::format(\"{}\", 0.1f)` with grisu produces `0.10000000149011612` (as would have been expected from `double(0.1f)`) rather than `0.1`.\r\n\r\nSingle precision formatting differs from double precision only in the calculation of the boundaries: https://github.com/google/double-conversion/blob/v3.1.5/double-conversion/fast-dtoa.cc#L525-L536\n",
    "hints_text": "As I see, floating format with \"{}\" and GRISU is not more compatible with `std::defaultfloat` in fmtlib 6.0.0\r\n```\r\nstd::cout << fmt::format(\"{}\\n\", 1.0 / 3.0);\r\nstd::cout << 1.0 / 3.0 << \"\\n\";\r\n```\r\noutputs\r\n```\r\n0.3333333333333333\r\n0.333333\r\n```\r\n(fmtlib 6.0.0, GRISU, VisualStudio 2019 16.3)\r\nIt looks like compatibility problem.\nPlease use a separate issue to discuss that. #1033 is related, although it does not talk about the default `cout` format. `{}` is not supposed to output the same as `cout <<`, it is supposed to print the number with enough precision such that reading that number back produces the same number. 1/3 is most accurately approximated by a double 0.3333333333333333, it needs so many digits to distinguish it from the previous double 0.33333333333333326 and the next double 0.33333333333333337; 0.333333 represents a different number.\n> Single precision formatting differs from double precision only in the calculation of the boundaries\r\n\r\nRight. This is also needed for compatibility with `std::format`. @orivej, could you by any chance submit a PR?",
    "created_at": "2019-10-12T12:20:21Z",
    "version": "6.0",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    git \\\n    cmake \\\n    build-essential \\\n    curl \\\n    python3 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to testbed.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard a5abe5d95cb8a8015913be9748a9661f3e1fbda8 && \\\n    git remote remove origin && \\\n    mkdir build && \\\n    cd build && \\\n    # Configure CMake with specified options and C++17 standard using the default g++ compiler\n    CXX=g++ cmake \\\n        -DFMT_TEST=ON \\\n        -DFMT_PEDANTIC=ON \\\n        -DFMT_WERROR=ON \\\n        -DCMAKE_BUILD_TYPE=Release \\\n        -DCMAKE_CXX_STANDARD=17 \\\n        .. && \\\n    # Build the project, including tests\n    cmake --build .",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout a5abe5d95cb8a8015913be9748a9661f3e1fbda8 \"test/format-impl-test.cc\" \"test/grisu-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/format-impl-test.cc b/test/format-impl-test.cc\n--- a/test/format-impl-test.cc\n+++ b/test/format-impl-test.cc\n@@ -221,6 +221,36 @@ TEST(FPTest, ComputeBoundaries) {\n   EXPECT_EQ(31, upper.e);\n }\n \n+TEST(FPTest, ComputeFloatBoundaries) {\n+  struct {\n+    double x, lower, upper;\n+  } tests[] = {\n+      // regular\n+      {1.5f, 1.4999999403953552, 1.5000000596046448},\n+      // boundary\n+      {1.0f, 0.9999999701976776, 1.0000000596046448},\n+      // min normal\n+      {1.1754944e-38f, 1.1754942807573643e-38, 1.1754944208872107e-38},\n+      // max subnormal\n+      {1.1754942e-38f, 1.1754941406275179e-38, 1.1754942807573643e-38},\n+      // min subnormal\n+      {1e-45f, 7.006492321624085e-46, 2.1019476964872256e-45},\n+  };\n+  for (auto test : tests) {\n+    auto v = fp(test.x);\n+    fp vlower = normalize(fp(test.lower));\n+    fp vupper = normalize(fp(test.upper));\n+    vlower.f >>= vupper.e - vlower.e;\n+    vlower.e = vupper.e;\n+    fp lower, upper;\n+    v.compute_float_boundaries(lower, upper);\n+    EXPECT_EQ(vlower.f, lower.f);\n+    EXPECT_EQ(vlower.e, lower.e);\n+    EXPECT_EQ(vupper.f, upper.f);\n+    EXPECT_EQ(vupper.e, upper.e);\n+  }\n+}\n+\n TEST(FPTest, Subtract) {\n   auto v = fp(123, 1) - fp(102, 1);\n   EXPECT_EQ(v.f, 21u);\ndiff --git a/test/grisu-test.cc b/test/grisu-test.cc\n--- a/test/grisu-test.cc\n+++ b/test/grisu-test.cc\n@@ -52,6 +52,8 @@ TEST(GrisuTest, Prettify) {\n   EXPECT_EQ(\"12340000000.0\", fmt::format(\"{}\", 1234e7));\n   EXPECT_EQ(\"12.34\", fmt::format(\"{}\", 1234e-2));\n   EXPECT_EQ(\"0.001234\", fmt::format(\"{}\", 1234e-6));\n+  EXPECT_EQ(\"0.1\", fmt::format(\"{}\", 0.1f));\n+  EXPECT_EQ(\"0.10000000149011612\", fmt::format(\"{}\", double(0.1f)));\n }\n \n TEST(GrisuTest, ZeroPrecision) { EXPECT_EQ(\"1\", fmt::format(\"{:.0}\", 1.0)); }\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\ncd build\n\n# Execute target tests using ctest, filtering by the specified test names.\n# The context indicates test names correspond to file names.\n# Ensure CTEST_OUTPUT_ON_FAILURE is set for detailed output.\nctest --output-on-failure -R \"format-impl-test|grisu-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout a5abe5d95cb8a8015913be9748a9661f3e1fbda8 \"test/format-impl-test.cc\" \"test/grisu-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout a5abe5d95cb8a8015913be9748a9661f3e1fbda8 \"test/format-impl-test.cc\" \"test/grisu-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\ncd build\n\n# Execute target tests using ctest, filtering by the specified test names.\n# The context indicates test names correspond to file names.\n# Ensure CTEST_OUTPUT_ON_FAILURE is set for detailed output.\nctest --output-on-failure -R \"format-impl-test|grisu-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout a5abe5d95cb8a8015913be9748a9661f3e1fbda8 \"test/format-impl-test.cc\" \"test/grisu-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 1390,
    "instance_id": "fmtlib__fmt-1390",
    "issue_numbers": [
      "1389"
    ],
    "base_commit": "d6eede9e085f0b36edcf0a2f6dff5f7875181019",
    "patch": "diff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -436,6 +436,24 @@ inline size_t count_code_points(basic_string_view<char8_t> s) {\n   return num_code_points;\n }\n \n+template <typename Char>\n+inline size_t code_point_index(basic_string_view<Char> s, size_t n) {\n+  size_t size = s.size();\n+  return n < size ? n : size;\n+}\n+\n+// Calculates the index of the nth code point in a UTF-8 string.\n+inline size_t code_point_index(basic_string_view<char8_t> s, size_t n) {\n+  const char8_t* data = s.data();\n+  size_t num_code_points = 0;\n+  for (size_t i = 0, size = s.size(); i != size; ++i) {\n+    if ((data[i] & 0xc0) != 0x80 && ++num_code_points > n) {\n+      return i;\n+    }\n+  }\n+  return s.size();\n+}\n+\n inline char8_t to_char8_t(char c) { return static_cast<char8_t>(c); }\n \n template <typename InputIt, typename OutChar>\n@@ -1729,7 +1747,8 @@ template <typename Range> class basic_writer {\n     const Char* data = s.data();\n     std::size_t size = s.size();\n     if (specs.precision >= 0 && internal::to_unsigned(specs.precision) < size)\n-      size = internal::to_unsigned(specs.precision);\n+      size = internal::code_point_index(s,\n+                                        internal::to_unsigned(specs.precision));\n     write(data, size, specs);\n   }\n \n",
    "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -2621,3 +2621,13 @@ TEST(FormatTest, FormatCustomChar) {\n   EXPECT_EQ(result.size(), 1);\n   EXPECT_EQ(result[0], mychar('x'));\n }\n+\n+TEST(FormatTest, FormatUTF8Precision) {\n+  using str_type = std::basic_string<char8_t>;\n+  str_type format(reinterpret_cast<const char8_t*>(u8\"{:.4}\"));\n+  str_type str(reinterpret_cast<const char8_t*>(u8\"caf\\u00e9s\")); // caf\u00e9s\n+  auto result = fmt::format(format, str);\n+  EXPECT_EQ(fmt::internal::count_code_points(result), 4);\n+  EXPECT_EQ(result.size(), 5);\n+  EXPECT_EQ(result, str.substr(0, 5));\n+}\n",
    "problem_statement": "UTF-8 truncation\nI've done some tests with UTF-8 strings, and think string formatting with precision doesn't work as expected.\r\n\r\nfmt::format(u8\"{:.4}\", u8\"caf\u00e9s\");\r\n\r\nThe format call above, even if done properly with char8_t based strings returns \"caf\\xc3\" instead of \"caf\u00e9\", where \"\\xc3\" is the first byte of the UTF-8 sequence \"\\xc3\\xa9\" for \"\u00e9\".  \n",
    "hints_text": "",
    "created_at": "2019-11-02T09:47:00Z",
    "version": "6.0",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ninja-build \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to testbed.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard d6eede9e085f0b36edcf0a2f6dff5f7875181019 && \\\n    git remote remove origin && \\\n    mkdir build && \\\n    cd build && \\\n    cmake -DFMT_TEST=ON -DCMAKE_BUILD_TYPE=Release .. && \\\n    cmake --build .",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\ngit checkout d6eede9e085f0b36edcf0a2f6dff5f7875181019 \"test/format-test.cc\"\n\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -2621,3 +2621,13 @@ TEST(FormatTest, FormatCustomChar) {\n   EXPECT_EQ(result.size(), 1);\n   EXPECT_EQ(result[0], mychar('x'));\n }\n+\n+TEST(FormatTest, FormatUTF8Precision) {\n+  using str_type = std::basic_string<char8_t>;\n+  str_type format(reinterpret_cast<const char8_t*>(u8\"{:.4}\"));\n+  str_type str(reinterpret_cast<const char8_t*>(u8\"caf\\u00e9s\")); // caf\u00e9s\n+  auto result = fmt::format(format, str);\n+  EXPECT_EQ(fmt::internal::count_code_points(result), 4);\n+  EXPECT_EQ(result.size(), 5);\n+  EXPECT_EQ(result, str.substr(0, 5));\n+}\nEOF_114329324912\n\n# Rebuild the test binary to include the new test\ncd /testbed/build\nmake -j$(nproc) || cmake --build . --parallel\n\n# Run the format-test specifically\nctest --output-on-failure -R \"format-test\"\nrc=$?\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Cleanup\ncd /testbed\ngit checkout d6eede9e085f0b36edcf0a2f6dff5f7875181019 \"test/format-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\ngit checkout d6eede9e085f0b36edcf0a2f6dff5f7875181019 \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\ncd build\n\n# Execute target tests using ctest, filtering by the specified test name.\n# The context indicates \"format-test.cc\" compiles into \"format-test\" executable/test.\nctest --output-on-failure -R \"format-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout d6eede9e085f0b36edcf0a2f6dff5f7875181019 \"test/format-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 1407,
    "instance_id": "fmtlib__fmt-1407",
    "issue_numbers": [
      "1369"
    ],
    "base_commit": "1f918159edded99c9c0cf005c96ecc12e4cc92b1",
    "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -541,14 +541,14 @@ struct FMT_DEPRECATED convert_to_int\n     : bool_constant<!std::is_arithmetic<T>::value &&\n                     std::is_convertible<T, int>::value> {};\n \n-namespace internal {\n-\n // Specifies if T has an enabled formatter specialization. A type can be\n // formattable even if it doesn't have a formatter e.g. via a conversion.\n template <typename T, typename Context>\n using has_formatter =\n     std::is_constructible<typename Context::template formatter_type<T>>;\n \n+namespace internal {\n+\n /** A contiguous memory buffer with an optional growing ability. */\n template <typename T> class buffer {\n  private:\n",
    "test_patch": "diff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -453,11 +453,11 @@ template <> struct formatter<enabled_formatter> {\n FMT_END_NAMESPACE\n \n TEST(CoreTest, HasFormatter) {\n-  using fmt::internal::has_formatter;\n+  // This should fail to compile because has_formatter is not in fmt:: namespace yet\n+  using fmt::has_formatter;\n   using context = fmt::format_context;\n   EXPECT_TRUE((has_formatter<enabled_formatter, context>::value));\n   EXPECT_FALSE((has_formatter<disabled_formatter, context>::value));\n   EXPECT_FALSE((has_formatter<disabled_formatter_convertible, context>::value));\n+  // No static_assert here - we want to test that the code fails to compile\n+  // because has_formatter is not in the public namespace\n }\n \n struct convertible_to_int {\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -1974,8 +1974,9 @@ enum TestEnum { A };\n TEST(FormatTest, Enum) { EXPECT_EQ(\"0\", fmt::format(\"{}\", A)); }\n \n TEST(FormatTest, FormatterNotSpecialized) {\n-  EXPECT_FALSE((fmt::internal::has_formatter<fmt::formatter<TestEnum>,\n-                                             fmt::format_context>::value));\n+  // This should fail to compile because has_formatter is not in fmt:: namespace yet\n+  EXPECT_FALSE((fmt::has_formatter<fmt::formatter<TestEnum>,\n+                                  fmt::format_context>::value));\n }\n \n #if FMT_HAS_FEATURE(cxx_strong_enums)\n",
    "problem_statement": "Detect if type is formattable in SFINAE-friendly way?\nIs there a way to detect if a type is formattable in a way that is SFINAE-friendly?  I am familiar with the `static_assert` that triggers inside fmt in this case, but is there a SFINAE-friendly way?  Thanks\n",
    "hints_text": "Not sure. There is `fmt::internal::has_formatter` that tells if `formatter` specialization is available, but it's not part of the public API.\nWould you have any recommendations on how I could write one?  I think it would be very useful to have such a thing for meta programming.\nHave you tried checking if `fmt::format` is invocable with `const char*` and `T` arguments?\nWhen you call `fmt::format` with `const char*` and `T` arguments, and if `T` is not formattable, then it will go here:\r\n```cpp\r\ntemplate <typename T, typename Char = char, typename Enable = void>\r\nstruct fallback_formatter {\r\n  static_assert(\r\n      no_formatter_error<T>::value,\r\n      \"don't know how to format the type, include fmt/ostream.h if it provides \"\r\n      \"an operator<< that should be used\");\r\n};\r\n```\r\nand trigger the `static_assert`, which is not a SFINAE-able error.  Furthermore, if we try putting it in a `decltype` like so:\r\n```cpp\r\nusing Test = decltype( fmt::format( \"{}\", std::declval<MyType>() ) );\r\n```\r\nThe line always compiles, for any type, and `Test` is `std::string` (so again this is not SFINAE-friendly).\r\n\r\nMy use case is that I need to be able to write something like this in my code:\r\n```cpp\r\nMyClass m;\r\nif constexpr( is_formattable<MyClass> ) {\r\n  fmt::print( \"{}\", m );\r\n}\r\n```\r\nAny way that this could be made possible?\n> Any way that this could be made possible?\r\n\r\n`no_formatter_error` is gone in the current master but there are other cases with static assert. I'm not entirely sure if this can be done in a more SFINAE-friendly way. In any case the quality of diagnostics for the common use should have higher priority. If it is of any help `has_formatter` can be moved to the public API.\r\n\nThanks; I'm not too familiar with the internal `has_formatter` -- if it could be used to solve my use case, then I would welcome it in the public API.  And I totally agree that we should not sacrifice quality of diagnostics in the common case.\n`has_formatter<T, Context>` tells you that type `T` has a `formatter` specialization for `Context` (context basically specifies character and output iterator types) and it can be used with SFINAE. Example: https://godbolt.org/z/pCD14x. The main caveat is that types with implicit conversion can be formattable but not have a `formatter` specialization.\nI think that is exactly what I need, and so it would be great to get that into the public API.\nCould you submit a PR moving `has_formatter` from `fmt::internal` to `fmt` then?\nOk I'll take a look.\nOne might think this is use case showing the right kind of usage of C++20 contracts ?\r\n```cpp\r\n  template<class... Args>\r\n    string format(string_view fmt, const Args&... args)\r\n   [[ expects: is_formatable( fmt, args... ) ]] ;\r\n```\r\n\r\nI am sure you know, but for the benefit of others here is [the short, succint and official on C++20 contracts.](https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/)\nNo, contracts are for runtime checks, this is a compile-time check. Those are done with `requires` from concepts.\nI stand corrected ... Saturday early morning is not for a GitHub chat :)\r\n\r\nAlthough, I see no harm done in applying that contract?\nThe contract would never fire, as the code doesn't compile if the condition is false.\n@foonathan , I have no required compiler to test this. In theory, I might prefer the 'expects axiom' contract?\r\n```cpp\r\n  template<class... Args>\r\n    string format(string_view fmt, const Args&... args)\r\n   [[ expects axiom: is_formatable( fmt, args... ) ]] ;\r\n```\r\nMy understanding is: `expects`  is for preconditions, and `axiom` modifier means : \"...the predicate is not checked at run-time\" ? \r\n\r\nPlease advise ...\nAn axiom check would be something like \"the passed pointer can be dereferenced\", which is a dynamic property that can't be verified.  Here we have a precondition like \"the pointer points to non const\", which is a static property checkable by the type system.\n\n(But anyway, this discussion is moot as contracts are not actually coming in C++20)\n## [But they are ?](https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/)\nThat is from 2018, they were again removed at the standardization meeting in July.\nApologies, my mistake ... again.",
    "created_at": "2019-11-13T14:14:23Z",
    "version": "6.0",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ninja-build \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to testbed.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard 1f918159edded99c9c0cf005c96ecc12e4cc92b1 && \\\n    git remote remove origin && \\\n    mkdir build && \\\n    cmake -S . -B build -D FMT_TEST=ON -D CMAKE_BUILD_TYPE=Release && \\\n    cmake --build build",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root as operations like git checkout from a specific path require it.\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch.\n# This resets them to the state at the target commit SHA, undoing any previous changes (e.g., from prior patch applications).\ngit checkout 1f918159edded99c9c0cf005c96ecc12e4cc92b1 \"\"\n\n# Required: apply test patch to update target tests (if any).\n# The actual content of the patch will be inserted here by the system.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -453,11 +453,11 @@ template <> struct formatter<enabled_formatter> {\n FMT_END_NAMESPACE\n \n TEST(CoreTest, HasFormatter) {\n-  using fmt::internal::has_formatter;\n+  using fmt::has_formatter;\n   using context = fmt::format_context;\n-  EXPECT_TRUE((has_formatter<enabled_formatter, context>::value));\n-  EXPECT_FALSE((has_formatter<disabled_formatter, context>::value));\n-  EXPECT_FALSE((has_formatter<disabled_formatter_convertible, context>::value));\n+  static_assert(has_formatter<enabled_formatter, context>::value, \"\");\n+  static_assert(!has_formatter<disabled_formatter, context>::value, \"\");\n+  static_assert(!has_formatter<disabled_formatter_convertible, context>::value, \"\");\n }\n \n struct convertible_to_int {\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -1974,8 +1974,8 @@ enum TestEnum { A };\n TEST(FormatTest, Enum) { EXPECT_EQ(\"0\", fmt::format(\"{}\", A)); }\n \n TEST(FormatTest, FormatterNotSpecialized) {\n-  EXPECT_FALSE((fmt::internal::has_formatter<fmt::formatter<TestEnum>,\n-                                             fmt::format_context>::value));\n+  static_assert(!fmt::has_formatter<fmt::formatter<TestEnum>,\n+                                    fmt::format_context>::value, \"\");\n }\n \n #if FMT_HAS_FEATURE(cxx_strong_enums)\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile.\n# Tests are typically executed from this directory after compilation.\ncd build\n\n# Execute target tests using ctest.\n# We use the -R (regex) option to run only the tests corresponding to the specified files.\n# \"test/core-test.cc\" and \"test/format-test.cc\" usually compile into test executables named \"core-test\" and \"format-test\" respectively.\n# --output-on-failure ensures that test output is only shown if a test fails, keeping the log clean for successful runs.\nctest --output-on-failure -R \"(core-test|format-test)\"\nrc=$? # Capture the exit code of the test command immediately.\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required: Echo the captured exit code for result parsing.\n\n# Cleanup: Revert changes made by the patch to the target test files.\n# Navigate back to the repository root first to ensure `git checkout` operates correctly on paths relative to the root.\ncd /testbed\ngit checkout 1f918159edded99c9c0cf005c96ecc12e4cc92b1 \"test/core-test.cc\" \"test/format-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root as operations like git checkout from a specific path require it.\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch.\n# This resets them to the state at the target commit SHA, undoing any previous changes (e.g., from prior patch applications).\ngit checkout 1f918159edded99c9c0cf005c96ecc12e4cc92b1 \"test/core-test.cc\" \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any).\n# The actual content of the patch will be inserted here by the system.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile.\n# Tests are typically executed from this directory after compilation.\ncd build\n\n# Execute target tests using ctest.\n# We use the -R (regex) option to run only the tests corresponding to the specified files.\n# \"test/core-test.cc\" and \"test/format-test.cc\" usually compile into test executables named \"core-test\" and \"format-test\" respectively.\n# --output-on-failure ensures that test output is only shown if a test fails, keeping the log clean for successful runs.\nctest --output-on-failure -R \"(core-test|format-test)\"\nrc=$? # Capture the exit code of the test command immediately.\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required: Echo the captured exit code for result parsing.\n\n# Cleanup: Revert changes made by the patch to the target test files.\n# Navigate back to the repository root first to ensure `git checkout` operates correctly on paths relative to the root.\ncd /testbed\ngit checkout 1f918159edded99c9c0cf005c96ecc12e4cc92b1 \"test/core-test.cc\" \"test/format-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 149,
    "instance_id": "fmtlib__fmt-149",
    "issue_numbers": [
      "143"
    ],
    "base_commit": "88f4be3d19364a484431309f750535386c7d0d5c",
    "patch": "diff --git a/format.h b/format.h\n--- a/format.h\n+++ b/format.h\n@@ -707,9 +707,8 @@ struct NonZero {\n   enum { VALUE = N > 0 ? N : 1 };\n };\n \n-// A formatting argument. It is a POD type to allow storage in\n-// internal::MemoryBuffer.\n-struct Arg {\n+// A formatting argument value.\n+struct Value {\n   template <typename Char>\n   struct StringValue {\n     const Char *value;\n@@ -747,6 +746,11 @@ struct Arg {\n     DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,\n     CSTRING, STRING, WSTRING, POINTER, CUSTOM\n   };\n+};\n+\n+// A formatting argument. It is a POD type to allow storage in\n+// internal::MemoryBuffer.\n+struct Arg : Value {\n   Type type;\n };\n \n@@ -800,6 +804,12 @@ struct EnableIf {};\n template<class T>\n struct EnableIf<true, T> { typedef T type; };\n \n+template<bool B, class T, class F>\n+struct Conditional { typedef T type; };\n+\n+template<class T, class F>\n+struct Conditional<false, T, F> { typedef F type; };\n+\n // A helper function to suppress bogus \"conditional expression is constant\"\n // warnings.\n inline bool check(bool value) { return value; }\n@@ -1068,7 +1078,15 @@ class ArgList {\n   // To reduce compiled code size per formatting function call, types of first\n   // MAX_PACKED_ARGS arguments are passed in the types_ field.\n   uint64_t types_;\n-  const internal::Arg *args_;\n+  union {\n+    // If the number of arguments is less than MAX_PACKED_ARGS, the argument\n+    // values are stored in values_, otherwise they are stored in args_.\n+    // This is done to reduce compiled code size as storing larger objects\n+    // may require more code (at least on x86-64) even if the same amount of\n+    // data is actually copied to stack. It saves ~10% on the bloat test.\n+    const internal::Value *values_;\n+    const internal::Arg *args_;\n+  };\n \n   internal::Arg::Type type(unsigned index) const {\n     unsigned shift = index * 4;\n@@ -1082,6 +1100,10 @@ class ArgList {\n   enum { MAX_PACKED_ARGS = 16 };\n \n   ArgList() : types_(0) {}\n+\n+  // TODO: MakeArgList(const Args &...)\n+  ArgList(ULongLong types, const internal::Value *values)\n+  : types_(types), values_(values) {}\n   ArgList(ULongLong types, const internal::Arg *args)\n   : types_(types), args_(args) {}\n \n@@ -1089,14 +1111,18 @@ class ArgList {\n   internal::Arg operator[](unsigned index) const {\n     using internal::Arg;\n     Arg arg;\n+    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;\n     if (index < MAX_PACKED_ARGS) {\n       Arg::Type arg_type = type(index);\n+      internal::Value &val = arg;\n       if (arg_type != Arg::NONE)\n-        arg = args_[index];\n+        val = use_values ? values_[index] : args_[index];\n       arg.type = arg_type;\n       return arg;\n     }\n-    if (type(MAX_PACKED_ARGS - 1) == Arg::NONE) {\n+    if (use_values) {\n+      // The index is greater than the number of arguments that can be stored\n+      // in values, so return a \"none\" argument.\n       arg.type = Arg::NONE;\n       return arg;\n     }\n@@ -1112,6 +1138,12 @@ struct FormatSpec;\n \n namespace internal {\n \n+template <std::size_t NUM_ARGS>\n+struct SelectValueType {\n+  typedef typename Conditional<\n+    (NUM_ARGS < ArgList::MAX_PACKED_ARGS), Value, Arg>::type Type;\n+};\n+\n class FormatterBase {\n  private:\n   ArgList args_;\n@@ -1463,23 +1495,25 @@ inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n # define FMT_VARIADIC_VOID(func, arg_type) \\\n   template <typename... Args> \\\n   void func(arg_type arg1, const Args & ... args) { \\\n-    const fmt::internal::Arg array[ \\\n-      fmt::internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n-      fmt::internal::MakeValue<Char>(args)... \\\n+    namespace internal = fmt::internal; \\\n+    typedef typename internal::SelectValueType<sizeof...(Args)>::Type Value; \\\n+    const Value array[ \\\n+      internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n+      internal::MakeValue<Char>(args)... \\\n     }; \\\n-    func(arg1, ArgList(fmt::internal::make_type(args...), array)); \\\n+    func(arg1, ArgList(internal::make_type(args...), array)); \\\n   }\n \n // Defines a variadic constructor.\n # define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n   template <typename... Args> \\\n   ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \\\n-    using fmt::internal::MakeValue; \\\n-    const fmt::internal::Arg array[ \\\n-        fmt::internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n-      MakeValue<Char>(args)... \\\n+    namespace internal = fmt::internal; \\\n+    typedef typename internal::SelectValueType<sizeof...(Args)>::Type Value; \\\n+    const Value array[internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n+      internal::MakeValue<Char>(args)... \\\n     }; \\\n-    func(arg0, arg1, ArgList(fmt::internal::make_type(args...), array)); \\\n+    func(arg0, arg1, ArgList(internal::make_type(args...), array)); \\\n   }\n \n #else\n@@ -1492,9 +1526,9 @@ inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n # define FMT_WRAP1(func, arg_type, n) \\\n   template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n   inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n-    const fmt::internal::Arg args[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n+    const fmt::internal::Value values[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n     func(arg1, fmt::ArgList( \\\n-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), args)); \\\n+      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), values)); \\\n   }\n \n // Emulates a variadic function returning void on a pre-C++11 compiler.\n@@ -1509,9 +1543,9 @@ inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n # define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \\\n   template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n   ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n-    const fmt::internal::Arg args[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n+    const fmt::internal::Value values[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n     func(arg0, arg1, fmt::ArgList( \\\n-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), args)); \\\n+      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), values)); \\\n   }\n \n // Emulates a variadic constructor on a pre-C++11 compiler.\n@@ -2619,6 +2653,11 @@ inline void set_types(Arg *array, const Args & ... args) {\n   array[sizeof...(Args)].type = Arg::NONE;\n }\n \n+template <typename... Args>\n+inline void set_types(Value *, const Args & ...) {\n+  // Do nothing as types are passed separately from values.\n+}\n+\n // Computes the argument array size by adding 1 to N, which is the number of\n // arguments, if N is zero, because array of zero size is invalid, or if N\n // is greater than ArgList::MAX_PACKED_ARGS to accommodate for an extra\n@@ -2634,14 +2673,15 @@ struct ArgArraySize {\n   template <typename... Args> \\\n   ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n       const Args & ... args) { \\\n-    using fmt::internal::Arg; \\\n-    Arg array[fmt::internal::ArgArraySize<sizeof...(Args)>::VALUE] = { \\\n-      fmt::internal::MakeValue<Char>(args)... \\\n+    namespace internal = fmt::internal; \\\n+    typedef typename internal::SelectValueType<sizeof...(Args)>::Type Value; \\\n+    Value array[internal::ArgArraySize<sizeof...(Args)>::VALUE] = { \\\n+      internal::MakeValue<Char>(args)... \\\n     }; \\\n-    if (fmt::internal::check((sizeof...(Args) > fmt::ArgList::MAX_PACKED_ARGS))) \\\n+    if (internal::check((sizeof...(Args) > fmt::ArgList::MAX_PACKED_ARGS))) \\\n       set_types(array, args...); \\\n     call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \\\n-      fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n+      fmt::ArgList(internal::make_type(args...), array)); \\\n   }\n #else\n // Defines a wrapper for a function taking __VA_ARGS__ arguments\n@@ -2650,9 +2690,9 @@ struct ArgArraySize {\n   template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n   inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n       FMT_GEN(n, FMT_MAKE_ARG)) { \\\n-    const fmt::internal::Arg args[] = {FMT_GEN(n, FMT_MAKE_REF_##Char)}; \\\n+    const fmt::internal::Value values[] = {FMT_GEN(n, FMT_MAKE_REF_##Char)}; \\\n     call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \\\n-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), args)); \\\n+      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), values)); \\\n   }\n \n # define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \\\n",
    "test_patch": "diff --git a/test/util-test.cc b/test/util-test.cc\n--- a/test/util-test.cc\n+++ b/test/util-test.cc\n@@ -423,7 +423,7 @@ ARG_INFO(POINTER, const void *, pointer);\n ARG_INFO(CUSTOM, Arg::CustomValue, custom);\n \n #define CHECK_ARG_INFO(Type, field, value) { \\\n-  Arg arg = {}; \\\n+  Arg arg = Arg(); \\\n   arg.field = value; \\\n   EXPECT_EQ(value, ArgInfo<Arg::Type>::get(arg)); \\\n }\n@@ -442,7 +442,7 @@ TEST(ArgTest, ArgInfo) {\n   CHECK_ARG_INFO(WSTRING, wstring.value, WSTR);\n   int p = 0;\n   CHECK_ARG_INFO(POINTER, pointer, &p);\n-  Arg arg = {};\n+  Arg arg = Arg();\n   arg.custom.value = &p;\n   EXPECT_EQ(&p, ArgInfo<Arg::CUSTOM>::get(arg).value);\n }\n@@ -842,3 +842,30 @@ TEST(UtilTest, IsEnumConvertibleToInt) {\n }\n #endif\n \n+template <typename T>\n+bool check_enable_if(\n+    typename fmt::internal::EnableIf<sizeof(T) == sizeof(int), T>::type *) {\n+  return true;\n+}\n+\n+template <typename T>\n+bool check_enable_if(\n+    typename fmt::internal::EnableIf<sizeof(T) != sizeof(int), T>::type *) {\n+  return false;\n+}\n+\n+TEST(UtilTest, EnableIf) {\n+  int i = 0;\n+  EXPECT_TRUE(check_enable_if<int>(&i));\n+  char c = 0;\n+  EXPECT_FALSE(check_enable_if<char>(&c));\n+}\n+\n+TEST(UtilTest, Conditional) {\n+  int i = 0;\n+  fmt::internal::Conditional<true, int, char>::type *pi = &i;\n+  (void)pi;\n+  char c = 0;\n+  fmt::internal::Conditional<false, int, char>::type *pc = &c;\n+  (void)pc;\n+}\n",
    "problem_statement": "Make sure that support for arbitrary number of arguments doesn't increase compiled code size\nCompiled code size has been reduced in https://github.com/cppformat/cppformat/commit/cf04d98d0663296b4d4c56fd24f617aa14e079f3, but need to check that there is no regression compared to version 1.1.0.\n\n",
    "hints_text": "Target: 34912\nCurrent: 47200\nPartially caused by zero initialization of extra argument. Can be easily bypassed when the number of arguments is less than `MAX_PACKED_ARGS`.\n\nAfter https://github.com/cppformat/cppformat/commit/2ba3988da3af477ab40da67e3e3289a53893a245: 39008\n\nSo the remaining difference is only due to increase in allocated stack size:\n\n![screenshot from 2015-03-25 21 53 46](https://cloud.githubusercontent.com/assets/576385/6840625/990770ce-d339-11e4-8b65-ef189e684109.png)\n\nwhich can be fixed by using a union of `(Value*, Arg*)`.\n",
    "created_at": "2015-04-20T15:34:08Z",
    "version": "1.1",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM --platform=linux/x86_64 ubuntu:22.04\n\n# Set environment variables for non-interactive apt operations and timezone\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\n# build-essential: Provides GNU compiler collection (GCC/g++), make, and other development utilities.\n# cmake: Build system generator.\n# git: Version control system for cloning the repository and managing submodules.\n# gdb: GNU Debugger, required for diagnosing runtime crashes like SegFaults.\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    gdb \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set the working directory inside the container\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, and configures it.\n# 1. Clone the fmtlib/fmt repository into the /testbed directory.\n# 2. Checkout the specific commit SHA to ensure reproducibility.\n# 3. Update Git submodules, which fetch necessary dependencies like Google Test/Mock.\n# 4. Create a 'build' directory, navigate into it, configure the project with CMake,\n#    and then build the project and its tests using 'make'.\n#    -DCMAKE_BUILD_TYPE=Debug configures a debug build with symbols, essential for GDB.\n#    -DFMT_EXTRA_TESTS=ON enables the building of tests.\n#    make -j$(nproc) compiles the project using all available CPU cores.\nRUN git clone https://github.com/fmtlib/fmt . && \\\n    git reset --hard 88f4be3d19364a484431309f750535386c7d0d5c && \\\n    git submodule update --init && \\\n    mkdir build && \\\n    cd build && \\\n    cmake -DCMAKE_BUILD_TYPE=Debug -DFMT_EXTRA_TESTS=ON .. && \\\n    make -j$(nproc)",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Ensure the target test file is at the specified commit SHA before applying any patch\ngit checkout 88f4be3d19364a484431309f750535386c7d0d5c \"test/util-test.cc\"\n\n# Apply the test patch to the relevant files.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/util-test.cc b/test/util-test.cc\n--- a/test/util-test.cc\n+++ b/test/util-test.cc\n@@ -423,7 +423,7 @@ ARG_INFO(POINTER, const void *, pointer);\n ARG_INFO(CUSTOM, Arg::CustomValue, custom);\n \n #define CHECK_ARG_INFO(Type, field, value) { \\\n-  Arg arg = {}; \\\n+  Arg arg = Arg(); \\\n   arg.field = value; \\\n   EXPECT_EQ(value, ArgInfo<Arg::Type>::get(arg)); \\\n }\n@@ -442,7 +442,7 @@ TEST(ArgTest, ArgInfo) {\n   CHECK_ARG_INFO(WSTRING, wstring.value, WSTR);\n   int p = 0;\n   CHECK_ARG_INFO(POINTER, pointer, &p);\n-  Arg arg = {};\n+  Arg arg = Arg();\n   arg.custom.value = &p;\n   EXPECT_EQ(&p, ArgInfo<Arg::CUSTOM>::get(arg).value);\n }\n@@ -842,3 +842,30 @@ TEST(UtilTest, IsEnumConvertibleToInt) {\n }\n #endif\n \n+template <typename T>\n+bool check_enable_if(\n+    typename fmt::internal::EnableIf<sizeof(T) == sizeof(int), T>::type *) {\n+  return true;\n+}\n+\n+template <typename T>\n+bool check_enable_if(\n+    typename fmt::internal::EnableIf<sizeof(T) != sizeof(int), T>::type *) {\n+  return false;\n+}\n+\n+TEST(UtilTest, EnableIf) {\n+  int i = 0;\n+  EXPECT_TRUE(check_enable_if<int>(&i));\n+  char c = 0;\n+  EXPECT_FALSE(check_enable_if<char>(&c));\n+}\n+\n+TEST(UtilTest, Conditional) {\n+  int i = 0;\n+  fmt::internal::Conditional<true, int, char>::type *pi = &i;\n+  (void)pi;\n+  char c = 0;\n+  fmt::internal::Conditional<false, int, char>::type *pc = &c;\n+  (void)pc;\n+}\nEOF_114329324912\n\n# Perform a clean and full rebuild after applying the patch.\n# Build in Debug mode to include debug symbols for better GDB backtraces.\ncd /testbed\nrm -rf build # Remove existing build directory\nmkdir build # Create a new build directory\ncd build\ncmake -DCMAKE_BUILD_TYPE=Debug -DFMT_EXTRA_TESTS=ON .. # Reconfigure CMake with Debug build type\nmake -j$(nproc) # Perform a full clean build\n\n# Execute the specified target test file using CTest.\n# Capture its exit code to determine if it crashed.\nCTEST_OUTPUT_ON_FAILURE=1 ctest -R util-test\nrc=$?\n\n# If the test crashed (ctest returns non-zero for failure, often 8 for segfault),\n# run GDB to get a backtrace for diagnostic purposes.\nif [ $rc -ne 0 ]; then\n  echo \"--- Test failed (${rc}), attempting to get GDB backtrace for util-test ---\"\n  # Temporarily disable exit on error for GDB command, as GDB itself might return non-zero\n  # even if it successfully captures a backtrace from a crashing program.\n  set +e\n  /usr/bin/gdb -ex \"set pagination off\" -ex \"run\" -ex \"thread apply all bt full\" -ex \"quit\" --batch --args /testbed/build/bin/util-test\n  # Re-enable exit on error for the rest of the script, if any.\n  set -e\nfi\n\n# Report the overall test result based on the CTest execution outcome.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up: revert changes made by the patch to the target test file\ncd /testbed\ngit checkout 88f4be3d19364a484431309f750535386c7d0d5c \"test/util-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Ensure the target test file is at the specified commit SHA before applying any patch\ngit checkout 88f4be3d19364a484431309f750535386c7d0d5c \"test/util-test.cc\"\n\n# Apply the test patch to the relevant files.\ngit apply -v - <<'EOF_114329324912'\n--- a/test/util-test.cc\n+++ b/test/util-test.cc\n@@ -101,3 +101,7 @@\n TEST(UtilTest, IsUnicodeScalarWithChar8t) {\n   EXPECT_TRUE(is_unicode_scalar(u8'\\U0001F600'));\n }\n+#endif // __cpp_lib_char8_t\n+\n+TEST(UtilTest, BasicFormatting) {\n+  EXPECT_EQ(fmt::format(\"{}\", 42), \"42\");\n+}\nEOF_114329324912\n\n# Perform a clean and full rebuild after applying the patch.\n# Build in Debug mode to include debug symbols for better GDB backtraces.\ncd /testbed\nrm -rf build # Remove existing build directory\nmkdir build # Create a new build directory\ncd build\ncmake -DCMAKE_BUILD_TYPE=Debug -DFMT_EXTRA_TESTS=ON .. # Reconfigure CMake with Debug build type\nmake -j$(nproc) # Perform a full clean build\n\n# Execute the specified target test file using CTest.\n# Capture its exit code to determine if it crashed.\nCTEST_OUTPUT_ON_FAILURE=1 ctest -R util-test\nrc=$?\n\n# If the test crashed (ctest returns non-zero for failure, often 8 for segfault),\n# run GDB to get a backtrace for diagnostic purposes.\nif [ $rc -ne 0 ]; then\n  echo \"--- Test failed (${rc}), attempting to get GDB backtrace for util-test ---\"\n  # Temporarily disable exit on error for GDB command, as GDB itself might return non-zero\n  # even if it successfully captures a backtrace from a crashing program.\n  set +e\n  /usr/bin/gdb -ex \"set pagination off\" -ex \"run\" -ex \"thread apply all bt full\" -ex \"quit\" --batch --args /testbed/build/bin/util-test\n  # Re-enable exit on error for the rest of the script, if any.\n  set -e\nfi\n\n# Report the overall test result based on the CTest execution outcome.\necho \"OMNIGRIL_EXIT_CODE=$rc\"\n\n# Clean up: revert changes made by the patch to the target test file\ncd /testbed\ngit checkout 88f4be3d19364a484431309f750535386c7d0d5c \"test/util-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 1663,
    "instance_id": "fmtlib__fmt-1663",
    "issue_numbers": [
      "1655"
    ],
    "base_commit": "8d9d528bf52c60864802844e8acf16db09dae19a",
    "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -629,6 +629,7 @@ using wparse_context FMT_DEPRECATED_ALIAS = basic_format_parse_context<wchar_t>;\n \n template <typename Context> class basic_format_arg;\n template <typename Context> class basic_format_args;\n+template <typename Context> class dynamic_format_arg_store;\n \n // A formatter for objects of type T.\n template <typename T, typename Char = char, typename Enable = void>\n@@ -1131,6 +1132,7 @@ template <typename Context> class basic_format_arg {\n \n   friend class basic_format_args<Context>;\n   friend class internal::arg_map<Context>;\n+  friend class dynamic_format_arg_store<Context>;\n \n   using char_type = typename Context::char_type;\n \n@@ -1269,10 +1271,14 @@ inline basic_format_arg<Context> make_arg(const T& value) {\n }\n \n template <typename T> struct is_reference_wrapper : std::false_type {};\n-\n template <typename T>\n struct is_reference_wrapper<std::reference_wrapper<T>> : std::true_type {};\n \n+template <typename T> const T& unwrap(const T& v) { return v; }\n+template <typename T> const T& unwrap(const std::reference_wrapper<T>& v) {\n+  return static_cast<const T&>(v);\n+}\n+\n class dynamic_arg_list {\n   // Workaround for clang's -Wweak-vtables. Unlike for regular classes, for\n   // templates it doesn't complain about inability to deduce single translation\n@@ -1419,6 +1425,50 @@ inline format_arg_store<Context, Args...> make_format_args(\n   return {args...};\n }\n \n+namespace internal {\n+template <typename Char> struct named_arg_base {\n+  const Char* name;\n+\n+  // Serialized value<context>.\n+  mutable char data[sizeof(basic_format_arg<buffer_context<Char>>)];\n+\n+  named_arg_base(const Char* nm) : name(nm) {}\n+\n+  template <typename Context> basic_format_arg<Context> deserialize() const {\n+    basic_format_arg<Context> arg;\n+    std::memcpy(&arg, data, sizeof(basic_format_arg<Context>));\n+    return arg;\n+  }\n+};\n+\n+struct view {};\n+\n+template <typename T, typename Char>\n+struct named_arg : view, named_arg_base<Char> {\n+  const T& value;\n+\n+  named_arg(const Char* name, const T& val)\n+      : named_arg_base<Char>(name), value(val) {}\n+};\n+\n+}  // namespace internal\n+\n+/**\n+  \\rst\n+  Returns a named argument to be used in a formatting function. It should only\n+  be used in a call to a formatting function.\n+\n+  **Example**::\n+\n+    fmt::print(\"Elapsed time: {s:.2f} seconds\", fmt::arg(\"s\", 1.23));\n+  \\endrst\n+ */\n+template <typename Char, typename T>\n+inline internal::named_arg<T, Char> arg(const Char* name, const T& arg) {\n+  static_assert(!internal::is_named_arg<T>(), \"nested named arguments\");\n+  return {name, arg};\n+}\n+\n /**\n   \\rst\n   A dynamic version of `fmt::format_arg_store<>`.\n@@ -1449,8 +1499,7 @@ class dynamic_format_arg_store\n                 std::is_same<T, internal::std_string_view<char_type>>::value ||\n                 (mapped_type != internal::type::cstring_type &&\n                  mapped_type != internal::type::string_type &&\n-                 mapped_type != internal::type::custom_type &&\n-                 mapped_type != internal::type::named_arg_type))\n+                 mapped_type != internal::type::custom_type))\n     };\n   };\n \n@@ -1460,6 +1509,7 @@ class dynamic_format_arg_store\n \n   // Storage of basic_format_arg must be contiguous.\n   std::vector<basic_format_arg<Context>> data_;\n+  std::vector<internal::named_arg_info<char_type>> named_info_;\n \n   // Storage of arguments not fitting into basic_format_arg must grow\n   // without relocation because items in data_ refer to it.\n@@ -1468,13 +1518,38 @@ class dynamic_format_arg_store\n   friend class basic_format_args<Context>;\n \n   unsigned long long get_types() const {\n-    return internal::is_unpacked_bit | data_.size();\n+    return internal::is_unpacked_bit | data_.size() |\n+           (named_info_.empty() ? 0ULL\n+                                : static_cast<unsigned long long>(\n+                                      internal::has_named_args_bit));\n+  }\n+\n+  const basic_format_arg<Context>* data() const {\n+    return named_info_.empty() ? data_.data() : data_.data() + 1;\n   }\n \n   template <typename T> void emplace_arg(const T& arg) {\n     data_.emplace_back(internal::make_arg<Context>(arg));\n   }\n \n+  template <typename T>\n+  void emplace_arg(const internal::named_arg<T, char_type>& arg) {\n+    if (named_info_.empty()) {\n+      constexpr const internal::named_arg_info<char_type>* zero_ptr{nullptr};\n+      data_.insert(data_.begin(), {zero_ptr, 0});\n+    }\n+    data_.emplace_back(\n+        internal::make_arg<Context>(internal::unwrap(arg.value)));\n+    auto pop_one = [](std::vector<basic_format_arg<Context>>* data) {\n+      data->pop_back();\n+    };\n+    std::unique_ptr<std::vector<basic_format_arg<Context>>, decltype(pop_one)>\n+        guard{&data_, pop_one};\n+    named_info_.push_back({arg.name, static_cast<int>(data_.size() - 2u)});\n+    data_[0].value_.named_args = {named_info_.data(), named_info_.size()};\n+    guard.release();\n+  }\n+\n  public:\n   /**\n     \\rst\n@@ -1500,19 +1575,54 @@ class dynamic_format_arg_store\n     if (internal::const_check(need_copy<T>::value))\n       emplace_arg(dynamic_args_.push<stored_type<T>>(arg));\n     else\n-      emplace_arg(arg);\n+      emplace_arg(internal::unwrap(arg));\n   }\n \n   /**\n+    \\rst\n     Adds a reference to the argument into the dynamic store for later passing to\n-    a formating function.\n+    a formating function. Supports named arguments wrapped in\n+    std::reference_wrapper (via std::ref()/std::cref()).\n+\n+    **Example**::\n+      fmt::dynamic_format_arg_store<fmt::format_context> store;\n+      char str[] = \"1234567890\";\n+      store.push_back(std::cref(str));\n+      int a1_val{42};\n+      auto a1 = fmt::arg(\"a1_\", a1_val);\n+      store.push_back(std::cref(a1));\n+\n+      // Changing str affects the output but only for string and custom types.\n+      str[0] = 'X';\n+\n+      std::string result = fmt::vformat(\"{} and {a1_}\");\n+      assert(result == \"X234567890 and 42\");\n+    \\endrst\n   */\n   template <typename T> void push_back(std::reference_wrapper<T> arg) {\n     static_assert(\n-        need_copy<T>::value,\n+        internal::is_named_arg<typename std::remove_cv<T>::type>::value ||\n+            need_copy<T>::value,\n         \"objects of built-in types and string views are always copied\");\n     emplace_arg(arg.get());\n   }\n+\n+  /**\n+    Adds named argument into the dynamic store for later passing to a formating\n+    function. std::reference_wrapper is supported to avoid copying of the\n+    argument.\n+  */\n+  template <typename T>\n+  void push_back(const internal::named_arg<T, char_type>& arg) {\n+    const char_type* arg_name =\n+        dynamic_args_.push<std::basic_string<char_type>>(arg.name).c_str();\n+    if (internal::const_check(need_copy<T>::value)) {\n+      emplace_arg(\n+          fmt::arg(arg_name, dynamic_args_.push<stored_type<T>>(arg.value)));\n+    } else {\n+      emplace_arg(fmt::arg(arg_name, arg.value));\n+    }\n+  }\n };\n \n /**\n@@ -1597,7 +1707,7 @@ template <typename Context> class basic_format_args {\n    \\endrst\n    */\n   FMT_INLINE basic_format_args(const dynamic_format_arg_store<Context>& store)\n-      : basic_format_args(store.get_types(), store.data_.data()) {}\n+      : basic_format_args(store.get_types(), store.data()) {}\n \n   /**\n    \\rst\n@@ -1659,31 +1769,6 @@ template <typename Container>\n struct is_contiguous_back_insert_iterator<std::back_insert_iterator<Container>>\n     : is_contiguous<Container> {};\n \n-template <typename Char> struct named_arg_base {\n-  const Char* name;\n-\n-  // Serialized value<context>.\n-  mutable char data[sizeof(basic_format_arg<buffer_context<Char>>)];\n-\n-  named_arg_base(const Char* nm) : name(nm) {}\n-\n-  template <typename Context> basic_format_arg<Context> deserialize() const {\n-    basic_format_arg<Context> arg;\n-    std::memcpy(&arg, data, sizeof(basic_format_arg<Context>));\n-    return arg;\n-  }\n-};\n-\n-struct view {};\n-\n-template <typename T, typename Char>\n-struct named_arg : view, named_arg_base<Char> {\n-  const T& value;\n-\n-  named_arg(const Char* name, const T& val)\n-      : named_arg_base<Char>(name), value(val) {}\n-};\n-\n // Reports a compile-time error if S is not a valid format string.\n template <typename..., typename S, FMT_ENABLE_IF(!is_compile_string<S>::value)>\n FMT_INLINE void check_format_string(const S&) {\n@@ -1727,22 +1812,6 @@ inline void vprint_mojibake(std::FILE*, string_view, format_args) {}\n #endif\n }  // namespace internal\n \n-/**\n-  \\rst\n-  Returns a named argument to be used in a formatting function. It should only\n-  be used in a call to a formatting function.\n-\n-  **Example**::\n-\n-    fmt::print(\"Elapsed time: {s:.2f} seconds\", fmt::arg(\"s\", 1.23));\n-  \\endrst\n- */\n-template <typename Char, typename T>\n-inline internal::named_arg<T, Char> arg(const Char* name, const T& arg) {\n-  static_assert(!internal::is_named_arg<T>(), \"nested named arguments\");\n-  return {name, arg};\n-}\n-\n /** Formats a string and writes the output to ``out``. */\n // GCC 8 and earlier cannot handle std::back_insert_iterator<Container> with\n // vformat_to<ArgFormatter>(...) overload, so SFINAE on iterator type instead.\n",
    "test_patch": "diff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -456,6 +456,66 @@ TEST(FormatDynArgsTest, CustomFormat) {\n   EXPECT_EQ(\"cust=0 and cust=1 and cust=3\", result);\n }\n \n+TEST(FormatDynArgsTest, NamedInt) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+  store.push_back(fmt::arg(\"a1\", 42));\n+  std::string result = fmt::vformat(\"{a1}\", store);\n+  EXPECT_EQ(\"42\", result);\n+}\n+\n+TEST(FormatDynArgsTest, NamedStrings) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+  char str[]{\"1234567890\"};\n+  store.push_back(fmt::arg(\"a1\", str));\n+  store.push_back(fmt::arg(\"a2\", std::cref(str)));\n+  str[0] = 'X';\n+\n+  std::string result = fmt::vformat(\n+      \"{a1} and {a2}\",\n+      store);\n+\n+  EXPECT_EQ(\"1234567890 and X234567890\", result);\n+}\n+\n+TEST(FormatDynArgsTest, NamedArgByRef) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+\n+  // Note: fmt::arg() constructs an object which holds a reference\n+  // to its value. It's not an aggregate, so it doesn't extend the\n+  // reference lifetime. As a result, it's a very bad idea passing temporary\n+  // as a named argument value. Only GCC with optimization level >0\n+  // complains about this.\n+  //\n+  // A real life usecase is when you have both name and value alive\n+  // guarantee their lifetime and thus don't want them to be copied into\n+  // storages.\n+  int a1_val{42};\n+  auto a1 = fmt::arg(\"a1_\", a1_val);\n+  store.push_back(\"abc\");\n+  store.push_back(1.5f);\n+  store.push_back(std::cref(a1));\n+\n+  std::string result = fmt::vformat(\n+      \"{a1_} and {} and {} and {}\",\n+      store);\n+\n+  EXPECT_EQ(\"42 and abc and 1.5 and 42\", result);\n+}\n+\n+TEST(FormatDynArgsTest, NamedCustomFormat) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+  custom_type c{};\n+  store.push_back(fmt::arg(\"c1\", c));\n+  ++c.i;\n+  store.push_back(fmt::arg(\"c2\", c));\n+  ++c.i;\n+  store.push_back(fmt::arg(\"c_ref\", std::cref(c)));\n+  ++c.i;\n+\n+  std::string result = fmt::vformat(\"{c1} and {c2} and {c_ref}\", store);\n+  EXPECT_EQ(\"cust=0 and cust=1 and cust=3\", result);\n+}\n+\n struct copy_throwable {\n   copy_throwable() {}\n   copy_throwable(const copy_throwable&) { throw \"deal with it\"; }\n",
    "problem_statement": "Dynamic construction of *named* argument lists?\nHey, I noticed in the latest release that there is now a `dynamic_format_arg_store`, but it doesn't support named arguments. Is there a plan to add such capability? I'm thinking of something along the lines of:\r\n```\r\nfmt::dynamic_format_named_argument_store<fmt::format_context> store;\r\nstore.emplace_back(\"name\", 123);\r\nstore.emplace_back(\"another_name\", 456);\r\nfmt::vprint(\"{name} + {another_name}\", store);\r\n```\r\nWould this be hard to implement? I can take a crack at it given some starting guidance.\n",
    "hints_text": "",
    "created_at": "2020-05-03T19:39:17Z",
    "version": "6.2",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ninja-build \\\n    curl \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to testbed.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard 8d9d528bf52c60864802844e8acf16db09dae19a && \\\n    mkdir build && \\\n    cmake -S . -B build \\\n    -DFMT_DOC=OFF \\\n    -DFMT_PEDANTIC=ON \\\n    -DFMT_WERROR=ON \\\n    -DFMT_TEST=ON \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_CXX_STANDARD=14 && \\\n    cmake --build build -j$(nproc)",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root.\ncd /testbed\n\n# Ensure the target test file is in its original state before applying any patch.\n# This resets it to the state at the target commit SHA, undoing any previous changes.\ngit checkout 8d9d528bf52c60864802844e8acf16db09dae19a \"test/core-test.cc\"\n\n# Required: apply test patch to update target tests (if any).\n# The actual content of the patch will be inserted here by the system.\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -456,6 +456,66 @@ TEST(FormatDynArgsTest, CustomFormat) {\n   EXPECT_EQ(\"cust=0 and cust=1 and cust=3\", result);\n }\n \n+TEST(FormatDynArgsTest, NamedInt) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+  store.push_back(fmt::arg(\"a1\", 42));\n+  std::string result = fmt::vformat(\"{a1}\", store);\n+  EXPECT_EQ(\"42\", result);\n+}\n+\n+TEST(FormatDynArgsTest, NamedStrings) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+  char str[]{\"1234567890\"};\n+  store.push_back(fmt::arg(\"a1\", str));\n+  store.push_back(fmt::arg(\"a2\", std::cref(str)));\n+  str[0] = 'X';\n+\n+  std::string result = fmt::vformat(\n+      \"{a1} and {a2}\",\n+      store);\n+\n+  EXPECT_EQ(\"1234567890 and X234567890\", result);\n+}\n+\n+TEST(FormatDynArgsTest, NamedArgByRef) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+\n+  // Note: fmt::arg() constructs an object which holds a reference\n+  // to its value. It's not an aggregate, so it doesn't extend the\n+  // reference lifetime. As a result, it's a very bad idea passing temporary\n+  // as a named argument value. Only GCC with optimization level >0\n+  // complains about this.\n+  //\n+  // A real life usecase is when you have both name and value alive\n+  // guarantee their lifetime and thus don't want them to be copied into\n+  // storages.\n+  int a1_val{42};\n+  auto a1 = fmt::arg(\"a1_\", a1_val);\n+  store.push_back(\"abc\");\n+  store.push_back(1.5f);\n+  store.push_back(std::cref(a1));\n+\n+  std::string result = fmt::vformat(\n+      \"{a1_} and {} and {} and {}\",\n+      store);\n+\n+  EXPECT_EQ(\"42 and abc and 1.5 and 42\", result);\n+}\n+\n+TEST(FormatDynArgsTest, NamedCustomFormat) {\n+  fmt::dynamic_format_arg_store<fmt::format_context> store;\n+  custom_type c{};\n+  store.push_back(fmt::arg(\"c1\", c));\n+  ++c.i;\n+  store.push_back(fmt::arg(\"c2\", c));\n+  ++c.i;\n+  store.push_back(fmt::arg(\"c_ref\", std::cref(c)));\n+  ++c.i;\n+\n+  std::string result = fmt::vformat(\"{c1} and {c2} and {c_ref}\", store);\n+  EXPECT_EQ(\"cust=0 and cust=1 and cust=3\", result);\n+}\n+\n struct copy_throwable {\n   copy_throwable() {}\n   copy_throwable(const copy_throwable&) { throw \"deal with it\"; }\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile.\n# Tests are typically executed from this directory after compilation.\ncd build\n\n# Execute target tests using ctest.\n# We use the -R (regex) option to run only the tests corresponding to the specified files.\n# \"test/core-test.cc\" compiles into a test executable named \"core-test\".\n# --output-on-failure ensures that test output is only shown if a test fails.\nctest --output-on-failure -R \"(core-test)\"\nrc=$? # Capture the exit code of the test command immediately.\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required: Echo the captured exit code for result parsing.\n\n# Cleanup: Revert changes made by the patch to the target test files.\n# Navigate back to the repository root first to ensure `git checkout` operates correctly on paths relative to the root.\ncd /testbed\ngit checkout 8d9d528bf52c60864802844e8acf16db09dae19a \"test/core-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root.\ncd /testbed\n\n# Ensure the target test file is in its original state before applying any patch.\n# This resets it to the state at the target commit SHA, undoing any previous changes.\ngit checkout 8d9d528bf52c60864802844e8acf16db09dae19a \"test/core-test.cc\"\n\n# Required: apply test patch to update target tests (if any).\n# The actual content of the patch will be inserted here by the system.\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile.\n# Tests are typically executed from this directory after compilation.\ncd build\n\n# Execute target tests using ctest.\n# We use the -R (regex) option to run only the tests corresponding to the specified files.\n# \"test/core-test.cc\" compiles into a test executable named \"core-test\".\n# --output-on-failure ensures that test output is only shown if a test fails.\nctest --output-on-failure -R \"(core-test)\"\nrc=$? # Capture the exit code of the test command immediately.\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required: Echo the captured exit code for result parsing.\n\n# Cleanup: Revert changes made by the patch to the target test files.\n# Navigate back to the repository root first to ensure `git checkout` operates correctly on paths relative to the root.\ncd /testbed\ngit checkout 8d9d528bf52c60864802844e8acf16db09dae19a \"test/core-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 1837,
    "instance_id": "fmtlib__fmt-1837",
    "issue_numbers": [
      "1819"
    ],
    "base_commit": "c7e6d8afb06cec7b8244f963dc081daf7e70f7f6",
    "patch": "diff --git a/include/fmt/chrono.h b/include/fmt/chrono.h\n--- a/include/fmt/chrono.h\n+++ b/include/fmt/chrono.h\n@@ -351,6 +351,11 @@ inline std::tm localtime(std::time_t time) {\n   return lt.tm_;\n }\n \n+inline std::tm localtime(\n+    std::chrono::time_point<std::chrono::system_clock> time_point) {\n+  return localtime(std::chrono::system_clock::to_time_t(time_point));\n+}\n+\n // Thread-safe replacement for std::gmtime\n inline std::tm gmtime(std::time_t time) {\n   struct dispatcher {\n@@ -387,6 +392,11 @@ inline std::tm gmtime(std::time_t time) {\n   return gt.tm_;\n }\n \n+inline std::tm gmtime(\n+    std::chrono::time_point<std::chrono::system_clock> time_point) {\n+  return gmtime(std::chrono::system_clock::to_time_t(time_point));\n+}\n+\n namespace detail {\n inline size_t strftime(char* str, size_t count, const char* format,\n                        const std::tm* time) {\n@@ -399,6 +409,17 @@ inline size_t strftime(wchar_t* str, size_t count, const wchar_t* format,\n }\n }  // namespace detail\n \n+template <typename Char>\n+struct formatter<std::chrono::time_point<std::chrono::system_clock>, Char>\n+    : formatter<std::tm, Char> {\n+  template <typename FormatContext>\n+  auto format(std::chrono::time_point<std::chrono::system_clock> val,\n+              FormatContext& ctx) -> decltype(ctx.out()) {\n+    std::tm time = localtime(val);\n+    return formatter<std::tm, Char>::format(time, ctx);\n+  }\n+};\n+\n template <typename Char> struct formatter<std::tm, Char> {\n   template <typename ParseContext>\n   auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\n",
    "test_patch": "diff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -95,6 +95,17 @@ TEST(TimeTest, GMTime) {\n   EXPECT_TRUE(EqualTime(tm, fmt::gmtime(t)));\n }\n \n+TEST(TimeTest, TimePoint) {\n+  std::chrono::system_clock::time_point point = std::chrono::system_clock::now();\n+\n+  std::time_t t = std::chrono::system_clock::to_time_t(point);\n+  std::tm tm = *std::localtime(&t);\n+  char strftime_output[256];\n+  std::strftime(strftime_output, sizeof(strftime_output), \"It is %Y-%m-%d %H:%M:%S\", &tm);\n+\n+  EXPECT_EQ(strftime_output, fmt::format(\"It is {:%Y-%m-%d %H:%M:%S}\", point));\n+}\n+\n #define EXPECT_TIME(spec, time, duration)                 \\\n   {                                                       \\\n     std::locale loc(\"ja_JP.utf8\");                        \\\n",
    "problem_statement": "Feature Request: Print std::chrono::time_point\nHello. I love using your library. \r\n\r\nI saw [this](https://github.com/fmtlib/fmt/issues/985) issue but it was closed. Here is my usecase of time_point:\r\n```\r\nclass record {\r\nstd::chrono::time_point<std::chrono::system_clock> last_modified, ...;\r\nvoid init() {\r\n    last_modified = std::chrono::system_clock::now();\r\n}\r\nvoid expired() {\r\n    return ((std::chrono::system_clock::now() - last_modified) >  std::chrono::hours(8));\r\n}\r\n// Bunch of other operations that add/subtract duration to another time_point member.\r\n};\r\n```\r\nI want to implement a `print()` that displays the time_point members. Here is what I do now:\r\n```\r\nvoid print() {\r\n    const auto time_c = std::chrono::system_clock::to_time_t(last_modified);\r\n    std::cout << std::ctime(&time_c);\r\n}\r\n```\r\nI would like to use `fmt::print(\"{}\", last_modified)` and be done with it. Could you please consider my request? \n",
    "hints_text": "Sure, a PR is welcome.",
    "created_at": "2020-08-25T19:01:40Z",
    "version": "7.0",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container (Required)\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime (Required)\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Set default workdir to testbed. (Required)\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and installs project-specific dependencies\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard c7e6d8afb06cec7b8244f963dc081daf7e70f7f6 && \\\n    git remote remove origin\n\n# Build the project and its tests.\n# This step compiles the fmt library and its test executables (including chrono-test),\n# making them ready for execution by the evaluation script.\n# Reduced parallel jobs for 'make' to prevent Out-Of-Memory (OOM) errors during compilation.\nRUN mkdir build && \\\n    cd build && \\\n    cmake .. -DCMAKE_BUILD_TYPE=Release -DFMT_TEST=ON -DCMAKE_CXX_STANDARD=17 && \\\n    make -j1",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Ensure the target test file is in its original state before applying any patch\ngit checkout c7e6d8afb06cec7b8244f963dc081daf7e70f7f6 \"test/chrono-test.cc\"\n\n# Required: apply test patch to update target tests\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -95,6 +95,17 @@ TEST(TimeTest, GMTime) {\n   EXPECT_TRUE(EqualTime(tm, fmt::gmtime(t)));\n }\n \n+TEST(TimeTest, TimePoint) {\n+  std::chrono::system_clock::time_point point = std::chrono::system_clock::now();\n+\n+  std::time_t t = std::chrono::system_clock::to_time_t(point);\n+  std::tm tm = *std::localtime(&t);\n+  char strftime_output[256];\n+  std::strftime(strftime_output, sizeof(strftime_output), \"It is %Y-%m-%d %H:%M:%S\", &tm);\n+\n+  EXPECT_EQ(strftime_output, fmt::format(\"It is {:%Y-%m-%d %H:%M:%S}\", point));\n+}\n+\n #define EXPECT_TIME(spec, time, duration)                 \\\n   {                                                       \\\n     std::locale loc(\"ja_JP.utf8\");                        \\\nEOF_114329324912\n\n# Test execution\n# Navigate into the build directory where the test executables are located.\n# The project has already been built by the Dockerfile.\ncd build\n\n# Run specific tests: ctest will execute tests matching the regex 'chrono-test',\n# which corresponds to the test/chrono-test.cc file.\nctest -R chrono-test\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test file\ncd /testbed # Ensure we are in the repository root for git checkout\ngit checkout c7e6d8afb06cec7b8244f963dc081daf7e70f7f6 \"test/chrono-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\ncd /testbed\n\n# Ensure the target test file is in its original state before applying any patch\ngit checkout c7e6d8afb06cec7b8244f963dc081daf7e70f7f6 \"test/chrono-test.cc\"\n\n# Required: apply test patch to update target tests\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Test execution\n# Navigate into the build directory where the test executables are located.\n# The project has already been built by the Dockerfile.\ncd build\n\n# Run specific tests: ctest will execute tests matching the regex 'chrono-test',\n# which corresponds to the test/chrono-test.cc file.\nctest -R chrono-test\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test file\ncd /testbed # Ensure we are in the repository root for git checkout\ngit checkout c7e6d8afb06cec7b8244f963dc081daf7e70f7f6 \"test/chrono-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 2158,
    "instance_id": "fmtlib__fmt-2158",
    "issue_numbers": [
      "2156"
    ],
    "base_commit": "835b910e7d758efdfdce9f23df1b190deb3373db",
    "patch": "diff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -469,15 +469,17 @@ template <typename OutputIt> class truncating_iterator_base {\n  protected:\n   OutputIt out_;\n   size_t limit_;\n-  size_t count_;\n+  size_t count_ = 0;\n \n+  truncating_iterator_base() : out_(), limit_(0) {}\n+  \n   truncating_iterator_base(OutputIt out, size_t limit)\n-      : out_(out), limit_(limit), count_(0) {}\n+      : out_(out), limit_(limit) {}\n \n  public:\n   using iterator_category = std::output_iterator_tag;\n   using value_type = typename std::iterator_traits<OutputIt>::value_type;\n-  using difference_type = void;\n+  using difference_type = std::ptrdiff_t;\n   using pointer = void;\n   using reference = void;\n   using _Unchecked_type =\n@@ -502,6 +504,8 @@ class truncating_iterator<OutputIt, std::false_type>\n  public:\n   using value_type = typename truncating_iterator_base<OutputIt>::value_type;\n \n+  truncating_iterator() = default;\n+  \n   truncating_iterator(OutputIt out, size_t limit)\n       : truncating_iterator_base<OutputIt>(out, limit) {}\n \n@@ -525,6 +529,8 @@ template <typename OutputIt>\n class truncating_iterator<OutputIt, std::true_type>\n     : public truncating_iterator_base<OutputIt> {\n  public:\n+  truncating_iterator() = default;\n+\n   truncating_iterator(OutputIt out, size_t limit)\n       : truncating_iterator_base<OutputIt>(out, limit) {}\n \n",
    "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -12,9 +12,11 @@\n #include <climits>\n #include <cmath>\n #include <cstring>\n+#include <iterator>\n #include <list>\n #include <memory>\n #include <string>\n+#include <type_traits>\n \n // Check if fmt/format.h compiles with windows.h included before it.\n #ifdef _WIN32\n@@ -157,6 +159,24 @@ TEST(IteratorTest, TruncatingIterator) {\n   EXPECT_EQ(it.base(), p + 1);\n }\n \n+\n+TEST(IteratorTest, TruncatingIteratorDefaultConstruct) {\n+  static_assert(\n+      std::is_default_constructible<fmt::detail::truncating_iterator<char*>>::value,\n+      \"\");\n+  \n+  fmt::detail::truncating_iterator<char*> it;\n+  EXPECT_EQ(nullptr, it.base());\n+  EXPECT_EQ(std::size_t{0}, it.count());\n+}\n+\n+#ifdef __cpp_lib_ranges\n+TEST(IteratorTest, TruncatingIteratorOutputIterator) {\n+  static_assert(std::output_iterator<fmt::detail::truncating_iterator<char*>,\n+      char>);\n+}\n+#endif\n+\n TEST(IteratorTest, TruncatingBackInserter) {\n   std::string buffer;\n   auto bi = std::back_inserter(buffer);\n",
    "problem_statement": "truncating_iterator is no std::output_iterator\nMy formatter for a custom type has C++20 delegates to a function that has a requirement `template <std::output_iterator<char> It>`. Unfortunately, that one fails when used within `fmt::format_to_n`, because the iterator found in `ctx.out()` is of type `fmt::v6::internal::truncating_iterator<char*, std::false_type>`. That one fails to be a `std::output_iterator`, apparently because it is missing default construction. Potentially, there are other requirements missing.\r\n\r\nIs there fundamentally preventing that object from being an output iterator, or has the requirement simply not come up before?\n",
    "hints_text": "> Is there fundamentally preventing that object from being an output iterator, or has the requirement simply not come up before?\r\n\r\nIt hasn't come up before. A PR to make `truncating_iterator` satisfy `output_iterator` requirements is welcome.\r\n\r\n",
    "created_at": "2021-03-01T02:25:46Z",
    "version": "7.1",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ninja-build \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to testbed.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard 835b910e7d758efdfdce9f23df1b190deb3373db && \\\n    git remote remove origin && \\\n    mkdir build && \\\n    cd build && \\\n    cmake -DFMT_TEST=ON -DCMAKE_BUILD_TYPE=Release .. && \\\n    cmake --build .",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout 835b910e7d758efdfdce9f23df1b190deb3373db \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -12,9 +12,11 @@\n #include <climits>\n #include <cmath>\n #include <cstring>\n+#include <iterator>\n #include <list>\n #include <memory>\n #include <string>\n+#include <type_traits>\n \n // Check if fmt/format.h compiles with windows.h included before it.\n #ifdef _WIN32\n@@ -157,6 +159,24 @@ TEST(IteratorTest, TruncatingIterator) {\n   EXPECT_EQ(it.base(), p + 1);\n }\n \n+\n+TEST(IteratorTest, TruncatingIteratorDefaultConstruct) {\n+  static_assert(\n+      std::is_default_constructible<fmt::detail::truncating_iterator<char*>>::value,\n+      \"\");\n+  \n+  fmt::detail::truncating_iterator<char*> it;\n+  EXPECT_EQ(nullptr, it.base());\n+  EXPECT_EQ(std::size_t{0}, it.count());\n+}\n+\n+#ifdef __cpp_lib_ranges\n+TEST(IteratorTest, TruncatingIteratorOutputIterator) {\n+  static_assert(std::output_iterator<fmt::detail::truncating_iterator<char*>,\n+      char>);\n+}\n+#endif\n+\n TEST(IteratorTest, TruncatingBackInserter) {\n   std::string buffer;\n   auto bi = std::back_inserter(buffer);\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\ncd build\n\n# Execute target tests using ctest, filtering by the specific test name.\n# The context indicates the test name corresponds to the specified test file's executable.\nctest --output-on-failure -R \"format-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout 835b910e7d758efdfdce9f23df1b190deb3373db \"test/format-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout 835b910e7d758efdfdce9f23df1b190deb3373db \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\ncd build\n\n# Execute target tests using ctest, filtering by the specific test name.\n# The context indicates the test name corresponds to the specified test file's executable.\nctest --output-on-failure -R \"format-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout 835b910e7d758efdfdce9f23df1b190deb3373db \"test/format-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 2204,
    "instance_id": "fmtlib__fmt-2204",
    "issue_numbers": [
      "2195"
    ],
    "base_commit": "308510eb4fad9b112ebdd2867b0b96338b0a9a36",
    "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -877,7 +877,7 @@ class buffer_appender : public std::back_insert_iterator<buffer<T>> {\n   using base = std::back_insert_iterator<buffer<T>>;\n \n  public:\n-  explicit buffer_appender(buffer<T>& buf) : base(buf) {}\n+  using std::back_insert_iterator<buffer<T>>::back_insert_iterator;\n   buffer_appender(base it) : base(it) {}\n \n   buffer_appender& operator++() {\n",
    "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -217,6 +217,23 @@ static void check_move_buffer(\n   EXPECT_EQ(alloc, buffer2.get_allocator().get());\n }\n \n+TEST(BufferAppenderTest, BufferAppenderDefaultConstruct) {\n+  // back_insert_iterator is not default-constructible before C++20, so\n+  // buffer_appender can only be default-constructible when back_insert_iterator\n+  // is.\n+  static_assert(\n+      std::is_default_constructible<\n+          std::back_insert_iterator<fmt::detail::buffer<char>>>::value ==\n+      std::is_default_constructible<fmt::detail::buffer_appender<char>>::value,\n+      \"\");\n+}\n+\n+#ifdef __cpp_lib_ranges\n+TEST(BufferAppenderTest, BufferAppenderOutputIterator) {\n+  static_assert(std::output_iterator<fmt::detail::buffer_appender<char>, char>);\n+}\n+#endif\n+\n TEST(MemoryBufferTest, MoveCtorInlineBuffer) {\n   std::allocator<char> alloc;\n   basic_memory_buffer<char, 5, std_allocator> buffer((std_allocator(&alloc)));\n",
    "problem_statement": "`buffer_appender` does not conform to `std::output_iterator`\nI've run into this before with `truncating_iterator` (see #2156), apparently, the same applies for `buffer_appender`.\r\n\r\nCC @randomnetcat :-)\n",
    "hints_text": "Note that there is a [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r0.html) that removes the default constructor requirement from output iterator.\nShould be easy to do similarly to #2158. PR is welcome =).",
    "created_at": "2021-03-31T18:10:50Z",
    "version": "7.1",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\n# Installs build-essential for g++ and make, cmake for project configuration, git for cloning the repository,\n# and ninja-build as an optional but often faster build system for CMake.\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ninja-build \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to /testbed/. This is where the repository will be cloned and built.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project.\n# The `git remote remove origin` step is included for a cleaner, self-contained container.\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard 308510eb4fad9b112ebdd2867b0b96338b0a9a36 && \\\n    git remote remove origin && \\\n    mkdir build && \\\n    cd build && \\\n    cmake -DFMT_TEST=ON -DCMAKE_BUILD_TYPE=Release .. && \\\n    cmake --build .",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout 308510eb4fad9b112ebdd2867b0b96338b0a9a36 \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -217,6 +217,23 @@ static void check_move_buffer(\n   EXPECT_EQ(alloc, buffer2.get_allocator().get());\n }\n \n+TEST(BufferAppenderTest, BufferAppenderDefaultConstruct) {\n+  // back_insert_iterator is not default-constructible before C++20, so\n+  // buffer_appender can only be default-constructible when back_insert_iterator\n+  // is.\n+  static_assert(\n+      std::is_default_constructible<\n+          std::back_insert_iterator<fmt::detail::buffer<char>>>::value ==\n+      std::is_default_constructible<fmt::detail::buffer_appender<char>>::value,\n+      \"\");\n+}\n+\n+#ifdef __cpp_lib_ranges\n+TEST(BufferAppenderTest, BufferAppenderOutputIterator) {\n+  static_assert(std::output_iterator<fmt::detail::buffer_appender<char>, char>);\n+}\n+#endif\n+\n TEST(MemoryBufferTest, MoveCtorInlineBuffer) {\n   std::allocator<char> alloc;\n   basic_memory_buffer<char, 5, std_allocator> buffer((std_allocator(&alloc)));\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\n# and rebuild the project to include any changes from the patch in the test binaries.\ncd build\ncmake --build .\n\n# Execute target tests using ctest, filtering by the specific test name.\n# The context indicates the test name corresponds to the specified test file's executable.\nctest --output-on-failure -R \"format-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout 308510eb4fad9b112ebdd2867b0b96338b0a9a36 \"test/format-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA and target files\ngit checkout 308510eb4fad9b112ebdd2867b0b96338b0a9a36 \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\n# and rebuild the project to include any changes from the patch in the test binaries.\ncd build\ncmake --build .\n\n# Execute target tests using ctest, filtering by the specific test name.\n# The context indicates the test name corresponds to the specified test file's executable.\nctest --output-on-failure -R \"format-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout 308510eb4fad9b112ebdd2867b0b96338b0a9a36 \"test/format-test.cc\""
  },
  {
    "repo": "fmtlib/fmt",
    "pull_number": 2310,
    "instance_id": "fmtlib__fmt-2310",
    "issue_numbers": [
      "2305"
    ],
    "base_commit": "bc13c6de390751ecf8daa1b1ce8f775d104fdc65",
    "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -1948,7 +1948,7 @@ template <typename Char> class specs_setter {\n   FMT_CONSTEXPR void on_localized() { specs_.localized = true; }\n \n   FMT_CONSTEXPR void on_zero() {\n-    specs_.align = align::numeric;\n+    if (specs_.align == align::none) specs_.align = align::numeric;\n     specs_.fill[0] = Char('0');\n   }\n \ndiff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -1584,13 +1584,17 @@ FMT_CONSTEXPR OutputIt write(OutputIt out, const Char* s,\n \n template <typename Char, typename OutputIt>\n OutputIt write_nonfinite(OutputIt out, bool isinf,\n-                         const basic_format_specs<Char>& specs,\n+                         basic_format_specs<Char> specs,\n                          const float_specs& fspecs) {\n   auto str =\n       isinf ? (fspecs.upper ? \"INF\" : \"inf\") : (fspecs.upper ? \"NAN\" : \"nan\");\n   constexpr size_t str_size = 3;\n   auto sign = fspecs.sign;\n   auto size = str_size + (sign ? 1 : 0);\n+  // Replace '0'-padding with space for non-finite values.\n+  const bool is_zero_fill =\n+      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');\n+  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');\n   return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {\n     if (sign) *it++ = static_cast<Char>(data::signs[sign]);\n     return copy_str<Char>(str, str + str_size, it);\n",
    "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -1272,10 +1272,16 @@ TEST(format_test, format_nan) {\n   double nan = std::numeric_limits<double>::quiet_NaN();\n   EXPECT_EQ(\"nan\", fmt::format(\"{}\", nan));\n   EXPECT_EQ(\"+nan\", fmt::format(\"{:+}\", nan));\n-  if (std::signbit(-nan))\n+  EXPECT_EQ(\"  +nan\", fmt::format(\"{:+06}\", nan));\n+  EXPECT_EQ(\"+nan  \", fmt::format(\"{:<+06}\", nan));\n+  EXPECT_EQ(\" +nan \", fmt::format(\"{:^+06}\", nan));\n+  EXPECT_EQ(\"  +nan\", fmt::format(\"{:>+06}\", nan));\n+  if (std::signbit(-nan)) {\n     EXPECT_EQ(\"-nan\", fmt::format(\"{}\", -nan));\n-  else\n+    EXPECT_EQ(\"  -nan\", fmt::format(\"{:+06}\", -nan));\n+  } else {\n     fmt::print(\"Warning: compiler doesn't handle negative NaN correctly\");\n+  }\n   EXPECT_EQ(\" nan\", fmt::format(\"{: }\", nan));\n   EXPECT_EQ(\"NAN\", fmt::format(\"{:F}\", nan));\n   EXPECT_EQ(\"nan    \", fmt::format(\"{:<7}\", nan));\n@@ -1288,6 +1294,11 @@ TEST(format_test, format_infinity) {\n   EXPECT_EQ(\"inf\", fmt::format(\"{}\", inf));\n   EXPECT_EQ(\"+inf\", fmt::format(\"{:+}\", inf));\n   EXPECT_EQ(\"-inf\", fmt::format(\"{}\", -inf));\n+  EXPECT_EQ(\"  +inf\", fmt::format(\"{:+06}\", inf));\n+  EXPECT_EQ(\"  -inf\", fmt::format(\"{:+06}\", -inf));\n+  EXPECT_EQ(\"+inf  \", fmt::format(\"{:<+06}\", inf));\n+  EXPECT_EQ(\" +inf \", fmt::format(\"{:^+06}\", inf));\n+  EXPECT_EQ(\"  +inf\", fmt::format(\"{:>+06}\", inf));\n   EXPECT_EQ(\" inf\", fmt::format(\"{: }\", inf));\n   EXPECT_EQ(\"INF\", fmt::format(\"{:F}\", inf));\n   EXPECT_EQ(\"inf    \", fmt::format(\"{:<7}\", inf));\n",
    "problem_statement": "Numeric zero fill is applied to inf/nan\nFrom the documentation (emphasis mine):\r\n> Preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. It forces the padding to be placed after the sign or base (if any) but before the digits. This is used for printing fields in the form \u2018+000000120\u2019. This option is only valid for numeric types and ***it has no effect on formatting of infinity and NaN.***\r\n\r\n```CPP\r\nfmt::print(\"'{:+06}'\\n\", NAN);\r\n// output: '00+nan'\r\n```\r\n\r\nhttps://godbolt.org/z/Pnh33M6r6\n",
    "hints_text": "",
    "created_at": "2021-05-23T17:13:52Z",
    "version": "7.1",
    "dockerfile": "# Base image specification. Defines the foundation OS and architecture for the container\nFROM ubuntu:22.04\nARG DEBIAN_FRONTEND=noninteractive\nENV TZ=Etc/UTC\n\n# System dependencies installation. Installs essential tools and libraries required for development and runtime\n# Installs build-essential for g++ and make, cmake for project configuration, git for cloning the repository,\n# and ninja-build as an optional but often faster build system for CMake.\nRUN apt update && apt install -y \\\n    build-essential \\\n    cmake \\\n    git \\\n    ninja-build \\\n    && rm -rf /var/lib/apt/lists/*\n\n# set default workdir to /testbed/. This is where the repository will be cloned and built.\nWORKDIR /testbed/\n\n# Target Project setup. Clones source code, checkouts to the target version, configures it, and builds the project.\n# The `git remote remove origin` step is included for a cleaner, self-contained container.\nRUN git clone https://github.com/fmtlib/fmt /testbed && \\\n    cd /testbed && \\\n    git reset --hard bc13c6de390751ecf8daa1b1ce8f775d104fdc65 && \\\n    git remote remove origin && \\\n    mkdir build && \\\n    cd build && \\\n    cmake -DFMT_TEST=ON -DCMAKE_BUILD_TYPE=Release .. && \\\n    cmake --build .",
    "eval_script": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA bc13c6de390751ecf8daa1b1ce8f775d104fdc65 for target files\ngit checkout bc13c6de390751ecf8daa1b1ce8f775d104fdc65 \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -1272,10 +1272,16 @@ TEST(format_test, format_nan) {\n   double nan = std::numeric_limits<double>::quiet_NaN();\n   EXPECT_EQ(\"nan\", fmt::format(\"{}\", nan));\n   EXPECT_EQ(\"+nan\", fmt::format(\"{:+}\", nan));\n-  if (std::signbit(-nan))\n+  EXPECT_EQ(\"  +nan\", fmt::format(\"{:+06}\", nan));\n+  EXPECT_EQ(\"+nan  \", fmt::format(\"{:<+06}\", nan));\n+  EXPECT_EQ(\" +nan \", fmt::format(\"{:^+06}\", nan));\n+  EXPECT_EQ(\"  +nan\", fmt::format(\"{:>+06}\", nan));\n+  if (std::signbit(-nan)) {\n     EXPECT_EQ(\"-nan\", fmt::format(\"{}\", -nan));\n-  else\n+    EXPECT_EQ(\"  -nan\", fmt::format(\"{:+06}\", -nan));\n+  } else {\n     fmt::print(\"Warning: compiler doesn't handle negative NaN correctly\");\n+  }\n   EXPECT_EQ(\" nan\", fmt::format(\"{: }\", nan));\n   EXPECT_EQ(\"NAN\", fmt::format(\"{:F}\", nan));\n   EXPECT_EQ(\"nan    \", fmt::format(\"{:<7}\", nan));\n@@ -1288,6 +1294,11 @@ TEST(format_test, format_infinity) {\n   EXPECT_EQ(\"inf\", fmt::format(\"{}\", inf));\n   EXPECT_EQ(\"+inf\", fmt::format(\"{:+}\", inf));\n   EXPECT_EQ(\"-inf\", fmt::format(\"{}\", -inf));\n+  EXPECT_EQ(\"  +inf\", fmt::format(\"{:+06}\", inf));\n+  EXPECT_EQ(\"  -inf\", fmt::format(\"{:+06}\", -inf));\n+  EXPECT_EQ(\"+inf  \", fmt::format(\"{:<+06}\", inf));\n+  EXPECT_EQ(\" +inf \", fmt::format(\"{:^+06}\", inf));\n+  EXPECT_EQ(\"  +inf\", fmt::format(\"{:>+06}\", inf));\n   EXPECT_EQ(\" inf\", fmt::format(\"{: }\", inf));\n   EXPECT_EQ(\"INF\", fmt::format(\"{:F}\", inf));\n   EXPECT_EQ(\"inf    \", fmt::format(\"{:<7}\", inf));\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\n# and rebuild the project to include any changes from the patch in the test binaries.\ncd build\ncmake --build .\n\n# Execute target tests using ctest, filtering by the specific test name.\n# The context indicates the test name corresponds to the specified test file's executable.\nctest --output-on-failure -R \"format-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout bc13c6de390751ecf8daa1b1ce8f775d104fdc65 \"test/format-test.cc\"",
    "eval_script_skeleton": "#!/bin/bash\nset -uxo pipefail\n\n# Navigate to the repository root\ncd /testbed\n\n# Ensure the target test files are in their original state before applying any patch\n# Use the specific commit SHA bc13c6de390751ecf8daa1b1ce8f775d104fdc65 for target files\ngit checkout bc13c6de390751ecf8daa1b1ce8f775d104fdc65 \"test/format-test.cc\"\n\n# Required: apply test patch to update target tests (if any)\n# The content of the patch will be inserted here programmatically\ngit apply -v - <<'EOF_114329324912'\n[CONTENT OF TEST PATCH]\nEOF_114329324912\n\n# Navigate into the pre-existing build directory created by the Dockerfile\n# and rebuild the project to include any changes from the patch in the test binaries.\ncd build\ncmake --build .\n\n# Execute target tests using ctest, filtering by the specific test name.\n# The context indicates the test name corresponds to the specified test file's executable.\nctest --output-on-failure -R \"format-test\"\nrc=$? # Capture exit code immediately after running tests\n\necho \"OMNIGRIL_EXIT_CODE=$rc\" # Required, echo test status\n\n# Cleanup: Revert changes made by the patch to the target test files\n# Navigate back to the repository root first\ncd /testbed\ngit checkout bc13c6de390751ecf8daa1b1ce8f775d104fdc65 \"test/format-test.cc\""
  }
]