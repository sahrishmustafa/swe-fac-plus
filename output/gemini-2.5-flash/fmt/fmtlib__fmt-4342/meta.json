{
    "task_id": "fmtlib__fmt-4342",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-4342_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 4342,
        "instance_id": "fmtlib__fmt-4342",
        "issue_numbers": [
            "4335"
        ],
        "base_commit": "d5b866e2421786a661448a41fb6dfb7fe2457f53",
        "patch": "diff --git a/include/fmt/compile.h b/include/fmt/compile.h\n--- a/include/fmt/compile.h\n+++ b/include/fmt/compile.h\n@@ -19,11 +19,11 @@ FMT_BEGIN_NAMESPACE\n // A compile-time string which is compiled into fast formatting code.\n FMT_EXPORT class compiled_string {};\n \n-namespace detail {\n-\n template <typename S>\n struct is_compiled_string : std::is_base_of<compiled_string, S> {};\n \n+namespace detail {\n+\n /**\n  * Converts a string literal `s` into a format string that will be parsed at\n  * compile time and converted into efficient formatting code. Requires C++17\n@@ -425,7 +425,7 @@ constexpr auto compile_format_string(S fmt) {\n }\n \n template <typename... Args, typename S,\n-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\n+          FMT_ENABLE_IF(is_compiled_string<S>::value)>\n constexpr auto compile(S fmt) {\n   constexpr auto str = basic_string_view<typename S::char_type>(fmt);\n   if constexpr (str.size() == 0) {\n@@ -461,7 +461,7 @@ constexpr FMT_INLINE OutputIt format_to(OutputIt out, const CompiledFormat& cf,\n }\n \n template <typename S, typename... Args,\n-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\n+          FMT_ENABLE_IF(is_compiled_string<S>::value)>\n FMT_INLINE std::basic_string<typename S::char_type> format(const S&,\n                                                            Args&&... args) {\n   if constexpr (std::is_same<typename S::char_type, char>::value) {\n@@ -488,7 +488,7 @@ FMT_INLINE std::basic_string<typename S::char_type> format(const S&,\n }\n \n template <typename OutputIt, typename S, typename... Args,\n-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\n+          FMT_ENABLE_IF(is_compiled_string<S>::value)>\n FMT_CONSTEXPR OutputIt format_to(OutputIt out, const S&, Args&&... args) {\n   constexpr auto compiled = detail::compile<Args...>(S());\n   if constexpr (std::is_same<remove_cvref_t<decltype(compiled)>,\n@@ -503,7 +503,7 @@ FMT_CONSTEXPR OutputIt format_to(OutputIt out, const S&, Args&&... args) {\n #endif\n \n template <typename OutputIt, typename S, typename... Args,\n-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\n+          FMT_ENABLE_IF(is_compiled_string<S>::value)>\n auto format_to_n(OutputIt out, size_t n, const S& fmt, Args&&... args)\n     -> format_to_n_result<OutputIt> {\n   using traits = detail::fixed_buffer_traits;\n@@ -513,7 +513,7 @@ auto format_to_n(OutputIt out, size_t n, const S& fmt, Args&&... args)\n }\n \n template <typename S, typename... Args,\n-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\n+          FMT_ENABLE_IF(is_compiled_string<S>::value)>\n FMT_CONSTEXPR20 auto formatted_size(const S& fmt, const Args&... args)\n     -> size_t {\n   auto buf = detail::counting_buffer<>();\n@@ -522,7 +522,7 @@ FMT_CONSTEXPR20 auto formatted_size(const S& fmt, const Args&... args)\n }\n \n template <typename S, typename... Args,\n-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\n+          FMT_ENABLE_IF(is_compiled_string<S>::value)>\n void print(std::FILE* f, const S& fmt, const Args&... args) {\n   auto buf = memory_buffer();\n   fmt::format_to(appender(buf), fmt, args...);\n@@ -530,7 +530,7 @@ void print(std::FILE* f, const S& fmt, const Args&... args) {\n }\n \n template <typename S, typename... Args,\n-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>\n+          FMT_ENABLE_IF(is_compiled_string<S>::value)>\n void print(const S& fmt, const Args&... args) {\n   print(stdout, fmt, args...);\n }\n",
        "test_patch": "diff --git a/test/compile-test.cc b/test/compile-test.cc\n--- a/test/compile-test.cc\n+++ b/test/compile-test.cc\n@@ -316,6 +316,18 @@ TEST(compile_test, compile_format_string_literal) {\n }\n #endif\n \n+#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)\n+template <typename S>\n+bool check_is_compiled_string(const S&) {\n+  return fmt::is_compiled_string<S>::value;\n+}\n+\n+TEST(compile_test, is_compiled_string) {\n+  EXPECT_TRUE(check_is_compiled_string(FMT_COMPILE(\"asdf\")));\n+  EXPECT_TRUE(check_is_compiled_string(FMT_COMPILE(\"{}\")));\n+}\n+#endif\n+\n // MSVS 2019 19.29.30145.0 - OK\n // MSVS 2022 19.32.31332.0, 19.37.32826.1 - compile-test.cc(362,3): fatal error\n // C1001: Internal compiler error.\n",
        "problem_statement": "It doesn't seem to be possible to declare a funciton that can take compiled format string as an argument without referencing `fmt::detail`\nWriting a function that can take a regular format string as an argument is pretty straightforward:\nhttps://github.com/SwooshyCueb/irods/blob/5ceb3b6b99b19478ebb9f1681d3432f1e037472d/server/core/include/irods/notify_service_manager.hpp#L46-L70\n\nHowever, I can't figure out how to declare an overload that can take a *compiled* format string without dipping into `fmt::detail`:\nhttps://github.com/SwooshyCueb/irods/blob/5ceb3b6b99b19478ebb9f1681d3432f1e037472d/server/core/include/irods/notify_service_manager.hpp#L72-L99\n\nThere doesn't seem to be any documentation on how this might be done. Is this the proper solution?\n",
        "hints_text": "I don't know if this is exactly the best way, but this is how I do it.  For a variadic function that takes a format string plus arguments:\n```\n    template <typename... Args>\n    void fmt(fmt::format_string<Args...> fmt, Args&&... args)\n    { vfmt(fmt, fmt::make_format_args(args...)); }\n```\nthen to define the vfmt() method that accepts an already-compiled set of stuff it's just:\n```\n    void vfmt(fmt::string_view fmt, fmt::format_args args) { auto msg = fmt::vformat(fmt, args); }\n```\nIs that helpful?\nThat doesn't seem to work: https://godbolt.org/z/cze1sv1qf\nYou are right that this relies on the internal APIs at the moment. A PR to move `is_compiled_string` to the public API would be welcome.",
        "created_at": "2025-02-04T20:50:57Z",
        "version": "11.1"
    }
}