{
    "task_id": "fmtlib__fmt-1361",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-1361_2025-07-04_18-45-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 1361,
        "instance_id": "fmtlib__fmt-1361",
        "issue_numbers": [
            "1336"
        ],
        "base_commit": "a5abe5d95cb8a8015913be9748a9661f3e1fbda8",
        "patch": "diff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h\n--- a/include/fmt/format-inl.h\n+++ b/include/fmt/format-inl.h\n@@ -423,6 +423,18 @@ class fp {\n     lower.f <<= lower.e - upper.e;\n     lower.e = upper.e;\n   }\n+\n+  void compute_float_boundaries(fp& lower, fp& upper) const {\n+    constexpr int min_normal_e = std::numeric_limits<float>::min_exponent -\n+                                 std::numeric_limits<double>::digits;\n+    significand_type half_ulp = 1 << (std::numeric_limits<double>::digits -\n+                                      std::numeric_limits<float>::digits - 1);\n+    if (min_normal_e > e) half_ulp <<= min_normal_e - e;\n+    upper = normalize<0>(fp(f + half_ulp, e));\n+    lower = fp(f - (half_ulp >> (f == implicit_bit && e > min_normal_e)), e);\n+    lower.f <<= lower.e - upper.e;\n+    lower.e = upper.e;\n+  }\n };\n \n // Returns an fp number representing x - y. Result may not be normalized.\n@@ -1045,7 +1057,11 @@ bool grisu_format(Double value, buffer<char>& buf, int precision,\n     buf.resize(to_unsigned(handler.size));\n   } else {\n     fp lower, upper;  // w^- and w^+ in the Grisu paper.\n-    fp_value.compute_boundaries(lower, upper);\n+    if ((options & grisu_options::binary32) != 0)\n+      fp_value.compute_float_boundaries(lower, upper);\n+    else\n+      fp_value.compute_boundaries(lower, upper);\n+\n     // Find a cached power of 10 such that multiplying upper by it will bring\n     // the exponent in the range [min_exp, -32].\n     const auto cached_pow = get_cached_power(  // \\tilde{c}_{-k} in Grisu.\ndiff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -1111,7 +1111,7 @@ It grisu_prettify(const char* digits, int size, int exp, It it,\n }\n \n namespace grisu_options {\n-enum { fixed = 1, grisu2 = 2 };\n+enum { fixed = 1, grisu2 = 2, binary32 = 4 };\n }\n \n // Formats value using the Grisu algorithm:\n@@ -2809,12 +2809,16 @@ void internal::basic_writer<Range>::write_fp(T value,\n   memory_buffer buffer;\n   int exp = 0;\n   int precision = specs.precision >= 0 || !specs.type ? specs.precision : 6;\n+  unsigned options = 0;\n+  if (handler.fixed) options |= internal::grisu_options::fixed;\n+  if (sizeof(value) == sizeof(float))\n+    options |= internal::grisu_options::binary32;\n   bool use_grisu = USE_GRISU &&\n                    (specs.type != 'a' && specs.type != 'A' &&\n                     specs.type != 'e' && specs.type != 'E') &&\n                    internal::grisu_format(\n                        static_cast<double>(value), buffer, precision,\n-                       handler.fixed ? internal::grisu_options::fixed : 0, exp);\n+                       options, exp);\n   char* decimal_point_pos = nullptr;\n   if (!use_grisu)\n     decimal_point_pos = internal::sprintf_format(value, buffer, specs);\n",
        "test_patch": "diff --git a/test/format-impl-test.cc b/test/format-impl-test.cc\n--- a/test/format-impl-test.cc\n+++ b/test/format-impl-test.cc\n@@ -221,6 +221,36 @@ TEST(FPTest, ComputeBoundaries) {\n   EXPECT_EQ(31, upper.e);\n }\n \n+TEST(FPTest, ComputeFloatBoundaries) {\n+  struct {\n+    double x, lower, upper;\n+  } tests[] = {\n+      // regular\n+      {1.5f, 1.4999999403953552, 1.5000000596046448},\n+      // boundary\n+      {1.0f, 0.9999999701976776, 1.0000000596046448},\n+      // min normal\n+      {1.1754944e-38f, 1.1754942807573643e-38, 1.1754944208872107e-38},\n+      // max subnormal\n+      {1.1754942e-38f, 1.1754941406275179e-38, 1.1754942807573643e-38},\n+      // min subnormal\n+      {1e-45f, 7.006492321624085e-46, 2.1019476964872256e-45},\n+  };\n+  for (auto test : tests) {\n+    auto v = fp(test.x);\n+    fp vlower = normalize(fp(test.lower));\n+    fp vupper = normalize(fp(test.upper));\n+    vlower.f >>= vupper.e - vlower.e;\n+    vlower.e = vupper.e;\n+    fp lower, upper;\n+    v.compute_float_boundaries(lower, upper);\n+    EXPECT_EQ(vlower.f, lower.f);\n+    EXPECT_EQ(vlower.e, lower.e);\n+    EXPECT_EQ(vupper.f, upper.f);\n+    EXPECT_EQ(vupper.e, upper.e);\n+  }\n+}\n+\n TEST(FPTest, Subtract) {\n   auto v = fp(123, 1) - fp(102, 1);\n   EXPECT_EQ(v.f, 21u);\ndiff --git a/test/grisu-test.cc b/test/grisu-test.cc\n--- a/test/grisu-test.cc\n+++ b/test/grisu-test.cc\n@@ -52,6 +52,8 @@ TEST(GrisuTest, Prettify) {\n   EXPECT_EQ(\"12340000000.0\", fmt::format(\"{}\", 1234e7));\n   EXPECT_EQ(\"12.34\", fmt::format(\"{}\", 1234e-2));\n   EXPECT_EQ(\"0.001234\", fmt::format(\"{}\", 1234e-6));\n+  EXPECT_EQ(\"0.1\", fmt::format(\"{}\", 0.1f));\n+  EXPECT_EQ(\"0.10000000149011612\", fmt::format(\"{}\", double(0.1f)));\n }\n \n TEST(GrisuTest, ZeroPrecision) { EXPECT_EQ(\"1\", fmt::format(\"{:.0}\", 1.0)); }\n",
        "problem_statement": "Support single precision floats in grisu formatting\nCurrently `fmt::format(\"{}\", 0.1f)` with grisu produces `0.10000000149011612` (as would have been expected from `double(0.1f)`) rather than `0.1`.\r\n\r\nSingle precision formatting differs from double precision only in the calculation of the boundaries: https://github.com/google/double-conversion/blob/v3.1.5/double-conversion/fast-dtoa.cc#L525-L536\n",
        "hints_text": "As I see, floating format with \"{}\" and GRISU is not more compatible with `std::defaultfloat` in fmtlib 6.0.0\r\n```\r\nstd::cout << fmt::format(\"{}\\n\", 1.0 / 3.0);\r\nstd::cout << 1.0 / 3.0 << \"\\n\";\r\n```\r\noutputs\r\n```\r\n0.3333333333333333\r\n0.333333\r\n```\r\n(fmtlib 6.0.0, GRISU, VisualStudio 2019 16.3)\r\nIt looks like compatibility problem.\nPlease use a separate issue to discuss that. #1033 is related, although it does not talk about the default `cout` format. `{}` is not supposed to output the same as `cout <<`, it is supposed to print the number with enough precision such that reading that number back produces the same number. 1/3 is most accurately approximated by a double 0.3333333333333333, it needs so many digits to distinguish it from the previous double 0.33333333333333326 and the next double 0.33333333333333337; 0.333333 represents a different number.\n> Single precision formatting differs from double precision only in the calculation of the boundaries\r\n\r\nRight. This is also needed for compatibility with `std::format`. @orivej, could you by any chance submit a PR?",
        "created_at": "2019-10-12T12:20:21Z",
        "version": "6.0"
    }
}