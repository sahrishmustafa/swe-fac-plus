{
    "task_id": "fmtlib__fmt-3814",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3814_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3814,
        "instance_id": "fmtlib__fmt-3814",
        "issue_numbers": [
            "3794"
        ],
        "base_commit": "470c4e6ca8d648a70f0071fa7c81b15fbc4556a4",
        "patch": "diff --git a/include/fmt/chrono.h b/include/fmt/chrono.h\n--- a/include/fmt/chrono.h\n+++ b/include/fmt/chrono.h\n@@ -1151,18 +1151,23 @@ void write_fractional_seconds(OutputIt& out, Duration d, int precision = -1) {\n       out = std::fill_n(out, leading_zeroes, '0');\n       out = format_decimal<Char>(out, n, num_digits).end;\n     }\n-  } else {\n+  } else if (precision > 0) {\n     *out++ = '.';\n     leading_zeroes = (std::min)(leading_zeroes, precision);\n-    out = std::fill_n(out, leading_zeroes, '0');\n     int remaining = precision - leading_zeroes;\n-    if (remaining != 0 && remaining < num_digits) {\n-      n /= to_unsigned(detail::pow10(to_unsigned(num_digits - remaining)));\n-      out = format_decimal<Char>(out, n, remaining).end;\n+    out = std::fill_n(out, leading_zeroes, '0');\n+    if (remaining < num_digits) {\n+      int num_truncated_digits = num_digits - remaining;\n+      n /= to_unsigned(detail::pow10(to_unsigned(num_truncated_digits)));\n+      if (n) {\n+        out = format_decimal<Char>(out, n, remaining).end;\n+      }\n       return;\n     }\n-    out = format_decimal<Char>(out, n, num_digits).end;\n-    remaining -= num_digits;\n+    if (n) {\n+      out = format_decimal<Char>(out, n, num_digits).end;\n+      remaining -= num_digits;\n+    }\n     out = std::fill_n(out, remaining, '0');\n   }\n }\n",
        "test_patch": "diff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -791,6 +791,20 @@ TEST(chrono_test, cpp20_duration_subsecond_support) {\n             \"01.234000\");\n   EXPECT_EQ(fmt::format(\"{:.6%S}\", std::chrono::milliseconds{-1234}),\n             \"-01.234000\");\n+  EXPECT_EQ(fmt::format(\"{:.2%S}\", std::chrono::milliseconds{12345}),\n+            \"12.34\");\n+  EXPECT_EQ(fmt::format(\"{:.2%S}\", std::chrono::milliseconds{12375}),\n+            \"12.37\");\n+  EXPECT_EQ(fmt::format(\"{:.2%S}\", std::chrono::milliseconds{-12375}),\n+            \"-12.37\");\n+  EXPECT_EQ(fmt::format(\"{:.0%S}\", std::chrono::milliseconds{12054}),\n+            \"12\");\n+  EXPECT_EQ(fmt::format(\"{:.2%S}\", std::chrono::milliseconds{99999}),\n+            \"39.99\");\n+  EXPECT_EQ(fmt::format(\"{:.2%S}\", std::chrono::milliseconds{1000}),\n+            \"01.00\");\n+  EXPECT_EQ(fmt::format(\"{:.3%S}\", std::chrono::milliseconds{1}),\n+            \"00.001\");\n   EXPECT_EQ(fmt::format(\"{:.3%S}\", std::chrono::seconds{1234}), \"34.000\");\n   EXPECT_EQ(fmt::format(\"{:.3%S}\", std::chrono::hours{1234}), \"00.000\");\n   EXPECT_EQ(fmt::format(\"{:.5%S}\", dms(1.234)), \"00.00123\");\n",
        "problem_statement": "%S ignores precision for chrono durations where the decimal part should have been only zeros\nAny chrono duration *n* where 0 < *n* < 10\u207b*\u1d3a* formatted with `{:.N%S}` receives full precision instead of *N* decimals. This also holds if adding any number of whole seconds. In other words, any duration where the decimal part should have been rounded to `.0`, `.00`, `.000` etc. will be printed with all decimals. For example, with `{:.2%S}`, 4567 milliseconds are printed as `04.56`, while 4007 milliseconds are printed as `04.007` (instead of the expected `04.00`). 4007000 microseconds are printed as `04.007000` while 4017000 microseconds are printed as `04.01`.\r\n\r\nIf the decimal part is exactly zero (i.e., the duration is a whole number of seconds), there will be one zero more than the specified precision. Thus, 1000 milliseconds will be printed as `01.00` with `{:.1%S}`, `01.000` with `{:.2%S}` etc., whilst 1100 milliseconds will be printed as `01.1`, `01.10` etc. (as expected) for the same format strings.\r\n\r\nCode to reproduce:\r\n```c++\r\n#include <fmt/chrono.h>\r\n#include <fmt/core.h>\r\n\r\nint main()\r\n{\r\n  constexpr std::chrono::microseconds works{10'001};\r\n  constexpr std::chrono::microseconds fails{9'999};\r\n  fmt::println(\"{:.2%S} {:.2%S}\", works, fails);\r\n}\r\n```\r\n\r\nExpected output:\r\n```\r\n00.01 00.00\r\n```\r\n\r\nActual output:\r\n```\r\n00.01 00.009999\r\n```\r\n\r\nGodbolt:\r\nhttps://godbolt.org/z/rncqqGWW3\r\n\r\nTested with recent versions of Clang and GCC. Affects both `fmt::format` and `fmt::println`.\n",
        "hints_text": "I agree that it's inconsistent although the fractional part should probably be rounded (`00.01`) not truncated.",
        "created_at": "2024-01-17T03:22:25Z",
        "version": "10.2"
    }
}