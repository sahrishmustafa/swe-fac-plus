{
    "task_id": "fmtlib__fmt-4286",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-4286_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 4286,
        "instance_id": "fmtlib__fmt-4286",
        "issue_numbers": [
            "4285"
        ],
        "base_commit": "e3ddede6c4ee818825c4e5a6dfa1d384860c27d9",
        "patch": "diff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -3654,6 +3654,17 @@ void vformat_to(buffer<Char>& buf, basic_string_view<Char> fmt,\n   parse_format_string(\n       fmt, format_handler<Char>{parse_context<Char>(fmt), {out, args, loc}});\n }\n+\n+template <typename Char>\n+void basic_specs_copy_fill(basic_specs& dst, const basic_specs& src) {\n+  if (src.fill_size() == 1 && const_check(!std::is_same<Char, char>::value)) {\n+    Char fill = src.fill_unit<Char>();\n+    dst.set_fill(basic_string_view<Char>(&fill, 1));\n+    return;\n+  }\n+  dst.set_fill(basic_string_view<char>(src.fill<char>(), src.fill_size()));\n+}\n+\n }  // namespace detail\n \n FMT_BEGIN_EXPORT\n@@ -3960,8 +3971,7 @@ template <typename T, typename Char = char> struct nested_formatter {\n     write(basic_appender<Char>(buf));\n     auto specs = format_specs();\n     specs.width = width_;\n-    specs.set_fill(\n-        basic_string_view<Char>(specs_.fill<Char>(), specs_.fill_size()));\n+    detail::basic_specs_copy_fill<Char>(specs, specs_);\n     specs.set_align(specs_.align());\n     return detail::write<Char>(\n         ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs);\ndiff --git a/include/fmt/std.h b/include/fmt/std.h\n--- a/include/fmt/std.h\n+++ b/include/fmt/std.h\n@@ -184,7 +184,8 @@ FMT_END_NAMESPACE\n FMT_BEGIN_NAMESPACE\n FMT_EXPORT\n template <std::size_t N, typename Char>\n-struct formatter<std::bitset<N>, Char> : nested_formatter<string_view> {\n+struct formatter<std::bitset<N>, Char>\n+    : nested_formatter<basic_string_view<Char>, Char> {\n  private:\n   // Functor because C++11 doesn't support generic lambdas.\n   struct writer {\n@@ -204,7 +205,7 @@ struct formatter<std::bitset<N>, Char> : nested_formatter<string_view> {\n   template <typename FormatContext>\n   auto format(const std::bitset<N>& bs, FormatContext& ctx) const\n       -> decltype(ctx.out()) {\n-    return write_padded(ctx, writer{bs});\n+    return this->write_padded(ctx, writer{bs});\n   }\n };\n \n@@ -695,9 +696,7 @@ template <typename T, typename Char> struct formatter<std::complex<T>, Char> {\n \n     auto outer_specs = format_specs();\n     outer_specs.width = specs.width;\n-    auto fill = specs.template fill<Char>();\n-    if (fill)\n-      outer_specs.set_fill(basic_string_view<Char>(fill, specs.fill_size()));\n+    detail::basic_specs_copy_fill<Char>(outer_specs, specs);\n     outer_specs.set_align(specs.align());\n \n     specs.width = 0;\n",
        "test_patch": "diff --git a/test/std-test.cc b/test/std-test.cc\n--- a/test/std-test.cc\n+++ b/test/std-test.cc\n@@ -91,6 +91,9 @@ TEST(std_test, complex) {\n   EXPECT_EQ(fmt::format(\"{: }\", std::complex<double>(1, 2.2)), \"( 1+2.2i)\");\n   EXPECT_EQ(fmt::format(\"{: }\", std::complex<double>(1, -2.2)), \"( 1-2.2i)\");\n \n+  EXPECT_EQ(fmt::format(\"{:8}\", std::complex<double>(1, 2)), \"(1+2i)  \");\n+  EXPECT_EQ(fmt::format(\"{:-<8}\", std::complex<double>(1, 2)), \"(1+2i)--\");\n+\n   EXPECT_EQ(fmt::format(\"{:>20.2f}\", std::complex<double>(1, 2.2)),\n             \"        (1.00+2.20i)\");\n   EXPECT_EQ(fmt::format(\"{:<20.2f}\", std::complex<double>(1, 2.2)),\ndiff --git a/test/xchar-test.cc b/test/xchar-test.cc\n--- a/test/xchar-test.cc\n+++ b/test/xchar-test.cc\n@@ -79,7 +79,7 @@ TEST(xchar_test, format) {\n   EXPECT_THROW(fmt::format(fmt::runtime(L\"{:*\\x343E}\"), 42), fmt::format_error);\n   EXPECT_EQ(fmt::format(L\"{}\", true), L\"true\");\n   EXPECT_EQ(fmt::format(L\"{0}\", L'a'), L\"a\");\n-  EXPECT_EQ(fmt::format(L\"Letter {}\", L'\\x40e'), L\"Letter \\x40e\"); // \u040e\n+  EXPECT_EQ(fmt::format(L\"Letter {}\", L'\\x40e'), L\"Letter \\x40e\");  // \u040e\n   if (sizeof(wchar_t) == 4)\n     EXPECT_EQ(fmt::format(fmt::runtime(L\"{:\ud80c\udc28>3}\"), 42), L\"\ud80c\udc2842\");\n   EXPECT_EQ(fmt::format(L\"{}c{}\", L\"ab\", 1), L\"abc1\");\n@@ -491,12 +491,20 @@ TEST(locale_test, sign) {\n   EXPECT_EQ(fmt::format(std::locale(), L\"{:L}\", -50), L\"-50\");\n }\n \n+TEST(std_test_xchar, format_bitset) {\n+  auto bs = std::bitset<6>(42);\n+  EXPECT_EQ(fmt::format(L\"{}\", bs), L\"101010\");\n+  EXPECT_EQ(fmt::format(L\"{:0>8}\", bs), L\"00101010\");\n+  EXPECT_EQ(fmt::format(L\"{:-^12}\", bs), L\"---101010---\");\n+}\n+\n TEST(std_test_xchar, complex) {\n   auto s = fmt::format(L\"{}\", std::complex<double>(1, 2));\n   EXPECT_EQ(s, L\"(1+2i)\");\n   EXPECT_EQ(fmt::format(L\"{:.2f}\", std::complex<double>(1, 2)),\n             L\"(1.00+2.00i)\");\n   EXPECT_EQ(fmt::format(L\"{:8}\", std::complex<double>(1, 2)), L\"(1+2i)  \");\n+  EXPECT_EQ(fmt::format(L\"{:-<8}\", std::complex<double>(1, 2)), L\"(1+2i)--\");\n }\n \n TEST(std_test_xchar, optional) {\n",
        "problem_statement": "std::bitset formatting (nested_formatter) does not work with wchar_t\nI tried to test the formatting of `std::bitset` using `fmt/std.h`, but with `wchar_t` (and `char16_t`) instead of `char`, using this test:\r\n\r\n```c++\r\nTEST(std_test, format_bitset_Wide) {\r\n  auto bs = std::bitset<6>(42);\r\n  EXPECT_EQ(fmt::format(L\"{}\", bs), L\"101010\");\r\n  EXPECT_EQ(fmt::format(L\"{:0>8}\", bs), L\"00101010\");\r\n  EXPECT_EQ(fmt::format(L\"{:-^12}\", bs), L\"---101010---\");\r\n}\r\n```\r\n\r\nIt didn't compile until I applied the following changes to `std.h`:\r\n\r\n```diff\r\n--- a/include/fmt/std.h\r\n+++ b/include/fmt/std.h\r\n@@ -184,7 +184,7 @@ FMT_END_NAMESPACE\r\n FMT_BEGIN_NAMESPACE\r\n FMT_EXPORT\r\n template <std::size_t N, typename Char>\r\n-struct formatter<std::bitset<N>, Char> : nested_formatter<string_view> {\r\n+struct formatter<std::bitset<N>, Char> : nested_formatter<basic_string_view<Char>, Char> {\r\n  private:\r\n   // Functor because C++11 doesn't support generic lambdas.\r\n   struct writer {\r\n@@ -204,7 +204,7 @@ struct formatter<std::bitset<N>, Char> : nested_formatter<string_view> {\r\n   template <typename FormatContext>\r\n   auto format(const std::bitset<N>& bs, FormatContext& ctx) const\r\n       -> decltype(ctx.out()) {\r\n-    return write_padded(ctx, writer{bs});\r\n+    return this->write_padded(ctx, writer{bs});\r\n   }\r\n };\r\n```\r\n\r\nNow it runs into a segfault, which appears to be caused by the `set_fill` call in `nested_formatter::write_padded`:\r\n```c++\r\n    specs.set_fill(\r\n        basic_string_view<Char>(specs_.fill<Char>(), specs_.fill_size()));\r\n```\r\nin combination with the implementation of `fill()` for non-`char` types returning a nullpointer:\r\n```c++\r\n  template <typename Char, FMT_ENABLE_IF(!std::is_same<Char, char>::value)>\r\n  constexpr auto fill() const -> const Char* {\r\n    return nullptr;\r\n  }\r\n```\r\n\r\nHow is this supposed to work (or rather, can it be made to work)?\n",
        "hints_text": "",
        "created_at": "2025-01-02T18:09:20Z",
        "version": "11.1"
    }
}