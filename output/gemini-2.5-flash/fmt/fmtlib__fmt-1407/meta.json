{
    "task_id": "fmtlib__fmt-1407",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-1407_2025-07-08_00-42-49",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 1407,
        "instance_id": "fmtlib__fmt-1407",
        "issue_numbers": [
            "1369"
        ],
        "base_commit": "1f918159edded99c9c0cf005c96ecc12e4cc92b1",
        "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -541,14 +541,14 @@ struct FMT_DEPRECATED convert_to_int\n     : bool_constant<!std::is_arithmetic<T>::value &&\n                     std::is_convertible<T, int>::value> {};\n \n-namespace internal {\n-\n // Specifies if T has an enabled formatter specialization. A type can be\n // formattable even if it doesn't have a formatter e.g. via a conversion.\n template <typename T, typename Context>\n using has_formatter =\n     std::is_constructible<typename Context::template formatter_type<T>>;\n \n+namespace internal {\n+\n /** A contiguous memory buffer with an optional growing ability. */\n template <typename T> class buffer {\n  private:\n",
        "test_patch": "diff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -453,11 +453,11 @@ template <> struct formatter<enabled_formatter> {\n FMT_END_NAMESPACE\n \n TEST(CoreTest, HasFormatter) {\n-  using fmt::internal::has_formatter;\n+  using fmt::has_formatter;\n   using context = fmt::format_context;\n-  EXPECT_TRUE((has_formatter<enabled_formatter, context>::value));\n-  EXPECT_FALSE((has_formatter<disabled_formatter, context>::value));\n-  EXPECT_FALSE((has_formatter<disabled_formatter_convertible, context>::value));\n+  static_assert(has_formatter<enabled_formatter, context>::value, \"\");\n+  static_assert(!has_formatter<disabled_formatter, context>::value, \"\");\n+  static_assert(!has_formatter<disabled_formatter_convertible, context>::value, \"\");\n }\n \n struct convertible_to_int {\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -1974,8 +1974,8 @@ enum TestEnum { A };\n TEST(FormatTest, Enum) { EXPECT_EQ(\"0\", fmt::format(\"{}\", A)); }\n \n TEST(FormatTest, FormatterNotSpecialized) {\n-  EXPECT_FALSE((fmt::internal::has_formatter<fmt::formatter<TestEnum>,\n-                                             fmt::format_context>::value));\n+  static_assert(!fmt::has_formatter<fmt::formatter<TestEnum>,\n+                                    fmt::format_context>::value, \"\");\n }\n \n #if FMT_HAS_FEATURE(cxx_strong_enums)\n",
        "problem_statement": "Detect if type is formattable in SFINAE-friendly way?\nIs there a way to detect if a type is formattable in a way that is SFINAE-friendly?  I am familiar with the `static_assert` that triggers inside fmt in this case, but is there a SFINAE-friendly way?  Thanks\n",
        "hints_text": "Not sure. There is `fmt::internal::has_formatter` that tells if `formatter` specialization is available, but it's not part of the public API.\nWould you have any recommendations on how I could write one?  I think it would be very useful to have such a thing for meta programming.\nHave you tried checking if `fmt::format` is invocable with `const char*` and `T` arguments?\nWhen you call `fmt::format` with `const char*` and `T` arguments, and if `T` is not formattable, then it will go here:\r\n```cpp\r\ntemplate <typename T, typename Char = char, typename Enable = void>\r\nstruct fallback_formatter {\r\n  static_assert(\r\n      no_formatter_error<T>::value,\r\n      \"don't know how to format the type, include fmt/ostream.h if it provides \"\r\n      \"an operator<< that should be used\");\r\n};\r\n```\r\nand trigger the `static_assert`, which is not a SFINAE-able error.  Furthermore, if we try putting it in a `decltype` like so:\r\n```cpp\r\nusing Test = decltype( fmt::format( \"{}\", std::declval<MyType>() ) );\r\n```\r\nThe line always compiles, for any type, and `Test` is `std::string` (so again this is not SFINAE-friendly).\r\n\r\nMy use case is that I need to be able to write something like this in my code:\r\n```cpp\r\nMyClass m;\r\nif constexpr( is_formattable<MyClass> ) {\r\n  fmt::print( \"{}\", m );\r\n}\r\n```\r\nAny way that this could be made possible?\n> Any way that this could be made possible?\r\n\r\n`no_formatter_error` is gone in the current master but there are other cases with static assert. I'm not entirely sure if this can be done in a more SFINAE-friendly way. In any case the quality of diagnostics for the common use should have higher priority. If it is of any help `has_formatter` can be moved to the public API.\r\n\nThanks; I'm not too familiar with the internal `has_formatter` -- if it could be used to solve my use case, then I would welcome it in the public API.  And I totally agree that we should not sacrifice quality of diagnostics in the common case.\n`has_formatter<T, Context>` tells you that type `T` has a `formatter` specialization for `Context` (context basically specifies character and output iterator types) and it can be used with SFINAE. Example: https://godbolt.org/z/pCD14x. The main caveat is that types with implicit conversion can be formattable but not have a `formatter` specialization.\nI think that is exactly what I need, and so it would be great to get that into the public API.\nCould you submit a PR moving `has_formatter` from `fmt::internal` to `fmt` then?\nOk I'll take a look.\nOne might think this is use case showing the right kind of usage of C++20 contracts ?\r\n```cpp\r\n  template<class... Args>\r\n    string format(string_view fmt, const Args&... args)\r\n   [[ expects: is_formatable( fmt, args... ) ]] ;\r\n```\r\n\r\nI am sure you know, but for the benefit of others here is [the short, succint and official on C++20 contracts.](https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/)\nNo, contracts are for runtime checks, this is a compile-time check. Those are done with `requires` from concepts.\nI stand corrected ... Saturday early morning is not for a GitHub chat :)\r\n\r\nAlthough, I see no harm done in applying that contract?\nThe contract would never fire, as the code doesn't compile if the condition is false.\n@foonathan , I have no required compiler to test this. In theory, I might prefer the 'expects axiom' contract?\r\n```cpp\r\n  template<class... Args>\r\n    string format(string_view fmt, const Args&... args)\r\n   [[ expects axiom: is_formatable( fmt, args... ) ]] ;\r\n```\r\nMy understanding is: `expects`  is for preconditions, and `axiom` modifier means : \"...the predicate is not checked at run-time\" ? \r\n\r\nPlease advise ...\nAn axiom check would be something like \"the passed pointer can be dereferenced\", which is a dynamic property that can't be verified.  Here we have a precondition like \"the pointer points to non const\", which is a static property checkable by the type system.\n\n(But anyway, this discussion is moot as contracts are not actually coming in C++20)\n## [But they are ?](https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/)\nThat is from 2018, they were again removed at the standardization meeting in July.\nApologies, my mistake ... again.",
        "created_at": "2019-11-13T14:14:23Z",
        "version": "6.0"
    }
}