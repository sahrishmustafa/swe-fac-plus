{
    "task_id": "fmtlib__fmt-149",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-149_2025-07-04_18-45-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 149,
        "instance_id": "fmtlib__fmt-149",
        "issue_numbers": [
            "143"
        ],
        "base_commit": "88f4be3d19364a484431309f750535386c7d0d5c",
        "patch": "diff --git a/format.h b/format.h\n--- a/format.h\n+++ b/format.h\n@@ -707,9 +707,8 @@ struct NonZero {\n   enum { VALUE = N > 0 ? N : 1 };\n };\n \n-// A formatting argument. It is a POD type to allow storage in\n-// internal::MemoryBuffer.\n-struct Arg {\n+// A formatting argument value.\n+struct Value {\n   template <typename Char>\n   struct StringValue {\n     const Char *value;\n@@ -747,6 +746,11 @@ struct Arg {\n     DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,\n     CSTRING, STRING, WSTRING, POINTER, CUSTOM\n   };\n+};\n+\n+// A formatting argument. It is a POD type to allow storage in\n+// internal::MemoryBuffer.\n+struct Arg : Value {\n   Type type;\n };\n \n@@ -800,6 +804,12 @@ struct EnableIf {};\n template<class T>\n struct EnableIf<true, T> { typedef T type; };\n \n+template<bool B, class T, class F>\n+struct Conditional { typedef T type; };\n+\n+template<class T, class F>\n+struct Conditional<false, T, F> { typedef F type; };\n+\n // A helper function to suppress bogus \"conditional expression is constant\"\n // warnings.\n inline bool check(bool value) { return value; }\n@@ -1068,7 +1078,15 @@ class ArgList {\n   // To reduce compiled code size per formatting function call, types of first\n   // MAX_PACKED_ARGS arguments are passed in the types_ field.\n   uint64_t types_;\n-  const internal::Arg *args_;\n+  union {\n+    // If the number of arguments is less than MAX_PACKED_ARGS, the argument\n+    // values are stored in values_, otherwise they are stored in args_.\n+    // This is done to reduce compiled code size as storing larger objects\n+    // may require more code (at least on x86-64) even if the same amount of\n+    // data is actually copied to stack. It saves ~10% on the bloat test.\n+    const internal::Value *values_;\n+    const internal::Arg *args_;\n+  };\n \n   internal::Arg::Type type(unsigned index) const {\n     unsigned shift = index * 4;\n@@ -1082,6 +1100,10 @@ class ArgList {\n   enum { MAX_PACKED_ARGS = 16 };\n \n   ArgList() : types_(0) {}\n+\n+  // TODO: MakeArgList(const Args &...)\n+  ArgList(ULongLong types, const internal::Value *values)\n+  : types_(types), values_(values) {}\n   ArgList(ULongLong types, const internal::Arg *args)\n   : types_(types), args_(args) {}\n \n@@ -1089,14 +1111,18 @@ class ArgList {\n   internal::Arg operator[](unsigned index) const {\n     using internal::Arg;\n     Arg arg;\n+    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;\n     if (index < MAX_PACKED_ARGS) {\n       Arg::Type arg_type = type(index);\n+      internal::Value &val = arg;\n       if (arg_type != Arg::NONE)\n-        arg = args_[index];\n+        val = use_values ? values_[index] : args_[index];\n       arg.type = arg_type;\n       return arg;\n     }\n-    if (type(MAX_PACKED_ARGS - 1) == Arg::NONE) {\n+    if (use_values) {\n+      // The index is greater than the number of arguments that can be stored\n+      // in values, so return a \"none\" argument.\n       arg.type = Arg::NONE;\n       return arg;\n     }\n@@ -1112,6 +1138,12 @@ struct FormatSpec;\n \n namespace internal {\n \n+template <std::size_t NUM_ARGS>\n+struct SelectValueType {\n+  typedef typename Conditional<\n+    (NUM_ARGS < ArgList::MAX_PACKED_ARGS), Value, Arg>::type Type;\n+};\n+\n class FormatterBase {\n  private:\n   ArgList args_;\n@@ -1463,23 +1495,25 @@ inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n # define FMT_VARIADIC_VOID(func, arg_type) \\\n   template <typename... Args> \\\n   void func(arg_type arg1, const Args & ... args) { \\\n-    const fmt::internal::Arg array[ \\\n-      fmt::internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n-      fmt::internal::MakeValue<Char>(args)... \\\n+    namespace internal = fmt::internal; \\\n+    typedef typename internal::SelectValueType<sizeof...(Args)>::Type Value; \\\n+    const Value array[ \\\n+      internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n+      internal::MakeValue<Char>(args)... \\\n     }; \\\n-    func(arg1, ArgList(fmt::internal::make_type(args...), array)); \\\n+    func(arg1, ArgList(internal::make_type(args...), array)); \\\n   }\n \n // Defines a variadic constructor.\n # define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n   template <typename... Args> \\\n   ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \\\n-    using fmt::internal::MakeValue; \\\n-    const fmt::internal::Arg array[ \\\n-        fmt::internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n-      MakeValue<Char>(args)... \\\n+    namespace internal = fmt::internal; \\\n+    typedef typename internal::SelectValueType<sizeof...(Args)>::Type Value; \\\n+    const Value array[internal::NonZero<sizeof...(Args)>::VALUE] = { \\\n+      internal::MakeValue<Char>(args)... \\\n     }; \\\n-    func(arg0, arg1, ArgList(fmt::internal::make_type(args...), array)); \\\n+    func(arg0, arg1, ArgList(internal::make_type(args...), array)); \\\n   }\n \n #else\n@@ -1492,9 +1526,9 @@ inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n # define FMT_WRAP1(func, arg_type, n) \\\n   template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n   inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n-    const fmt::internal::Arg args[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n+    const fmt::internal::Value values[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n     func(arg1, fmt::ArgList( \\\n-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), args)); \\\n+      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), values)); \\\n   }\n \n // Emulates a variadic function returning void on a pre-C++11 compiler.\n@@ -1509,9 +1543,9 @@ inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n # define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \\\n   template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n   ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n-    const fmt::internal::Arg args[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n+    const fmt::internal::Value values[] = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n     func(arg0, arg1, fmt::ArgList( \\\n-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), args)); \\\n+      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), values)); \\\n   }\n \n // Emulates a variadic constructor on a pre-C++11 compiler.\n@@ -2619,6 +2653,11 @@ inline void set_types(Arg *array, const Args & ... args) {\n   array[sizeof...(Args)].type = Arg::NONE;\n }\n \n+template <typename... Args>\n+inline void set_types(Value *, const Args & ...) {\n+  // Do nothing as types are passed separately from values.\n+}\n+\n // Computes the argument array size by adding 1 to N, which is the number of\n // arguments, if N is zero, because array of zero size is invalid, or if N\n // is greater than ArgList::MAX_PACKED_ARGS to accommodate for an extra\n@@ -2634,14 +2673,15 @@ struct ArgArraySize {\n   template <typename... Args> \\\n   ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n       const Args & ... args) { \\\n-    using fmt::internal::Arg; \\\n-    Arg array[fmt::internal::ArgArraySize<sizeof...(Args)>::VALUE] = { \\\n-      fmt::internal::MakeValue<Char>(args)... \\\n+    namespace internal = fmt::internal; \\\n+    typedef typename internal::SelectValueType<sizeof...(Args)>::Type Value; \\\n+    Value array[internal::ArgArraySize<sizeof...(Args)>::VALUE] = { \\\n+      internal::MakeValue<Char>(args)... \\\n     }; \\\n-    if (fmt::internal::check((sizeof...(Args) > fmt::ArgList::MAX_PACKED_ARGS))) \\\n+    if (internal::check((sizeof...(Args) > fmt::ArgList::MAX_PACKED_ARGS))) \\\n       set_types(array, args...); \\\n     call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \\\n-      fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n+      fmt::ArgList(internal::make_type(args...), array)); \\\n   }\n #else\n // Defines a wrapper for a function taking __VA_ARGS__ arguments\n@@ -2650,9 +2690,9 @@ struct ArgArraySize {\n   template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n   inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n       FMT_GEN(n, FMT_MAKE_ARG)) { \\\n-    const fmt::internal::Arg args[] = {FMT_GEN(n, FMT_MAKE_REF_##Char)}; \\\n+    const fmt::internal::Value values[] = {FMT_GEN(n, FMT_MAKE_REF_##Char)}; \\\n     call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \\\n-      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), args)); \\\n+      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), values)); \\\n   }\n \n # define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \\\n",
        "test_patch": "diff --git a/test/util-test.cc b/test/util-test.cc\n--- a/test/util-test.cc\n+++ b/test/util-test.cc\n@@ -423,7 +423,7 @@ ARG_INFO(POINTER, const void *, pointer);\n ARG_INFO(CUSTOM, Arg::CustomValue, custom);\n \n #define CHECK_ARG_INFO(Type, field, value) { \\\n-  Arg arg = {}; \\\n+  Arg arg = Arg(); \\\n   arg.field = value; \\\n   EXPECT_EQ(value, ArgInfo<Arg::Type>::get(arg)); \\\n }\n@@ -442,7 +442,7 @@ TEST(ArgTest, ArgInfo) {\n   CHECK_ARG_INFO(WSTRING, wstring.value, WSTR);\n   int p = 0;\n   CHECK_ARG_INFO(POINTER, pointer, &p);\n-  Arg arg = {};\n+  Arg arg = Arg();\n   arg.custom.value = &p;\n   EXPECT_EQ(&p, ArgInfo<Arg::CUSTOM>::get(arg).value);\n }\n@@ -842,3 +842,30 @@ TEST(UtilTest, IsEnumConvertibleToInt) {\n }\n #endif\n \n+template <typename T>\n+bool check_enable_if(\n+    typename fmt::internal::EnableIf<sizeof(T) == sizeof(int), T>::type *) {\n+  return true;\n+}\n+\n+template <typename T>\n+bool check_enable_if(\n+    typename fmt::internal::EnableIf<sizeof(T) != sizeof(int), T>::type *) {\n+  return false;\n+}\n+\n+TEST(UtilTest, EnableIf) {\n+  int i = 0;\n+  EXPECT_TRUE(check_enable_if<int>(&i));\n+  char c = 0;\n+  EXPECT_FALSE(check_enable_if<char>(&c));\n+}\n+\n+TEST(UtilTest, Conditional) {\n+  int i = 0;\n+  fmt::internal::Conditional<true, int, char>::type *pi = &i;\n+  (void)pi;\n+  char c = 0;\n+  fmt::internal::Conditional<false, int, char>::type *pc = &c;\n+  (void)pc;\n+}\n",
        "problem_statement": "Make sure that support for arbitrary number of arguments doesn't increase compiled code size\nCompiled code size has been reduced in https://github.com/cppformat/cppformat/commit/cf04d98d0663296b4d4c56fd24f617aa14e079f3, but need to check that there is no regression compared to version 1.1.0.\n\n",
        "hints_text": "Target: 34912\nCurrent: 47200\nPartially caused by zero initialization of extra argument. Can be easily bypassed when the number of arguments is less than `MAX_PACKED_ARGS`.\n\nAfter https://github.com/cppformat/cppformat/commit/2ba3988da3af477ab40da67e3e3289a53893a245: 39008\n\nSo the remaining difference is only due to increase in allocated stack size:\n\n![screenshot from 2015-03-25 21 53 46](https://cloud.githubusercontent.com/assets/576385/6840625/990770ce-d339-11e4-8b65-ef189e684109.png)\n\nwhich can be fixed by using a union of `(Value*, Arg*)`.\n",
        "created_at": "2015-04-20T15:34:08Z",
        "version": "1.1"
    }
}