{
    "task_id": "fmtlib__fmt-1360",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-1360_2025-07-07_22-11-05",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 1360,
        "instance_id": "fmtlib__fmt-1360",
        "issue_numbers": [
            "1353"
        ],
        "base_commit": "96f91428c6ad2d19f1ce87ae160b78f52ed989fb",
        "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -657,6 +657,7 @@ enum type {\n   char_type,\n   last_integer_type = char_type,\n   // followed by floating-point types.\n+  float_type,\n   double_type,\n   long_double_type,\n   last_numeric_type = long_double_type,\n@@ -683,6 +684,7 @@ FMT_TYPE_CONSTANT(int128_t, int128_type);\n FMT_TYPE_CONSTANT(uint128_t, uint128_type);\n FMT_TYPE_CONSTANT(bool, bool_type);\n FMT_TYPE_CONSTANT(Char, char_type);\n+FMT_TYPE_CONSTANT(float, float_type);\n FMT_TYPE_CONSTANT(double, double_type);\n FMT_TYPE_CONSTANT(long double, long_double_type);\n FMT_TYPE_CONSTANT(const Char*, cstring_type);\n@@ -724,6 +726,7 @@ template <typename Context> class value {\n     uint128_t uint128_value;\n     bool bool_value;\n     char_type char_value;\n+    float float_value;\n     double double_value;\n     long double long_double_value;\n     const void* pointer;\n@@ -738,6 +741,7 @@ template <typename Context> class value {\n   value(unsigned long long val) : ulong_long_value(val) {}\n   value(int128_t val) : int128_value(val) {}\n   value(uint128_t val) : uint128_value(val) {}\n+  value(float val) : float_value(val) {}\n   value(double val) : double_value(val) {}\n   value(long double val) : long_double_value(val) {}\n   value(bool val) : bool_value(val) {}\n@@ -809,7 +813,7 @@ template <typename Context> struct arg_mapper {\n     return val;\n   }\n \n-  FMT_CONSTEXPR double map(float val) { return static_cast<double>(val); }\n+  FMT_CONSTEXPR float map(float val) { return val; }\n   FMT_CONSTEXPR double map(double val) { return val; }\n   FMT_CONSTEXPR long double map(long double val) { return val; }\n \n@@ -889,7 +893,11 @@ using mapped_type_constant =\n                   typename Context::char_type>;\n \n // Maximum number of arguments with packed types.\n-enum { max_packed_args = 15 };\n+enum {\n+  packed_arg_bitsize = 5,\n+  packed_arg_mask = (1 << packed_arg_bitsize) - 1,\n+  max_packed_args = 63 / packed_arg_bitsize,\n+};\n enum : unsigned long long { is_unpacked_bit = 1ull << 63 };\n \n template <typename Context> class arg_map;\n@@ -981,6 +989,8 @@ FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,\n     return vis(arg.value_.bool_value);\n   case internal::char_type:\n     return vis(arg.value_.char_value);\n+  case internal::float_type:\n+    return vis(arg.value_.float_value);\n   case internal::double_type:\n     return vis(arg.value_.double_value);\n   case internal::long_double_type:\n@@ -1052,7 +1062,7 @@ template <typename> constexpr unsigned long long encode_types() { return 0; }\n template <typename Context, typename Arg, typename... Args>\n constexpr unsigned long long encode_types() {\n   return mapped_type_constant<Arg, Context>::value |\n-         (encode_types<Context, Args...>() << 4);\n+         (encode_types<Context, Args...>() << packed_arg_bitsize);\n }\n \n template <typename Context, typename T>\n@@ -1197,8 +1207,8 @@ template <typename Context> class basic_format_args {\n   bool is_packed() const { return (types_ & internal::is_unpacked_bit) == 0; }\n \n   internal::type type(int index) const {\n-    int shift = index * 4;\n-    return static_cast<internal::type>((types_ & (0xfull << shift)) >> shift);\n+    int shift = index * internal::packed_arg_bitsize;\n+    return static_cast<internal::type>((types_ >> shift) & internal::packed_arg_mask);\n   }\n \n   friend class internal::arg_map<Context>;\ndiff --git a/include/fmt/format-inl.h b/include/fmt/format-inl.h\n--- a/include/fmt/format-inl.h\n+++ b/include/fmt/format-inl.h\n@@ -980,6 +980,13 @@ FMT_API bool grisu_format(Double value, buffer<char>& buf, int precision,\n   return true;\n }\n \n+template <>\n+char* sprintf_format<float>(float value, internal::buffer<char>& buf,\n+                            sprintf_specs specs) {\n+  // printf does not have a float format modifier, it only supports double.\n+  return sprintf_format<double>(value, buf, specs);\n+}\n+\n template <typename Double>\n char* sprintf_format(Double value, internal::buffer<char>& buf,\n                      sprintf_specs specs) {\ndiff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -1663,8 +1663,12 @@ template <typename Range> class basic_writer {\n                                    int_writer<T, Spec>(*this, value, spec));\n   }\n \n+  void write(float value, const format_specs& specs = format_specs()) {\n+    write_fp(value, specs);\n+  }\n+\n   void write(double value, const format_specs& specs = format_specs()) {\n-    write_double(value, specs);\n+    write_fp(value, specs);\n   }\n \n   /**\n@@ -1674,12 +1678,12 @@ template <typename Range> class basic_writer {\n     \\endrst\n    */\n   void write(long double value, const format_specs& specs = format_specs()) {\n-    write_double(value, specs);\n+    write_fp(value, specs);\n   }\n \n-  // Formats a floating-point number (double or long double).\n+  // Formats a floating-point number (float, double, or long double).\n   template <typename T, bool USE_GRISU = fmt::internal::use_grisu<T>()>\n-  void write_double(T value, const format_specs& specs);\n+  void write_fp(T value, const format_specs& specs);\n \n   /** Writes a character to the buffer. */\n   void write(char value) {\n@@ -1826,7 +1830,7 @@ class arg_formatter_base {\n \n   template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n   iterator operator()(T value) {\n-    writer_.write_double(value, specs_ ? *specs_ : format_specs());\n+    writer_.write_fp(value, specs_ ? *specs_ : format_specs());\n     return out();\n   }\n \n@@ -2766,8 +2770,8 @@ struct float_spec_handler {\n \n template <typename Range>\n template <typename T, bool USE_GRISU>\n-void internal::basic_writer<Range>::write_double(T value,\n-                                                 const format_specs& specs) {\n+void internal::basic_writer<Range>::write_fp(T value,\n+                                             const format_specs& specs) {\n   // Check type.\n   float_spec_handler handler(static_cast<char>(specs.type));\n   internal::handle_float_type_spec(handler.type, handler);\n@@ -3006,6 +3010,7 @@ struct formatter<T, Char,\n       handle_char_specs(\n           &specs_, internal::char_specs_checker<decltype(eh)>(specs_.type, eh));\n       break;\n+    case internal::float_type:\n     case internal::double_type:\n     case internal::long_double_type:\n       handle_float_type_spec(specs_.type,\n@@ -3061,7 +3066,6 @@ FMT_FORMAT_AS(short, int);\n FMT_FORMAT_AS(unsigned short, unsigned);\n FMT_FORMAT_AS(long, long long);\n FMT_FORMAT_AS(unsigned long, unsigned long long);\n-FMT_FORMAT_AS(float, double);\n FMT_FORMAT_AS(Char*, const Char*);\n FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);\n FMT_FORMAT_AS(std::nullptr_t, const void*);\n",
        "test_patch": "diff --git a/test/core-test.cc b/test/core-test.cc\n--- a/test/core-test.cc\n+++ b/test/core-test.cc\n@@ -290,8 +290,6 @@ VISIT_TYPE(long, long long);\n VISIT_TYPE(unsigned long, unsigned long long);\n #endif\n \n-VISIT_TYPE(float, double);\n-\n #define CHECK_ARG_(Char, expected, value)                                     \\\n   {                                                                           \\\n     testing::StrictMock<mock_visitor<decltype(expected)>> visitor;            \\\ndiff --git a/test/locale-test.cc b/test/locale-test.cc\n--- a/test/locale-test.cc\n+++ b/test/locale-test.cc\n@@ -23,7 +23,7 @@ TEST(LocaleTest, DoubleDecimalPoint) {\n   fmt::internal::writer w(buf, fmt::internal::locale_ref(loc));\n   auto specs = fmt::format_specs();\n   specs.type = 'n';\n-  w.write_double<double, false>(1.23, specs);\n+  w.write_fp<double, false>(1.23, specs);\n   EXPECT_EQ(fmt::to_string(buf), \"1?23\");\n }\n \n",
        "problem_statement": "Cannot override float processing\nTried to override format for standard types according to documentation:\r\n\r\n`\r\nusing arg_formatter = fmt::arg_formatter<fmt::back_insert_range<fmt::internal::buffer>>;\r\n\r\nclass na_arg_formatter : public arg_formatter {\r\npublic:\r\n\tna_arg_formatter(fmt::format_context &ctx, fmt::format_specs *spec = nullptr)\r\n\t\t: arg_formatter(ctx, spec),\r\n\t\tm_na_formatter(ctx)\r\n\t{}\r\n\r\n\tusing arg_formatter::operator();\r\n\r\n\tauto operator()(double value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\n\tauto operator()(float value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\n\tauto operator()(unsigned value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\n\tauto operator()(int value) {\r\n\t\tif (IsNA(value))\r\n\t\t\treturn m_na_formatter(\"NA\");\r\n\t\treturn arg_formatter::operator()(value);\r\n\t}\r\n\r\nprivate:\r\n\targ_formatter m_na_formatter;\r\n};\r\n\r\ninline std::string na_vformat(fmt::string_view format_str, fmt::format_args args) {\r\n\tfmt::memory_buffer buffer;\r\n\t// Pass custom argument formatter as a template arg to vformat_to.\r\n\tfmt::vformat_to<na_arg_formatter>(buffer, format_str, args);\r\n\treturn fmt::to_string(buffer);\r\n}\r\n\r\ntemplate <typename ...Args>\r\ninline std::string na_format(\r\n\tfmt::string_view format_str, const Args &... args) {\r\n\treturn na_vformat(format_str, fmt::make_format_args(args...));\r\n}\r\n`\r\n\r\nFloat overloading is not working.\r\nDouble case is chosen.\r\n`\r\nna_format(\"{}\", 4.f);\r\n`\r\n\n",
        "hints_text": "This is effectively a subset of the issue reported in #1336 - we should stop promoting `float` to `double`.",
        "created_at": "2019-10-12T03:47:16Z",
        "version": "6.0"
    }
}