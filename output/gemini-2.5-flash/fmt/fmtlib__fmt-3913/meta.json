{
    "task_id": "fmtlib__fmt-3913",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3913_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3913,
        "instance_id": "fmtlib__fmt-3913",
        "issue_numbers": [
            "3772"
        ],
        "base_commit": "3b5f3de3b57505c7f1a60ee40ef3448c623b1326",
        "patch": "diff --git a/include/fmt/chrono.h b/include/fmt/chrono.h\n--- a/include/fmt/chrono.h\n+++ b/include/fmt/chrono.h\n@@ -2040,6 +2040,7 @@ using weekday = std::chrono::weekday;\n using day = std::chrono::day;\n using month = std::chrono::month;\n using year = std::chrono::year;\n+using year_month_day = std::chrono::year_month_day;\n #else\n // A fallback version of weekday.\n class weekday {\n@@ -2085,46 +2086,75 @@ class year {\n   constexpr explicit operator int() const noexcept { return value_; }\n };\n \n-class year_month_day {};\n+class year_month_day {\n+ private:\n+  fmt::year year_;\n+  fmt::month month_;\n+  fmt::day day_;\n+\n+ public:\n+  year_month_day() = default;\n+  constexpr year_month_day(const year& y, const month& m, const day& d) noexcept\n+      : year_(y), month_(m), day_(d) {}\n+  constexpr fmt::year year() const noexcept { return year_; }\n+  constexpr fmt::month month() const noexcept { return month_; }\n+  constexpr fmt::day day() const noexcept { return day_; }\n+};\n #endif\n \n-// A rudimentary weekday formatter.\n-template <typename Char> struct formatter<weekday, Char> {\n+template <typename Char>\n+struct formatter<weekday, Char> : private formatter<std::tm, Char> {\n  private:\n-  bool localized = false;\n+  bool localized_{false};\n+  bool use_tm_formatter_{false};\n \n  public:\n   FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n       -> decltype(ctx.begin()) {\n-    auto begin = ctx.begin(), end = ctx.end();\n-    if (begin != end && *begin == 'L') {\n-      ++begin;\n-      localized = true;\n+    auto it = ctx.begin(), end = ctx.end();\n+    if (it != end && *it == 'L') {\n+      ++it;\n+      localized_ = true;\n+      return it;\n     }\n-    return begin;\n+    use_tm_formatter_ = it != end && *it != '}';\n+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;\n   }\n \n   template <typename FormatContext>\n   auto format(weekday wd, FormatContext& ctx) const -> decltype(ctx.out()) {\n     auto time = std::tm();\n     time.tm_wday = static_cast<int>(wd.c_encoding());\n-    detail::get_locale loc(localized, ctx.locale());\n+    if (use_tm_formatter_) {\n+      return formatter<std::tm, Char>::format(time, ctx);\n+    }\n+    detail::get_locale loc(localized_, ctx.locale());\n     auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n     w.on_abbr_weekday();\n     return w.out();\n   }\n };\n \n-template <typename Char> struct formatter<day, Char> {\n+template <typename Char>\n+struct formatter<day, Char> : private formatter<std::tm, Char> {\n+ private:\n+  bool use_tm_formatter_{false};\n+\n+ public:\n   FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n       -> decltype(ctx.begin()) {\n-    return ctx.begin();\n+    auto it = ctx.begin(), end = ctx.end();\n+    use_tm_formatter_ = it != end && *it != '}';\n+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;\n   }\n \n   template <typename FormatContext>\n   auto format(day d, FormatContext& ctx) const -> decltype(ctx.out()) {\n     auto time = std::tm();\n     time.tm_mday = static_cast<int>(static_cast<unsigned>(d));\n+    if (use_tm_formatter_) {\n+      return formatter<std::tm, Char>::format(time, ctx);\n+    }\n     detail::get_locale loc(false, ctx.locale());\n     auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n     w.on_day_of_month(detail::numeric_system::standard);\n@@ -2132,51 +2162,96 @@ template <typename Char> struct formatter<day, Char> {\n   }\n };\n \n-template <typename Char> struct formatter<month, Char> {\n+template <typename Char>\n+struct formatter<month, Char> : private formatter<std::tm, Char> {\n  private:\n-  bool localized = false;\n+  bool localized_{false};\n+  bool use_tm_formatter_{false};\n \n  public:\n   FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n       -> decltype(ctx.begin()) {\n-    auto begin = ctx.begin(), end = ctx.end();\n-    if (begin != end && *begin == 'L') {\n-      ++begin;\n-      localized = true;\n+    auto it = ctx.begin(), end = ctx.end();\n+    if (it != end && *it == 'L') {\n+      ++it;\n+      localized_ = true;\n+      return it;\n     }\n-    return begin;\n+    use_tm_formatter_ = it != end && *it != '}';\n+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;\n   }\n \n   template <typename FormatContext>\n   auto format(month m, FormatContext& ctx) const -> decltype(ctx.out()) {\n     auto time = std::tm();\n-    // std::chrono::month has a range of 1-12, std::tm requires 0-11\n     time.tm_mon = static_cast<int>(static_cast<unsigned>(m)) - 1;\n-    detail::get_locale loc(localized, ctx.locale());\n+    if (use_tm_formatter_) {\n+      return formatter<std::tm, Char>::format(time, ctx);\n+    }\n+    detail::get_locale loc(localized_, ctx.locale());\n     auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n     w.on_abbr_month();\n     return w.out();\n   }\n };\n \n-template <typename Char> struct formatter<year, Char> {\n+template <typename Char>\n+struct formatter<year, Char> : private formatter<std::tm, Char> {\n+ private:\n+  bool use_tm_formatter_{false};\n+\n+ public:\n   FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n       -> decltype(ctx.begin()) {\n-    return ctx.begin();\n+    auto it = ctx.begin(), end = ctx.end();\n+    use_tm_formatter_ = it != end && *it != '}';\n+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;\n   }\n \n   template <typename FormatContext>\n   auto format(year y, FormatContext& ctx) const -> decltype(ctx.out()) {\n     auto time = std::tm();\n-    // std::tm::tm_year is years since 1900\n     time.tm_year = static_cast<int>(y) - 1900;\n-    detail::get_locale loc(true, ctx.locale());\n+    if (use_tm_formatter_) {\n+      return formatter<std::tm, Char>::format(time, ctx);\n+    }\n+    detail::get_locale loc(false, ctx.locale());\n     auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n     w.on_year(detail::numeric_system::standard);\n     return w.out();\n   }\n };\n \n+template <typename Char>\n+struct formatter<year_month_day, Char> : private formatter<std::tm, Char> {\n+ private:\n+  bool use_tm_formatter_{false};\n+\n+ public:\n+  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n+      -> decltype(ctx.begin()) {\n+    auto it = ctx.begin(), end = ctx.end();\n+    use_tm_formatter_ = it != end && *it != '}';\n+    return use_tm_formatter_ ? formatter<std::tm, Char>::parse(ctx) : it;\n+  }\n+\n+  template <typename FormatContext>\n+  auto format(year_month_day val, FormatContext& ctx) const\n+      -> decltype(ctx.out()) {\n+    auto time = std::tm();\n+    time.tm_year = static_cast<int>(val.year()) - 1900;\n+    time.tm_mon = static_cast<int>(static_cast<unsigned>(val.month())) - 1;\n+    time.tm_mday = static_cast<int>(static_cast<unsigned>(val.day()));\n+    if (use_tm_formatter_) {\n+      return formatter<std::tm, Char>::format(time, ctx);\n+    }\n+    detail::get_locale loc(true, ctx.locale());\n+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n+    w.on_iso_date();\n+    return w.out();\n+  }\n+};\n+\n template <typename Rep, typename Period, typename Char>\n struct formatter<std::chrono::duration<Rep, Period>, Char> {\n  private:\n",
        "test_patch": "diff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -751,18 +751,17 @@ TEST(chrono_test, unsigned_duration) {\n TEST(chrono_test, weekday) {\n   auto loc = get_locale(\"es_ES.UTF-8\");\n   std::locale::global(loc);\n-  auto sat = fmt::weekday(6);\n \n-  auto tm = std::tm();\n-  tm.tm_wday = static_cast<int>(sat.c_encoding());\n+  auto sat = fmt::weekday(6);\n \n   EXPECT_EQ(fmt::format(\"{}\", sat), \"Sat\");\n-  EXPECT_EQ(fmt::format(\"{:%a}\", tm), \"Sat\");\n+  EXPECT_EQ(fmt::format(\"{:%a}\", sat), \"Sat\");\n+  EXPECT_EQ(fmt::format(\"{:%A}\", sat), \"Saturday\");\n \n   if (loc != std::locale::classic()) {\n     auto saturdays = std::vector<std::string>{\"s\u00e1b\", \"s\u00e1.\"};\n     EXPECT_THAT(saturdays, Contains(fmt::format(loc, \"{:L}\", sat)));\n-    EXPECT_THAT(saturdays, Contains(fmt::format(loc, \"{:%a}\", tm)));\n+    EXPECT_THAT(saturdays, Contains(fmt::format(loc, \"{:%a}\", sat)));\n   }\n }\n \n@@ -1014,13 +1013,33 @@ TEST(chrono_test, out_of_range) {\n }\n \n TEST(chrono_test, year_month_day) {\n-  auto loc = get_locale(\"es_ES.UTF-8\");\n-  std::locale::global(loc);  \n   auto year = fmt::year(2024);\n   auto month = fmt::month(1);\n   auto day = fmt::day(1);\n+  auto ymd = fmt::year_month_day(year, month, day);\n \n   EXPECT_EQ(fmt::format(\"{}\", year), \"2024\");\n+  EXPECT_EQ(fmt::format(\"{:%Y}\", year), \"2024\");\n+  EXPECT_EQ(fmt::format(\"{:%y}\", year), \"24\");\n+\n   EXPECT_EQ(fmt::format(\"{}\", month), \"Jan\");\n+  EXPECT_EQ(fmt::format(\"{:%m}\", month), \"01\");\n+  EXPECT_EQ(fmt::format(\"{:%b}\", month), \"Jan\");\n+  EXPECT_EQ(fmt::format(\"{:%B}\", month), \"January\");\n+\n   EXPECT_EQ(fmt::format(\"{}\", day), \"01\");\n+  EXPECT_EQ(fmt::format(\"{:%d}\", day), \"01\");\n+\n+  EXPECT_EQ(fmt::format(\"{}\", ymd), \"2024-01-01\");\n+  EXPECT_EQ(fmt::format(\"{:%Y-%m-%d}\", ymd), \"2024-01-01\");\n+  EXPECT_EQ(fmt::format(\"{:%Y-%b-%d}\", ymd), \"2024-Jan-01\");\n+  EXPECT_EQ(fmt::format(\"{:%Y-%B-%d}\", ymd), \"2024-January-01\");\n+\n+  auto loc = get_locale(\"es_ES.UTF-8\");\n+  std::locale::global(loc);\n+  if (loc != std::locale::classic()) {\n+    auto months = std::vector<std::string>{\"ene.\", \"ene\"};\n+    EXPECT_THAT(months, Contains(fmt::format(loc, \"{:L}\", month)));\n+    EXPECT_THAT(months, Contains(fmt::format(loc, \"{:%b}\", month)));\n+  }\n }\n",
        "problem_statement": "Add support for `std::chrono::year_month_day`\nSince c++20 there is https://en.cppreference.com/w/cpp/chrono/year_month_day. Currently the only way to format this is to convert it to a `time_point` or writing a custom formatter. I think it would be quite useful to support this directly.\r\n\r\nThere exists an std implementation https://en.cppreference.com/w/cpp/chrono/year_month_day/formatter, but none in {fmt}.\r\n\r\nThere exists a lot of other calendar points like this, which arent supported either\n",
        "hints_text": "Thanks for the suggestion. I think we should do it but let's merge this issue into #3758 which already discusses cases like this.\n@vitaut can we reopen this as a separate issue? The implementation is not trivial if we want to support all types of constructors and functionalities.\nWe don't need to support all constructors but let's reopen.",
        "created_at": "2024-03-30T12:08:42Z",
        "version": "10.2"
    }
}