{
    "task_id": "fmtlib__fmt-3906",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3906_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3906,
        "instance_id": "fmtlib__fmt-3906",
        "issue_numbers": [
            "3758"
        ],
        "base_commit": "88620e53a4ffe4cb02af02fc13d6618ff9727f94",
        "patch": "diff --git a/include/fmt/chrono.h b/include/fmt/chrono.h\n--- a/include/fmt/chrono.h\n+++ b/include/fmt/chrono.h\n@@ -2036,17 +2036,52 @@ struct chrono_formatter {\n \n #if defined(__cpp_lib_chrono) && __cpp_lib_chrono >= 201907\n using weekday = std::chrono::weekday;\n+using day = std::chrono::day;\n+using month = std::chrono::month;\n+using year = std::chrono::year;\n #else\n // A fallback version of weekday.\n class weekday {\n  private:\n-  unsigned char value;\n+  unsigned char value_;\n \n  public:\n   weekday() = default;\n-  explicit constexpr weekday(unsigned wd) noexcept\n-      : value(static_cast<unsigned char>(wd != 7 ? wd : 0)) {}\n-  constexpr auto c_encoding() const noexcept -> unsigned { return value; }\n+  constexpr explicit weekday(unsigned wd) noexcept\n+      : value_(static_cast<unsigned char>(wd != 7 ? wd : 0)) {}\n+  constexpr auto c_encoding() const noexcept -> unsigned { return value_; }\n+};\n+\n+class day {\n+ private:\n+  unsigned char value_;\n+\n+ public:\n+  day() = default;\n+  constexpr explicit day(unsigned d) noexcept\n+      : value_(static_cast<unsigned char>(d)) {}\n+  constexpr explicit operator unsigned() const noexcept { return value_; }\n+};\n+\n+class month {\n+ private:\n+  unsigned char value_;\n+\n+ public:\n+  month() = default;\n+  constexpr explicit month(unsigned m) noexcept\n+      : value_(static_cast<unsigned char>(m)) {}\n+  constexpr explicit operator unsigned() const noexcept { return value_; }\n+};\n+\n+class year {\n+ private:\n+  int value_;\n+\n+ public:\n+  year() = default;\n+  constexpr explicit year(int y) noexcept : value_(y) {}\n+  constexpr explicit operator int() const noexcept { return value_; }\n };\n \n class year_month_day {};\n@@ -2079,6 +2114,68 @@ template <typename Char> struct formatter<weekday, Char> {\n   }\n };\n \n+template <typename Char> struct formatter<day, Char> {\n+  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n+      -> decltype(ctx.begin()) {\n+    return ctx.begin();\n+  }\n+\n+  template <typename FormatContext>\n+  auto format(day d, FormatContext& ctx) const -> decltype(ctx.out()) {\n+    auto time = std::tm();\n+    time.tm_mday = static_cast<int>(static_cast<unsigned>(d));\n+    detail::get_locale loc(false, ctx.locale());\n+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n+    w.on_day_of_month(detail::numeric_system::standard);\n+    return w.out();\n+  }\n+};\n+\n+template <typename Char> struct formatter<month, Char> {\n+ private:\n+  bool localized = false;\n+\n+ public:\n+  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n+      -> decltype(ctx.begin()) {\n+    auto begin = ctx.begin(), end = ctx.end();\n+    if (begin != end && *begin == 'L') {\n+      ++begin;\n+      localized = true;\n+    }\n+    return begin;\n+  }\n+\n+  template <typename FormatContext>\n+  auto format(month m, FormatContext& ctx) const -> decltype(ctx.out()) {\n+    auto time = std::tm();\n+    // std::chrono::month has a range of 1-12, std::tm requires 0-11\n+    time.tm_mon = static_cast<int>(static_cast<unsigned>(m)) - 1;\n+    detail::get_locale loc(localized, ctx.locale());\n+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n+    w.on_abbr_month();\n+    return w.out();\n+  }\n+};\n+\n+template <typename Char> struct formatter<year, Char> {\n+  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n+      -> decltype(ctx.begin()) {\n+    return ctx.begin();\n+  }\n+\n+  template <typename FormatContext>\n+  auto format(year y, FormatContext& ctx) const -> decltype(ctx.out()) {\n+    auto time = std::tm();\n+    // std::tm::tm_year is years since 1900\n+    time.tm_year = static_cast<int>(y) - 1900;\n+    detail::get_locale loc(true, ctx.locale());\n+    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);\n+    w.on_year(detail::numeric_system::standard);\n+    return w.out();\n+  }\n+};\n+\n template <typename Rep, typename Period, typename Char>\n struct formatter<std::chrono::duration<Rep, Period>, Char> {\n  private:\n",
        "test_patch": "diff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -1011,4 +1011,16 @@ TEST(chrono_test, glibc_extensions) {\n TEST(chrono_test, out_of_range) {\n   auto d = std::chrono::duration<unsigned long, std::giga>(538976288);\n   EXPECT_THROW((void)fmt::format(\"{:%j}\", d), fmt::format_error);\n-}\n\\ No newline at end of file\n+}\n+\n+TEST(chrono_test, year_month_day) {\n+  auto loc = get_locale(\"es_ES.UTF-8\");\n+  std::locale::global(loc);  \n+  auto year = fmt::year(2024);\n+  auto month = fmt::month(1);\n+  auto day = fmt::day(1);\n+\n+  EXPECT_EQ(fmt::format(\"{}\", year), \"2024\");\n+  EXPECT_EQ(fmt::format(\"{}\", month), \"Jan\");\n+  EXPECT_EQ(fmt::format(\"{}\", day), \"01\");\n+}\n",
        "problem_statement": "Green Day Support\n{fmt} doesn't support printing green day at the moment:\r\n\r\n```c++\r\n#include <fmt/chrono.h>\r\n#include <fmt/color.h>\r\n\r\nint main() {\r\n  fmt::print(fg(fmt::color::green), \"{}\", std::chrono::day());\r\n}\r\n```\r\n\r\nError:\r\n\r\n```\r\ninclude/fmt/core.h:1594:63: error: implicit instantiation of undefined template 'fmt::detail::type_is_unformattable_for<const std::chrono::day, char>'\r\n    type_is_unformattable_for<T, typename Context::char_type> _;\r\n                                                              ^\r\n...\r\ninclude/fmt/core.h:1597:3: error: static assertion failed due to requirement 'formattable': Cannot format an argument. To make type T formattable provide a formatter<T> specialization: https://fmt.dev/latest/api.html#udt\r\n  static_assert(\r\n  ^\r\n2 errors generated.\r\n\n",
        "hints_text": "Looking at this, not only day(), but also month() and year(). It seems they do not have a formatter.\r\n\r\nAdding a custom formatter does fix it, but should we support it? If we want to, where is the best place to define them?\nThe C++ standard mentions these formatters (https://eel.is/c++draft/time):\r\n\r\n```c++\r\n  template<class charT> struct formatter<chrono::day, charT>;\r\n  template<class charT> struct formatter<chrono::month, charT>;\r\n  template<class charT> struct formatter<chrono::year, charT>;\r\n```\nin chrono.h, it defined the formatters for weekday, duration, time_point, etc., putting the defines for day, month, and year there works. I'll do some clean ups.\n> The C++ standard mentions these formatters (https://eel.is/c++draft/time):\r\n> \r\n> ```c++\r\n>   template<class charT> struct formatter<chrono::day, charT>;\r\n>   template<class charT> struct formatter<chrono::month, charT>;\r\n>   template<class charT> struct formatter<chrono::year, charT>;\r\n> ```\r\n\r\nyou're right, std should have those formatters, ~~but __cpp_lib_format is false, did some research, is it std::format not supported yet in MSVC?~~\r\n\r\nIt's interesting, as C++ 20 supports formatting all the chrono types, why you had to define the formatters for duration, weekday etc. in fmt in the first place? I think the issue is to make fmt make use the std::formatter's.\n> why you had to define the formatters for duration, weekday etc. in fmt in the first place? I think the issue is to make fmt make use the std::formatter's.\r\n\r\nGood question. `std::chrono` is usually wider available than `std::format` and considering that day/month/year formatters should be easy to implement I think we should just do it ourselves.",
        "created_at": "2024-03-25T19:01:08Z",
        "version": "10.2"
    }
}