{
    "task_id": "fmtlib__fmt-3943",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3943_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3943,
        "instance_id": "fmtlib__fmt-3943",
        "issue_numbers": [
            "3938"
        ],
        "base_commit": "f4b256c6676280dff9a9573c9b295414fd3e6861",
        "patch": "diff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -4017,11 +4017,14 @@ FMT_FORMAT_AS(unsigned short, unsigned);\n FMT_FORMAT_AS(long, detail::long_type);\n FMT_FORMAT_AS(unsigned long, detail::ulong_type);\n FMT_FORMAT_AS(Char*, const Char*);\n-FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);\n FMT_FORMAT_AS(std::nullptr_t, const void*);\n FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);\n FMT_FORMAT_AS(void*, const void*);\n \n+template <typename Char, typename Traits, typename Allocator>\n+class formatter<std::basic_string<Char, Traits, Allocator>, Char>\n+    : public formatter<basic_string_view<Char>, Char> {};\n+\n template <typename Char, size_t N>\n struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {};\n \n",
        "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -22,6 +22,7 @@\n #include <iterator>            // std::back_inserter\n #include <list>                // std::list\n #include <mutex>               // std::mutex\n+#include <string>              // std::string\n #include <thread>              // std::thread\n #include <type_traits>         // std::is_default_constructible\n \n@@ -2222,16 +2223,21 @@ template <typename Char, typename... T> void check_enabled_formatters() {\n }\n \n TEST(format_test, test_formatters_enabled) {\n+  using custom_string =\n+      std::basic_string<char, std::char_traits<char>, mock_allocator<char>>;\n+  using custom_wstring = std::basic_string<wchar_t, std::char_traits<wchar_t>,\n+                                           mock_allocator<wchar_t>>;\n+\n   check_enabled_formatters<char, bool, char, signed char, unsigned char, short,\n                            unsigned short, int, unsigned, long, unsigned long,\n                            long long, unsigned long long, float, double,\n                            long double, void*, const void*, char*, const char*,\n-                           std::string, std::nullptr_t>();\n-  check_enabled_formatters<wchar_t, bool, wchar_t, signed char, unsigned char,\n-                           short, unsigned short, int, unsigned, long,\n-                           unsigned long, long long, unsigned long long, float,\n-                           double, long double, void*, const void*, wchar_t*,\n-                           const wchar_t*, std::wstring, std::nullptr_t>();\n+                           std::string, custom_string, std::nullptr_t>();\n+  check_enabled_formatters<\n+      wchar_t, bool, wchar_t, signed char, unsigned char, short, unsigned short,\n+      int, unsigned, long, unsigned long, long long, unsigned long long, float,\n+      double, long double, void*, const void*, wchar_t*, const wchar_t*,\n+      std::wstring, custom_wstring, std::nullptr_t>();\n }\n \n TEST(format_int_test, data) {\ndiff --git a/test/mock-allocator.h b/test/mock-allocator.h\n--- a/test/mock-allocator.h\n+++ b/test/mock-allocator.h\n@@ -20,6 +20,16 @@ template <typename T> class mock_allocator {\n   using value_type = T;\n   using size_type = size_t;\n \n+  using pointer = T*;\n+  using const_pointer = const T*;\n+  using reference = T&;\n+  using const_reference = const T&;\n+  using difference_type = ptrdiff_t;\n+\n+  template <typename U> struct rebind {\n+    using other = mock_allocator<U>;\n+  };\n+\n   mock_allocator() {}\n   mock_allocator(const mock_allocator&) {}\n \n",
        "problem_statement": "Formatting for strings with custom allocators fails to compile\nWhen using a `std::basic_string` with a custom allocator, it fails to compile in a few use cases, e.g.:\r\n\r\n```cpp\r\nstd::string f1() {\r\n    // This compiles.\r\n    return fmt::format(\"{}\", std::tuple<std::string>{});\r\n}\r\n\r\nstd::string f2() {\r\n    // This compiles.\r\n    return fmt::format(\"{}\", std::pmr::string{});\r\n}\r\n\r\nstd::string f3() {\r\n    // This does not compile.\r\n    return fmt::format(\"{}\", std::tuple<std::pmr::string>{});\r\n}\r\n```\r\n\r\nYou can reproduce the error here: https://godbolt.org/z/4oa1jqr1G\r\n\r\nI checked the code, and it seems `std::basic_string` is specialized only for the default allocator. I think the fix might be as simple as replacing\r\n\r\n```cpp\r\nFMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);\r\n```\r\n\r\nwith\r\n\r\n```cpp\r\ntemplate <typename Char, typename Alloc>\r\nclass formatter<std::basic_string<Char, std::char_traits<Char>, Alloc>, Char>\r\n    : public formatter<basic_string_view<Char>, Char> {};\r\n```\r\n\r\nIt is also not clear why printing a `std::pmr::string` alone works. Maybe it's falling back to `string_view` while the tuple version is not.\r\n\n",
        "hints_text": "Thanks for reporting.\r\n\r\n> I checked the code, and it seems std::basic_string is specialized only for the default allocator. I think the fix might be as simple as replacing ...\r\n\r\nThat looks like the correct fix (modulo also making char_traits a template parameter). Could you submit a PR?\r\n\r\n\nSure thing!",
        "created_at": "2024-04-22T06:58:04Z",
        "version": "10.2"
    }
}