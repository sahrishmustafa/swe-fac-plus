{
    "task_id": "fmtlib__fmt-967",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-967_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 967,
        "instance_id": "fmtlib__fmt-967",
        "issue_numbers": [
            "944"
        ],
        "base_commit": "bf1f1c73e39c7ee6581ee0d5bb2471856a14bdb2",
        "patch": "diff --git a/include/fmt/color.h b/include/fmt/color.h\n--- a/include/fmt/color.h\n+++ b/include/fmt/color.h\n@@ -423,43 +423,67 @@ template <>\n inline void reset_color<wchar_t>(FILE *stream) FMT_NOEXCEPT {\n   fputs(internal::data::WRESET_COLOR, stream);\n }\n+\n+// The following specialiazation disables using std::FILE as a character type,\n+// which is needed because or else\n+//   fmt::print(stderr, fmt::emphasis::bold, \"\");\n+// would take stderr (a std::FILE *) as the format string.\n+template <>\n+struct is_string<std::FILE *> : std::false_type {};\n+template <>\n+struct is_string<const std::FILE *> : std::false_type {};\n } // namespace internal\n \n template <\n   typename S, typename Char = typename internal::char_t<S>::type>\n-void vprint(const text_style &tf, const S &format,\n+void vprint(std::FILE *f, const text_style &ts, const S &format,\n             basic_format_args<typename buffer_context<Char>::type> args) {\n-  if (tf.has_emphasis()) {\n+  if (ts.has_emphasis()) {\n     internal::fputs<Char>(\n-          internal::make_emphasis<Char>(tf.get_emphasis()), stdout);\n+          internal::make_emphasis<Char>(ts.get_emphasis()), f);\n   }\n-  if (tf.has_foreground()) {\n+  if (ts.has_foreground()) {\n     internal::fputs<Char>(\n-          internal::make_foreground_color<Char>(tf.get_foreground()), stdout);\n+          internal::make_foreground_color<Char>(ts.get_foreground()), f);\n   }\n-  if (tf.has_background()) {\n+  if (ts.has_background()) {\n     internal::fputs<Char>(\n-        internal::make_background_color<Char>(tf.get_background()), stdout);\n+        internal::make_background_color<Char>(ts.get_background()), f);\n   }\n-  vprint(format, args);\n-  internal::reset_color<Char>(stdout);\n+  vprint(f, format, args);\n+  internal::reset_color<Char>(f);\n }\n \n /**\n-  Formats a string and prints it to stdout using ANSI escape sequences to\n-  specify text formatting.\n+  Formats a string and prints it to the specified file stream using ANSI\n+  escape sequences to specify text formatting.\n   Example:\n     fmt::print(fmt::emphasis::bold | fg(fmt::color::red),\n                \"Elapsed time: {0:.2f} seconds\", 1.23);\n  */\n template <typename String, typename... Args>\n-typename std::enable_if<internal::is_string<String>::value>::type\n-print(const text_style &tf, const String &format_str, const Args & ... args) {\n+typename std::enable_if<internal::is_string<String>::value>::type print(\n+    std::FILE *f, const text_style &ts, const String &format_str,\n+    const Args &... args) {\n   internal::check_format_string<Args...>(format_str);\n   typedef typename internal::char_t<String>::type char_t;\n   typedef typename buffer_context<char_t>::type context_t;\n   format_arg_store<context_t, Args...> as{args...};\n-  vprint(tf, format_str, basic_format_args<context_t>(as));\n+  vprint(f, ts, format_str, basic_format_args<context_t>(as));\n+}\n+\n+/**\n+  Formats a string and prints it to stdout using ANSI escape sequences to\n+  specify text formatting.\n+  Example:\n+    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),\n+               \"Elapsed time: {0:.2f} seconds\", 1.23);\n+ */\n+template <typename String, typename... Args>\n+typename std::enable_if<internal::is_string<String>::value>::type print(\n+    const text_style &ts, const String &format_str,\n+    const Args &... args) {\n+  return print(stdout, ts, format_str, args...);\n }\n \n #endif\n",
        "test_patch": "diff --git a/test/format-impl-test.cc b/test/format-impl-test.cc\n--- a/test/format-impl-test.cc\n+++ b/test/format-impl-test.cc\n@@ -228,4 +228,8 @@ TEST(ColorsTest, Colors) {\n       stdout,\n       fmt::print(fg(fmt::color::blue) | fmt::emphasis::bold, \"blue/bold\"),\n       \"\\x1b[1m\\x1b[38;2;000;000;255mblue/bold\\x1b[0m\");\n+  EXPECT_WRITE(stderr, fmt::print(stderr, fmt::emphasis::bold, \"bold error\"),\n+               \"\\x1b[1mbold error\\x1b[0m\");\n+  EXPECT_WRITE(stderr, fmt::print(stderr, fg(fmt::color::blue), \"blue log\"),\n+                 \"\\x1b[38;2;000;000;255mblue log\\x1b[0m\");\n }\n",
        "problem_statement": "Colored print improvements\nThere are two things lacking which would be great:\r\n\r\n* colored print to `stderr` as well as `stdout`\r\n* text style, i.e. print bold\r\n\r\nI might be able to do a PR eventually but not at the moment.\n",
        "hints_text": "PRs are welcome =).\nStyles were implemented in #961. Thanks, @Rakete1111! Adding an overload that takes `stderr` should be trivial.",
        "created_at": "2018-12-06T19:15:08Z",
        "version": "5.2"
    }
}