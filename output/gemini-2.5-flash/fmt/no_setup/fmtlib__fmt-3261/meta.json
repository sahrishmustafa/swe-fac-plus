{
    "task_id": "fmtlib__fmt-3261",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3261_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3261,
        "instance_id": "fmtlib__fmt-3261",
        "issue_numbers": [
            "3117"
        ],
        "base_commit": "2622cd23e69b67316cf678a97c268a874774c0e1",
        "patch": "diff --git a/include/fmt/chrono.h b/include/fmt/chrono.h\n--- a/include/fmt/chrono.h\n+++ b/include/fmt/chrono.h\n@@ -1046,26 +1046,6 @@ inline Int to_nonnegative_int(T value, Int upper) {\n   return static_cast<Int>(value);\n }\n \n-template <typename Rep, typename Period,\n-          FMT_ENABLE_IF(std::numeric_limits<Rep>::is_signed)>\n-constexpr std::chrono::duration<Rep, Period> abs(\n-    std::chrono::duration<Rep, Period> d) {\n-  // We need to compare the duration using the count() method directly\n-  // due to a compiler bug in clang-11 regarding the spaceship operator,\n-  // when -Wzero-as-null-pointer-constant is enabled.\n-  // In clang-12 the bug has been fixed. See\n-  // https://bugs.llvm.org/show_bug.cgi?id=46235 and the reproducible example:\n-  // https://www.godbolt.org/z/Knbb5joYx.\n-  return d.count() >= d.zero().count() ? d : -d;\n-}\n-\n-template <typename Rep, typename Period,\n-          FMT_ENABLE_IF(!std::numeric_limits<Rep>::is_signed)>\n-constexpr std::chrono::duration<Rep, Period> abs(\n-    std::chrono::duration<Rep, Period> d) {\n-  return d;\n-}\n-\n constexpr long long pow10(std::uint32_t n) {\n   return n == 0 ? 1 : 10 * pow10(n - 1);\n }\n@@ -1101,7 +1081,7 @@ void write_fractional_seconds(OutputIt& out, Duration d, int precision = -1) {\n       std::ratio<1, detail::pow10(num_fractional_digits)>>;\n \n   const auto fractional =\n-      detail::abs(d) - std::chrono::duration_cast<std::chrono::seconds>(d);\n+      d - std::chrono::duration_cast<std::chrono::seconds>(d);\n   const auto subseconds =\n       std::chrono::treat_as_floating_point<\n           typename subsecond_precision::rep>::value\n@@ -2127,9 +2107,14 @@ struct formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,\n     if (period::num != 1 || period::den != 1 ||\n         std::is_floating_point<typename Duration::rep>::value) {\n       const auto epoch = val.time_since_epoch();\n-      const auto subsecs = std::chrono::duration_cast<Duration>(\n+      auto subsecs = std::chrono::duration_cast<Duration>(\n           epoch - std::chrono::duration_cast<std::chrono::seconds>(epoch));\n \n+      if (subsecs.count() < 0) {\n+        subsecs += std::chrono::seconds(1);\n+        val -= std::chrono::seconds(1);\n+      }\n+\n       return formatter<std::tm, Char>::do_format(\n           gmtime(std::chrono::time_point_cast<std::chrono::seconds>(val)), ctx,\n           &subsecs);\n",
        "test_patch": "diff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -879,4 +879,14 @@ TEST(chrono_test, timestamps_sub_seconds) {\n       t10(std::chrono::milliseconds(2000));\n \n   EXPECT_EQ(fmt::format(\"{:%S}\", t10), \"02.000\");\n+\n+  {\n+    const auto epoch = std::chrono::time_point<std::chrono::system_clock,\n+                                               std::chrono::milliseconds>();\n+    const auto d = std::chrono::milliseconds(250);\n+\n+    EXPECT_EQ(\"59.750\", fmt::format(\"{:%S}\", epoch - d));\n+    EXPECT_EQ(\"00.000\", fmt::format(\"{:%S}\", epoch));\n+    EXPECT_EQ(\"00.250\", fmt::format(\"{:%S}\", epoch + d));\n+  }\n }\n",
        "problem_statement": "Formatting std::chrono::time_point with double Rep or before Epoch\nHi,\r\n\r\nI have two questions concerning formatting the `time_point` object with `fmt`:\r\n\r\n1. It seems that it cannot format `time_point` with `Rep` set to `double`, could this be improved?\r\n2. It seems that it incorrectly formats timepoint before Epoch, you can see negative sub-seconds number in the output.\r\n\r\nCompiler Explorer: https://godbolt.org/z/qd4Y3b7P9\r\n\r\nCode:\r\n\r\n```c++\r\n#include <fmt/format.h>\r\n#include <fmt/chrono.h>\r\n#include <fmt/ostream.h>\r\n\r\ntemplate <typename Dur>\r\nstd::string getTimestamp(const std::chrono::time_point<std::chrono::system_clock, Dur>& tp)\r\n{\r\n    using namespace std::chrono;\r\n    const auto tp_ms = time_point_cast<milliseconds>(tp);\r\n    const auto milli_count = (tp_ms.time_since_epoch()).count() % 1000;\r\n    return fmt::format(\"{:%Y-%m-%d_%H:%M:%S}.{:03d}\", tp_ms, milli_count);\r\n}\r\n\r\ntemplate <typename Dur>\r\nstd::string getTimestamp2(const std::chrono::time_point<std::chrono::system_clock, Dur>& tp)\r\n{\r\n    using namespace std::chrono;\r\n    const auto milli_count = duration_cast<milliseconds>(tp.time_since_epoch()).count() % 1000;\r\n    return fmt::format(\"{:%Y-%m-%d_%H:%M:%S}.{:03d}\", tp, milli_count); // Passing tp to format directly\r\n}\r\n\r\nstd::chrono::system_clock::time_point makeTimePoint(const std::tm& tm1, double fraction)\r\n{\r\n    struct std::tm tm2 = tm1;\r\n    const auto t = std::mktime(&tm2);\r\n\r\n    using namespace std::chrono;\r\n    constexpr auto DEN = system_clock::duration::period::den;\r\n    const auto count_subsecs = static_cast<system_clock::rep>(t) * DEN +\r\n                               static_cast<system_clock::rep>(fraction * DEN);\r\n    system_clock::time_point tp(system_clock::duration{count_subsecs});\r\n    return tp;\r\n}\r\n\r\nint main()\r\n{\r\n    const auto tp = std::chrono::system_clock::now();\r\n    const auto tp2 = std::chrono::time_point_cast<std::chrono::duration<double>>(tp);\r\n\r\n    fmt::print(\"timepoint: {}\\n\", getTimestamp(tp));\r\n    fmt::print(\"timepoint: {}\\n\", getTimestamp(tp2));\r\n\r\n    // Issue 1:\r\n    // fmt::print(\"timepoint: {}\\n\", getTimestamp2(tp2)); // This causes build error at line 19 above.\r\n\r\n    // Issue 2:\r\n    std::tm tm{};\r\n    tm.tm_year = 1969 - 1900;\r\n    tm.tm_mon = 12 - 1;\r\n    tm.tm_mday = 31;\r\n    tm.tm_hour = 23;\r\n    tm.tm_min = 59;\r\n    tm.tm_sec = 59;\r\n    const auto tp3 = makeTimePoint(tm, 0.123456);\r\n    fmt::print(\"timepoint: {}\\n\", getTimestamp(tp3)); // timepoint: 1970-01-01_00:00:00.-876\r\n}\r\n```\n",
        "hints_text": "> It seems that it cannot format time_point with Rep set to double, could this be improved?\r\n\r\nYes, this can be done by adding `Duration` template argument in https://github.com/fmtlib/fmt/blob/ad91cab374b09ca45efe76633e083676d9c29b64/include/fmt/chrono.h#L2020\r\n\r\nA PR is welcome.\r\n\r\n> It seems that it incorrectly formats timepoint before Epoch, you can see negative sub-seconds number in the output.\r\n\r\nI am actually not sure what should happen in this case. Does the standard say anything about it?\nThe first issue is resolved by #3115. but the second one remains:  \r\n\r\n```cpp\r\n#include <fmt/chrono.h>\r\n#include <fmt/core.h>\r\n\r\n#include <chrono>\r\n\r\nint main() {\r\n  {\r\n    auto tp = std::chrono::system_clock::from_time_t(0) +\r\n              std::chrono::milliseconds(250);\r\n    fmt::print(\"{:%Y-%m-%d %H:%M:%S}\\n\", tp); // 1970-01-01 00:00:00.250000\r\n  }\r\n\r\n  {\r\n    auto tp = std::chrono::system_clock::from_time_t(0) -\r\n              std::chrono::milliseconds(250);\r\n    fmt::print(\"{:%Y-%m-%d %H:%M:%S}\\n\", tp); // 1970-01-01 00:00:00.250000\r\n  }\r\n}\r\n\r\n```",
        "created_at": "2023-01-04T04:01:24Z",
        "version": "9.1"
    }
}