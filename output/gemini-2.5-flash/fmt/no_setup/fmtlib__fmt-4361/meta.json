{
    "task_id": "fmtlib__fmt-4361",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-4361_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 4361,
        "instance_id": "fmtlib__fmt-4361",
        "issue_numbers": [
            "4360"
        ],
        "base_commit": "7f7695524a4bc3c9b7883afcc86ba61421989b7f",
        "patch": "diff --git a/include/fmt/base.h b/include/fmt/base.h\n--- a/include/fmt/base.h\n+++ b/include/fmt/base.h\n@@ -1706,7 +1706,19 @@ class format_string_checker {\n       -> const Char* {\n     context_.advance_to(begin);\n     if (id >= 0 && id < NUM_ARGS) return parse_funcs_[id](context_);\n-    while (begin != end && *begin != '}') ++begin;\n+\n+    // If id is out of range, it means we do not know the type and cannot parse\n+    // the format at compile time. Instead, skip over content until we finish\n+    // the format spec, accounting for any nested replacements.\n+    auto bracket_count = 0;\n+    while (begin != end && (bracket_count > 0 || *begin != '}')) {\n+      if (*begin == '{')\n+        ++bracket_count;\n+      else if (*begin == '}')\n+        --bracket_count;\n+\n+      ++begin;\n+    }\n     return begin;\n   }\n \n",
        "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -582,6 +582,8 @@ TEST(format_test, named_arg) {\n   EXPECT_EQ(\"1/a/A\", fmt::format(\"{_1}/{a_}/{A_}\", fmt::arg(\"a_\", 'a'),\n                                  fmt::arg(\"A_\", \"A\"), fmt::arg(\"_1\", 1)));\n   EXPECT_EQ(fmt::format(\"{0:{width}}\", -42, fmt::arg(\"width\", 4)), \" -42\");\n+  EXPECT_EQ(fmt::format(\"{value:{width}}\", fmt::arg(\"value\", -42),\n+      fmt::arg(\"width\", 4)), \" -42\");\n   EXPECT_EQ(\"st\",\n             fmt::format(\"{0:.{precision}}\", \"str\", fmt::arg(\"precision\", 2)));\n   EXPECT_EQ(fmt::format(\"{} {two}\", 1, fmt::arg(\"two\", 2)), \"1 2\");\n",
        "problem_statement": "Named arguments failing to compile with \"unmatched '}' in format string\"\nConsider the following format call.\n\n```cpp\nfmt::format(\"{enum:<{size}d}\", fmt::arg(\"enum\", 1), fmt::arg(\"size\", 10));\n```\nThis results in a compile time failure reporting an \"unmatched '}' in format string\". This is happening in VS17.14 Preview 1 and with GCC 14.2. I've reproduced the issue over on godbolt using {fmt} from trunk [0]. The above string compiled with 11.0.2 and fails with 11.1.3. I was unable to reproduce this compile failure within the {fmt} test code, so I was wondering if it was somehow fixed. However, checking out the tag for 11.1.3 locally, I was also unable to repro in the test code. Not sure what that's about.\n\nIf you wrap the above example into an `fmt::runtime()`, compilation is successful and output is what is expected. The godbolt link includes this example. Additionally, other format variations appear to work both with auto-indexed values as well as when not providing any explicit reference. The following example does compile. It also appears to be related to the dynamic width field as an explicit value there will compile.\n\n```cpp\nstd::cout << fmt::format(fmt::runtime(\"'{enum:<{size}d}'\\n\"), fmt::arg(\"enum\", 1),\n        fmt::arg(\"size\", 10));\nstd::cout << fmt::format(\"'{enum:<10d}'\\n\", fmt::arg(\"enum\", 2),\n        fmt::arg(\"size\", 10));\nstd::cout << fmt::format(\"'{:<{}d}'\\n\", fmt::arg(\"enum\", 2),\n        fmt::arg(\"size\", 10));\nstd::cout << fmt::format(\"'{0:<{1}d}'\\n\", fmt::arg(\"enum\", 3),\n        fmt::arg(\"size\", 10));\n```\n\nFull error output from GCC 14.2:\n```\n<source>: In function 'int main()':\n<source>:7:29: error: call to consteval function 'fmt::v11::fstring<fmt::v11::detail::named_arg<char, int>, fmt::v11::detail::named_arg<char, int> >(\"\\'{enum:<{size}d}\\'\\012\")' is not a constant expression\n    7 |     std::cout << fmt::format(\"'{enum:<{size}d}'\\n\", fmt::arg(\"enum\", 1),\n      |                  ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    8 |         fmt::arg(\"size\", 10));\n      |         ~~~~~~~~~~~~~~~~~~~~~\nIn file included from /opt/compiler-explorer/libs/fmt/trunk/include/fmt/format.h:41,\n                 from <source>:1:\n<source>:7:29:   in 'constexpr' expansion of 'fmt::v11::fstring<fmt::v11::detail::named_arg<char, int>, fmt::v11::detail::named_arg<char, int> >(\"\\'{enum:<{size}d}\\'\\012\")'\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/base.h:2708:53:   in 'constexpr' expansion of 'fmt::v11::detail::parse_format_string<char, format_string_checker<char, 2, 0, true> >(fmt::v11::basic_string_view<char>(((const char*)s)), fmt::v11::detail::format_string_checker<char, 2, 0, true>(fmt::v11::basic_string_view<char>(((const char*)s)), (fmt::v11::fstring<fmt::v11::detail::named_arg<char, int>, fmt::v11::detail::named_arg<char, int> >::arg_pack(), fmt::v11::fstring<fmt::v11::detail::named_arg<char, int>, fmt::v11::detail::named_arg<char, int> >::arg_pack())))'\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/base.h:1624:32: error: 'constexpr void fmt::v11::detail::format_string_checker<Char, NUM_ARGS, NUM_NAMED_ARGS, DYNAMIC_NAMES>::on_error(const char*) [with Char = char; int NUM_ARGS = 2; int NUM_NAMED_ARGS = 0; bool DYNAMIC_NAMES = true]' called in a constant expression\n 1624 |         return handler.on_error(\"unmatched '}' in format string\");\n      |                ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/base.h:1713:35: note: 'constexpr void fmt::v11::detail::format_string_checker<Char, NUM_ARGS, NUM_NAMED_ARGS, DYNAMIC_NAMES>::on_error(const char*) [with Char = char; int NUM_ARGS = 2; int NUM_NAMED_ARGS = 0; bool DYNAMIC_NAMES = true]' is not usable as a 'constexpr' function because:\n 1713 |   FMT_NORETURN FMT_CONSTEXPR void on_error(const char* message) {\n      |                                   ^~~~~~~~\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/base.h:1714:17: error: call to non-'constexpr' function 'void fmt::v11::report_error(const char*)'\n 1714 |     report_error(message);\n      |     ~~~~~~~~~~~~^~~~~~~~~\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/base.h:673:27: note: 'void fmt::v11::report_error(const char*)' declared here\n  673 | FMT_NORETURN FMT_API void report_error(const char* message);\n      |                           ^~~~~~~~~~~~\n```\n\n[0] https://godbolt.org/z/qvxo5qrTf\n",
        "hints_text": "Wanted to add another update as I was playing around with the UDL for args. It turns out that using the UDLs will also allow the format string to properly compile. That means switching to this is also another workaround. Does that mean this has something to do with `named_arg` since the `static_named_arg` seems to work?\n```cpp\nstd::cout << fmt::format(\"'{enum:<{size}d}'\\n\", \"enum\"_a = 0, \"size\"_a = 10);\n```\nI believe I've found a solution. Will post a PR later today. Short of it is, handling of format specs with dynamic named args would exit early because of the nested named replacement field. Static named args are fine because their parser func would be called, but for dynamic, a simple loop looking for the next `}` would exit too soon because of the nested replacement.",
        "created_at": "2025-02-25T02:32:50Z",
        "version": "11.1"
    }
}