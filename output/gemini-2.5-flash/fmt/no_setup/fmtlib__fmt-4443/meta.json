{
    "task_id": "fmtlib__fmt-4443",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-4443_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 4443,
        "instance_id": "fmtlib__fmt-4443",
        "issue_numbers": [
            "4272"
        ],
        "base_commit": "eb9a95d42688b32289c00c2b802ea650f57d4481",
        "patch": "diff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -2110,13 +2110,51 @@ FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,\n   return write_int<Char>(out, make_write_int_arg(value, specs.sign()), specs);\n }\n \n+FMT_INLINE auto count_code_points_with_display_width_precision(\n+    string_view s, size_t display_width_precision) -> size_t {\n+  size_t display_width = 0;\n+  size_t code_points = 0;\n+\n+  // Iterate through the string to compute display width\n+  for_each_codepoint(s, [&](uint32_t, string_view sv) {\n+    // Compute the display width of the current code point\n+    size_t cp_width = compute_width(sv);\n+    if (display_width + cp_width > display_width_precision) {\n+      return false;  // Stop iteration when display width exceeds precision\n+    }\n+\n+    display_width += cp_width;\n+    code_points++;\n+    return true;\n+  });\n+\n+  return code_points;\n+}\n+\n+template <typename Char>\n+FMT_CONSTEXPR auto handle_precision(\n+    basic_string_view<Char> s, const format_specs& specs,\n+    FMT_ENABLE_IF(std::is_same<Char, char>::value)) -> size_t {\n+  auto code_points = count_code_points_with_display_width_precision(\n+      s, to_unsigned(specs.precision));\n+  return code_point_index(s, code_points);\n+}\n+\n+template <typename Char>\n+FMT_CONSTEXPR auto handle_precision(\n+    basic_string_view<Char> s, const format_specs&,\n+    FMT_ENABLE_IF(!std::is_same<Char, char>::value)) -> size_t {\n+  return code_point_index(s, s.size());\n+}\n+\n template <typename Char, typename OutputIt>\n FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,\n                          const format_specs& specs) -> OutputIt {\n   auto data = s.data();\n   auto size = s.size();\n-  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)\n-    size = code_point_index(s, to_unsigned(specs.precision));\n+  if (specs.precision >= 0 && to_unsigned(specs.precision) < size) {\n+    size = handle_precision(s, specs);\n+  }\n \n   bool is_debug = specs.type() == presentation_type::debug;\n   if (is_debug) {\n",
        "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -6,6 +6,7 @@\n // For the license information refer to format.h.\n \n // Check if fmt/format.h compiles with windows.h included before it.\n+#include <gtest/gtest.h>\n #ifdef _WIN32\n #  include <windows.h>\n #endif\n@@ -552,6 +553,10 @@ TEST(format_test, arg_errors) {\n                    format_error, \"argument not found\");\n }\n \n+TEST(format_test, display_width_precision) {\n+  EXPECT_EQ(fmt::format(\"{:.5}\", \"\ud83d\udc31\ud83d\udc31\ud83d\udc31\"), \"\ud83d\udc31\ud83d\udc31\");\n+}\n+\n template <int N> struct test_format {\n   template <typename... T>\n   static auto format(fmt::string_view fmt, const T&... args) -> std::string {\n",
        "problem_statement": "Use display width in precision\nUse display width in precision. For example:\r\n\r\n```c++\r\nfmt::print(\"{:.5}\", \"\ud83d\udc31\ud83d\udc31\ud83d\udc31\");\r\n```\r\n\r\nshould print\r\n\r\n```\r\n\ud83d\udc31\ud83d\udc31\r\n```\n",
        "hints_text": "```cpp\nfmt::print(\"{:.2}\", \"\ud83d\udc31\ud83d\udc31\ud83d\udc31\");\n```\ndoes print\n```\n\ud83d\udc31\ud83d\udc31\n```\nan this matches printf-specification (but with unicode support - yeah) https://en.cppreference.com/w/cpp/io/c/fprintf  (\"_Precision specifies the maximum number of bytes to be written._\")\n```cpp\nstd::printf(\"%.2s\", \"abcde\"); // prints \"ab\"\n```\n\nwhy change?\n\n\n\ud83d\udc31 has a width of 2:\n<img width=\"65\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/faa10b58-7d78-499e-911e-8ff14199c42d\" />\nHello @vitaut \n\nI have been looking into this issue, could you please help me in resolving below query.\n\n- As far as I understand c++ does not have standard support to calculate display width of characters.\nIs the expectation here is to use external library like https://unicode-org.github.io/icu/userguide/strings/properties.html\n- How to handle terminal specific display width behaviour\n\nAlso, I think python's format implementation does not consider display width.\nWe already have display width estimation: https://github.com/fmtlib/fmt/blob/6caff7ed9ce3d0edee322c7426d1b12f1f2b87c2/include/fmt/format.h#L638\n\nThe only thing that is missing is applying it to precision. Python counts code points which doesn't work great with terminals.",
        "created_at": "2025-05-09T18:36:29Z",
        "version": "11.2"
    }
}