{
    "task_id": "fmtlib__fmt-3072",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3072_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3072,
        "instance_id": "fmtlib__fmt-3072",
        "issue_numbers": [
            "3068"
        ],
        "base_commit": "40e414d823d8af78cf6f52f3356c4c54e02eb62f",
        "patch": "diff --git a/include/fmt/std.h b/include/fmt/std.h\n--- a/include/fmt/std.h\n+++ b/include/fmt/std.h\n@@ -100,14 +100,12 @@ template <typename T>\n using variant_index_sequence =\n     std::make_index_sequence<std::variant_size<T>::value>;\n \n-// variant_size and variant_alternative check.\n-template <typename T, typename U = void>\n+template <typename>\n struct is_variant_like_ : std::false_type {};\n-template <typename T>\n-struct is_variant_like_<T, std::void_t<decltype(std::variant_size<T>::value)>>\n-    : std::true_type {};\n+template <typename... Types>\n+struct is_variant_like_<std::variant<Types...>> : std::true_type {};\n \n-// formattable element check\n+// formattable element check.\n template <typename T, typename C> class is_variant_formattable_ {\n   template <std::size_t... I>\n   static std::conjunction<\n",
        "test_patch": "diff --git a/test/std-test.cc b/test/std-test.cc\n--- a/test/std-test.cc\n+++ b/test/std-test.cc\n@@ -75,5 +75,8 @@ TEST(std_test, variant) {\n \n   EXPECT_EQ(fmt::format(\"{}\", v4), \"variant(monostate)\");\n   EXPECT_EQ(fmt::format(\"{}\", v5), \"variant(\\\"yes, this is variant\\\")\");\n+\n+  volatile int i = 42;  // Test compile error before GCC 11 described in #3068.\n+  EXPECT_EQ(fmt::format(\"{}\", i), \"42\");\n #endif\n }\n",
        "problem_statement": "Compile error when formatting volatile values before gcc11\n```\r\nIn file included from /opt/compiler-explorer/libs/fmt/trunk/include/fmt/std.h:26:0,\r\n                 from <source>:1:\r\n/opt/compiler-explorer/gcc-7.5.0/include/c++/7.5.0/variant: In instantiation of 'struct std::variant_size<volatile bool>':\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/std.h:135:31:   required from 'constexpr const bool fmt::v9::is_variant_like<volatile bool>::value'\r\n/opt/compiler-explorer/gcc-7.5.0/include/c++/7.5.0/type_traits:143:12:   required from 'struct std::__and_<fmt::v9::is_variant_like<volatile bool>, fmt::v9::is_variant_formattable<volatile bool, char> >'\r\n/opt/compiler-explorer/gcc-7.5.0/include/c++/7.5.0/type_traits:162:12:   required from 'struct std::conjunction<fmt::v9::is_variant_like<volatile bool>, fmt::v9::is_variant_formattable<volatile bool, char> >'\r\n/opt/compiler-explorer/gcc-7.5.0/include/c++/7.5.0/type_traits:177:27:   required from 'constexpr const bool std::conjunction_v<fmt::v9::is_variant_like<volatile bool>, fmt::v9::is_variant_formattable<volatile bool, char> >'\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/std.h:146:22:   [ skipping 9 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/core.h:1476:25:   required by substitution of 'template<class T, typename std::enable_if<(fmt::v9::detail::has_format_as<T>::value && (! std::is_constructible<fmt::v9::formatter<T> >::value)), int>::type <anonymous> > constexpr decltype (declval<fmt::v9::detail::arg_mapper<fmt::v9::basic_format_context<fmt::v9::appender, char> > >().fmt::v9::detail::arg_mapper<fmt::v9::basic_format_context<fmt::v9::appender, char> >::map(fmt::v9::detail::format_as(T()))) fmt::v9::detail::arg_mapper<fmt::v9::basic_format_context<fmt::v9::appender, char> >::map<T, <enumerator> >(const T&) [with T = volatile bool; typename std::enable_if<(fmt::v9::detail::has_format_as<T>::value && (! std::is_constructible<fmt::v9::formatter<T> >::value)), int>::type <anonymous> = <missing>]'\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/core.h:1735:15:   required from 'constexpr fmt::v9::detail::value<Context> fmt::v9::detail::make_value(T&&) [with Context = fmt::v9::basic_format_context<fmt::v9::appender, char>; T = volatile bool&]'\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/core.h:1777:29:   required from 'constexpr fmt::v9::detail::value<Context> fmt::v9::detail::make_arg(T&&) [with bool IS_PACKED = true; Context = fmt::v9::basic_format_context<fmt::v9::appender, char>; fmt::v9::detail::type <anonymous> = (fmt::v9::detail::type)7; T = volatile bool&; typename std::enable_if<IS_PACKED, int>::type <anonymous> = 0]'\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/core.h:1901:77:   required from 'constexpr fmt::v9::format_arg_store<Context, Args>::format_arg_store(T&& ...) [with T = {volatile bool&}; Context = fmt::v9::basic_format_context<fmt::v9::appender, char>; Args = {bool}]'\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/core.h:1918:31:   required from 'constexpr fmt::v9::format_arg_store<Context, fmt::v9::remove_cvref_t<Args>...> fmt::v9::make_format_args(Args&& ...) [with Context = fmt::v9::basic_format_context<fmt::v9::appender, char>; Args = {volatile bool&}]'\r\n/opt/compiler-explorer/libs/fmt/trunk/include/fmt/core.h:3203:44:   required from 'std::__cxx11::string fmt::v9::format(fmt::v9::format_string<T ...>, T&& ...) [with T = {volatile bool&}; std::__cxx11::string = std::__cxx11::basic_string<char>; fmt::v9::format_string<T ...> = fmt::v9::basic_format_string<char, volatile bool&>]'\r\n<source>:5:35:   required from here\r\n/opt/compiler-explorer/gcc-7.5.0/include/c++/7.5.0/variant:87:12: error: invalid use of incomplete type 'struct std::variant_size<bool>'\r\n     struct variant_size<volatile _Variant> : variant_size<_Variant> {};\r\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/opt/compiler-explorer/gcc-7.5.0/include/c++/7.5.0/variant:81:12: note: declaration of 'struct std::variant_size<bool>'\r\n     struct variant_size;\r\n            ^~~~~~~~~~~~\r\nCompiler returned: 1\r\n```\r\n\r\nhttps://godbolt.org/z/Eq678Tv5M\r\n\r\nThis failed to compile before gcc11 (gcc7-gcc10); probably introduced in #2941.\n",
        "hints_text": "Looks like a bug in `variant` formatter. cc @jehelset.\nNot sure why GCC chose the invalid template substitution; since the issue goes away since gcc 11 I am assuming it's a compiler bug. Nice to have a workaround for older compilers though. (maybe note the remove_cv part is for compiler bug workaround in comments?)\nI think it's not a compiler bug.\r\n\r\nThese are valid overloads:\r\n```c++\r\ntemplate <class T> class variant_size<const T>;\r\ntemplate <class T> class variant_size<volatile T>;\r\ntemplate <class T> class variant_size<const volatile T>;\r\n```\r\nhttps://en.cppreference.com/w/cpp/utility/variant/variant_size\nTrue, but in libstdc++ the overload is implemented as inherited from variant_size<T>\r\n```cpp\r\nstruct variant_size<volatile _Variant> : variant_size<_Variant> {}\r\n```\r\n![](https://user-images.githubusercontent.com/7200314/187967162-26ddd26f-3ec8-45ca-8a2a-5c7f8debfc87.png)\r\nwhich is undefined by standard (there is no `variant_size<bool>`), shouldn't this be a template substitution failure and make the is_variant_like_ : std::false_type {} overload be chosen?\r\nThe compile error goes away since gcc 11 too.",
        "created_at": "2022-09-01T17:12:47Z",
        "version": "9.1"
    }
}