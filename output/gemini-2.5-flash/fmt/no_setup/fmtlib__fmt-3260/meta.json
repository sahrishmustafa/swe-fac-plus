{
    "task_id": "fmtlib__fmt-3260",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3260_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3260,
        "instance_id": "fmtlib__fmt-3260",
        "issue_numbers": [
            "3237"
        ],
        "base_commit": "2622cd23e69b67316cf678a97c268a874774c0e1",
        "patch": "diff --git a/include/fmt/chrono.h b/include/fmt/chrono.h\n--- a/include/fmt/chrono.h\n+++ b/include/fmt/chrono.h\n@@ -2115,9 +2115,7 @@ template <typename Char, typename Duration>\n struct formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,\n                  Char> : formatter<std::tm, Char> {\n   FMT_CONSTEXPR formatter() {\n-    basic_string_view<Char> default_specs =\n-        detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};\n-    this->do_parse(default_specs.begin(), default_specs.end());\n+    this->format_str = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};\n   }\n \n   template <typename FormatContext>\n@@ -2145,9 +2143,7 @@ template <typename Char, typename Duration>\n struct formatter<std::chrono::local_time<Duration>, Char>\n     : formatter<std::tm, Char> {\n   FMT_CONSTEXPR formatter() {\n-    basic_string_view<Char> default_specs =\n-        detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};\n-    this->do_parse(default_specs.begin(), default_specs.end());\n+    this->format_str = detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};\n   }\n \n   template <typename FormatContext>\n@@ -2190,51 +2186,51 @@ struct formatter<std::chrono::time_point<std::chrono::utc_clock, Duration>,\n \n template <typename Char> struct formatter<std::tm, Char> {\n  private:\n-  enum class spec {\n-    unknown,\n-    year_month_day,\n-    hh_mm_ss,\n-  };\n-  spec spec_ = spec::unknown;\n-  basic_string_view<Char> specs;\n+  format_specs<Char> specs;\n+  detail::arg_ref<Char> width_ref;\n \n  protected:\n-  template <typename It> FMT_CONSTEXPR auto do_parse(It begin, It end) -> It {\n-    if (begin != end && *begin == ':') ++begin;\n+  basic_string_view<Char> format_str;\n+\n+  FMT_CONSTEXPR auto do_parse(basic_format_parse_context<Char>& ctx)\n+      -> decltype(ctx.begin()) {\n+    auto begin = ctx.begin(), end = ctx.end();\n+    if (begin == end || *begin == '}') return end;\n+\n+    begin = detail::parse_align(begin, end, specs);\n+    if (begin == end) return end;\n+\n+    begin = detail::parse_dynamic_spec(begin, end, specs.width, width_ref, ctx);\n+    if (begin == end) return end;\n+\n     end = detail::parse_chrono_format(begin, end, detail::tm_format_checker());\n-    // Replace default spec only if the new spec is not empty.\n-    if (end != begin) specs = {begin, detail::to_unsigned(end - begin)};\n+    // Replace default format_str only if the new spec is not empty.\n+    if (end != begin) format_str = {begin, detail::to_unsigned(end - begin)};\n     return end;\n   }\n \n   template <typename FormatContext, typename Duration>\n   auto do_format(const std::tm& tm, FormatContext& ctx,\n                  const Duration* subsecs) const -> decltype(ctx.out()) {\n+    auto specs_copy = specs;\n+    basic_memory_buffer<Char> buf;\n+    auto out = std::back_inserter(buf);\n+    detail::handle_dynamic_spec<detail::width_checker>(specs_copy.width,\n+                                                       width_ref, ctx);\n+\n     const auto loc_ref = ctx.locale();\n     detail::get_locale loc(static_cast<bool>(loc_ref), loc_ref);\n-    auto w = detail::tm_writer<decltype(ctx.out()), Char, Duration>(\n-        loc, ctx.out(), tm, subsecs);\n-    if (spec_ == spec::year_month_day)\n-      w.on_iso_date();\n-    else if (spec_ == spec::hh_mm_ss)\n-      w.on_iso_time();\n-    else\n-      detail::parse_chrono_format(specs.begin(), specs.end(), w);\n-    return w.out();\n+    auto w =\n+        detail::tm_writer<decltype(out), Char, Duration>(loc, out, tm, subsecs);\n+    detail::parse_chrono_format(format_str.begin(), format_str.end(), w);\n+    return detail::write(\n+        ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs_copy);\n   }\n \n  public:\n   FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)\n       -> decltype(ctx.begin()) {\n-    auto end = this->do_parse(ctx.begin(), ctx.end());\n-    // basic_string_view<>::compare isn't constexpr before C++17.\n-    if (specs.size() == 2 && specs[0] == Char('%')) {\n-      if (specs[1] == Char('F'))\n-        spec_ = spec::year_month_day;\n-      else if (specs[1] == Char('T'))\n-        spec_ = spec::hh_mm_ss;\n-    }\n-    return end;\n+    return this->do_parse(ctx);\n   }\n \n   template <typename FormatContext>\n",
        "test_patch": "diff --git a/test/chrono-test.cc b/test/chrono-test.cc\n--- a/test/chrono-test.cc\n+++ b/test/chrono-test.cc\n@@ -462,7 +462,7 @@ TEST(chrono_test, format_default) {\n       fmt::format(\"{}\", std::chrono::duration<int, std::ratio<15, 4>>(42)));\n }\n \n-TEST(chrono_test, align) {\n+TEST(chrono_test, duration_align) {\n   auto s = std::chrono::seconds(42);\n   EXPECT_EQ(\"42s  \", fmt::format(\"{:5}\", s));\n   EXPECT_EQ(\"42s  \", fmt::format(\"{:{}}\", s, 5));\n@@ -478,6 +478,35 @@ TEST(chrono_test, align) {\n             fmt::format(\"{:{}%H:%M:%S}\", std::chrono::seconds(12345), 12));\n }\n \n+TEST(chrono_test, tm_align) {\n+  auto t = make_tm(1975, 12, 29, 12, 14, 16);\n+  EXPECT_EQ(\"1975-12-29 12:14:16\", fmt::format(\"{:%F %T}\", t));\n+  EXPECT_EQ(\"1975-12-29 12:14:16           \", fmt::format(\"{:30%F %T}\", t));\n+  EXPECT_EQ(\"1975-12-29 12:14:16           \", fmt::format(\"{:{}%F %T}\", t, 30));\n+  EXPECT_EQ(\"1975-12-29 12:14:16           \", fmt::format(\"{:<30%F %T}\", t));\n+  EXPECT_EQ(\"     1975-12-29 12:14:16      \", fmt::format(\"{:^30%F %T}\", t));\n+  EXPECT_EQ(\"           1975-12-29 12:14:16\", fmt::format(\"{:>30%F %T}\", t));\n+\n+  EXPECT_EQ(\"1975-12-29 12:14:16***********\", fmt::format(\"{:*<30%F %T}\", t));\n+  EXPECT_EQ(\"*****1975-12-29 12:14:16******\", fmt::format(\"{:*^30%F %T}\", t));\n+  EXPECT_EQ(\"***********1975-12-29 12:14:16\", fmt::format(\"{:*>30%F %T}\", t));\n+}\n+\n+TEST(chrono_test, tp_align) {\n+  auto tp = std::chrono::time_point_cast<std::chrono::microseconds>(\n+      std::chrono::system_clock::from_time_t(0));\n+  EXPECT_EQ(\"00:00.000000\", fmt::format(\"{:%M:%S}\", tp));\n+  EXPECT_EQ(\"00:00.000000   \", fmt::format(\"{:15%M:%S}\", tp));\n+  EXPECT_EQ(\"00:00.000000   \", fmt::format(\"{:{}%M:%S}\", tp, 15));\n+  EXPECT_EQ(\"00:00.000000   \", fmt::format(\"{:<15%M:%S}\", tp));\n+  EXPECT_EQ(\" 00:00.000000  \", fmt::format(\"{:^15%M:%S}\", tp));\n+  EXPECT_EQ(\"   00:00.000000\", fmt::format(\"{:>15%M:%S}\", tp));\n+\n+  EXPECT_EQ(\"00:00.000000***\", fmt::format(\"{:*<15%M:%S}\", tp));\n+  EXPECT_EQ(\"*00:00.000000**\", fmt::format(\"{:*^15%M:%S}\", tp));\n+  EXPECT_EQ(\"***00:00.000000\", fmt::format(\"{:*>15%M:%S}\", tp));\n+}\n+\n TEST(chrono_test, format_specs) {\n   EXPECT_EQ(\"%\", fmt::format(\"{:%%}\", std::chrono::seconds(0)));\n   EXPECT_EQ(\"\\n\", fmt::format(\"{:%n}\", std::chrono::seconds(0)));\n",
        "problem_statement": "formatting chrono with padding\nThe grammar in the documentation \r\n\r\n```\r\n   replacement_field: \"{\" [`arg_id`] [\":\" (`format_spec` | `chrono_format_spec`)] \"}\"\r\n\r\n   chrono_format_spec: [[`fill`]`align`][`width`][\".\" `precision`][`chrono_specs`]\r\n   chrono_specs: [`chrono_specs`] `conversion_spec` | `chrono_specs` `literal_char`\r\n   conversion_spec: \"%\" [`modifier`] `chrono_type`\r\n```\r\n\r\nsuggests to me that `{:>30%H}` is valid, but this is not what fmt-9.1.0 and/or master @ b90895412f46e18e5b17efdea2c8f79e7d7504b3 outputs.\r\n\r\nInput:\r\n\r\n```c\r\n#include <chrono>\r\n#include <fmt/core.h>\r\n#include <fmt/chrono.h>\r\nint main()\r\n{\r\n        fmt::print(\"{:>30d}\\n\", 30);\r\n        fmt::print(\"{:>30%H:%M}\\n\", std::chrono::system_clock::now());\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n                            30\r\n>3023:48\r\n```\r\n\r\nExpected:\r\n\r\n```\r\n                            30\r\n                         23:48\r\n```\n",
        "hints_text": "Formatting of time points is still WIP and only supports `chrono_specs` at the moment. PRs to add support for other specifiers are welcome.\nOr maybe we can edit the documentation until that's supported?",
        "created_at": "2023-01-04T02:12:26Z",
        "version": "9.1"
    }
}