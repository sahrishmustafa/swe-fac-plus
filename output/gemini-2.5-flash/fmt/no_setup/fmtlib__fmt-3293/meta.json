{
    "task_id": "fmtlib__fmt-3293",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-3293_2025-07-04_18-38-48",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 3293,
        "instance_id": "fmtlib__fmt-3293",
        "issue_numbers": [
            "3234"
        ],
        "base_commit": "e03753c4ac04d80517ec5fa92e78b0dc1f896a70",
        "patch": "diff --git a/include/fmt/os.h b/include/fmt/os.h\n--- a/include/fmt/os.h\n+++ b/include/fmt/os.h\n@@ -337,6 +337,11 @@ class FMT_API file {\n   // Creates a buffered_file object associated with this file and detaches\n   // this file object from the file.\n   buffered_file fdopen(const char* mode);\n+\n+  # if defined(_WIN32) && !defined(__MINGW32__)\n+  // Opens a file and constructs a file object representing this file by wcstring_view filename. Windows only.\n+  static file open_windows_file(wcstring_view path, int oflag);\n+  #endif\n };\n \n // Returns the memory page size.\ndiff --git a/src/os.cc b/src/os.cc\n--- a/src/os.cc\n+++ b/src/os.cc\n@@ -213,21 +213,23 @@ int buffered_file::descriptor() const {\n }\n \n #if FMT_USE_FCNTL\n-file::file(cstring_view path, int oflag) {\n #  ifdef _WIN32\n-  using mode_t = int;\n+using mode_t = int;\n #  endif\n-  constexpr mode_t mode =\n-      S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n+constexpr mode_t default_open_mode =\n+    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n+\n+file::file(cstring_view path, int oflag) {\n #  if defined(_WIN32) && !defined(__MINGW32__)\n   fd_ = -1;\n-  FMT_POSIX_CALL(sopen_s(&fd_, path.c_str(), oflag, _SH_DENYNO, mode));\n+  auto converted = detail::utf8_to_utf16(string_view(path.c_str()));\n+  *this = file::open_windows_file(converted.c_str(), oflag);\n #  else\n-  FMT_RETRY(fd_, FMT_POSIX_CALL(open(path.c_str(), oflag, mode)));\n-#  endif\n+  FMT_RETRY(fd_, FMT_POSIX_CALL(open(path.c_str(), oflag, default_open_mode)));\n   if (fd_ == -1)\n     FMT_THROW(\n         system_error(errno, FMT_STRING(\"cannot open file {}\"), path.c_str()));\n+#  endif\n }\n \n file::~file() noexcept {\n@@ -353,6 +355,18 @@ buffered_file file::fdopen(const char* mode) {\n   return bf;\n }\n \n+#  if defined(_WIN32) && !defined(__MINGW32__)\n+file file::open_windows_file(wcstring_view path, int oflag) {\n+  int fd_ = -1;\n+  auto err =\n+      _wsopen_s(&fd_, path.c_str(), oflag, _SH_DENYNO, default_open_mode);\n+  if (fd_ == -1)\n+    FMT_THROW(system_error(err, FMT_STRING(\"cannot open file {}\"),\n+                           detail::utf16_to_utf8(path.c_str()).c_str()));\n+  return file(fd_);\n+}\n+#  endif\n+\n long getpagesize() {\n #  ifdef _WIN32\n   SYSTEM_INFO si;\n",
        "test_patch": "diff --git a/test/os-test.cc b/test/os-test.cc\n--- a/test/os-test.cc\n+++ b/test/os-test.cc\n@@ -127,6 +127,17 @@ TEST(os_test, report_windows_error) {\n                fmt::to_string(out));\n }\n \n+#  if FMT_USE_FCNTL && !defined(__MINGW32__)\n+TEST(file_test, open_windows_file) {\n+  using fmt::file;\n+  file out = file::open_windows_file(L\"test-file\",\n+                                     file::WRONLY | file::CREATE | file::TRUNC);\n+  out.write(\"x\", 1);\n+  file in = file::open_windows_file(L\"test-file\", file::RDONLY);\n+  EXPECT_READ(in, \"x\");\n+}\n+#  endif  // FMT_USE_FCNTL && !defined(__MINGW32__)\n+\n #endif  // _WIN32\n \n #if FMT_USE_FCNTL\ndiff --git a/test/posix-mock-test.cc b/test/posix-mock-test.cc\n--- a/test/posix-mock-test.cc\n+++ b/test/posix-mock-test.cc\n@@ -72,12 +72,6 @@ int test::open(const char* path, int oflag, int mode) {\n   EMULATE_EINTR(open, -1);\n   return ::open(path, oflag, mode);\n }\n-#else\n-errno_t test::sopen_s(int* pfh, const char* filename, int oflag, int shflag,\n-                      int pmode) {\n-  EMULATE_EINTR(open, EINTR);\n-  return _sopen_s(pfh, filename, oflag, shflag, pmode);\n-}\n #endif\n \n #ifndef _WIN32\n@@ -220,11 +214,11 @@ TEST(os_test, getpagesize) {\n }\n \n TEST(file_test, open_retry) {\n+#  ifndef _WIN32\n   write_file(\"temp\", \"there must be something here\");\n   std::unique_ptr<file> f{nullptr};\n   EXPECT_RETRY(f.reset(new file(\"temp\", file::RDONLY)), open,\n                \"cannot open file temp\");\n-#  ifndef _WIN32\n   char c = 0;\n   f->read(&c, 1);\n #  endif\ndiff --git a/test/posix-mock.h b/test/posix-mock.h\n--- a/test/posix-mock.h\n+++ b/test/posix-mock.h\n@@ -37,8 +37,6 @@ int fstat(int fd, struct stat* buf);\n #else\n typedef unsigned size_t;\n typedef int ssize_t;\n-errno_t sopen_s(int* pfh, const char* filename, int oflag, int shflag,\n-                int pmode);\n #endif\n \n #ifndef _WIN32\n",
        "problem_statement": "_wfopen support\nOn Windows it is important to use UTF-16 file paths for opening files (at least until recent versions that allow using UTF-8 locale for WinAPI).\r\n\r\nstd::fstream has overload for std::wstring\r\nfor std::FILE* there is Windows-specific \"_wfopen\" method as a replacement for standard std::fopen.\r\n\r\nIs it possible to provide a way to use fmt::output_file with UTF-16 encoded filepath?\n",
        "hints_text": "Supporting UTF-16 in a portable way is problematic but we could replace `sopen_s` with `_wopen` in\r\n\r\nhttps://github.com/fmtlib/fmt/blob/master/src/os.cc#L224\r\n\r\nThis will allow passing UTF-8 paths. A PR to do this would be welcome.\n> This will allow passing UTF-8 paths.\r\n\r\nIs it possible just transfer a handle to already opened file? \n> Is it possible just transfer a handle to already opened file?\r\n\r\nIt is not possible with the current API.\nI'd like to work on this.\r\nMy current idea is adding a new ctor `file(wcstring_view path, int oflag);`, meanwhile cast UTF-8 path to UTF-16 in original ctor.\r\nI wonder if it's a proper way to deal with the problem.\nConverting UTF-8 to UTF-16 and invoking `_wopen` on Windows makes sense but I don't think we should be adding a new ctor.\n> Converting UTF-8 to UTF-16 and invoking `_wopen` on Windows makes sense but I don't think we should be adding a new ctor.\r\n\r\nMaybe sometimes only `wchar_t *` is available. Converting from UTF-16 to UTF-8 then convert it back seems a little weird.\r\n\r\nNot sure if this is a common situation. I'll just start with no extra ctor.\nI think it would be OK to add a static \"factory\" function with the name that indicates that it is Windows-specific, e.g. `open_windows_file`, that takes a wide filename and returns `file`.",
        "created_at": "2023-02-06T07:22:55Z",
        "version": "9.1"
    }
}