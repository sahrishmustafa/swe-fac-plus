{
    "task_id": "fmtlib__fmt-2310",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-2310_2025-07-07_14-29-31",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 2310,
        "instance_id": "fmtlib__fmt-2310",
        "issue_numbers": [
            "2305"
        ],
        "base_commit": "bc13c6de390751ecf8daa1b1ce8f775d104fdc65",
        "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -1948,7 +1948,7 @@ template <typename Char> class specs_setter {\n   FMT_CONSTEXPR void on_localized() { specs_.localized = true; }\n \n   FMT_CONSTEXPR void on_zero() {\n-    specs_.align = align::numeric;\n+    if (specs_.align == align::none) specs_.align = align::numeric;\n     specs_.fill[0] = Char('0');\n   }\n \ndiff --git a/include/fmt/format.h b/include/fmt/format.h\n--- a/include/fmt/format.h\n+++ b/include/fmt/format.h\n@@ -1584,13 +1584,17 @@ FMT_CONSTEXPR OutputIt write(OutputIt out, const Char* s,\n \n template <typename Char, typename OutputIt>\n OutputIt write_nonfinite(OutputIt out, bool isinf,\n-                         const basic_format_specs<Char>& specs,\n+                         basic_format_specs<Char> specs,\n                          const float_specs& fspecs) {\n   auto str =\n       isinf ? (fspecs.upper ? \"INF\" : \"inf\") : (fspecs.upper ? \"NAN\" : \"nan\");\n   constexpr size_t str_size = 3;\n   auto sign = fspecs.sign;\n   auto size = str_size + (sign ? 1 : 0);\n+  // Replace '0'-padding with space for non-finite values.\n+  const bool is_zero_fill =\n+      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');\n+  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');\n   return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {\n     if (sign) *it++ = static_cast<Char>(data::signs[sign]);\n     return copy_str<Char>(str, str + str_size, it);\n",
        "test_patch": "diff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -1272,10 +1272,16 @@ TEST(format_test, format_nan) {\n   double nan = std::numeric_limits<double>::quiet_NaN();\n   EXPECT_EQ(\"nan\", fmt::format(\"{}\", nan));\n   EXPECT_EQ(\"+nan\", fmt::format(\"{:+}\", nan));\n-  if (std::signbit(-nan))\n+  EXPECT_EQ(\"  +nan\", fmt::format(\"{:+06}\", nan));\n+  EXPECT_EQ(\"+nan  \", fmt::format(\"{:<+06}\", nan));\n+  EXPECT_EQ(\" +nan \", fmt::format(\"{:^+06}\", nan));\n+  EXPECT_EQ(\"  +nan\", fmt::format(\"{:>+06}\", nan));\n+  if (std::signbit(-nan)) {\n     EXPECT_EQ(\"-nan\", fmt::format(\"{}\", -nan));\n-  else\n+    EXPECT_EQ(\"  -nan\", fmt::format(\"{:+06}\", -nan));\n+  } else {\n     fmt::print(\"Warning: compiler doesn't handle negative NaN correctly\");\n+  }\n   EXPECT_EQ(\" nan\", fmt::format(\"{: }\", nan));\n   EXPECT_EQ(\"NAN\", fmt::format(\"{:F}\", nan));\n   EXPECT_EQ(\"nan    \", fmt::format(\"{:<7}\", nan));\n@@ -1288,6 +1294,11 @@ TEST(format_test, format_infinity) {\n   EXPECT_EQ(\"inf\", fmt::format(\"{}\", inf));\n   EXPECT_EQ(\"+inf\", fmt::format(\"{:+}\", inf));\n   EXPECT_EQ(\"-inf\", fmt::format(\"{}\", -inf));\n+  EXPECT_EQ(\"  +inf\", fmt::format(\"{:+06}\", inf));\n+  EXPECT_EQ(\"  -inf\", fmt::format(\"{:+06}\", -inf));\n+  EXPECT_EQ(\"+inf  \", fmt::format(\"{:<+06}\", inf));\n+  EXPECT_EQ(\" +inf \", fmt::format(\"{:^+06}\", inf));\n+  EXPECT_EQ(\"  +inf\", fmt::format(\"{:>+06}\", inf));\n   EXPECT_EQ(\" inf\", fmt::format(\"{: }\", inf));\n   EXPECT_EQ(\"INF\", fmt::format(\"{:F}\", inf));\n   EXPECT_EQ(\"inf    \", fmt::format(\"{:<7}\", inf));\n",
        "problem_statement": "Numeric zero fill is applied to inf/nan\nFrom the documentation (emphasis mine):\r\n> Preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. It forces the padding to be placed after the sign or base (if any) but before the digits. This is used for printing fields in the form \u2018+000000120\u2019. This option is only valid for numeric types and ***it has no effect on formatting of infinity and NaN.***\r\n\r\n```CPP\r\nfmt::print(\"'{:+06}'\\n\", NAN);\r\n// output: '00+nan'\r\n```\r\n\r\nhttps://godbolt.org/z/Pnh33M6r6\n",
        "hints_text": "",
        "created_at": "2021-05-23T17:13:52Z",
        "version": "7.1"
    }
}