{
    "task_id": "fmtlib__fmt-264",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-264_2025-07-04_18-39-02",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 264,
        "instance_id": "fmtlib__fmt-264",
        "issue_numbers": [
            "257"
        ],
        "base_commit": "97e9ed11bce828235a25e2cb72910fa6928ffdf5",
        "patch": "diff --git a/CMakeLists.txt b/CMakeLists.txt\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -1,6 +1,6 @@\n message(STATUS \"CMake version: ${CMAKE_VERSION}\")\n \n-cmake_minimum_required(VERSION 2.6)\n+cmake_minimum_required(VERSION 2.8.12)\n \n # Set the default CMAKE_BUILD_TYPE to Release.\n # This should be done before the project command since the latter can set\n@@ -142,7 +142,7 @@ endif ()\n set_target_properties(cppformat PROPERTIES\n   VERSION ${CPPFORMAT_VERSION} SOVERSION ${CPACK_PACKAGE_VERSION_MAJOR})\n \n-if (EXISTS .gitignore)\n+if (EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/.gitignore\")\n   # Get the list of ignored files from .gitignore.\n   file (STRINGS \".gitignore\" lines)\n   LIST(REMOVE_ITEM lines /doc/html)\n@@ -156,15 +156,53 @@ if (EXISTS .gitignore)\n \n   set(CPACK_SOURCE_GENERATOR ZIP)\n   set(CPACK_SOURCE_IGNORE_FILES ${ignored_files})\n-  set(CPACK_SOURCE_PACKAGE_FILE_NAME cppformat-${CPPFORMAT_VERSION})\n+  set(CPACK_SOURCE_PACKAGE_FILE_NAME \"cppformat-${CPPFORMAT_VERSION}\")\n+  set(CPACK_PACKAGE_NAME \"cppformat\")\n   set(CPACK_RESOURCE_FILE_README ${FORMAT_SOURCE_DIR}/README.rst)\n   include(CPack)\n endif ()\n \n # Install targets.\n if (FMT_INSTALL)\n-  set(FMT_LIB_DIR lib CACHE STRING\n+  include(CMakePackageConfigHelpers)\n+  set(config_install_dir \"lib/cmake/cppformat\")\n+  set(version_config \"${CMAKE_CURRENT_BINARY_DIR}/cppformatConfigVersion.cmake\")\n+  set(project_config \"${CMAKE_CURRENT_BINARY_DIR}/cppformatConfig.cmake\")\n+  set(targets_export_name \"cppformatTargets\")\n+\n+  set(FMT_LIB_DIR \"lib\" CACHE STRING\n     \"Installation directory for libraries, relative to ${CMAKE_INSTALL_PREFIX}.\")\n-  install(TARGETS cppformat DESTINATION ${FMT_LIB_DIR})\n-  install(FILES format.h DESTINATION include/cppformat)\n+\n+  # copy the header into the build directory to mimic the installed tree\n+  configure_file(\"format.h\" \"cppformat/format.h\" COPYONLY)\n+  # add the include directories for both build and install tree\n+  target_include_directories(\n+    cppformat PUBLIC\n+    $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n+    $<INSTALL_INTERFACE:include>\n+  )\n+\n+  # generate the version, config and target files into the build directory\n+  write_basic_package_version_file(\n+    \"${version_config}\"\n+    VERSION ${CPPFORMAT_VERSION}\n+    COMPATIBILITY AnyNewerVersion\n+  )\n+  configure_package_config_file(\n+    \"support/cmake/cppformatConfig.cmake.in\"\n+    \"${project_config}\"\n+    INSTALL_DESTINATION \"${config_install_dir}\"\n+  )\n+  export(TARGETS cppformat FILE \"${targets_export_name}.cmake\")\n+\n+  # install version, config and target files\n+  install(\n+      FILES \"${project_config}\" \"${version_config}\"\n+      DESTINATION \"${config_install_dir}\"\n+  )\n+  install(EXPORT \"${targets_export_name}\" DESTINATION \"${config_install_dir}\")\n+\n+  # install the library and the include file\n+  install(TARGETS cppformat EXPORT \"${targets_export_name}\" DESTINATION \"${FMT_LIB_DIR}\")\n+  install(FILES format.h DESTINATION \"include/cppformat\")\n endif ()\n",
        "test_patch": "diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt\n--- a/test/CMakeLists.txt\n+++ b/test/CMakeLists.txt\n@@ -10,12 +10,6 @@ function (target_link_cppformat target)\n   endif ()\n endfunction ()\n \n-function (fmt_target_include_directories)\n-  if (CMAKE_MAJOR_VERSION VERSION_GREATER 2.8.10)\n-    target_include_directories(${ARGN})\n-  endif ()\n-endfunction ()\n-\n # We compile Google Test ourselves instead of using pre-compiled libraries.\n # See the Google Test FAQ \"Why is it not recommended to install a\n # pre-compiled copy of Google Test (for example, into /usr/local)?\"\n@@ -24,7 +18,7 @@ endfunction ()\n add_library(gmock STATIC\n   ${FMT_GMOCK_DIR}/gmock-gtest-all.cc ${FMT_GMOCK_DIR}/gmock/gmock.h\n   ${FMT_GMOCK_DIR}/gtest/gtest.h ${FMT_GMOCK_DIR}/gtest/gtest-spi.h)\n-fmt_target_include_directories(gmock INTERFACE ${FMT_GMOCK_DIR})\n+target_include_directories(gmock INTERFACE ${FMT_GMOCK_DIR})\n find_package(Threads)\n if (Threads_FOUND)\n   target_link_libraries(gmock ${CMAKE_THREAD_LIBS_INIT})\n@@ -43,7 +37,7 @@ check_cxx_source_compiles(\"\n check_cxx_source_compiles(\"\n   #include <initializer_list>\n   int main() {}\" FMT_INITIALIZER_LIST)\n-  \n+\n if (NOT FMT_VARIADIC_TEMPLATES OR NOT FMT_INITIALIZER_LIST)\n   add_definitions(-DGTEST_LANG_CXX11=0)\n endif ()\n",
        "problem_statement": "CMakeLists file missing export\nThis would be nice to allow the cppformat project to be transitively included in an existing CMake build tree without requiring a separate make install step.\n\n",
        "hints_text": "It's already possible to include cppformat in a CMake project via `add_subdirectory`. Is there any advantage of using `export`?\n\nYes. Suppose I have library A which links cppformat and I want all users of library A to transitively link cppformat as well if they link A. Further, suppose I want A to be exported. The export will fail because A now publicly links cppformat which is not part of the export list. I'm not sure how to resolve this without directly modifying cppformat's CMakeLists.txt itself. It would be nice if an option was provided to specify an export list (optionally). My Cmake-fu is not 100% yet, but I believe this is the correct use case.\n\nIt's possible to simply add cppformat with `add_subdirectory` and export `cppformat` or any other target:\n\n``` cmake\nadd_subdirectory(cppformat)\nexport(TARGETS cppformat FILE test.cmake)\n```\n\nWill it work for you?\n\nI was referring to adding the cppformat target to an existing export list which isn't possible outside of the cppformat CMakeLists.txt file I believe. I'll play around with things some tomorrow and see if I can get something to work.\n\nIt would help if you showed an example of what you are expecting to have in the cppformat's `CMakeFiles.txt` or, better, submitted a PR. I haven't used CMake export before and I'm not sure I fully understand what's the purpose of it other than for cross-compilation, but I'll be happy to accept the export-related changes if they simplify some use case.\n\n@jeremyong, have my suggestion worked for you or have you found an alternative?\n",
        "created_at": "2016-01-12T12:11:53Z",
        "version": "2.0"
    }
}