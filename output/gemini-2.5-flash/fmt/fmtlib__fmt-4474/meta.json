{
    "task_id": "fmtlib__fmt-4474",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-4474_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 4474,
        "instance_id": "fmtlib__fmt-4474",
        "issue_numbers": [
            "4470"
        ],
        "base_commit": "730fd4d9a7a9f5973a47c5c540becc71b62b8387",
        "patch": "diff --git a/include/fmt/base.h b/include/fmt/base.h\n--- a/include/fmt/base.h\n+++ b/include/fmt/base.h\n@@ -2032,6 +2032,17 @@ struct has_back_insert_iterator_container_append<\n                         .append(std::declval<InputIt>(),\n                                 std::declval<InputIt>()))>> : std::true_type {};\n \n+template <typename OutputIt, typename InputIt, typename = void>\n+struct has_back_insert_iterator_container_insert_at_end : std::false_type {};\n+\n+template <typename OutputIt, typename InputIt>\n+struct has_back_insert_iterator_container_insert_at_end<\n+    OutputIt, InputIt,\n+    void_t<decltype(get_container(std::declval<OutputIt>())\n+                        .insert(get_container(std::declval<OutputIt>()).end(),\n+                                std::declval<InputIt>(),\n+                                std::declval<InputIt>()))>> : std::true_type {};\n+\n // An optimized version of std::copy with the output value type (T).\n template <typename T, typename InputIt, typename OutputIt,\n           FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value&&\n@@ -2046,6 +2057,8 @@ FMT_CONSTEXPR20 auto copy(InputIt begin, InputIt end, OutputIt out)\n template <typename T, typename InputIt, typename OutputIt,\n           FMT_ENABLE_IF(is_back_insert_iterator<OutputIt>::value &&\n                         !has_back_insert_iterator_container_append<\n+                            OutputIt, InputIt>::value &&\n+                        has_back_insert_iterator_container_insert_at_end<\n                             OutputIt, InputIt>::value)>\n FMT_CONSTEXPR20 auto copy(InputIt begin, InputIt end, OutputIt out)\n     -> OutputIt {\n@@ -2055,7 +2068,11 @@ FMT_CONSTEXPR20 auto copy(InputIt begin, InputIt end, OutputIt out)\n }\n \n template <typename T, typename InputIt, typename OutputIt,\n-          FMT_ENABLE_IF(!is_back_insert_iterator<OutputIt>::value)>\n+          FMT_ENABLE_IF(!(is_back_insert_iterator<OutputIt>::value &&\n+                          (has_back_insert_iterator_container_append<\n+                               OutputIt, InputIt>::value ||\n+                           has_back_insert_iterator_container_insert_at_end<\n+                               OutputIt, InputIt>::value)))>\n FMT_CONSTEXPR auto copy(InputIt begin, InputIt end, OutputIt out) -> OutputIt {\n   while (begin != end) *out++ = static_cast<T>(*begin++);\n   return out;\n",
        "test_patch": "diff --git a/test/base-test.cc b/test/base-test.cc\n--- a/test/base-test.cc\n+++ b/test/base-test.cc\n@@ -279,6 +279,17 @@ TEST(base_test, is_back_insert_iterator) {\n                std::front_insert_iterator<std::string>>::value);\n }\n \n+struct minimal_container {\n+  using value_type = char;\n+  void push_back(char) {}\n+};\n+\n+TEST(base_test, copy) {\n+  minimal_container c;\n+  static constexpr char str[] = \"a\";\n+  fmt::detail::copy<char>(str, str + 1, std::back_inserter(c));\n+}\n+\n TEST(base_test, get_buffer) {\n   mock_buffer<char> buffer;\n   void* buffer_ptr = &buffer;\n",
        "problem_statement": "Bustache does not compile anymore with v11\nThe [bustache](https://github.com/jamboree/bustache) library does not compile with recent fmt versions.\n\nI'm using bustache at commit [1a6d4422](https://github.com/jamboree/bustache/commit/1a6d4422bff46c7c8f37d2ba48c910532bdc8b37) (almost up-to-date).\nUsing fmt 10.2.1 the library compiles fine, with fmt 11.2.0 I get the following error:\n```\nIn file included from /src/build/fmt-stage/include/fmt/format.h:41,\n                 from /src/build/bustache-prefix/src/bustache/include/bustache/model.hpp:18,\n                 from /src/build/bustache-prefix/src/bustache/include/bustache/render.hpp:10,\n                 from /src/build/bustache-prefix/src/bustache/src/render.cpp:8:\n/src/build/fmt-stage/include/fmt/base.h: In instantiation of \u2018constexpr OutputIt fmt::v11::detail::copy(InputIt, InputIt, OutputIt) [with T = char; InputIt = const char*; OutputIt = std::back_insert_iterator<bustache::detail::output_buffer>; typename std::enable_if<(is_back_insert_iterator<OutputIt>::value && (! has_back_insert_iterator_container_append<OutputIt, InputIt>::value)), int>::type <anonymous> = 0]\u2019:\n/src/build/fmt-stage/include/fmt/format.h:1663:26:   required from \u2018constexpr OutputIt fmt::v11::detail::write_bytes(OutputIt, fmt::v11::string_view, const fmt::v11::format_specs&) [with Char = char; fmt::v11::align default_align = fmt::v11::align::left; OutputIt = std::back_insert_iterator<bustache::detail::output_buffer>; fmt::v11::string_view = fmt::v11::basic_string_view<char>]\u2019\n/src/build/fmt-stage/include/fmt/format.h:3425:33:   required from \u2018constexpr OutputIt fmt::v11::detail::write(OutputIt, T, const fmt::v11::format_specs&, locale_ref) [with Char = char; OutputIt = std::back_insert_iterator<bustache::detail::output_buffer>; T = bool; typename std::enable_if<std::is_same<T, bool>::value, int>::type <anonymous> = 0]\u2019\n/src/build/fmt-stage/include/fmt/format.h:3647:23:   required from \u2018constexpr decltype (ctx.out()) fmt::v11::detail::native_formatter<T, Char, TYPE>::format(const T&, FormatContext&) const [with FormatContext = fmt::v11::generic_context<std::back_insert_iterator<bustache::detail::output_buffer>, char>; T = bool; Char = char; fmt::v11::detail::type TYPE = fmt::v11::detail::type::bool_type; decltype (ctx.out()) = std::back_insert_iterator<bustache::detail::output_buffer>]\u2019\n/src/build/bustache-prefix/src/bustache/include/bustache/model.hpp:354:19:   required from \u2018void bustache::detail::print_fmt(const T&, bustache::output_handler, const char*) [with T = bool; bustache::output_handler = bustache::fn_ref<void(const char*, long unsigned int)>]\u2019\n/src/build/bustache-prefix/src/bustache/src/render.cpp:511:30:   required from here\n/src/build/fmt-stage/include/fmt/base.h:2054:5: error: \u2018struct bustache::detail::output_buffer\u2019 has no member named \u2018insert\u2019\n 2054 |   c.insert(c.end(), begin, end);\n      |   ~~^~~~~~\n/src/build/fmt-stage/include/fmt/base.h:2054:14: error: \u2018struct bustache::detail::output_buffer\u2019 has no member named \u2018end\u2019\n 2054 |   c.insert(c.end(), begin, end);\n      |            ~~^~~\n```\nThe bustache code uses a [custom buffer/container](https://github.com/jamboree/bustache/blob/master/include/bustache/model.hpp#L317-L354) that does not implement all \"standard\" methods, in particular no `insert` and no `end`. However it provides `push_back` and uses `std::back_insert_iterator`.\n\nI may be wrong, but while such a custom container may be a corner case for fmt, I believe there is an issue in the selected `copy` implementation. `std::back_insert_iterator` seems to only require a `push_back` method, so fmt should probably not call `insert`/`end`.\n",
        "hints_text": "",
        "created_at": "2025-06-20T00:06:29Z",
        "version": "11.2"
    }
}