{
    "task_id": "fmtlib__fmt-2819",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-2819_2025-07-04_18-39-02",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 2819,
        "instance_id": "fmtlib__fmt-2819",
        "issue_numbers": [
            "2818"
        ],
        "base_commit": "69396347af67b0307866a24283fcaaad02f98a59",
        "patch": "diff --git a/include/fmt/core.h b/include/fmt/core.h\n--- a/include/fmt/core.h\n+++ b/include/fmt/core.h\n@@ -1260,7 +1260,7 @@ template <typename Context> class value {\n };\n \n template <typename Context, typename T>\n-FMT_CONSTEXPR auto make_arg(const T& value) -> basic_format_arg<Context>;\n+FMT_CONSTEXPR auto make_arg(T&& value) -> basic_format_arg<Context>;\n \n // To minimize the number of types we need to deal with, long is translated\n // either to int or to long long depending on its size.\n@@ -1513,7 +1513,7 @@ template <typename Context> class basic_format_arg {\n   detail::type type_;\n \n   template <typename ContextType, typename T>\n-  friend FMT_CONSTEXPR auto detail::make_arg(const T& value)\n+  friend FMT_CONSTEXPR auto detail::make_arg(T&& value)\n       -> basic_format_arg<ContextType>;\n \n   template <typename Visitor, typename Ctx>\n@@ -1674,19 +1674,7 @@ constexpr auto encode_types() -> unsigned long long {\n }\n \n template <typename Context, typename T>\n-FMT_CONSTEXPR auto make_arg(const T& value) -> basic_format_arg<Context> {\n-  basic_format_arg<Context> arg;\n-  arg.type_ = mapped_type_constant<T, Context>::value;\n-  arg.value_ = arg_mapper<Context>().map(value);\n-  return arg;\n-}\n-\n-// The type template parameter is there to avoid an ODR violation when using\n-// a fallback formatter in one translation unit and an implicit conversion in\n-// another (not recommended).\n-template <bool IS_PACKED, typename Context, type, typename T,\n-          FMT_ENABLE_IF(IS_PACKED)>\n-FMT_CONSTEXPR FMT_INLINE auto make_arg(T&& val) -> value<Context> {\n+FMT_CONSTEXPR FMT_INLINE auto make_value(T&& val) -> value<Context> {\n   const auto& arg = arg_mapper<Context>().map(std::forward<T>(val));\n \n   constexpr bool formattable_char =\n@@ -1715,9 +1703,26 @@ FMT_CONSTEXPR FMT_INLINE auto make_arg(T&& val) -> value<Context> {\n   return {arg};\n }\n \n+template <typename Context, typename T>\n+FMT_CONSTEXPR auto make_arg(T&& value) -> basic_format_arg<Context> {\n+  basic_format_arg<Context> arg;\n+  arg.type_ = mapped_type_constant<T, Context>::value;\n+  arg.value_ = make_value<Context>(value);\n+  return arg;\n+}\n+\n+// The type template parameter is there to avoid an ODR violation when using\n+// a fallback formatter in one translation unit and an implicit conversion in\n+// another (not recommended).\n+template <bool IS_PACKED, typename Context, type, typename T,\n+          FMT_ENABLE_IF(IS_PACKED)>\n+FMT_CONSTEXPR FMT_INLINE auto make_arg(T&& val) -> value<Context> {\n+  return make_value<Context>(val);\n+}\n+\n template <bool IS_PACKED, typename Context, type, typename T,\n           FMT_ENABLE_IF(!IS_PACKED)>\n-inline auto make_arg(const T& value) -> basic_format_arg<Context> {\n+FMT_CONSTEXPR inline auto make_arg(T&& value) -> basic_format_arg<Context> {\n   return make_arg<Context>(value);\n }\n FMT_END_DETAIL_NAMESPACE\n@@ -2647,17 +2652,27 @@ FMT_CONSTEXPR FMT_INLINE void parse_format_string(\n   }\n }\n \n+template <typename T, bool = is_named_arg<T>::value> struct strip_named_arg {\n+  using type = T;\n+};\n+\n+template <typename T> struct strip_named_arg<T, true> {\n+  using type = remove_cvref_t<decltype(T::value)>;\n+};\n+\n template <typename T, typename ParseContext>\n FMT_CONSTEXPR auto parse_format_specs(ParseContext& ctx)\n     -> decltype(ctx.begin()) {\n   using char_type = typename ParseContext::char_type;\n   using context = buffer_context<char_type>;\n+  using stripped_type = typename strip_named_arg<T>::type;\n   using mapped_type = conditional_t<\n       mapped_type_constant<T, context>::value != type::custom_type,\n-      decltype(arg_mapper<context>().map(std::declval<const T&>())), T>;\n+      decltype(arg_mapper<context>().map(std::declval<const T&>())),\n+      stripped_type>;\n   auto f = conditional_t<has_formatter<mapped_type, context>::value,\n                          formatter<mapped_type, char_type>,\n-                         fallback_formatter<T, char_type>>();\n+                         fallback_formatter<stripped_type, char_type>>();\n   return f.parse(ctx);\n }\n \ndiff --git a/include/fmt/ostream.h b/include/fmt/ostream.h\n--- a/include/fmt/ostream.h\n+++ b/include/fmt/ostream.h\n@@ -11,6 +11,7 @@\n #include <ostream>\n \n #include \"format.h\"\n+#include \"xchar.h\"\n \n FMT_BEGIN_NAMESPACE\n \n@@ -115,7 +116,8 @@ struct fallback_formatter<T, Char, enable_if_t<is_streamable<T, Char>::value>>\n \n FMT_MODULE_EXPORT\n template <typename Char>\n-void vprint(std::basic_ostream<Char>& os, basic_string_view<Char> format_str,\n+void vprint(std::basic_ostream<Char>& os,\n+            basic_string_view<type_identity_t<Char>> format_str,\n             basic_format_args<buffer_context<type_identity_t<Char>>> args) {\n   auto buffer = basic_memory_buffer<Char>();\n   detail::vformat_to(buffer, format_str, args);\n@@ -132,12 +134,17 @@ void vprint(std::basic_ostream<Char>& os, basic_string_view<Char> format_str,\n   \\endrst\n  */\n FMT_MODULE_EXPORT\n-template <typename S, typename... Args,\n-          typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>\n-void print(std::basic_ostream<Char>& os, const S& format_str, Args&&... args) {\n-  vprint(os, to_string_view(format_str),\n-         fmt::make_format_args<buffer_context<Char>>(args...));\n+template <typename... Args>\n+void print(std::ostream& os, format_string<Args...> fmt, Args&&... args) {\n+  vprint(os, fmt, fmt::make_format_args(args...));\n }\n+\n+FMT_MODULE_EXPORT\n+template <typename... Args>\n+void print(std::wostream& os, wformat_string<Args...> fmt, Args&&... args) {\n+  vprint(os, fmt, fmt::make_wformat_args(args...));\n+}\n+\n FMT_END_NAMESPACE\n \n #endif  // FMT_OSTREAM_H_\n",
        "test_patch": "diff --git a/test/compile-error-test/CMakeLists.txt b/test/compile-error-test/CMakeLists.txt\n--- a/test/compile-error-test/CMakeLists.txt\n+++ b/test/compile-error-test/CMakeLists.txt\n@@ -6,6 +6,8 @@ project(compile-error-test CXX)\n set(fmt_headers \"\n   #include <fmt/format.h>\n   #include <fmt/xchar.h>\n+  #include <fmt/ostream.h>\n+  #include <iostream>\n \")\n \n set(error_test_names \"\")\n@@ -154,6 +156,16 @@ expect_compile(format-function-error \"\n   fmt::format(\\\"{}\\\", f);\n \" ERROR)\n \n+# Formatting an unformattable argument should always be a compile time error\n+expect_compile(format-lots-of-arguments-with-unformattable \"\n+  struct E {};\n+  fmt::format(\\\"\\\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, E());\n+\" ERROR)\n+expect_compile(format-lots-of-arguments-with-function \"\n+  void (*f)();\n+  fmt::format(\\\"\\\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, f);\n+\" ERROR)\n+\n # Make sure that compiler features detected in the header\n # match the features detected in CMake.\n if (SUPPORTS_USER_DEFINED_LITERALS)\n@@ -181,6 +193,20 @@ if (CMAKE_CXX_STANDARD GREATER_EQUAL 20)\n       #error\n     #endif\n   \" ERROR)\n+  expect_compile(print-string-number-spec-error \"\n+    #ifdef FMT_HAS_CONSTEVAL\n+      fmt::print(\\\"{:d}\\\", \\\"I am not a number\\\");\n+    #else\n+      #error\n+    #endif\n+  \" ERROR)\n+  expect_compile(print-stream-string-number-spec-error \"\n+  #ifdef FMT_HAS_CONSTEVAL\n+    fmt::print(std::cout, \\\"{:d}\\\", \\\"I am not a number\\\");\n+  #else\n+    #error\n+  #endif\n+  \" ERROR)\n \n   # Compile-time argument name check\n   expect_compile(format-string-name \"\ndiff --git a/test/format-test.cc b/test/format-test.cc\n--- a/test/format-test.cc\n+++ b/test/format-test.cc\n@@ -1816,6 +1816,7 @@ TEST(format_test, compile_time_string) {\n                                   \"foo\"_a = \"foo\"));\n   EXPECT_EQ(\"\", fmt::format(FMT_STRING(\"\")));\n   EXPECT_EQ(\"\", fmt::format(FMT_STRING(\"\"), \"arg\"_a = 42));\n+  EXPECT_EQ(\"42\", fmt::format(FMT_STRING(\"{answer}\"), \"answer\"_a = Answer()));\n #endif\n \n   (void)static_with_null;\n@@ -1885,6 +1886,8 @@ TEST(format_test, named_arg_udl) {\n       fmt::format(\"{first}{second}{first}{third}\", fmt::arg(\"first\", \"abra\"),\n                   fmt::arg(\"second\", \"cad\"), fmt::arg(\"third\", 99)),\n       udl_a);\n+\n+  EXPECT_EQ(\"42\", fmt::format(\"{answer}\", \"answer\"_a = Answer()));\n }\n #endif  // FMT_USE_USER_DEFINED_LITERALS\n \n",
        "problem_statement": "unpacked make_arg should also assert on unformattable arguments\n```cpp\r\n#include <fmt/format.h>\r\n\r\nstruct E {};\r\n\r\nint main() {\r\n    fmt::print(fmt::runtime(\"\"), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, E());\r\n}\r\n```\r\n\r\nThis compiles and produces a linker error from the undefined reference to `value(unformattable)` constructor. The static_asserts are only engaged when there are 15 or fewer format arguments.\r\n\n",
        "hints_text": "",
        "created_at": "2022-03-18T05:16:10Z",
        "version": "8.1"
    }
}