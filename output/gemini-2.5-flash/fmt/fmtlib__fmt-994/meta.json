{
    "task_id": "fmtlib__fmt-994",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-994_2025-07-08_07-01-21",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 994,
        "instance_id": "fmtlib__fmt-994",
        "issue_numbers": [
            "993"
        ],
        "base_commit": "1b8a216ddf1a3bb612958b912bce5121372dd2e2",
        "patch": "diff --git a/include/fmt/color.h b/include/fmt/color.h\n--- a/include/fmt/color.h\n+++ b/include/fmt/color.h\n@@ -452,6 +452,13 @@ struct ansi_color_escape {\n   }\n   FMT_CONSTEXPR operator const Char *() const FMT_NOEXCEPT { return buffer; }\n \n+  FMT_CONSTEXPR const Char * begin() const FMT_NOEXCEPT {\n+    return buffer;\n+  }\n+  FMT_CONSTEXPR const Char * end() const FMT_NOEXCEPT {\n+    return buffer + std::strlen(buffer);\n+  }\n+\n private:\n   Char buffer[7u + 3u * 4u + 1u];\n \n@@ -502,6 +509,13 @@ inline void reset_color<wchar_t>(FILE *stream) FMT_NOEXCEPT {\n   fputs(internal::data::WRESET_COLOR, stream);\n }\n \n+template <typename Char>\n+inline void reset_color(basic_memory_buffer<Char>& buffer) FMT_NOEXCEPT {\n+  const char* begin = data::RESET_COLOR;\n+  const char* end = begin + sizeof(data::RESET_COLOR) - 1;\n+  buffer.append(begin, end);\n+}\n+\n // The following specialiazation disables using std::FILE as a character type,\n // which is needed because or else\n //   fmt::print(stderr, fmt::emphasis::bold, \"\");\n@@ -510,6 +524,37 @@ template <>\n struct is_string<std::FILE *> : std::false_type {};\n template <>\n struct is_string<const std::FILE *> : std::false_type {};\n+\n+template <typename Char>\n+std::basic_string<Char> vformat(\n+    const text_style &ts, basic_string_view<Char> format_str,\n+    basic_format_args<typename buffer_context<Char>::type> args) {\n+  basic_memory_buffer<Char> buffer;\n+  bool has_style = false;\n+  if (ts.has_emphasis()) {\n+    has_style = true;\n+    ansi_color_escape<Char> escape =\n+      make_emphasis<Char>(ts.get_emphasis());\n+    buffer.append(escape.begin(), escape.end());\n+  }\n+  if (ts.has_foreground()) {\n+    has_style = true;\n+    ansi_color_escape<Char> escape =\n+      make_foreground_color<Char>(ts.get_foreground());\n+    buffer.append(escape.begin(), escape.end());\n+  }\n+  if (ts.has_background()) {\n+    has_style = true;\n+    ansi_color_escape<Char> escape =\n+        make_background_color<Char>(ts.get_background());\n+    buffer.append(escape.begin(), escape.end());\n+  }\n+  internal::vformat_to(buffer, format_str, args);\n+  if (has_style) {\n+    reset_color<Char>(buffer);\n+  }\n+  return fmt::to_string(buffer);\n+}\n } // namespace internal\n \n template <\n@@ -570,6 +615,35 @@ typename std::enable_if<internal::is_string<String>::value>::type print(\n   return print(stdout, ts, format_str, args...);\n }\n \n+\n+template <typename S, typename Char = FMT_CHAR(S)>\n+inline std::basic_string<Char> vformat(\n+    const text_style &ts,\n+    const S &format_str,\n+    basic_format_args<typename buffer_context<Char>::type> args) {\n+  return internal::vformat(ts, to_string_view(format_str), args);\n+}\n+\n+/**\n+  \\rst\n+  Formats arguments and returns the result as a string using ANSI\n+  escape sequences to specify text formatting.\n+\n+  **Example**::\n+\n+    #include <fmt/color.h>\n+    std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),\n+                                      \"The answer is {}\", 42);\n+  \\endrst\n+*/\n+template <typename S, typename... Args>\n+inline std::basic_string<FMT_CHAR(S)> format(\n+    const text_style &ts, const S &format_str, const Args &... args) {\n+  return internal::vformat(\n+    ts, to_string_view(format_str),\n+    *internal::checked_args<S, Args...>(format_str, args...));\n+}\n+\n #endif\n \n FMT_END_NAMESPACE\n",
        "test_patch": "diff --git a/test/format-impl-test.cc b/test/format-impl-test.cc\n--- a/test/format-impl-test.cc\n+++ b/test/format-impl-test.cc\n@@ -206,7 +206,7 @@ TEST(FormatTest, CountCodePoints) {\n   EXPECT_EQ(4, fmt::internal::count_code_points(fmt::u8string_view(\"\u0451\u0436\u0438\u043a\")));\n }\n \n-TEST(ColorsTest, Colors) {\n+TEST(ColorsTest, ColorsPrint) {\n   EXPECT_WRITE(stdout, fmt::print(fg(fmt::rgb(255, 20, 30)), \"rgb(255,20,30)\"),\n                \"\\x1b[38;2;255;020;030mrgb(255,20,30)\\x1b[0m\");\n   EXPECT_WRITE(stdout, fmt::print(fg(fmt::color::blue), \"blue\"),\n@@ -244,3 +244,35 @@ TEST(ColorsTest, Colors) {\n                fmt::print(bg(fmt::terminal_color::bright_magenta), \"tbmagenta\"),\n                \"\\x1b[105mtbmagenta\\x1b[0m\");\n }\n+\n+TEST(ColorsTest, ColorsFormat) {\n+  EXPECT_EQ(fmt::format(fg(fmt::rgb(255, 20, 30)), \"rgb(255,20,30)\"),\n+            \"\\x1b[38;2;255;020;030mrgb(255,20,30)\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fg(fmt::color::blue), \"blue\"),\n+            \"\\x1b[38;2;000;000;255mblue\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fg(fmt::color::blue) | bg(fmt::color::red), \"two color\"),\n+            \"\\x1b[38;2;000;000;255m\\x1b[48;2;255;000;000mtwo color\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fmt::emphasis::bold, \"bold\"),\n+            \"\\x1b[1mbold\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fmt::emphasis::italic, \"italic\"),\n+            \"\\x1b[3mitalic\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fmt::emphasis::underline, \"underline\"),\n+            \"\\x1b[4munderline\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fmt::emphasis::strikethrough, \"strikethrough\"),\n+            \"\\x1b[9mstrikethrough\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fg(fmt::color::blue) | fmt::emphasis::bold, \"blue/bold\"),\n+            \"\\x1b[1m\\x1b[38;2;000;000;255mblue/bold\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fmt::emphasis::bold, \"bold error\"),\n+            \"\\x1b[1mbold error\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fg(fmt::color::blue), \"blue log\"),\n+            \"\\x1b[38;2;000;000;255mblue log\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fmt::text_style(), \"hi\"), \"hi\");\n+  EXPECT_EQ(fmt::format(fg(fmt::terminal_color::red), \"tred\"),\n+            \"\\x1b[31mtred\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(bg(fmt::terminal_color::cyan), \"tcyan\"),\n+            \"\\x1b[46mtcyan\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(fg(fmt::terminal_color::bright_green), \"tbgreen\"),\n+            \"\\x1b[92mtbgreen\\x1b[0m\");\n+  EXPECT_EQ(fmt::format(bg(fmt::terminal_color::bright_magenta), \"tbmagenta\"),\n+            \"\\x1b[105mtbmagenta\\x1b[0m\");\n+}\n",
        "problem_statement": "Allow fmt::format and friends to use colors\nWould it be possible to add a color specifier to `fmt::format`, `fmt::vformat` just like it is possible with `fmt::print` and `fmt::vprint`? I'm having an issue where I only want part of a string to be colored, so I'd like to wrap it in `fmt::format` and pass the colored result to a `fmt::print`, but currently that is not possible. I thought about changing it myself but it required more changes than expected and I don't fully know how the code works.\r\n\r\nGreat library, by the way!\n",
        "hints_text": "",
        "created_at": "2018-12-30T16:08:04Z",
        "version": "5.3"
    }
}