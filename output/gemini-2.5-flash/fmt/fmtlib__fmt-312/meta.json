{
    "task_id": "fmtlib__fmt-312",
    "setup_info": {
        "repo_path": "github/_cache/fmtlib__fmt-312_2025-07-04_18-39-02",
        "repo_cache_path": "github/_cache/fmtlib/fmt_cache"
    },
    "task_info": {
        "repo": "fmtlib/fmt",
        "pull_number": 312,
        "instance_id": "fmtlib__fmt-312",
        "issue_numbers": [
            "311"
        ],
        "base_commit": "b64d13a357d3556e54ed92a959baf3a14e2f6078",
        "patch": "diff --git a/fmt/format.h b/fmt/format.h\n--- a/fmt/format.h\n+++ b/fmt/format.h\n@@ -99,7 +99,13 @@ typedef __int64          intmax_t;\n # define FMT_GCC_EXTENSION\n #endif\n \n-#if defined(__clang__) && !defined(__INTEL_COMPILER)\n+#if defined(__INTEL_COMPILER)\n+# define FMT_ICC_VERSION __INTEL_COMPILER\n+#elif defined(__ICL)\n+# define FMT_ICC_VERSION __ICL\n+#endif\n+\n+#if defined(__clang__) && !defined(FMT_ICC_VERSION)\n # pragma clang diagnostic push\n # pragma clang diagnostic ignored \"-Wdocumentation\"\n #endif\n@@ -212,10 +218,12 @@ typedef __int64          intmax_t;\n // All compilers which support UDLs also support variadic templates. This\n // makes the fmt::literals implementation easier. However, an explicit check\n // for variadic templates is added here just in case.\n+// For Intel's compiler both it and the system gcc/msc must support UDLs.\n # define FMT_USE_USER_DEFINED_LITERALS \\\n    FMT_USE_VARIADIC_TEMPLATES && FMT_USE_RVALUE_REFERENCES && \\\n    (FMT_HAS_FEATURE(cxx_user_literals) || \\\n-       (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1900)\n+       (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1900) && \\\n+   (!defined(FMT_ICC_VERSION) || FMT_ICC_VERSION >= 1500)\n #endif\n \n #ifndef FMT_ASSERT\n@@ -3907,7 +3915,7 @@ operator\"\" _a(const wchar_t *s, std::size_t) { return {s}; }\n # pragma GCC diagnostic pop\n #endif\n \n-#if defined(__clang__) && !defined(__INTEL_COMPILER)\n+#if defined(__clang__) && !defined(FMT_ICC_VERSION)\n # pragma clang diagnostic pop\n #endif\n \n",
        "test_patch": "diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt\n--- a/test/CMakeLists.txt\n+++ b/test/CMakeLists.txt\n@@ -123,7 +123,11 @@ if (FMT_PEDANTIC)\n     \"${CMAKE_CURRENT_SOURCE_DIR}/compile-test\"\n     \"${CMAKE_CURRENT_BINARY_DIR}/compile-test\"\n     --build-generator ${CMAKE_GENERATOR}\n-    --build-makeprogram ${CMAKE_MAKE_PROGRAM})\n+    --build-makeprogram ${CMAKE_MAKE_PROGRAM}\n+    --build-options \n+    \"-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}\"\n+    \"-DCPP11_FLAG=${CPP11_FLAG}\"\n+    \"-DSUPPORTS_USER_DEFINED_LITERALS=${SUPPORTS_USER_DEFINED_LITERALS}\")\n \n   # test if the targets are findable from the build directory\n   add_test(find-package-test ${CMAKE_CTEST_COMMAND}\ndiff --git a/test/compile-test/CMakeLists.txt b/test/compile-test/CMakeLists.txt\n--- a/test/compile-test/CMakeLists.txt\n+++ b/test/compile-test/CMakeLists.txt\n@@ -4,6 +4,7 @@ cmake_minimum_required(VERSION 2.8)\n \n include(CheckCXXSourceCompiles)\n set(CMAKE_REQUIRED_INCLUDES ${CMAKE_CURRENT_SOURCE_DIR}/../..)\n+set(CMAKE_REQUIRED_FLAGS ${CPP11_FLAG})\n \n function (generate_source result fragment)\n   set(${result} \"\n@@ -57,3 +58,14 @@ expect_compile_error(\"fmt::MemoryWriter() << fmt::pad(42, 5, L' ');\")\n expect_compile_error(\"fmt::format(\\\"{}\\\", L'a';\")\n \n expect_compile_error(\"FMT_STATIC_ASSERT(0 > 1, \\\"oops\\\");\")\n+\n+# Make sure that compiler features detected in the header\n+# match the features detected in CMake.\n+if (SUPPORTS_USER_DEFINED_LITERALS)\n+  set(supports_udl 1)\n+else ()\n+  set(supports_udl 0)\n+endif ()\n+expect_compile(\"#if FMT_USE_USER_DEFINED_LITERALS != ${supports_udl}\n+                # error\n+                #endif\")\n",
        "problem_statement": "User-defined literals check for Intel C++ compiler\nWhen compiling with the Intel C++ compiler version 14 using c++11 mode, the check for whether user-defined literals can be used does not work. Including `format.h` leads to the error:\n\n```\ninclude/cantera/ext/format.h(3223): error: expected an operator\n  operator\"\" _format(const char *s, std::size_t) { return {s}; }\n```\n\nThis compiler version does not support user-defined literals (support is introduced in version 15, per https://software.intel.com/en-us/articles/c0x-features-supported-by-intel-c-compiler). However, the macro `FMT_USE_USER_DEFINED_LITERALS` ends up being defined only by the GCC version.\n\nThe Intel compiler version can be checked using the macros `__ICC` on Linux/OSX and `__ICL` on Windows, which returns the number `1400` for my compiler version. There is apparently no macro that is actually cross-platform.\n\nI've only checked this on version 2.1, but it looks like the test for this hasn't changed in master.\n\n",
        "hints_text": "Thanks for reporting. Does https://github.com/fmtlib/fmt/commit/ca33c935197d4e5adbe93851ae96a0719d4b3cf0 fix the problem?\n\nThe `__INTEL_COMPILER` macro should work cross-platform as far as I know. Note that Intel also defines the `__GNUC__` family of macros or `_MSC_VER` depending on platform, which usually means that Intel's macro should be checked before anything else (it's a bit of a mess).\n\nI have access to both older and newer icc versions so I can test it and/or make any required changes. Let me know if it's needed.\n\n> I have access to both older and newer icc versions so I can test it and/or make any required changes. Let me know if it's needed.\n\nThat would be very helpful, thanks!\n\nI am not sure if `__INTEL_COMPILER` is portable because https://software.intel.com/en-us/node/524490 says `__INTEL_COMPILER (Linux*, OS X*)`.\n\nYes, you're right. Sorry about that. I was using a compatibility layer which I forgot about and assumed to be the native macro. Anyhow, I'll test it out a bit later today.\n\nca33c93 does not fix the problem for me. I'm working on Linux, so the problem is not the value of `_MSC_VER`, it's the value of `FMT_GCC_VERSION` which is 408, corresponding to the system installation of GCC 4.8. (Although I guess there could be similar issues on Windows depending on the combination of Intel and MSVC versions).\n",
        "created_at": "2016-05-03T14:10:58Z",
        "version": "2.0"
    }
}